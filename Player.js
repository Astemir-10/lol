//	Playerjs.com 18.8.2
//	01.03.2023 19:08:24
//	API - https://playerjs.com/docs/q=api
if(!window.pljssglobal) {
	var pljssglobal = [];
	var pljssglobalid
}
if(window['PlayerjsAsync']) {
	setTimeout(PlayerjsAsync, 1)
};

function Playerjs(options) {
    console.log("LOL")
	var o = {
		play: false,
		audiosrc: [],
		audioctx: [],
		playerid: 'b8b2rru42rda',
		default_w: 640,
		default_h: 360,
		version: '18.8.2',
		compilation: ['HLS', 'VASTP'],
		compilations: '',
		fullscreen: false,
		realfullscreen: false,
		nativecontrols: false,
		fullwheel: false,
		fullscreen_start: false,
		airplay: false,
		pipwebkit: false,
		ispipkit: false,
		u: '#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#Hxonhy9XjbpUgRM#Hxoner48cu9riRh#ANoNfbFngOANGNA8h3eSAziUezJTHKhqEuhlfyaUe2m0HKhqEuh#HyhleRQXgu1qibpQHKiZg256ecBnBqtRfbpXHKhOEvsoEvsoBqt0hRxZh2enhR09B3Jqdb5rgyx0eKl1Dus0CKh#HzBQd3Iljv0SEuhljL0SEuhli2QPiyl9BrEZFKhlfyaUe2m0HKhpENhleRQXgv0SA2eReReReNihDr48hRaOiut4HKh2DOMSAzP9BrsSAziUezJTHKhrDOMSAymQfbiTiv0SELASAyeUgyo9BqFReReReRdScu8#Hxoner48cu9riRh#ANoNfbFngOENGNA8h3eSAziUezJTHKhqEuhlfyaUe2m0HKhqEuh#HyhlizBmgSFRg3BYHKi0hRxZh2pmiyMTENolEqPSHOpodcJTAyI9B00pFNo3DOwrFOdpELEqAwopFNo3DOwoGLw2GLI1AwopFK4qEvlpFrl1DvhZELs5ELd5FvMlLvw0DOA3FLs5Eqo3DOwoGLw2GLI1AwEpFu4qFrMoGLEXEq4pGLPpEOdqFKspEK4oFOEpGLhXEus3DOwrFrM0FOI1DvslIrEZEOwpGvP1GLwXEusoDvEZELP5ELA2EOMlEuo3DOwoGLw2GLI1AwEoDvwpDOspGLApEOdlEq4qELw4GLM5EKopFu4qELlrErl5AvhZELE3FLI2FvMXELIZEOw4ErE4GKtEFq4pErh1Fvd0FKopEN40FvwoFvd1AwE0DOw5ErEoGvM1DvwqDOI0ELs0FOMlEK43GvIrGvd2ENopEu4oFvw3Evw4AvwZFrl0Erl2FOAXFq4pEvPpFOP0FKtvEK43GvIrGvd2ENo0DOw3FOdrFrs1AvIZELPrErs4FLMXEK43FrhqGLArFNs3DOwrFrM0FOI1DvwZFrh3EOPqErdlIrwoDOs4ELh4FvIXEK43FrhqGLArFNspEN40GLs3EvdrDvIZELh2FOE3EvMlELAZFvPoFrs2Eqo3DOwoGLw2GLI1AwopEu42FvI1ELd3DvhZELs5ELd5FvMlLvwrDOE4EOl5GLdXELwZFLMqFvsoFutEELdXFq4pErd2ELwrENtfBqtRfbpXHKhOeReReReRBr48cu9odcJTHOphD2h#Hxonh3eSHNAXARxOiyQngNA6AStXdcPNDuBmd3JUg24qAOTNhyx1h2MNDuB0jctQAOTNh3eSANoNh2FmgyMNGNApDOMNDuBrd2xXeb92ecANGOwZFKoNgbxqe2QZAOTNEuspFKspEuspFKAXARBSd29Xg3BniRaqAOTNEvtmeyaRANoNdRhNGOwXARBSd29Xg3ANGNAqEOAqEOANDuBNe3tmeyJUgRhNGNA0AvwoAvIlELsNDuBNe28NGNAoANoNdRimAOTNEu43FKAXARBSdb92ecANGNApANoNfbFngSFqectXdcPNGOsXASJUhuA6EuoNdb5Ugbx0fb9ZAOTNdbpofywNDuBTfbJQAOToDuBrd2xXecFYdbpXAOTNDLwNkKoNd29ZizBngx9YicJQAOU7AR9qeyaqAOTpFKoNg24NGOwXARQOg24NGNA8h3eSAziUezJTHKhqEuhlfyaUe2m0HKhqEuh#HyhlizBmgSFRg3BYHKi0hRxZh2pmiyMTEKolEKPSHOpodcJTAyI9B00oDOP5GLh4FOE3FqopEN4oEOsrGvM3AwEoDOI0Frw1FrEoGKopEN4oEOsqFOh3Au0oDOsoEvdoFvd3Evd3EqopEK41Frw5ELPqAvMZGLP3GLErE2MYEvhXELwZEvw5EOPoFKtEEu4oEvIrGLMpErwoFuo3DOsoFOP2ELE4AwEoDOsoFvP5FrdpFLw2DvdZFvM2Gvh2FOMlEu40FvP3FrI0FrIXFN4oELs1FOI3AvsZGLP5GvMrGvd1DvdZEvs4Evd2GLMlLvIZFLd4EOsrEOIXFK45GLw4FOIpAwo5DOA4FOP1ELI4DvwZEOPpFLwrFvElIrPZGLw3GLs2FrPXEu42FOEoELlpELIlELsZGLPrFrPpGuopDOwpEvd4FOP2AvwoDOP5EOd3FKoqDOsoELA1Fvs0AwopEu45FrMoGLd5Dvw2DOspGvI2FNtvELsZGLhrGLh5EKopFN45EvP3FrI5AvPZGvP1FvIqFvEXELhZErM0Fvs2AvPZEOd2FLwqELEXELdZFrAqGvE2GKtEFu41GvI0FrwqEKopEN4oEOwpFLw1AwooDOP5GLh4FOE3FqopEN4oEOsrGvM3AxTSAyeUgyoYhSaXeL0SgR9ZjRaqgqhleRQXgv0SA2eReReReNihDr48hyx0futPHKiFELMZFOwpGLs3Eqo1DOI1FrM4FLs0AwEpFK42FvP3Frl2DvMZFvl5Frs0GLElELMZFrEqFLI3Fuo1DOM2GLP0FrI3Avw1DOl0FLM5GvlXFK42GLh4ErP2EqtvELdZEvIqErl5Fqo1DOPqEvI2FvspAvw2DOA0ELs3ELPXFN4pGLsqErAqAvw2DOIqFrI4GvlXFN41Evd2GvM1FNtvELdZGLd1Erd0EKo3DOIpGLh1GLd1Avw3DOA4GvPpFNo4DOMpGvd3ErMqAvw3DOA4GvPpFNo5DOlpELsrFLw2AwEpFq4qGvl5ELdXELwZEvl3FrdqEKspFN45FrMpFrMrDvwqDOs1EvsrEvwlELdZFvdoEvI2GuopEN43FLI4FvI2AwEpFN4pFOMoFLAXELEZELM4Fvd1FNspFK44GvA2ErP4DvwrDOE4FvP0FLElELMZFrArFOl5ENopEq40FOh0EvP4AwEpFK40EOP1Fvh3DvwrDOdqEvspEOwlELMZErw0Gvs3FKopEq45GvApFOP0Avw1DOI2FrIoGLlXELIZEOh2ErwoGutvELMZFOAoEvwqEKopFu41Frs0FLArAvw1DOP4EOw2GLIXELIZFOl1ELPqFKspFN4qFrdrELs4Dvw0DOMrEOM5EvAlIrw2DOM4GLM4GLAXELIZErhoEvM5FNspFq4oELM1EOs1Dvw0DOsqGvI4FLwlELhZFvA4Gvd5ENopEq40FOA5EOl4AwEpGu4oGLIrELErDvwqDOM1EOI0FrPlELlZFvl4GLw2DvwpDOE0EOw2GLMlELlZFvl4GLw2DvPZGvwpEvE1ELdlIrw4DOI4GvPpFNo4DOA5FLMrFLI3Avw4DOwoFvwqFvIXFN45Gvl2EOd1GuspFq40FOw0EOhqDvMZGvP3FOwpErwlIrw3DOs3EvE4FLlXFK4qErE3GLdpENspFN42FrArEOP0DvIZFrlrFvl1ErwlELdZErl4EvPqFqo0DOM0EOIpFvP2AwEpFN4pErMrFrM0DvIZErA4Evh3EOPlELMZFrM2FrMqFNo0DOE1GLw5Evs4Avw1DOM0EOIpFKo0DOdpELPoFrEqAwEpFK4rEOloFrhrDvIZGvd0FOA0FLdlELMZErM5ELPoEKo1DOA0ErA0FrE4Avw1DOdpELPoFrEXFK40FLh1GvMoFutfBqtUev0ShyUrc3engzaYea9QgyaYeb50ENhleRQXgv0SA2eReReReNihDr48hyx0futPHKiFELEZFrIpELs5Guo3DOIqFrh1FOh4AwEpEq44ELP0ELMXFq40FrMpFvPqEqspEq45FOP4GLE1DvhZFOs4GLwpFqspFu4pEOP1FOPXFq44Fvw0FvI5FKtvELIZFvwpFLw3FKo4DOA1EOs0EOl0Avw0DOM4ErI5FOwXGu43GLMqEOs3FNspFu41GvE0GLdpDvPZFKtvELIZFLlrFvP2EKopEu4qEvI3FrPqAvw0DOIpELMpFrMXELsZFrI3GLM3ENspFu4pEOP1FOPXELwZELM4FLM1EKtvELEZGLd5GvPrFKopEK4rGLwoGvlrAvwrDOlpGLIpFKopEK41EOI4FLs4AvwrDOh0ELwoGLlXELwZFLhqEOIrENtvELEZFLs0Gvd2EqopEK43ELMqEOIrAvwrDOIqGLA2EOwXELAZEvAqFOI2FqspEq41FrAqFvEqDvwqDOA1Gvl5EvAlIrwrDOhpFLAqFvEXELAZFvP1ELErFqspFu4oEOA2Fvd3DvwqDOM3EvhrFrPlELIZEOM4GvPoENopEN40EOh3FLd4AwEpFu40FLw0FLPXELAZErwpEOs4GuspFu43EvhqGLw1DvwqDOs4Erh5FLhlELIZGLMrGLA3EKopEK43EOI2EOE3AwEpFK4rFvPpFOE2DvwpDOw0GLs0FNspFK41GvE0GLdpDvwoDOIoGvPqGLElELMZFLlrFvP2EKo5DOMlIrw1DOM4ErI5FOwXGu41GLwoFrs3FKspFK4rFvPpFOE2DvhZGvMoGLMrGLPlELIZGLMrGLA3EKo3DOA3FLE3FOE0AwEpFu43EvhqGLw1DvdZGLw2EOs0EOhlELIZFvMpFvM5DvdZFOl4FrPpENspFu4qFLl4GLsqDvdZFLhqEOIrEOAlIrw0DOsqEOd0FOhXFN40EOPqFOApEKspEq43ELMqEOIrDvdZFLs0Gvd2EOMlELEZFLhqEOIrENo2DOh0ELwoGLllIrwrDOIqGLA2EOwXFN45FrhrFLErFKspEq41EvI4FOdrDvhZEOl0Frh1FOhlELEZFrIpELs5Guo3DOIqFrh1FOh4AxTSAyQPHKiofSFkiR9Xib1Qc2aXeb1QgSIpBqtRfbpXHKhOeReReReRB1onHOphD2h#Hxonh3eSHNAXARQOg24qAOTNHzF2eqt3fbJ0fv0SEOsSAymQfbiTiv0SEOsSHOpSAyeUgyoYhSaXeL0SgR9ZjRaqgqhleRQXgv0SArsoEvsoEuhlizBmgSFRg3BYHKi0hRxZh2pmiyMTEKolEKPSHOpodcJTAyI9B00pEu45GLs4FLE4DvEZFvMrFLwpEOhlLvAZFvArFOh1ELPXELAZEvAoFOl5GKtEEu45GLP3GvdrFrhXELAZEvAoErl1FqtvEu40FvhpFLhrEvPXELAZEvAoEOd3FqsYEu4oEvs2EvI2Frs2FrEXELwZFLhpGLw5ENs1DOP5FrPrErEreK0oFqopEK4oELPqGLs1AwooDOsoFvE5FLwrELs0DvhZEvs2GLdpErllIrsZEvs0GLP3FOw1ELdXFN40FLd4Frd2FKsoDOI0GLh3FvI3Fuo2DOspEvM2FvhlEu45GLP4FLE4FOMXFN4oEvloFOd5FKtEFu41FOlqEvEqFuo1DOP5ELl2FvwlLvPZEOl2GLMpFvlXEK4qGLw1ELE0EqtvGK45ELh5Evd3GKooDOd2ErspGvwpFuspEu45GLE3GLw4DvwZELwoFOl2GLdlELsZGLPqFOh1DvAZEvspEOM0EvIlLvwoDOP5Evl1ErlXEq40FLE1ELwqFqtfAw0pEu45Gvd5FvhrDvdZFLd4FOl3FOdlLvwoDOP3FLs5FOPXELdZEvw4Fvd2AwEpEu45FrE5FrPpDvw2DOPoGLh3FvPlGK44GLM0FvA0EqopFq4rFLI0EvdlGK4qFOd1ELApEqopFN43EOA4Erd5Awo1DOs1GvI4EOPqDvwqDOI5Frw1ENtEELsZGLl2GLI3Eqo2DOM2Gvd4Frd2AxTSAyeUgyo9BqFReReReRdScu8#Hztmiyllev0SLLw0DOs3FLhrFLPXEK4oFrM3ErM5EqtEEu41FrM3ErM5ErwXELIZFLh1FrE1GKtvEu4rFvw0EOwrFLdXELIZGvwoEvMoFKsoDOE0ELIqELE1FNopFK4pGvP5FvP1AvsZFLh1FrE1GLEpDvw1DOIqFvA2FvwlIrsZGvwoEvMoFLs2Dvw1DOd1GvM3GvdlEK4pGvP5FvP0GKopFK42FLl1Frl2AvwZFvA0EOd0EvhXELMZFvA0EOd0EKtEELIZGLA0EOd0EKopDOPqFvA2Fvs3AwEpFK4pFLl1Frl2DvwZFOl5GLI5FvPlELMZELM4FLh4FNopDOEpEvs1EvMpAvw0DOPqFvA2FvwXEK4oFrM3ErM5EqtvELIZFOl5GLI5FKooDOl0ELIqELE1FNspFu4rELsoFLs1DvsZGvIpFvApErM2Avw0DOs3FLhrFLPXEK4oFrM3ErM5EqtfBqtRfbpXHKhOeReReReRB1onHOphD2h#Hxonh3eSHNAXARxOiyQngNA6AR11iyMNDuBmd3JUg24qAOTNib5YicJQANoNizQoeKA6ASF2eqAXAR1mhRiUgNA6AOslDLIlGusoANoNh2FmgyMNGNAoDOhNDuB0fcsNGOsXARxZfb1miyQngNA6ARxXhymmANoNdb92ecANGNAoDOhNkKoNd29ZizBngx92g2p1gbMNGSXNg3BPecANGOw3DuBngNA6EKoNizQoeKA6ASFTdctQANoNdbF0fb9ZAOTNiR9Xib1QANoNfuA6ELAXASBnib5Pfb5SAOToDuBOicF0g213fbJ0fuA6EKoNiqA6FLAXARwNGOwXARxNeqA6AOsZEqAXARxniRaqAOTNEuAXARFngy9qAOTNeReReReRANoNd29Xg3BNeqA6AReReReReNAXARFngy9qg3eQhNA6AReReReReNAXARmUeyMNGOsXARmUeyanicJYicJQAOTpDuBqg3JmiyQngNA6EuoNdRiodbJPfb5SAOTNFKsoAvMlEuAXARBSAOToDuBTdb5PgyMNGOsXAR1mhRiUgNA6AOslEus4AvMNDuBOicF0g21PecFUe24NGOwXARF1h3JngbJQh2QSgSF2eqA6AOpriRhli2QPiyl9BrM3hzlSAymQfbiTiv0SEOtojuhliRQQi0Bnjv0SEusYEqs1FqsqEuhliRaqh2QngO0SEK4pBqt4gbpZhr0SfzJ0hvUhD1oni3i3DShrDR9qe1onEOsoExonh3eSBqt4gbpZhrU4gyQZfr0SfzJ0hvUhD1oni3i3DShrDR9qe1onELP5GaonjypUgRXSHQpZAuslAvpSAyQPHKizhR91huhlh3Jqg2YQHKiZg25QBqtrizBnf2MYi2QPiyl9BrwSAyeUgyo9B25ngRMSAyeUgyoYhSaXeL0SeceQgR9PeuhlizBmgSFRg3BYHKi0hRxZh2pmiyMTEu4oEvsoEvsXAu0rDOsoEvsoEuPSHQpZAuslAuslAus8hRaOiutRfbpXHKhOEvttJwayBqtRfbpXDcB1gyM9B25ngSUQhR8SAzl9BrsSAzP9BrsSAziUezJTHKhrBqtTebQSfzI9BrAoBr48cu9qebF0HQpZAuslAuslAus8hRaOiutRfbpXHKhOEvttJwayBqtRfbpXDcB1gyM9B25ngSUQhR8SAzl9BrdSAzP9BrsSAziUezJTHKhrBqtTebQSfzI9BrAoBr48cu9qebF0HQpZAuslAuslAus8hRaOiutRfbpXHKhOEvttJwayBqtRfbpXDcB1gyM9B25ngSUQhR8SAzl9Brw4Bqt5HKhoBqt3fbJ0fv0SEqhlfyaUe2m0HKhqEuh#HxonhRaOiv5hgNslAuslAuslHzBQd3IleRQXgv0SArsoIMJxJNhleRQXgu1qibpQHKiZg256ecBnBqt4HKhpENhljL0SEuhli2QPiyl9BrESAymQfbiTiv0SEOsSHOphD3BQd3I#cy4lAuslAuslAvpqebF0AyeUgyo9BqEoEwxwJMdSAyeUgyoYhSaXeL0SgR9ZjRaqgqhljv0SEOISAzP9BrsSAziUezJTHKhrBqtTebQSfzI9BrAoBr48cu9qebF0HQpZAuslAuslAus8hRaOiutRfbpXHKhOEvttJwayBqtRfbpXDcB1gyM9B25ngSUQhR8SAzl9BrEoBqt5HKhoBqt3fbJ0fv0SEqhlfyaUe2m0HKhqEuh#HxonhRaOiv5hgNslAuslAuslHzBQd3IleRQXgv0SArsoIMJxJNhleRQXgu1qibpQHKiZg256ecBnBqt4HKh0ENhljL0SEuhli2QPiyl9BrESAymQfbiTiv0SEOsSHOphD3BQd3I#cy4lAuslAuslAvpqebF0AyeUgyo9BqEoEwxwJMdSAyeUgyoYhSaXeL0SgR9ZjRaqgqhljv0SErdSAzP9BrsSAziUezJTHKhrBqtTebQSfzI9BrAoBr48cu9qebF0HQpZAuslAuslAus8hRaOiutRfbpXHKhOEvttJwayBqtRfbpXDcB1gyM9B25ngSUQhR8SAzl9BrM0Bqt5HKhoBqt3fbJ0fv0SEqhlfyaUe2m0HKhqEuh#HxonhRaOiv5hgNslAuslAuslHzBQd3IleRQXgv0SArsoIMJxJNhleRQXgu1qibpQHKiZg256ecBnBqt4HKh0GuhljL0SEuhli2QPiyl9BrESAymQfbiTiv0SEOsSHOphD3BQd3I#cy4lAuslHxoner5hgOphD3F2er4NDuBngSJnhuA6EKoNiRxXibMNGOwXASJUhuA6EKoNdb5Ugbx0fb9ZAOTNdbpofywNDuBTdb5PgyaUd29Zh292ecANGOx9DuBOg250hR9Xc3JUgbMNGSXNg3BPecANGOhXAR9ZAOTpDuBmd3JUg24NGNB0fb1QANoNizQoeKA6ASJQjzINDuB0ecm0AOTNEvToEuAXARengSJrfcUQAOTpEuoNgbxqe2QZAOTNDLwlEus4Avw1ANoNd2pUd2XNGOsXASFQhyxqdcJnhNA6AQonANoNdR9XeuA6EuoNdb5Ugbx0fb9ZAOTNdbpofywNkKoNd29ZizBngx9PicBmiyQngNA6jqBnhRJQhNA6GKoNg24NGOwXARxOiyQngNA6ARJ1hRx0fb9ZANoNizQoeKA6ASJQjzINDuB0ecm0AOTNEvToEuAXARengSJrfcUQAOTpEuoNgbxqe2QZAOTNDLPlEusoAvsNDuBOgyQOfqA6EuoNdR9XeuA6EuoNizBUdb5SgyMNGOsXASJUhuA6EuoNhy9rfcJUg24NGNBOg250hR9XhqAXARpQizJQhSFodbFUgRhNGOsXARxZfb1miyQngNA6ARxXhymmANoNfyQPeKA6EKoNfyQPeb9Zgb9NfbpQAOTpkKoNd29ZizBngx9NibeRecANGSXNg3BPecANGOw4DuBngNA6EKoNfbFngNA6AOpofSFPfcdld2pmh3E9B2pndbJQhNmqdb5PCKh#HxonhyUreyQ2HSp8ku5Xg2xPecAThRxZeuPXAu5Xg2xPecAThRxZeuP6dbe0ecAlj2JUh3tXdcP6dRpnd2X7dR9qeyaqDcBmeyQ1hrTlFLsQGqt3fbJ0fvTlFbaYGqtTebQSfzI6AvaQgLXlkKsZgy9meyaqCzBmgRIUjqtYdcBSfb46Au0rEzt4AvslEusYErtojvXleR9Ziu1rfcUQGNspEzt4Gqtog3FUiyQngOTlhRaXdcJUiRM7AzJQjzIYfb5Peb50GNsYGLP5GbaYGqtNg3BPecAYiy9oGNsoDOmQgKtrg2pUeutqe2BmCvA1FKolEOM1DusqFLMXAvsZEqP7AyBnhRJQhN1qfbiTivTlEu44eb0lh29XfbIlhRiNdKlqFLMXAvA1FKolEOM1DusoDOEUGqtNg3BPecAYdR90iy9YGNsoDOmQgKtrg2pUeutqe2BmCvA1FKolEOM1DusqFLMXAvsZEqP7AyBnhRJQhN1Xebe0GNsoDOmQgKtrg2pUeusTd29Xg3AUGqt0hRxZh2enhR06AzJqdb5rgyx0eaTTEuP7AyxZfb1miyQngOTldb5UgKmqdb5PCKspDOxrAyQZeRQZfcJQAypUgRamhOXlkKtsf2a5eSBmgbarAyxZfb0ThRxZeuPljqsoBKt7AzJqdb5reR9qgLTlhR90dcJQCvtPebhUGqt9AvwoEuMljqt0hRxZh2enhR06AzBniyx0eKlrFOtPebhUGqt9Az0NDuBmd3JUg24NGNBNibeRecANDuB0jctQAOTNd3FrANoNhy9rfcJUg24NGNBOeb50ecANDuBrd2xXeKA6AOwNDuBOgyQOfqA6EuoNfyQPeKA6EKoNgbxqe2QZAOTNEusoAvslEuAXAR5Ud24NGNApFqB9DuBOg250hR9Xc3FQizJUgRirAOU7AR9qeyaqAOTpGKoNg24NGOwXARQOg24NGNA8h3eSAziUezJTHKhqEuhlfyaUe2m0HKhqEuh#HyhleRQXgu1qibpQHKiZg256ecBnBqt0hRxZh2enhR09B3Jqdb5rgyx0eKlpDuspCKh#Hztmiyllev0SLLPZGLM5EOw2ErdXEutEELwZEvhrFvE1ENoqDOIqEOP4Evh1AwopEN4oGvIqFrlXEN45Frd4Erd3FKtEELIZFLd1FvA2EqopDOl2GLwqFvh1AwopFN4oEvwrFLMrDvEZErM3FOd2GvPlLvw1DOw5FrA2FvhXFK44Fvw0ELhoGKtEELMZFvw1Fvh1FNo2DOlrEvd4FvE1AwopFq44FrE3EvdrDvhZFrl4ErPpEKtEELlXGK44FvAqGLP1FutEELMZFLMrErMpFuopEu44EvsoEvdrAwopFK4oFrs4Fvh3DvwpDOlrGvIoGvPlLvw2DOs4ELd5EvMXELIZErIqEOs5EqtEELIZFOM2FOs0ENopFK44ELE1Fvh5AwopEN4pFLEpFLIrDvw0DOh2GLAoFvMlLvwpDOsqFrI3FOdXELMZEOIqEOIoGutEELsZEvl1FLwoEKopFq42Evh2FqtEGu4oFOE4EOI1FuopFq43Awo2DOP4FvwoFLI3Dvw1DOA4GvIoFLllLvMZGvwqFvd5ENopFu43Gvs3ELI4AworDOI0FOw1FLh0Dvw1DOl1Erh3EOwlLvwZGLd0EOd4ELwXELIZFvE0FLE5EqtEEN45EOPqFrM1EKopEK44GvI1FrE5AwoqDOE2FOEpErI1DvwoDOlqErsqFOPlLvsXGK44GLP5FrI4EqtEEu4oEOEoFvs5Evd5DvhZGvArEvI1FrllLvAZFvI2FrhpGvwXFN44FvArELl0ENtEEN45Fvs3ErIrFKo1DOl0ELIpFrs5AwopDOl4ErPrEOP3DvEZErM3FOd2GvPlLvEZErEpErAoGvMXEK44GLAqFOPpEqtEFK44FOP4Gvd2FuoqDOl5FOw0Evl2Awo2DOP3EOd0FOdqDvAZFvloFrh5GutEFq45Erh1Ers4DvsZEvI2EvIpEOwrFNtEGK45FLPqELdrFNooAxTlLLlZGvI5GLE4FrEXFNtvFq4qFrdoErE0FKo2AvdXFq4qFrdoELEqGus2DvlZGvI5GLE5FrIlIrdXELsZFvArGLl2Fqs3DOA3FOsrErI1DvwpDOhlGu44FvP5Erl3EqopEK43AwEpEu40EOE5FOd2DvwpDOhlELwZFqopEu40EOE5Gvd3AvwpDOhXGu44FvP5ErP3FutvELwZFqo3DOA3FOspErA4AvwoDOIqErP2FOdXFNs4DOl0GLPrGvhrDvdlbNhleRQXgv0SA2eReReReNihDr48cu9SHOphD3F2er4NDuBmd3JUg24NGNBrecJ0fb5ShqAXAStnh2Q0fb9ZAOTNd29ZizBngzEYhRQSfzINDuBYdcBSfb4NGNAoAvslGuspENAXASJ5hyMNGNBriRhNDuBrd2xXeKA6AOsZGuAXARQOg25rd29Xg3ANGNBReReReRdNDuBUd29Zh2Fngy9qg3eQhNA6AOsodbJQeNAXARmPfbFngNA6EKoNfyQPeKA6EuoNfyQPebpmhuA6Ec0XARFngSJqg2pkhypmjbpUh3INGSXNg3BPecANGOw2DuBngNA6EuoNfbFngNA6AOpriRhli2QPiyl9BrAoBqtTebQSfzI9BrAoBr48eqt0hRxZh2enhR09B3Jqdb5rgyx0eKlqDusrCKh#Hztmiyllev0SLLw0DOIXFu44EvI4FrloFKtvELMZEOlXFu44EvI4FrloFKspFNo1DOMqFLdoGLh2Avw2DvdZFvs2FLs0EKtvELdXFq4qGvhrGLl0Avw1DOA4DvlZEvs4ELEoEKspFu40DvlZEvs4ELEoEKtEEK42DvlZEvs4ELEoEKtvEu43ENo4DOsoGvwrEvwlEuo3DOA4FrE5GvIlEuo2DOIoFOMoFvwlIrsXFK41EOM2EvP3FNsoDOhqDvIZGvs0Gvh4EvMlEK42DvIZGvs0Gvh4EvMlLvw0DOIXFu44EvI4FrloFKtfAw0pDOdXEq4qEvEqFLAoEqtvEu43ENorDOAoErA1EOsrAvsXEN40GvA1EOsrEqsoDvwZFOspFOA2EvAlIrsXEu43EOs3Erw3EKsoDOhqDvwZFrh2ErM2GvJQDLw1AvwZFNopDOh3FOE1FOl0eK0pFKtEELwZENopDOh3FOE1FOl0eK0pFKtvELAZEvlXEK43FrdrFLd4FyMYELMlELAZGuooDOhqEvhrELhpAvwqDOlXEK42Evw2EOdoENtvELAZGuoqDOI4EOMqEvErAvwqDOs4DvEZEOsrEOMqEvElELwZENorDOAoErA1EOsrAwopDOdXEq4qEvEqFLAoEqtfAw0pEK4qDvPZFOs5FrM2EKtvELAZEvlXGK42EvP3FLdpAvwqDOlXELsZErEoFvl3GuspEN44DvwpDOApELE4EOwlIrwqDOlXELAZEvPqEOh2FuspEN4oGuopEN44ELEoEvlpAvwpDOAXELAZGvwrEvs4EKtEEK42DvwqDOlpErsoGvwlIrsZFrAXELAZGvwrEvs4EKsoDvwqDOs5EOA3FOIlEuopEK4qELwrGvApAwEoDvwoDOErEvI4FrllEu43ENo5DOdoGLh1FOwlEK42DvPZFOs5FrM2EKtEELwZENo5DOdoGLh1FOwlbNhleRQXgv0SA2eReReReNihDr48cu9SHOphD3F2er4NDuBmd3JUg24NGNBogyx5gyQriuAXAStnh2Q0fb9ZAOTNdR90iy9YANoNgbxqe2QZAOTNEusoAu00EusqEKAXARBSAOTpDuBrd2xXeKA6AOwZFKAXASJ5hyMNGNBriRhNDuBmgRQYdcJUg24NGNBog3FUiyQngNAXARBShyxPeyQZeqA6AOElEqsrAvENDuBNe2wNGNAoDOhNDuBNe2xniRaqAOTNEKAXASJUhuA6EuoNdRiOg2pnhNA6AOw3EOEqENAXARBSgqA6AOsZENAXARBSd29Xg3BniRaqAOTNDLwNDuBUd29Zh2Fngy9qAOTNEvtmeyaRANoNeRpUhzPNGOwXAReXfct4AOTokKoNd29ZizBngx9RibpXAOU7AR9qeyaqAOTqEKoNg24NGOwXARQOg24NGNA8h3eSAziUezJTHKhpGzt4BqtTebQSfzI9Brw2hzlSAzeUeciug3l9BrA0ENsrAvw4Avw2Bqt2ecBrfb9ZHKhpDOwSAzmYgy5rHKiTizJoGQoncu93i3hZirEZg3BScu8qEvsocu9riRhSAzmYgy5rGSmXfb5WHKiTizJoGQoncu93i3hZirEZg3BScu8pGLP5cu94gyQZfqh#HyhlfbI9B2e1gyprd3BQeb4pEqhlh3Jqg2YQHKiZg25QBqtrizBnf2MYi2QPiyl9BrwSAyeUgyo9B25ngRMSAyeUgyoYhSaXeL0SeceQgR9PeuhlizBmgSFRg3BYHKi0hRxZh2pmiyMTEOIqDOw5GLP5FqolEq4oEvsoEvsUBr48hy9XjbpUgRMlAyeUgyo9BqFReReReRdSAztnfb50hr0SEu43FOs3FvApGvllFK41FOPrELlqFKsoDOh2Evh0EOw4GusoDOArFOPoFLwpFKs1DOh1FLApEOs4AvsZEOE2GLs1ELw1AvIZErMpFOE0EOIlEK44FLAqELspEKs3DOApGLP5Frl0AvIZFOspGvh3EOAlFK4qGLE4FvlqEqs2DOhpEvw5FLAqAvAZEOl3ErspGvhlEq44GLE4EOw5Fqh#Hxonhy9XjbpUgRM#HztngzQSg24leRQXgv0SA2eReReReNhlhy9UgSJrHKhpFN44ELspFLdrAvMZFvIoGvl0FLllELdZGvwoELM2EqsoDOwoGvI3ELI0AvwpDOlpFLd4FOIlEu4pEvl0Frw0FuspEq4qELPqFOIqAvwZFrArFrh2FvIlELsZErMoGLsoFNs0DOI3ErI0ErM1AvwqDOA3Frs1EvAlFN41Gvw3FOw1FuspFK4qGvE1GLd2AvEZFrd1Erl4Eqh#Hxonhy9XjbingO48hy9XjbingNtRfbpXHKhOeReReReRBqtog2QZizE9Brw2DOlpEvw1FOElELsZFLAqFLMpFNspFN44ELspFLdrAvw1DOl1FvP2FvllELwZGvw1FOl2FuspFK44FLI5FOI4AvwrDOApGLA2FvAlELIZEOE5FOM5GuspEu4rFLs5Evs2AvwpDOI4GLP5EOhlELAZEOh3EvMoENs5DOE4ELd3Fvd2Avw1DOA4ErM5FOdlELAZELP4EvI3GKh#Hxonhy9XjbingO48hy9XjbingNsleRQXgv0SA2eReReReNhlhy9UgSJrHKhoDOh2Evh0EOw4GuspEu42FLs5GvMrAvsZFrdoFrIqELl4Avw1DOP4ErE5GvIlFK43FLMqELAoGuspFK45GvErGLl0AvIZErMpFOE0EOIlELIZErd4EvPrFus3DOApGLP5Frl0AvwpDOdpGvIqFOElFK4qGLE4FvlqEqs5DOMpEvwoGvE0AvAZEOl3ErspGvhlELAZErA2FvlpFNh#Hxonhy9XjbingO48cu9SHOphD3F2er4NDuBUd29ZENA6AQpZHzF2eqt3fbJ0fv0SELmojuhlfyaUe2m0HKhpFSt4Bqt2fba3IR94HKhqFOAlEqspGuspFNhliRaqh2QngO0SEK4pBqt4gbpZhr0SfzJ0hvUhD1oni3i3DShrDR9qe1onEOsoExonh3eSBqt4gbpZhrU4gyQZfr0SfzJ0hvUhD1oni3i3DShrDR9qe1onELP5GaonjypUgRXSHOpSAzF0hR9WeL0SgR9ZeKhlh3Jqg2YQDciUezJTHKhpBqtRfbpXHKiZg25QBqtRfbpXDcB1gyM9B2a2eb5neyISAzJqdb5reR9qgL0SizBmgSFXdcJQCvA2EN4pGLP5GLhXAvEZEvsoEvsoCKh#HztngzQSg24leRQXgv0SA2eReReReNhlizBmgSFRg3BYHKi0hRxZh2pmiyMTEq45GLsrFrsXAvEZFvhrFLMoCKtrd2xXeKlYEKolDLwUAzJqdb5rgyx0eKlYEq45GLsrFrsXAu0rDOI3ErM1EuPlBqtog2QZizE9BrsZFrdoFrIqELl4AvMZFLd5Erw4EOMlEu43FOs3FvApGvllEu4qErd5EvMpELMlFK43FLMqELAoGusoDOArFOPoFLwpFKs0DOE1ELdrFvA0AvwZGvMqEOwoELwlFq4qELP5GLh4Fus0DOdoELl3FrAqAvMZEOPrGvI4EOElFN43ELspGLMqENsqDOA4FrEoELl3AvEZGvPrGvApGLhSHOphD3tngzQSg24#HztngzQSg24leRQXgv0SA2eReReReNhlizBmgSFRg3BYHKi0hRxZh2pmiyMTELEZFLloFLA4DusrDOE0FLwpFNPlh2FmgyMTDLwXAu0pCKt0hRxZh2pmiyMTDLwrDOM4EvMqGuolDLEZErI1ELw2CKsSAztnfb50hr0SELdZGvwoELM2Eqs1DOI0Evl4FvM4Avw2DOlpEvw1FOElEu4pEvl0Frw0FuspEK44ELM2Gvd0AvsZELs4FvhpFvIlELEZEOw5EOd0ENspDOhqErh3FOI0AvwoDOE1EvPoEvdlFu40FrE0FvE1FKspEN4qFrhoFLsqAvdZFLlpFrdpFLIlELMZEOlrFLP2FNsrDOh2FLE4GvESHOphD3tngzQSg24#HztngzQSg24leRQXgv0SA2eReReReNhlizBmgSFRg3BYHKi0hRxZh2pmiyMTELEZFLloFLA4DuspEN42ELlrEOsUAzFOdbpQCu0pDusYEKPlizBmgSFXdcJQCu0pEq41Gvs1EOlXAu0pEN42ELlrEOsUAuhlhy9UgSJrHKhpFN44ELspFLdrAvwoDOMqEOM1ELdlELdZGvwoELM2EqspFK44FLI5FOI4AvwpDOlpFLd4FOIlELMZGvM0GLd0GuspEq4qELPqFOIqAvw0DOArGLd1GLllELsZErMoGLsoFNspEK40GvP5GLA3AvwqDOA3Frs1EvAlGK4rGvw2FrI2FNspFK4qGvE1GLd2AvwqDOw5Gvs0FrPSHOphD3tngzQSg24#HztngzQSg24leRQXgv0SA2eReReReNhlizBmgSFRg3BYHKi0hRxZh2pmiyMTEq45GLsrFrsXAvwqDOh0FOh1EqPlh2FmgyMTDLwXAu0pCKt0hRxZh2pmiyMTDLEZGLPoErhoDusYELAZFrI2FrMrCKsSAztnfb50hr0SEu43FOs3FvApGvllELsZFOMoGLl1EqsoDOh2Evh0EOw4GuspFK45GvErGLl0AvMZFrM1EOwqEvllELMZGLlrErP4Fus0DOE1ELdrFvA0Avw0DOE2Gvs5ErIlFq4qELP5GLh4FuspEK42ELl0EOdrAvMZEOPrGvI4EOElGK41ELspEvlrFusqDOA4FrEoELl3AvwqDOEqFOI4ELdSHOphD3tngzQSg24#cy4lAuslHxoner5hgOphD3F2er4NDuBmd3JUg24NGNBRibpXh2FqebaZANoNdbF0fb9ZENA6AR5nhR1mgzFOhRaQgNAXASJ5hyMNGNBriRhNDuBog3FUiyQngNA6ARFngSJqg2prDcBUe2m0ANoNgbxqe2QZAOTNEuspFKs2AvwoANoNh2FmgyMNGNAoDOlNDuBUd29Zh2Fngy9qAOTNeReReReRANoNfbFngSFOg2pnhR92ecANGNAoEyxPebdNDuBTfbJQAOToDuBmgRQYdcJUg24NGNBmgztTdKAXASFOdbpQg3eQhNA6AOwNkKoNd29ZizBngx9riyxqiuA6jqBnhRJQhNA6EOlXAStnh2Q0fb9ZAOTNd2aZiyaqANoNh2FmgyMNGNAqDOMNDuBngNA6EKoNfbFngNA6AOpriRhli2QPiyl9BrAoBqtTebQSfzI9BrAoBr48eqtRfbpXDcB1gyM9B25ngSUQhR8SAzJqdb5reR9qgL0SizBmgSFXdcJQCvMXAvEUBr48hy9XjbpUgRMlhy9UgSJrHKhoDOM5Erh1AvsZFvl0ErllEu41FOA1AvwrDOMpFLdrAvwpDOIrFrMlFqsoDOM5Erh1AvsZFvl0ErlSAyeUgyo9BqFReReReRdScu8#Hxoner48cu9riRh#ANoNfbFngOENGNA8h3eSAziUezJTHKhqEuhlfyaUe2m0HKhqEuh#HyhlizBmgSFRg3BYHKi0hRxZh2pmiyMTENolEqPSHOpodcJTAyI9B00pFNo3DOwrFOdpELEqAwopFNo3DOwoGLw2GLI1AwopFK4qEvlpFrl1DvhZELs5ELd5FvMlLvw0DOA3FLs5Eqo3DOwoGLw2GLI1AwEpFu4qFrMoGLEXEq4pGLPpEOdqFKspEK4oFOEpGLhXEus3DOwrFrM0FOI1DvslIrEZEOwpGvP1GLwXEusoDvEZELP5ELA2EOMlEuo3DOwoGLw2GLI1AwEoDvwpDOspGLApEOdlEq4qELw4GLM5EKopFu4qELlrErl5AvhZELE3FLI2FvMXELIZEOw4ErE4GKtEFq4pErh1Fvd0FKopEN40FvwoFvd1AwE0DOw5ErEoGvM1DvwqDOI0ELs0FOMlEK43GvIrGvd2ENopEu4oFvw3Evw4AvwZFrl0Erl2FOAXFq4pEvPpFOP0FKtvEK43GvIrGvd2ENo0DOw3FOdrFrs1AvIZELPrErs4FLMXEK43FrhqGLArFNs3DOwrFrM0FOI1DvwZFrh3EOPqErdlIrwoDOs4ELh4FvIXEK43FrhqGLArFNspEN40GLs3EvdrDvIZELh2FOE3EvMlELAZFvPoFrs2Eqo3DOwoGLw2GLI1AwopEu42FvI1ELd3DvhZELs5ELd5FvMlLvwrDOE4EOl5GLdXELwZFLMqFvsoFutEELdXFq4pErd2ELwrENtfBqtRfbpXHKhOeReReReRBr48cu9odcJTHOphD2h#Hxonh3eSHNAXARxOiyQngNA6AStXdcPNDuB0jctQAOTNh3eSANoNdRhNGOwXARBSd29Xg3ANGNAqdbwpdrANDuBNe28NGNApANoNdRiodbJPfb5SAOTNENsqAvAlENAXARQOg25YdcBSfb4NGNAoAvslEus0ANoNdRimAOTNEKAXARBSdb92ecANGNApANoNh2FmgyaniRaqAOTNEqAXARmUeyMNGOwXARmUeyangStXdcPNGOwXARmUeyangSQnicJ1dRMNGOwXARQOg25rd29Xg3ANGNAYEKAXARBSd29Xg3BniRaqAOTNDLwNDuBmgRQYdcJUg24NGNBZg25QANoNfbFngSFqectXdcPNGOsXARFXfbFWdcBQdKA6EuoNfyxZeuA6EKoNeRpUhzPNGOsXASJUhuA6EuoNdb92ecANGNAYEKAXAR1mhRiUgNA6AOslEusoAvsNDuBrd2xXecFYdbpXAOTNDLwNkKoNd29ZizBngx9XfceQAOU7AR9qeyaqAOTrDuBngNA6EKoNiya4iuA6ARpUiRMNDuBXecJ0ecBrhyxOfb5SAOTqDuBmd3JUg24NGNBXfceQANoNizQoeKA6ASJQjzINDuBTdb5PAOToDuBOgyQOfqA6EuoNeR9ZizFUjRMNGOwoDuBYdcBSfb4NGNAoAvslGusqEuAXARwNGOsZFKoNfyQPeKA6EKoNfyQPeb9ZiR9PAOTpkKoNd29ZizBngx9riy9oAOU7AR9qeyaqAOTqFuoNg24NGOsXARQOg24NGNA8h3eSAziUezJTHKhqEuhlfyaUe2m0HKhqEuh#HyhlizBmgSFRg3BYHKi0hRxZh2pmiyMTFuolFuPSHOpqebF0Azl9BrsSAzP9BrsSAziUezJTHKhpENhlfyaUe2m0HKhpENhleRQXgv0SA2eReReReNihDr48cu9SHOphD3F2er4NDuBmd3JUg24NGNBriy9oANoNizQoeKA6ASF2eqAXARBSAOTokKoNd29ZizBngx9ohRa2AOU7AR9qeyaqAOT0DuBngNA6EuoNfbFngNA6AOpriRhli2QPiyl9BrAoBqtTebQSfzI9BrAoBr48eqtRfbpXDcB1gyM9B25ngSUQhR8SAyeUgyo9BqEoEvsoEvsSAzJqdb5reR9qgL0SizBmgSFXdcJQCvdXAvIUBr48hyx0futPHKiFFq41DvdlIrhZFKo2DOA1FLPqEOEqAvhZFvsqErd4GLEXFN41ELw4FvI2Fus3DOAoFrwoFOh4DvdZFrs3ELs2FrllLvAZEOs3ELs2FrlXELwZFrs3ELs2GutvEK44ELd1GvA0GKopEN4oGLh2ErwpAvwZELlrFvw3FLwXELAZEvP3FOEpEKsoDOh5EOl5ErApGKopEK43EvhpEvd4AwEoDOIoEOE2GvPqFqopEK4rELd1GvA1AvsZFvsqErd4GLA3DvwoDOd4ErIpFrMlEu43GLA4GLEqELPXELsZEOPqGvPrENtEFK4oGvM3Gvd0Fuo2AwooDOh5EOl5ErApGKopDOhoFrwoFOh4AwEoDOIoEOE2GvPqFqopDOEpFOM4EOI5AvsZFvsqErd4GLA3DvsZFOlrFvw3FLwpAvsZFrPqGvPrEOw5DvsZEOPqGvPrEOw5AwEpDOw4ErIpFrMpDu0oDOs5FrdrELs3EOPlEK44ELd1GvA0GKoYEu4oGLh2ErwoFrA5AvAZEOs3ELs2FrlXEu4qGLA4GLEqELPlLvhZEOs3ELs2FrlXFK4qGLA4GLEqENtvFq40EvArFOl5Eqo1DOI4Gvw1FLE2AvhZFKo1DOh0Fvs3Frd4AvhZFKo2AxTSAzJqdb5reR9qgL0SizBmgSFXdcJQCvIZEvsoEvsoDus2DOsoEvsoEuPlh2FmgyMTDLwXAvwUAzJqdb5rgyx0eKlYFu4oEvsoEvsXAu02DOsoEvsoEuPlBqtRfbpXHKhOeReReReRB1onHOphD2h#Hxonh3eSHNAXARxOiyQngNA6AStqecdNDuB0jctQAOTNh3eSANoNh2FmgyMNGOwZENoNhy9rfcJUg24NGNBOg250hR9Xhq1Ng3J0g20NDuBYdcBSfb4NGNAoAu0pEus4AvMNDuBUd29Zh2Fngy9qAOTNFLJmdbeRANoNfbFngSFOg2pnhR92ecANGNArGLloeLENkKoNd29ZizBngx9Zecm0AOU7AR9qeyaqAOTpEKoNg24NGOsXARQOg24NGNA8h3eSAziUezJTHKhqEuhlfyaUe2m0HKhqEuh#HyhleRQXgu1qibpQHKiZg256ecBnBqtRfbpXHKhOEvsoEvsoBqt0hRxZh2enhR09B3Jqdb5rgyx0eKl2DOMXAvIUBr48hyx0futPHKiFFq41DvdlIrhZFKo2DOA1FLPqEOEqAvhZFvsqErd4GLEXFN41ELw4FvI2Fus3DOAoFrwoFOh4DvdZFrs3ELs2FrllLvAZEOs3ELs2FrlXELwZFrs3ELs2GutvEK44ELd1GvA0GKopEN4oGLh2ErwpAvwZELlrFvw3FLwXELAZEvP3FOEpEKsoDOh5EOl5ErApGKopEK43EvhpEvd4AwEoDOIoEOE2GvPqFqopEK4rELd1GvA1AvsZFvsqErd4GLA3DvwoDOd4ErIpFrMlEu43GLA4GLEqELPXELsZEOPqGvPrENtEFK4oGvM3Gvd0Fuo2AwooDOh5EOl5ErApGKopDOhoFrwoFOh4AwEoDOIoEOE2GvPqFqopDOEpFOM4EOI5AvsZFvsqErd4GLA3DvsZFOlrFvw3FLwpAvsZFrPqGvPrEOw5DvsZEOPqGvPrEOw5AwEpDOw4ErIpFrMpDu0oDOs5FrdrELs3EOPlEK44ELd1GvA0GKoYEu4oGLh2ErwoFrA5AvAZEOs3ELs2FrlXEu4qGLA4GLEqELPlLvhZEOs3ELs2FrlXFK4qGLA4GLEqENtvFq40EvArFOl5Eqo1DOI4Gvw1FLE2AvhZFKo1DOh0Fvs3Frd4AvhZFKo2AxTSAyeUgyo9BqFReReReRdScu8#Hxoner48cu9riRh#ANoNdbF0fb9ZAOTNgRa4iuAXASJ5hyMNGNBriRhNDuBrd2xXeKA6EK4qDuBog3FUiyQngNA6ARFngSJqg2prDbBnizJngKAXAR1mhRiUgNA6AOslEus4AvsNDuBUd29Zh2Fngy9qAOTNE2E5dRemANoNfbFngSFOg2pnhR92ecANGNArGLloeLENkKoNd29ZizBngx9rfyxqeKA6jqBnhRJQhNA6EOMXAR9ZAOToDuBUd29ZAOTNHzF2eqt3fbJ0fv0SEOsSAymQfbiTiv0SEOsSHOpSAyeUgyo9BqEoEvsoEvsSAzJqdb5reR9qgL0SizBmgSFXdcJQCvwXAvEUBr48hyx0futPHKiFELsZFLAqFrMoEqopEN4rFvl0ELA4AwopEu41EOA3FLsrDvPZErsrErP0EvwlIrMZFLE2FLl2FvlXGK4pELP1Evl5GusqDOMrFvloGLl5DvwpDOE4GLd5GvwlEuopEq45ELA1Ers1AwEoDvhZGLw1GLA1ELPlFK4qEOd5FOl3FqorDOw5EOhpFLE2AvwoDOMqEOh1EvEXEq4pErP4FOspAwopEu41EOA3FLsrDvsZELw3FOI3EvM5AwopGu4oEvE1Gvw4DvdZEOErEvA5GLElLvwoDOMqEOh1EvEXELAZErI4FvwqGutfBqtRfbpXHKhOeReReReRB1onHOphD2h#Hxonh3eSHNAXARxOiyQngNA6ASFTdcBQANoNizQoeKA6ASF2eqAXAStnh2Q0fb9ZAOTNiy9oDcBUe2m0ANoNgbxqe2QZAOTNELMlELMlEusoANoNdRhNGOwXARBSgqA6AOsZENAXASFOdbpQAOTpDuBNe3tmeyJUgRhNGNA2AvdlFNs2ANoNdRimAOToDOEXARBSdb92ecANGNApANoNdb5Ugbx0fb9ZAOTNdbpofywNDuBQdcFQAOTNebpmh3JUdqAXARBSd29Xg3ANGNApFrArEOANDuBNe2Fngy9qg3eQhNA6AOsodbJQeNAXASFOdbpQg3eQhNA6AOwZEKAXARmUeyMNGOwXARmUeyangRJQh2Y0g3sNGOx9DuBXdb5SAOTNhSMNDuBrfyxqeLENGNBSg29SgyMNDuBXg2hNGOsXARa2eb50h3JqdbFWecANGOwXARa2eb50gyQriyaZecBrAOTpDuBQiRaZizF0hRxOf2aqiRxriuA6EKoNfyprh3aNizBmd2YrAOToDuBNdcFQFOINGOwXARa2eb50hqA6ARxXgy9TdaJbANoNiRxriuA6EKoNdRXoAOTNH3o7cQ58CO4VHO8/HQ58cOp8HSo/AKUhiLApELdTkvXmH15hiLApELd#ANoNdRXpAOTNHrX#CKwTCOY8kv58COpjkuU8cNUlHO98CzoVHSp8kQ1gkv58CQ4VANoNdRXqAOTNHytjCRsVHSphiLApELdVCQp1EOwpFQ0/bqT7kzo#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EOApGKtvFK4pEOMpFrsrGKopFq4pGLlqEOw5AvAZErspFrh4EvhXELIZErh0GvA5FNsqDOEoELh3Gvs3DvwoDOl5ELP5GvhlIrAZErspFrh4EvhXGK43ELI0ErM5EKsqDOdqFvw4EOArDvlZFLl2Fvl5FOdlEq4qEOI5FLErGuo3DOdoFLspFvw1AwopDOd4GvApEOIqDvdZFOd0ErM5ErdlbNtFFN42ErE3Gvh0FKopFu40GLM1FLI4Awo1DOdoEvs1EOI4Dvw0DOI5FLM1FvllLvMZFOsoEvMqFvlXELsZErIrEvw5FutvFK42EvsoFLA0Guo5DOl0FrIpEvd4AvMZFOwpFrlqFOPXGK40FLI0Fvl2GKs1DOdrFLA0ErI2DvPZELd0ELApFOhlIrMZFLd3FrPrFrIXGK4qErI1EvE5Fqs1DOI4FvP0GLw1DvPZErwqEOw2FOwlFK4rGvd3EvhpFqo5DOE5FrA2ELl5AwE1DOA4GvI2FLAXGK40GvArEvhpGus0DOP1GLA4FOAqDvPZFrMqELspGLllFu4rGLPpFOsrFNopEu4qEvd2FLI0AworDOl4Evs5ErIrDvPZFLMpEOAqFvAlLvMZFrhpFOs4FKo4DOs2FvIoErdpAwo2DOdrErh4FrI1DvlZEvd0FvsrFOwlLvdZFOErFrl3FvMXELIZFvP1FLM0GutfAw0pEN41FLP1GLdqDvwpDOA3GLP3GLAlIrwqDOM1GLM5FOAXELAZErP3EOP4FuspEN4rFrP5Frh0DvwrDOAqFrApEvdlELAZEvAoFrE0FuopEq43FOP3Fvs5AwEpEK42FOw0GLwrDvw0DOEpEOA3ELAlELwZELwqErhoGKopFu41GvE1ErArAvwoDOE3ErE1FOhXELIZFLlrFLEqEqtvGK42FLh4EvEqFuopFu41GvE1ErArAvPZELw1EOlpEvPXELIZErsrFvhrFKs4DOh0FLh3ErP3DvwrDOh0ErE0FrhlIrlZErh2EOd2GvdXELEZELlrEOApGus4DOw5ELMpFOs3DvwqDOE2EOwoFrAlGu4pGLw1ELdoFqopEK4qFrP5FrPqAwE4DOw5ELMpFOs3DvwoDOw0FLs2FvMlGu4rFrwpErI4GKo5DOEoGvM1Fus4DOhrEvE3FrPqDvlZFrhoFvAqFNtvGK4oGvP2EOs5FKo4DOArEOA5ELApAvPZFOE3EOh1EvhXFq45FOEqEOP1FuspEu4rFrErFLd3DvhZGLdrEOA5FLIlIrwpDOs5ELl0EOlXFq45FOEqEOP1FuspEK42ErM4ErwqDvlZEOI0FrM0FLMlELAZEvs1ErE4Eqo4DOloFrlpErspAwEpEN4rFrI4FvM0DvPZErhoGvhpFvllELAZFLM5FLP2ENopEu4pGLI5ELl2AvwqDOM1GLM5FOAXELwZEOh5GLh5ENtfAw05DOArGvI0Frd3DvwpDOA3GLP3GLAlIrPZEOE4FvI3FOhXELAZELM2GvA1FKs5DOEqGvdqErd0DvwqDOh4EOPqFLIlGK41Evl5FrlrEKopEq4pFLlqGLh3AwE5DOd4GLErEOP3DvwrDOMrErd3AvPZGLh3FvM2EOAXELEZFrApErMrEqspEu4rFrErFLd3DvwrDOhqELE1ErElIrwoDOh2GLA1FrAXELEZFrApErMrEqspEK4oFLl4Fvd3DvwrDOMrEvhrFrIlELwZEOIqELE0DvwrDOw0GLI5GLPlIrwpDOIqFLIqELAXELAZFrd4EOdqFuspEK41ELhoFOE1DvwqDOw0FLs5FLwlELwZFLw3EvdrFKopEK4qFrP5FrPqAwEpEK41ELhoFOE1DvwoDOIpFrh5FLPlELwZFvA1FvApENo5DOh5Erl5FLI3AvwpDOA0EOwrFuo5DOIoGvA1GLs4AwEpEK4oFLl4Fvd3DvPZEvAqFOAqFOllELsZFrd5EOM3ENo4DOlqGLloFrE4AvwoDOE3ErE1FOhXGu44EOP4EvhrGutvGK45Frh0FLdqENo4DOlqGLloFrE4AvPZFOl5ErEqGLhXGK4oELl5FLd5GKs5DOMoGvP3GvEpDvPZErP3EOdpGvPlIrPZErA4FOArFOIXGK43FrM1FOd4AvPZEOE4FvI3FOhXELsZFvsrELErAvPZEOE4FvI3FOhXELwZEOh5GLh5ENtfBqtRfbpXHKhOeReReReRBr48cu9odcJTHOphD2h#Hxonh3eSHNAXASJ5hyMNGNBriRhNDuBog3FUiyQngNA6ARFngSJqg2prANoNgbxqe2QZAOTNDLPlDLPlEuspFKAXARpUgRXNGOwXARpUgRY1hRoNGNBmhyP6h2aQfqoYELsNDuBmg3eQhNA6AOsZFqAXARxZfb1miyQngNA6ARxXhymmANoNh2FmgyargbxXguA6AN0pANoNfyQPeKA6EKoNfyQPeb9Zgb9NfbpQAOTpkKoNd29ZizBngx80FrJVMNA6jqBngNA6EKoNg3BPecANGOwoDuBmd3JUg24NGNBOicF0g20NDuBUd29ZAOTNHzF2eqt3fbJ0fv0SEOsSAymQfbiTiv0SEOsSHOpSAyeUgyoYhSaXeL0SgR9ZjRaqgqhleRQXgv0SA2eReReReNhlizBmgSFRg3BYHKi0hRxZh2pmiyMTEK41DusoCKh#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#Hxoner48cu9riRh#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#Hxonh3eSHNAXASJ5hyMNGNBriRhNDuBog3FUiyQngNA6ASJnhu1qfbiTiuAXAR1mhRiUgNA6AOwoAvwoAvslDLsNDuBmgRQYdcJUg24NGNBmgztTdKAXARxniRaqAOTNEu43ANoNgyQZfqA6EKoNgyQZf3aqguA6ARFThR9YebFmh3INDuB0fcsNGOwXASJUhzJQjzINGNBvfzBngbaOdcF0ANoNfyQPeKA6Ez0XARFngSJqg2pkfwUbbvPNGSXNg24NGOsXAR9qeyaqAOTqENoNdbF0fb9ZAOTNd3ariy9YANoNfbFngNA6AOpriRhli2QPiyl9BrAoBqtTebQSfzI9BrAoBr48eqtRfbpXDcB1gyM9B25ngSUQhR8SAyeUgyo9BqFReReReRdSAzJqdb5reR9qgL0SizBmgSFXdcJQCvEXAvEUBr48hyx0futPHKiFEuopEqtEELAXELElLvwqDvwoAwopFuopEutEELIXELElLvw0Dvw1AwooDvw1AwooDvwrAxTlLLsXELslLvAXELslLvAXELElLvsXELElLvsXELslbNtFFKooAwo5DvslLvPXFqtEELwXFqtEFqopENtEEqo3Awo1DvhlLvMXEutfBqtRfbpXHKhOeReReReRBr48cu9odcJTHOphD2h#Hxonh3eSHNAXASJ5hyMNGNBriRhNDuBog3FUiyQngNA6ARFngSJqg2prANoNgbxqe2QZAOTNDLllEusoAvMNDuBmg3eQhNA6AOsZFqAXARpUgRXNGOwXARpUgRY1hRoNGNBPg3iZgy9meuAXARxZfb1miyQngNA6ARxXhymmAS0XARFngSJqg2pkJQa5jRdNGSXNg24NGOwXAR9qeyaqAOTpFuoNdbF0fb9ZAOTNd3ariy9YANoNfbFngNA6AOpriRhli2QPiyl9BrAoBqtTebQSfzI9BrAoBr48eqt0hRxZh2enhR09B3Jqdb5rgyx0eKloDusqCKh#HztngzQSg24leRQXgu1qibpQHKiZg256ecBnBqtog2QZizE9BrwZGvMoEvl4FvIlEK41ELI2Fvl0FuspGu4qFvApELE4AvwZFLw0FOI4FvIlELlZEOIqELwrGus3DOh0ELApEvP0Avw5DOA0EOwpErllFq43FvwqELs5FuspGK4qFvApELE4AvsZFLw0FOI4FvE4AvsZGvMoEvl4FvIrAvsZFLw0FOI4FvE4AvsZGvMoEvl4FvIrAvwpDOhqFvI1FrAlGK4pFOMrGLErEKspEK43FrM4FOPrAvPZELhpFLh2EvElELsZFrh1Gvl4FKspDOl1Evs4GvI0AvwoDOhrEvdqEvPSAyeUgyo9BqFReReReRdSHOphD3tngzQSg24#HzBQd3Iljv0SELsZFKhljL0SGKhli2QPiyl9BrPZFKhlfyaUe2m0HKh2BqtRfbpXHKhOeReReReRBr48cu9qebF0HOpodcJTAyI9B004DOI5FLw3GLEpDvdZGLPrFvErGKtEFu41GvA2GvPoFuorDOwoFLE5FOd5AworDOl3FrloEOE1DvEZGvw0Frw2FOAlLvhZFrM1GLsqGLdXFq42FOl1FrPpAwo1DOw0EvA1FOI5DvhZFOd4FLh5EKtEFK4pFvsqFLd0GKo4DOd2GvM3GLwlLvPZFvP1ELh5ErwXGu42FOl1FrPpAwo5DOI5FLw3GLEpDvIZFOI0Fvd3FrwlLvlZFvP1ELh5ErwXFu42FvI0FOh3EKtEGu40GLMpFrPrEKo2DOP5ErIrErPlbNhleRQXgu1qibpQHKiZg256ecBnBqtRfbpXHKhOeReReReRBr48cu9odcJTHOphD2h#Hxonh3eSHNAXASJ5hyMNGNBriRhNDuBog3FUiyQngNA6ARFngSJqg2prANoNgbxqe2QZAOTNDLdlGuspAvlNDuBrd2xXeKA6AOwZEKAXARxZfb1miyQngNA6ARxXhymmANoNdb92ecANGNAoDOhNDuBXfb5WAOTpDuBXfb5WicBXAOTNdctUGStUhziQdRYUiuB9DuBOg250hR9Xc3QvhaT2AOU7AR9ZAOTpDuBnhRJQhNA6EOEXARxOiyQngNA6ARF1h3JngKAXARQOg24NGNA8h3eSAziUezJTHKhqEuhlfyaUe2m0HKhqEuh#Hyhlh3Jqg2YQHKhOeReReReRBqtrizBnf2MYgyQZebFmhv0ShR91gRISAzF0hR9WeK1Xfb5QfR9UgO0ShR91gRISAzJqdb5reR9qgL0SizBmgSFXdcJQCvwZFKolEq41CKh#HyaXgyQoh2Mld3l9BrlZFKhld3P9BrdZGuhlhSl9BrwZFqhlhSP9BrwZFqhleRQXgv0SA2eReReReNh#HxonebpXfctreL48hyx0futPHKiFELAZELs0DvEZELP2AwEpEq4oFOw2FOA5DvIZELMqFLP4ELwlELEZFLP5FrdpGKo1DOI1Evd2EOlrAvwrDOM5GLh2ELPXFN44EvIqFKtvELEZFLP5FrdpGKo4DOw1FrlrFrw3AvwrDOs2ELd2EOPXGK40FLM5Evw4GKspEN4pEvIXELsZFvwqFKtFFu44GLdXELsZFvs0AwErDOPrGvErFrs4DvPZFvI3FvspGvPlEq40EvsqErloFKo4DOw0GLErFrw3AvEZFvsoEOE4EvMXFN43GLM3FKtvEq40EvsqErloFKo1DOI0EOw2EOlrAvEZGLE4ErE3EvlXFu4pFvIoGLlpEKs0DOl5FNorDOw4FrMlLLw0DOMoGLMXEu43GLs1AwEpFq44EOh3Fvd1DvIZELs5FrI4FrIlELhZGvA3FrI2FKo5DOI5EvA1ELA2Avw0DOMoGLMXELAZGvs5FKtFEN40GLs1DvwqDOloGLMlIq0oDOlqFrh0FOI3FNo5DOI5EvA1ELA2Au0oDOlqFrh0FOI3FNo0DOwoGLh0Gvh0AvAZFvPoFKooDOh5EvMSAyeUgyo9BqFReReReRdSHOphD3tmiyl#Hxoner48cu9riRh#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#Hxoner48cu9riRh#ANoNizQoeKA6ASF2eqAXAStnh2Q0fb9ZAOTNd29ZizBngzENDuBYdcBSfb4NGNAoAu0pEus4AvMNDuBXfb5WAOTpDuBPg20NGNBohRa2c2eUgyMNDuBXfb5WicBXAOTNfSE6hzBQiQ9RfbpQc3tXdcQQhNAXARQOg25rd29Xg3ANGNA1FyxmeRdNDuBUd29Zh2Fngy9qg3eQhNA6AOE5GvtQEqAXASFOdbpQAOTNEK4qANoNdb5Ugbx0fb9ZAOTNdbpofywNDuBTfbJQAOTpDuBTfbJQg25Yg2BUgyMNGOx9DuBOg250hR9Xc0YCMwx1AOU7AR9ZAOTpDuBnhRJQhNA6ELAXARxOiyQngNA6ARF1h3JngKAXARQOg24NGNA8h3eSAziUezJTHKhqEuhlfyaUe2m0HKhqEuh#HyhleRQXgu1qibpQHKiZg256ecBnBqtRfbpXHKhOEvsoEvsoBqt0hRxZh2enhR09B3Jqdb5rgyx0eKl2DOMXAvIUBr48hyx0futPHKiFFq41DvdlIrhZFKo2DOA1FLPqEOEqAvhZFvsqErd4GLEXFN41ELw4FvI2Fus3DOAoFrwoFOh4DvdZFrs3ELs2FrllLvAZEOs3ELs2FrlXELwZFrs3ELs2GutvEK44ELd1GvA0GKopEN4oGLh2ErwpAvwZELlrFvw3FLwXELAZEvP3FOEpEKsoDOh5EOl5ErApGKopEK43EvhpEvd4AwEoDOIoEOE2GvPqFqopEK4rELd1GvA1AvsZFvsqErd4GLA3DvwoDOd4ErIpFrMlEu43GLA4GLEqELPXELsZEOPqGvPrENtEFK4oGvM3Gvd0Fuo2AwooDOh5EOl5ErApGKopDOhoFrwoFOh4AwEoDOIoEOE2GvPqFqopDOEpFOM4EOI5AvsZFvsqErd4GLA3DvsZFOlrFvw3FLwpAvsZFrPqGvPrEOw5DvsZEOPqGvPrEOw5AwEpDOw4ErIpFrMpDu0oDOs5FrdrELs3EOPlEK44ELd1GvA0GKoYEu4oGLh2ErwoFrA5AvAZEOs3ELs2FrlXEu4qGLA4GLEqELPlLvhZEOs3ELs2FrlXFK4qGLA4GLEqENtvFq40EvArFOl5Eqo1DOI4Gvw1FLE2AvhZFKo1DOh0Fvs3Frd4AvhZFKo2AxTSAyeUgyo9BqFReReReRdScu8#Hxoner48cu9riRh#ANoNizQoeKA6ASF2eqAXAStnh2Q0fb9ZAOTNd29ZizBngzENDuBYdcBSfb4NGNAoAvslGusoANoNgyQZfqA6EKoNey9YAOTNgRa4ix9RfbpQANoNgyQZf3aqguA6ARUrGR5QjzJkeRQXea9ogyx5ecANDuBUd29Zh2Fngy9qAOTNFLJmdbeRANoNfbFngSFOg2pnhR92ecANGNArGLloeLENDuBrd2xXeKA6AOwZENAXARxZfb1miyQngNA6ARxXhymmANoNd29ojKA6EKoNfyQPeKA6EKoNfyQPeb9Zgb9NfbpQAOTpkKoNhy9riyaqAOTNfzJ0hzE6cu9hD2xXgy9TdK50iQonfb1me2arcu9ogyx5ecBhD3tqeceUechZfStSANoNfyprhcamgyQ0jKA6EKoNiRxrix9rf2QoESBUe2m0AOTpDuBTgzFRg3BOeKA6EKoNfyprhbmrg3B0AOTpDuBTgzFPebB1eqA6EuoNh3B2h2imAOToDuBqebpndbJ0fb1QhqA6ENoNhRpPgR9qgRINGOwXASJme2FnhSENGOwXAR5njcINGOwXASQnicJ1dRaog3F0ecANGOsXAR1ndRQXecFQebYRibpXAOTpDuBniRaqgyx5hqA6EKoNiRxrix9YfbJqg2pXhRariuA6DLwXASemh3Jkhyx1h2aqg2pXdRiXg2xPAOTpDuBniRaqgyx5c2QYdbiQc3FUjRMNGOwXAR92ecBXdcQkf2aQhuA6EKoNg3eQhRpmja94c3FUjRMNGOwqDuB2dcF0c21UezBngypkdb5PgyQYfcINGOwXASemh3JkgbQPhR9Xgx92gbxoAOToDuB2dcF0c3tmicFQhR9Xgx9mgRJXfb1UiuA6EKoNiRxrix9odcarecBngypkiR1mhuA6EuoNiRxrix9og3F0hR9Xgx9mgRJXfb1UiuA6EKoNiRxrix9og3F0hR9Xgx92gbxoAOToDuB2hyxUex9Zg3BQgbxUgRQZe3JUgbMNGOwXASemh3Jkfb1ohRarh2QngR11iyMNGOsXASeodbQPiRQPeb90fb1Qg3a0AOToDuB2dcF0c21UezBngypkdb5PERpUgbQ0AOTYEKoNiRxrix9odcarecBngypkdb5PERpUgbQ0AOTYEKoNiRxrix9og3F0hR9Xgx9mgRIqgyQYfcINGN0pDuB2hyxUex9riyxqiypUgbQ0AOTpDuB2hyxUex90fb1Qg3a0FKA6DLwXASemh3JkhzBQhR9Xgx9mgRJXfb1UiuA6ENoNiRxrix9ohRaqg2pXc2Fnib50ecANGOwXAStmhSJZecBohRaqg2pXg3ANGNBmgRINDuBTgzFnicJrfbJQAOToDuB2dcF0c3tqecBngypkiR1mhuA6EuoNhRaXg2xPhyp1hqA6EKoNiStmfbJkiyQYeb91iuA6GvsXASemh3JkiyQYeb91iuA6ErsXARJqib5OfzANGOsXASemh3JkgbQPhR9XgyBSgy9mevANGOx9',
		u2: '',
		u3: '',
		u4: '',
		u5: '',
		u6: '',
		u7: '',
		u8: '',
		u9: '',
		u10: '',
		y: 'xx??x?=xx??x?=',
		p: '#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RE2JNebM4f1onErA3EN54gboNDuBog3F0hR9XguA6ARm0iztrGQoncu92EK1OFrFQDRY4d2JZDRFngaonFzA1ErxRE2JNebM4f1onErA3EN54gboNkKoNgcQ2dcF0ErA3EqA6jqB0fcJXeKA6AQp1EvIqEap1EvIrEQp1EvIreap1EvIrGKtbIaFMAum0ecF0CKAXARQPAOTNiRxrivI0ELANDuBohRaqg2pXAOTNfzJ0hzE6cu9hD3dpDbE3E2MZf3mOey4Zd29Ycu80hOMrEbdreyBQeLmWcu8rEOhrDSmYguAXAStmicFQhR9XguA6ARm0iztrGQoncu92EK1OFrFQDRY4d2JZDRFngaonFzA1ErxRE2JNebM4f1onErA3Eq54gboNDuBog3F0hR9XguA6ARm0iztrGQoncu92EK1OFrFQDRY4d2JZDRFngaonFzA1ErxRE2JNebM4f1onErA3Eq54gboNkKoNgcQ2dcF0ErA3FuA6jqB0fcJXeKA6AQp1EvIqEap1EvIrEQp1EvIreap1EvIrGKtbIaFMAumchRxohyaqAwxXgy9TdK50iNtIhRaqg2pXCKAXARQPAOTNiRxrivI0ELENDuBohRaqg2pXAOTNfzJ0hzE6cu9hD3dpDbE3E2MZf3mOey4Zd29Ycu80hOMrEbdreyBQeLmWcu8rEOh0DSmYguAXAStmicFQhR9XguA6ARm0iztrGQoncu92EK1OFrFQDRY4d2JZDRFngaonFzA1ErxRE2JNebM4f1onErA3Fu54gboNDuBog3F0hR9XguA6ARm0iztrGQoncu92EK1OFrFQDRY4d2JZDRFngaonFzA1ErxRE2JNebM4f1onErA3Fu54gboNkKoNgcQ2dcF0ErA3FKA6jqB0fcJXeKA6AQp1EvIqEap1EvIrEQp1EvIreap1EvIrGKtbIaFMAumchRxohyaqAwxXgy9TdK50iNtFfbJqg2pXCKAXARQPAOTNiRxrivI0ELINDuBohRaqg2pXAOTNfzJ0hzE6cu9hD3dpDbE3E2MZf3mOey4Zd29Ycu80hOMrEbdreyBQeLmWcu8rEOh1DSmYguAXAStmicFQhR9XguA6ARm0iztrGQoncu92EK1OFrFQDRY4d2JZDRFngaonFzA1ErxRE2JNebM4f1onErA3FK54gboNDuBog3F0hR9XguA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',
		isflash: -1,
		brand: "playerjs",
		brandurl: "//playerjs.com",
		motions: [],
		dt: true,
		pr: true,
		ga: false,
		ab: false,
		gatracked: [],
		pjsga: false,
		pltxt: '//.txt//',
		pldur2: 0,
		files_quality: [],
		files_audiotrack: [],
		files_quality_ag: [],
		files_subtitle: [],
		files_channel: [],
		plhistory: [],
		rightclick: 0,
		vastclick: false,
		focus: false,
		start: false,
		start2: false,
		metadata: false,
		ni: '<noindex>',
		ni2: '</noindex>',
		small: window.screen.width < 1000 && window.screen.height < 1000,
		moving: [],
		moved: [],
		menuproc: {
			'scale': 1,
			'contrast': 1,
			'brightness': 1,
			'saturate': 1,
			'sepia': 0
		},
		fltrs: [],
		piped: 0,
		or0: 0,
		live: false,
		subtitle_on: false,
		starttimeout: false,
		thumbs_on: false,
		thumbs_img: [],
		noads: false,
		clicks: 0,
		airplayed: false,
		timerInterval: undefined,
		toolbarInterval: undefined,
		toolbarhidden: false,
		sFNKZsHf: function(x) {
			var a;
			eval(decode('#1dKs9AzlZh3aNh3JqCvAUG2enhNm2dcAlfL00G2P#DLw7fK0YCcYUeNmQjyQrium2bqBNfqAWfa0UCcYUeNm2bqBNfqAWfa0mHKANCcYmAv0ldK5qectXdbFQCzdZeRQXeLFkh2aodcBmiy9qC2ApCzegARBWANYUcKPXANAUG319kcJqjcYmAv0ldOATdKP7kbFmiyFTCyMUj2w9ANA7kITlAuslAuslAuslAuslAusleSaZd3JUg24ldOwTh3JqCKt7uNslAuslAuslAuslAuslAuslAuslhRa0icBZAyB0g2wTeb5Og2JQaaBBI29Yhy9Zeb50CzF0hNPZhRaogyxOeKlnBKmgEu05IK1yccXqkKPneqoCAuslAuslAuslAuslAuslAuslAuslAusleSaZd3JUg24liy9Lg2pUewB5iyarCy1miyFTDutoEKPljoTlAuslAuslAuslAuslAuslAuslAuslAuslAuslhRa0icBZAxF0hRQZeq5RhR9YI2mmhPFneyMTAOt4ANsWAzspCLXCAuslAuslAuslAuslAuslAuslAut9CKP7uNslAuslAuslAuslAuslAut9uNslAuslAuslAuslAuslAutRib5OiyQngNtNENmrizAUAzXCAuslAuslAuslAuslAuslAuslAutqecJ1hR4leyaOg2JQaaBBI29Yhy9Zeb50Cyx0g2ATh3JqCK5rhypUiulNANPZgbxoCye1gRF0fb9ZCyEUAzXCAuslAuslAuslAuslAuslAuslAuslAuslhRa0icBZAuAQANsWAulNEvsNAuXldq5OfyxqI29PeMx0CvsUDSJnM3Jqfb5SCvw2CKPZh2pUd2MTDLAUGoTlAuslAuslAuslAuslAuslAuslAz0UDRUnfb4TANAUCLXCAuslAuslAuslAuslAuslAz0='));
			return a
		},
		reloaderTimer: 0,
		timerTime: 200,
		tagvideo: false,
		controlover: false,
		doctype: document.doctype,
		d: location.hostname,
		domain: location.hostname,
		href: location.href,
		https: location.href.indexOf("https") == 0,
		logos: {},
		gaurl: 'google-analytics.com/analytics.js',
		fd: ["sFNKZsHf", "thTKrkfs"],
		files_speed: [],
		files_scale: [],
		files_sleep: [],
		custom_speed: 1,
		gifed: [],
		thTKrkfs: function(x) {
			var a;
			eval(function(w, i, s, e) {
				var lIll = 0;
				var ll1I = 0;
				var Il1l = 0;
				var ll1l = [];
				var l1lI = [];
				while(true) {
					if(lIll < 5) l1lI.push(w.charAt(lIll));
					else if(lIll < w.length) ll1l.push(w.charAt(lIll));
					lIll++;
					if(ll1I < 5) l1lI.push(i.charAt(ll1I));
					else if(ll1I < i.length) ll1l.push(i.charAt(ll1I));
					ll1I++;
					if(Il1l < 5) l1lI.push(s.charAt(Il1l));
					else if(Il1l < s.length) ll1l.push(s.charAt(Il1l));
					Il1l++;
					if(w.length + i.length + s.length + e.length == ll1l.length + l1lI.length + e.length) break
				}
				var lI1l = ll1l.join('');
				var I1lI = l1lI.join('');
				ll1I = 0;
				var l1ll = [];
				for(lIll = 0; lIll < ll1l.length; lIll += 2) {
					var ll11 = -1;
					if(I1lI.charCodeAt(ll1I) % 2) ll11 = 1;
					l1ll.push(String.fromCharCode(parseInt(lI1l.substr(lIll, 2), 36) - ll11));
					ll1I++;
					if(ll1I >= l1lI.length) ll1I = 0
				}
				return l1ll.join('')
			}('85bc01s212a29333718263q012z1o27312q193x2e1d3q0z112m3q01202m3x3u37242v223p11203a251s27332116212x23211c3u291z113a251s2535211622261y1112161z153x2b2q1731261u3u2t312p113w243e153x2b2o19212611101o253e1i2c2b38182x3s12111o280w12113b233v312b38182v3u12111o2c182v3b233v2b233x3b213x2b233x1z112u2911203u291u2u271r2q1i27203q2e1z23121b3x111120243516212o1b3x111k1t35211d222n3e113w2o2z1q1g27211o1o25111s253t193126143e1e3e2b361c3y2b341v3w2u3q3u37322b3r3720391916211411121o252c1q11113w243e1d373a3v111z23141g1i1h1a1f1k1g1l1f1l3c1a1e1v3e1c2g1d3f163e1r3g1m1e1w1g141f192c1v2e122e1u2e112e1v2d1w2e1u1e152e1v3g102c1w2e172e1t3g1w2e1w2c1m2e1w1e1z2e1w1e1z2c1u2f1y2e1t3e1v2e1u2d192e1v2e1u2e1u2e1g2c1w2g1v2e1u2f1t2e1u3e1z2e1u2g142e1w2g102c1v2g112e1s2e1u2e1u2e1x2e1v2e1v2e1v3e1x2c1u3f1y2e1u3e1s2e1u3e1j2e1u2f192e1u3f122c1u2f1a2e1s3f1j2e1u1d192e1u3g102e1u3f192c1w3f1w2e1s3f1b2e1u3d1v2e1u2f172e1w3f1x2c1u3f1b2e1t3e1e2e1u3d1a2e1w3f1y2e1u3f1b2c1w3f1a2e1s1f1b2e1w3d1d2e1u3f172e1u3g1t2c1u2f1b2e1s3g1e2e1u3d1b2e1u3g1w2e1u1f192c1u3g1b2e1s3f192e1u3d1d2e1u2e1u2e1u1e1h1c1d2g1g3g1c1e1k1f1r3e1t3d1e3f1c3f1k2f143d1q2f1e2f1p1e1d3e1e3e1e1g1r1g1c2g1s3g1e1c1e1f1e3e1d2f181g1u1d1d1g1e3f1c1g1i3f1i2c1e1e1f1e1c1g1r3e1e1c1a3f151g1h2e1d2f1m1e1f1e1i1g1j1g1l1g1l1e161g1g3f1p1g1r1g1k1e1d2e1e1g1h3d1f2f1e1c1u2g1e1f1f1g141e1e3d1e1e1r3f1o3e1f3g1a1e1f1e141e1b1f1b1f1h1d1f1f1l1g1c2e1q2e1e1c1e1e1f3f1c1e1a1d1e1e1j1f1x2e1u2g1j2e1t1e1z2e1w3e1u2e1w3g102c1t2f1z2e1s3g112e1u1e1e2e1w1g1v2e1v2f1h2c1w2g1a2e1u1f172e1w2d182e1v2g162e1u2g1l2c1v2f112e1s3g1z2e1v1c1j2e1u1f1r2e1u3g1m2c1w2e1m2e1r3e122e1u2c1f2e1w3e1o2e1w2f1z2c1w1e1y2e1r2f1v2e1v3d1h2e1w2e182e1v3g1d2c1v2e162e1t2f1v2e1w1c1v2e1t2g1x2e1u3e112c1v2e1q2e1s3e1z2e1v1c1l2e1u2g1s2e1u2f1j2c1v1e102e1t1g1z2e1u1c102e1w2f1z2e1w1g1x2c1w2e1f2e1u1f1j2e1u2c1z2e1t2g1r2e1w1e1f2c1u3g1h2e1t3g1c2e1u1c1t2e1w1e1d2e1t2g1v2c1u2g1y2e1t3f1e2e1v2c1h2e1v1f1h2e1v2g1r2c1v2g1l2e1t1g1j2e1u1c1t2e1v3e1f2e1w2g1i2c1w1f172e1r2g1q2e1u1c172e1w3g1t2e1v3g1u2c1u1f192f1y2e1w3f1v2c1t2f122e1t2e1y2e1w2c1v2e1w2g1c2e1t3f1x2c1u3e1v2e1t2g1w2e1w1e162e1w1g152e1u1g192c1v2e112e1s2f1h2e1u2e1u2e1u1e1u2e1u2e1j2c1u1e1z2e1t1g1r2e1v2d122e1w2e1p2e1v2e1b2c1w2f122e1u1f192e1u2e1u2e1v2g1p2e1u2e102c1v1g1x2e1s3g1u2e1t1e1u2e1w2e1t2e1t1e1x2c1u1f1v2e1s2g1l2e1u3c1u2e1w1f1g2e1u2g1m2c1w2f1z2e1u3f1j2e1t1e1k2e1u3g1o2e1w2e112c1t2e1w2e1u2e1e2e1w2c102e1w3g1r2e1u3f112c1v2g1v2e1r2f1v2e1u1e192e1w3g1t2e1w3f192c1u3g1v2e1s3e1v2e1v2e1q2e1v2e1b2e1u2g1s2c1w3g1f2e1t2e1f2e1v2e1d2e1v1g192e1v2e122c1v1f1q2e1u3g102e1v2d182e1w1g1r2e1v2e122c1u3e162e1s3e1d2e1t3e1h1e122e1s2f102e1t2c1t2e1v2e162e1w3f182c1u3g122e1r3e1v2e1u2e1f2e1v2g162e1v1e1c2c1w2g172e1s2f1t2e1w2c172e1v2g1d2e1u1e1x2c1w2g162e1t2e1h2e1u2e1h2e1w3f1o2e1v3g1l2c1v2g162e1t3g1u2e1u2e172e1w2f102e1u3f1f2c1u3g1q2e1t2g1q2e1v3d1i2e1w3f192e1v2g1t2c1w2g122e1t1g1v2e1w2e102e1v2g1f2e1w3e1z2c1w2e1x2e1s3e1g2e1v2c102e1u2g1v2e1v1f1t2c1u2e1j2e1u1f1c2e1v2e1t2e1v3f1s2e1v1g1t2c1t2e102e1t2g192e1u1c1v2e1v2e1t2e1v2g1f2c1u3g102e1t2g102e1u2c172e1v2g1h2e1v2e1d2c1w3e1f2e1s1e1h2e1u2c1a2e1u1f1j2e1u1g1s2c1w2g1r2e1t1g1l2e1v1e1d2e1u2f1c2e1u2f1r2c1w3f192e1t2e1v2e1t3e192e1w3e172e1v3e1t2c1w1e1x2e1r2f193f19121m1q3g193d1s1e191e133g143e141e1k3f171g1e2g1m1e1x3e1k3g152e1t3g1x2e1u2c1x2e1u2g192e1w1f1y2c1v2g1q2e1s2f102e1t2e1q2e1t1e1u2e1v2e1s2c1u2e1y2e1s3e1b2e1u2e122e1s3e172e1v3g1z2c1u2e1w2e1u1e1q2e1t2c172e1s1e1o2e1u3g1f2c1w2e1e2e1s3g1i2e1u1d1z2e1t2g1j2e1w3g1t2c1w3g1z2e1s2e1e2e1u1c1z2e1u2e1h2e1u1f182c1w3f1a2e1s3f1b2e1s3d1c2e1s3f192e1w3f1l2c1u3f192e1t3e1f2e1s1d1a2e1u3f152e1u3f172c1v3f1d2e1s3f1a2e1u3e122e1s3f182e1u3f192c1u3f182e1s3e192e1s3d192e1s3e1d2e1u3f172c1u3f1l2e1s3f1b2e1u3d1e2e1s3f172e1u3f1j2c1u2f182e1u3f1d2e1s3d192e1s3f1b2e1u3e1z2c1u2e1k1e1h3e1e2f1e1c1j3d1f3f1c3e1d2e143c123d1d3g181f1b1g1f1e1i3f1g1e1c3f1e2g1k3c1q1e1i1f1h1g1e1e1h3c1d2f1k1f183f1e3e1a1d1i3f141f1h3e141g1w2d1l1f181e121d1f1g1e3d1r1e1b3e1c3g1l3g1e3d1g3g1e3f1e3e1e3f1f1d1m3f1k3f1w1g162e1e1c1d1e1d1g1h3f1r3e1y3e1e2f132e1a3f162f1f3c1i1e1i3e1c1e1u2g1m1c1e2g1b3f143g1f2g1i1d1m1f1h1e121g161e1a1d1t1g1b1e1e1e163e1u2c1q2e1u1g1j2e1w2g1y2c1w2e1s2e1s2g172e1r3e1f2e1s2e1i2e1u2g1f2c1u3f182e1t3e1r2e1r2e182e1r2e152e1v2f1j2c1w2e1s2e1s1e162e1u2e1r2e1s3e1x2e1w3f152c1v1g1d2e1u2g122e1s1e1t2e1u3f102e1w2e1u2c1u2f192e1t1e1u2e1s1e172e1t2e182e1v2e102c1u2f1t2e1s1e122e1s1e182e1u1e1u2e1u2g1r2c1u3e1z2e1u2e1v2e1u2c1w2e1s2g1w2e1w2g1f2c1w2f172e1s2e1y2e1t1c1i2e1s3g1y2e1w3g162c1u2g1k2e1s3g1w2e1s2d1e2e1u1e1u2e1u2g1r2c1u2f1y2e1s3g1f2e1s3e1f2e1s3f1z2e1u1f1s2c1w2g1h2e1t1e1e2e1s3c162e1s1g1z2e1v3g1a2c1v1g1h2e1t2f1h2e1t3e1u2e1u2g1y2e1w2g1y2c1u2e1h2e1s2e172e1r2e1f2e1s3g1x2e1u2e1q2c1w2g1t2e1t1f163f172c1u2g152e1u2e1a2e1u1c1z2e1t1e1v2e1v1e1t2c1u2f192e1t3f1z2e1t2c1q2e1u2g1o2e1v2g1t2c1u2e1t2e1t2g1w2e1s2e162e1u3f1h2e1v2g1w2c1w2f1z2e1s2g1x2e1s2e1s2e1s2g1a2e1v1e1w2c1u1e102e1t2f1e2e1t2d172e1s2g1j2e1v3e1f2c1v1g1s2e1t3g1u2e1u3d1d2e1t2g1h2e1v1e1x2c1u3e1t2e1s3e192e1t2d1h2e1u2e1t2e1w2g172c1u2f1h2e1u2f1e2e1t2c1a2e1s2g1f2e1u2f1r2c1w2e1z2e1s1g122e1s2e112e1t2e1w2e1w3g1f2c1v2f172e1s1g1s2e1u2e182e1t2e1f2e1v3g1f2c1u2g182e1u2f1j2e1t2c102e1u2e1h2e1w3e1t2c1w1g1r2e1u1f1l2e1u1d1w2e1s2e1p2e1u1g1j2c1v2f1s2e1t3g1e2e1u1e1h2e1s2f1b2e1u1f1t2c1u2e1w2e1t3e1z2e1u2d122e1s2e1s2e1t3e1s2d1c2e1t1g1y2e1u2g1y2c1v3e162e1s2g1d2e1s2c112e1t3g1p2e1u3e1t2c1w2f102e1s1g1i2e1t2e1f2e1u2g1y2e1w2f1h2c1u1g1v2e1t3e1r2e1u1d122e1t2f1d2e1w1g172c1v2f1h2e1s1e1h2e1s2e1j2e1u3e1q2e1u3e1f2c1w3f172e1t2f1k2e1u2e1j2e1t2e172e1v2e162c1u1g1d2e1t3e1h2e1t2e1j2e1s1e1f2e1u1g1d2c1w3e1w2e1s2g1t2e1t1d1w2e1t2f1u2e1u2e1m2c1w2g172e1t2g1w2e1t2e162e1s2f1o2e1w2g172c1u1g1l2e1u1e1y2e1u3c1r2e1s2e1x2e1w3e1s2c1u1e1d2e1u3e1m2e1u2c1h2e1s3g1r2e1w1e1d2c1w3e1y2e1u1g1t2e1s3e102e1u1g1u2e1w2g152c1w1g1h2e1s2f1h2e1t3e1d2e1t1e1o2e1v3g142c1v2f172e1r2g182e1s2d1y2e1r2e1b2e1u3e1u2c1v1e102e1u2g103e1x3d1b3e172e121m2r1r1g1a1e1k2g141e1g3g1j1f1c3g141f1i1e1l1g1v2e1g1g1w2e1r1e1i2e1w1e1s2e1t3e1k2c1w2e182e1q2g1m2e1s1d1b2e1w2g1k2e1u2g1x2c1u2g102e1q3f102e1s2c1y2e1u1f1i2e1r2g1v2c1v3g1i2e1q2e1u2e1s1d1t2e1v2g1r2e1s3e1w2c1u2g1g2e1s1e1z2e1s3c1t2e1w2e122e1s2g1m2c1w1e1m2e1s3e1h2e1u2d112e1u3e1x2e1t1f1u2c1u1f192e1r3e162e1s1d1a2e1w3f162e1s1f172c1u3e1d2e1q3f172e1u3e1v2e1u1f172e1s3f1e2c1u3f192e1q3g162e1s1d1b2e1u3f1e2e1s3f172c1w3f162e1q2f192e1s3d112e1u3f172e1s3g1w2c1u3f1b2e1r3f1e2e1s3d192e1u3e1c2e1s3f182c1v3f1b2e1q1f172e1t3c1b2e1u3f152e1s3f192c1u2e1w2e1q2e1w1e1f1c143e181e1i3g1b1e141c141f161g1q2e1b1e1q1c1a3e1e1e1e3g141g1h3e1b1g1e3f1q1g1m3e1d1c1e3f1u2g1k1e1b3e1d3e1e3e1r1g1d1g1c3g1f1c1u1f1e3e1b1f161g1s1d1d1g1l3f1d3g1g3f1g2c1e1e1s3f1a3f1j3f183d162e1c1e1d3f1f3f183e1e3g1r3e101f141e1e1c1f3f1u3f1g1g1f1g1m1e1f1e163e1q3f1m3e181c1v3e1e3g1e1g1i3f171e1g3e1q1e1d1e1f2e1s1d1e3g1r1g1d3e1k1g1m3c141e1w3e1s2e1t2g1t2c1w1f1r2e1r1g102e1u3c1g2e1w2e1p2e1s3g102c1u2e1h2e1s2e162e1t2c1w2e1v1e1k2e1u2f1z2c1v2e172e1r2f1w2e1u2e1x2e1v3e1e2e1u2g102c1v2e1a2e1q1g1j2e1t1c1u2e1w2e1q2e1u3f172c1u2f1y2e1s3e192e1r1e1z2e1w2f1o2e1s2e1z2c1v1g1w2e1q3e1e2e1t2e1x2e1w2f1d2e1s3g1y2c1w3g1j2e1s2e1v2e1s2c1w2e1v2g1s2e1s3g1l2c1w2e1f2e1s2e1e2e1r2e1y2e1u3f1w2e1u2e1r2c1v3e1q2e1r1f1r2e1u2c1t2e1u3e1a2e1u1f1z2c1v1e1d2e1r3f1e2e1u1d1h2e1t3e1h2e1s3e172c1w1e1e2e1s1e1m2e1s1c122e1u1f1t2e1t2e1f2c1w2f1h2e1r2e1f2e1u3c1a2e1v2f1q2e1t2e1k2c1v1g1h2e1q2f1w2e1t3e1y2e1u1f1r2e1u1g1t2c1u3e1y2e1s2e1j2e1s2c1e1e172e1s2g1f2e1s2e122e1u3f1x2e1u2e1w2c1t3f102e1q3e1f2e1t2c1f2e1w2f1y2e1s3g1j2c1v2g1j2e1q2f1x2e1s3e1s2e1w2g1k2e1t3e1a2c1w3g1s2e1r2g1a2e1s2d1r2e1v3g1f2e1u2g1m2c1w3e1w2e1q3g1t2e1s1c1b2e1w2f122e1s3e1t2c1w2e122e1q1e1k2e1t3d1l2e1w2f182e1r1f1h2c1w3e102e1r2e1v2e1s2d1y2e1v2e1b2e1s3g1t2c1v2g1m2e1q2f152e1u1c162e1w1f1s2e1t3e1t2c1v2f192e1r3g1v2e1t1c1f2e1t3e1q2e1s2f1w2c1w2g1i2e1s1e152e1s2c1d2e1u3g1b2e1u1g1t2c1w3e1t2e1s2f1f2e1s2e192e1w3g1t2e1u2g1w2c1t2g112e1q3e1h2e1t2c1e2e1t1g1c2e1t1e1u2c1v1g1u2e1q2g1c2e1s2c1d2e1v1e1d2e1u2f1e2c1t3g1b2e1s2e1s2e1t2c1z2e1w2g152e1s3g1x2c1u1f1v1e132e1u1e1f2c1t2g1h2e1r2e1v2e1u2e1t2e1u2g1t2e1r3e1l2c1u2f102e1s2f152e1t2d1j2e1w3g1o2e1s3e1r2c1u2e162e1q2e1m2e1u1d1u2e1u2e1c2e1u2e172c1w2e1i2e1r1e192e1t2e1v2e1v2f1d2e1u1e1w2c1u3g112e1s3g192e1s3c1a2e1w2g1f2e1s2e102c1v2g1x2e1q3f1t2e1u1d1u2e1v2g1h2e1s2g1w2c1u3e1r2e1s2e1y2e1s1e1q2e1v3g122e1u2g172c1w1g122e1q2g1d2e1s2e1r2e1w1g1p2e1s2g1e2c1u2f1t2e1r2f1h2e1u2c1y2e1u3e1w2e1s3f1x2c1t2g1w2e1q3f1y2e1t2c1u2e1w3g1s2e1s3e1f2c1u2f1y2e1q3g1y2e1t2e1t2e1w2f1d2e1t2e1j2c1u1g1s2e1p2g1s2e1t2e1b2e1w3g1k2e1r2g1x2c1v1g1m2e1s1g152e1t3c1t2e1u2f142e1u1f1r2c1u3g1u2e1q2g1w2e1t2e1f1f112e122f1u3e1f321k1q1h1j1r2k1v2r1m2r1k161', 'b1573m3q1t3s221a291s3b3v2z1d3o01101m272z3q193v3e1i1b3v1z1k1a21173s3y1z31141z153v3b2o1732341u3s2t323n113u243e133x392o1930361z3z1o233e1g3c2b361y2v3s11101o260w11102b213v3139381w2v3u1z121m3c182t212n1z3238251q25353c162z2v253c182s27111z3a231q27333e142z381w1c2s271y3s29163s291s3u271o3e1z3w261z113u281z3u263s3o3o0z113z3b3w121o252e2o1z1z21141z101o253e2o2m37303q1z3z3139233v3038143q0z1c1e2t2e292o142s11101d311o112z3825353w253u273r153621111z3a371z31141j1z1c1o3c182t3z2r3c2b213v312o1i27313e393y121m142d1e1c2d1g1c1j1c122f1k1e1c2e1r1c1c3e181g151g1k1c1m1d1h2c1s1f1r2e1t3e1v2c1u2c1w2e1s3g1e2c1w1c112c1s3e1r2e1u2c162c1u2e1p2e1u1e1k2c1w3c1j2c1u3f1z2e1s3c112c1v1d1u2e1s1f1u2c1u2c1w2c1t3g1v2e1u2c1x2c1w2e192e1u1f1y2c1v2e1s2c1s2f1y2e1t2e1q2c1v1c1u2e1t2e1s2c1u3c102c1s3e192e1u2e122c1u3c172e1t3g1t2c1u2d192c1s3f1x2e1s3d192c1u3d1b2e1s3f192c1u3d1c2c1s1f192e1t3e182c1u3d182e1s3f1v2c1u2d192c1t3f1c2e1s3d1a2c1u3d142e1s3f192c1w3d1c2c1s3f182e1s3d1j2c1u1d192e1s3f1d2c1u3d192c1s3f1t2e1s3d1b2c1u3d162e1s3f172c1v3c1k2c1s2f172e1s3d1b2c1u3d172e1u2e1u2c1u2c1g1c1f1e1p1g1c1c1m2d1f3c1b2e141e121d163d1u3d1c1g1u1f1w2d1l2d1a1e121d1c1g1e3d1r1c1d3c1c3f1j3g131d1q1c1k1e1h1f1g2e181c1e2d181e1s1f1j3e1c1c1i3e161d1h3g191g1c3d1u1e1r3c1c1e1c3f1c3d1e3d1e3d1c3f1c2f1b2d1g3d1g3d1b2g1s1e1f1c161e1u2e1f3f1r3d1c3d1e1c1e1c181e1c2g1b2c1e1e1d3d1g2e1c2e1c1e1m1c1f3c1g1f1g2e1j1d1v2c1u1e1j3e1d1g181c1f3e1k1e1f1e1g3f1r3c1r2c1w1e1f2e1t3e1a2c1w1c162c1s3e1z2e1s3d1a2c1u1e1f2e1s3e1j2c1w2c1u2c1t2f1s2e1t2c1e2c1u3e1y2e1r3g1w2c1w3e1u2c1u2g1q2e1t3e112c1v1d1k2e1t2e1i2c1v1e1d2c1t2e1w2e1t2e102c1t3d1z2e1s3e102c1v3c1w2c1s1g1h2e1u3e1y2c1u2c102e1t2e1z2c1u2e102c1t2g1r2e1t3e1v2c1v1e1f2e1s1e1y2c1u2d172c1s3e1t2e1t1c192c1u2e1k2e1r2e1y2c1u3e1u2c1s2e1f2e1s3e1f2c1t2d1h2e1s2e1w2c1t3c1l2c1t2e1p2e1s2c1j2c1w3e1s2e1t2g1t2c1u3c1f2c1t3f172e1s3d122c1u2d1f2e1s2g1h2c1u2e1t2c1r3g1w2e1u3d102c1w2e1r2e1t3f1b2c1v3e1w2c1s2g1p2e1t3d1f2c1v2c1h2e1s2g1c2c1w3e1y2c1r2e1d2e1t3e1t2c1v2d1k2e1u2g162c1u2c172c1t2g1k3e1r2c1v1c102c1u1g1q2e1s3e1y2c1u3e1v2e1u3g1x2c1v2e112c1u2f1b2e1t3c1w2c1v1c1j2e1u2e1h2c1v3e1j2c1r2e1r2e1s1e1u2c1v2c1y2e1s2e1i2c1v2c1r2c1t3g1h2e1s1c1k2c1w1c1o2e1s3g1s2c1w2e1v2c1u2e1x2e1u3c1e2c1v2e1x2e1u2f1u2c1u3e1u2c1t3f1k2e1u3d1f2c1w3e1i2e1s3g1q2c1v3c1j2c1u3e1f2e1s2c1w2c1u1c1b2e1t2e1d2c1u3c1z2c1r2e1p2e1r3c122c1u2c1h2e1t3g102c1u1c1v2c1t2g1v2e1s2e1v2c1v3e1o2e1u1f182c1w2c102c1s2g1p2e1u2c1v2c1w1c1d2e1u2e172c1v3c112c1s1e152e1u1c112c1u2e1t2e1u1f1u2c1v2e1v2c1u2g1c2e1t1e1s2c1v2e1x2e1r1g1k2c1u1e1u2c1t3e1f2e1u3e102c1t3e1t2e1s1g1b2c1t2c1t2c1t2f152e1u2c122c1w2e162e1k3e1u2e1s2c1u2e1y2e1t2g1x2c1v2d122c1u1e182e1s2e1e2c1w2d1s2e1r3e1t2c1v3c1j2c1t3g1v2e1s2e1v2c1t2c1t2e1s2e1q2c1w2e1j2c1r3e1x2e1t2e1r2c1u2c1o2e1u2g142c1v2e122c1t2g1x2e1u3c182c1w2d1u2e1r1e1v2c1w2d1f2c1s3e162e1r1c1x2c1u2c162e1t2e102c1u3e1v2c1r3e1x2e1s2c1d2c1w2e1y2e1s2g1o2c1u2d1b2c1s1e1p2e1s1e192c1w1c1t2e1u1e1r2c1w1c1h2c1r1e1p2e1u2c1f2c1u2e1r2e1t3g172c1v3e1j2c1u2g1v2e1s2d1y2c1u3c1h2e1t1e1s2c1u3e1t2c1s3f172e1u1e1r2c1u2d1w2e1s3g1t2c1u2d1q2c1t2g152e1t3d1l2c1v2e1y2e1r1g1d2c1w2e1m2c1u1g1t2e1s2d1h2c1w2e1b2e1t2f1y2c1t1c1r2c1s3g142e1t3c1t2c1v3e1d2e1s1e102c1t1e172c1u2e1k3f1x2d1u3d102c1h142i143c141e1k3g1g2e1f3d162c1g3f1a1g1g1d1q1e1l1c103g1c1e1r3e142c1w2e1p2e1s2e1z2c1u2c1i2c1s3e1t2e1u3e1w2c1v2c1r2e1u2g1g2c1t2c1z2c1s2f1y2e1u2c182c1u2e1v2e1u2g1b2c1s1d182c1q3e1z2e1s1e1g2c1w1c1s2e1t2e1k2c1u2c182c1q2g1p2e1s1d192c1w2e1k2e1u1g1x2c1s2e102c1q3f102e1s3c1w2c1u1d1i2e1r2g1v2c1t3e1i2c1q1f192e1u3e182c1u3d172e1t3g162c1s3d192c1s3f1c2e1s2d172c1w3e1e2e1s3f192c1u3d1f2c1q3f182e1u3e1e2c1u3d152e1s3f172c1s2d192c1s3e1a2e1s3d182c1u3d182e1s3f182c1s3d1c2c1q1f172e1t3d1b2c1u3d172e1s3f152c1s2d192c1s3g1w2e1s1d172c1u3d1c2e1s3f172c1s3c112c1q3e1w2e1k1c123d1q1e1i1f143g121e141e1u2e1d1f143g103e1i1d1f3c1b2f161g1c1d1b1d1s3d1d1g1g3f1g1c1d1c1e1c1d1g1p3e1c1c183d151e1f2e1b1f1k1d1f1c1i2c1q2g1j3g1d1c1j3c1e2d191f1j1f181c122c1b2d192f1b1f1b2d1b3c1a1c1b3f183f153c1i1d1u3d1d2g1c3g1f1c1f3c1d1c171f1r1g1s1e123c1w1d123f1c3f171e1h1d1u2d1h2g1p1e1a3e181d1r3e1b1e1h3e1c1c1g2c1e1e1f2e1i1g1c3d1f2c181d1q2e1u2e1f2c1r2e1w2c1q2g1y2e1t3d1x2c1v2c132e1r2f1r2c1s3e1x2c1s2g102e1s1e1a2c1u2e1y2e1s2g1o2c1t1c1s2c1p2e1t2e1s3e1h2c1u2d1r2e1s3e1a2c1r3c122c1s1g1b2e1u2e1s2c1u1c1f2e1t2e1d2c1s3e1w2c1s2f1z2e1r2e1m2c1w3e1f2e1s1g1u2c1t1e1v2c1q3f1t2e1t3e1h2c1u2c1j2e1s1e1d2c1s3d1u2c1q2e172e1u3c1y2c1w2c1t2e1s3f1q2c1u2c1y2c1s2e1r2e1u3e1y2c1t3d1j2e1s2e152c1s2d102c1p1g1x2e1s2c102c1u3d1v2e1u3g1d2c1t2e1q2c1s2f1v2e1u1e152c1w3d1c2e1s2f152c1s3e1f2c1s1g1q2e1t2e1i2c1v2e152e1s3e1b2c1t1e172c1r2e1b2e1t2d1r2c1v2c192e1t2e1u2c1u1e1q2c1r3g1p2e1t1d1s2c1u2e1r2e1u2g152c1s3d1q2c1q3g1x2e1t1c1g1c122c1r3e1w2e1s3e1t2c1v1d1f2e1u2g1j2c1s2d1i2c1p3f1t2e1u3c1f2c1w1c1y2e1u1f1x2c1t3c1x2c1q2e1p2e1u2c1v2c1v3c1r2e1t3e102c1u2d1w2c1r2g1x2e1s3c1r2c1v1d1w2e1r1g1u2c1t2d1h2c1s3f1j2e1u1e1x2c1w1c1w2e1t2f1t2c1s2e1c2c1s2g1h2e1t3d1d2c1w2c152e1s1g1s2c1u2d1h2c1s2e102e1t3e102c1v1c1x2e1s3f1u2c1u3c1y2c1q3e1x2e1u2e1y2c1u1e1y2e1u3f1w2c1u2c1r2c1s2e1z2e1r2e1l2c1v1d1r2e1s1e1q2c1t1c172c1s1g1y2e1u3c1d2c1w2d1y2e1s1g1u2c1u1d122c1p2g1x2e1s2c1x2c1u1d1s2e1t2g1o2c1t1c1e2c1q3e1f2e1s3e1d2c1t2e1k2e1t1g1o2c1s2e1k2c1s2g1o2e1t1e102c1w1e1j2e1u1g1s2c1s2d1h2c1q2e1z2e1r3e172c1w2c1u2e1t2f1t2c1s1c102e1q2e1t2g1f2c1s1c1s2c1r3e162e1u2e1v2c1w3c1r2e1u2f1a2c1s3c102c1s2e1t2e1s3c1m2c1w2d1r2e1u2e1u2c1u1e1z2c1s2e1b2e1t1e102c1u3e1b2e1s1e1u2c1t2e1m2c1p3g1r2e1t2c1j2c1v2c1w2e1u2g152c1t2d112c1r2f1d2e1s2d1w2c1w2c1w2e1r2g1v2c1t1e1w2c1q3f1d2e1t2e102c1v2c1u2e1r3g1k2c1u2d1d2c1q2e192e1s3e1y2c1u2d1g2e1s3e1s2c1t2e1z2c1r2e1r2e1s2e1v2c1w3e1s2e1s1g1r2c1u3e1u2c1s1e1d2e1u2c1h2c1u3d182e1s1f1w2c1s1c122c1r2f1f2e1t2c172c1v1d1r2e1u2f162c1s3c1h2c1r2f1c2e1r1e1l2c1w3c152e1u2g1f2c1s1e1v2c1q2e1g2e1t1e1t2c1v1d162e1s2g1j2c1r1e1c2c1q1g1t2e1s2d1r2c1u1c1y2e1t2g1r2c1u3d122c1p2e1b2e1r2c1x1c162c153e153f1y1c141s2f1e1e1g3e1w1e1j1f191e1h1d191d1h1d1d1e1h1e1s1e1l3c1u3d1e2e1q1e1g2c1s3c112c1u1e1t2e1s1d1r2c1v1c1g2e1q1f1v2c1t2c1r2c1u1g1t2e1r2c152c1w2c1y2e1q3e1c2c1u2c1t2c1s1f142e1q2c1u2c1u2e1k2e1r3e1x2c1u3e102c1t2e1w2e1q3d1k2c1u2c182e1q3e1p2c1u2c1s2c1t1e1e2e1s3c142c1w2c1z2e1q2e192c1u2e1g2c1t3g1h2e1q3d182c1u3c1c2e1q3f172c1s3e1d2c1s3f162e1r3c192c1u3d172e1q3e1f2c1s3d1a2c1u3e1b2e1q1d192c1u3c1h2e1q3f162c1u3d1b2c1s3f172e1q3c1z2c1u2d192e1q3f1c2c1s1d1b2c1s3g1a2e1q1d172c1v3e1b2e1q2f162c1s3d1a2c1s2f152e1r3c1j2c1u2d182e1q3f172c1s3d192c1s3f1r2e1q2c1u2c1h1c1f3d123g1d2d182e1e2e1c1e1g3g1k3e1y2e1e2c1c1g1a3g1f1c1b2d1m1e183f1b3e181e1g3e161e1h3g101g1u2d1j3d1a3c121d1d1f1c3e1m1c1d3c1d3g1h3f111e1l1c1k1e1h3f1e2e161c1f2d181e1s1f1h3e161c181c1a1c181e1q3g1h1c1a1c1c1e123d1d3g1a1c1i2d1e3d1f3e101g123e1d3c1e3e1e3g1h1g1d2c192d161d1c1e1d3e1d2d1i3d1c1e1g1f1d3g1i1e1h2c1u3e1j3g132f1c3e142d1g2e1c1e1d3e162c1u2e1z2c1r2e1i2e1s3c1h2c1u1c182e1r2e1x2c1s2c1a2c1s2f1p2e1s2c1q2c1u3e1p2e1s2f1f2c1t2d1v2c1t2f1w2e1s2d1z2c1w2e1p2e1s2e1c2c1t1c1y2c1s1g1w2e1q3e1d2c1t1e1i2e1s2g1t2c1u3c102c1t2f1p2e1s3e172c1w2c1d2e1r3e1p2c1s2e1v2c1t3g1j2e1s3d1e2c1v3e1r2e1s2f1u2c1s2e102c1r3e132e1s2c1w2c1u2c1v2e1s2g1u2c1s3c1c2c1t1g1p2e1r2e1s2c1u2e1r2e1s1e122c1u3c1v2c1t1e1a2e1s2c1d2c1w2c1s2e1s3g152c1s2e1i2c1s3e1d2e1r2e172c1v2e1f2e1q2g152c1r2d192c1u2e1b2e1r2e1h2c1v2e1h2e1q2e1b2c1u2d1u2c1t3g1p2e1q3e1z2c1u2e182e1r3g1v2c1r1e1u2c1r2g1h2e1r2e1r2c1v3e152e1q2f1h2c1s1e1d2c1r2f142e1s1e1t2c1u2e1y2e1d2f1q2c1s2c1u2e1r2e1q1e162c1u2c1q2c1r2g1c2e1q2e182c1v2c1w2e1q1e1v2c1s2c172c1s3f1s2e1r3d1x2c1u3d102e1p3e1u2c1t2e122c1t2g182e1p2c1s2c1u1e1x2e1r1e132c1s1e1v2c1s2e182e1s3e1a2c1v2d1j2e1s2e1u2c1s2d192c1u1e1q2e1s3e1f2c1u2c172e1r2e1x2c1s1e1k2c1t2g182e1s3e1w2c1t2c1r2e1s1g1w2c1u3e192c1s3g1w2e1q2e1y2c1w2e1d2e1q3e1j2c1s3e192c1r1g1t2e1q2e102c1t3c1h2e1p3e132c1s3d1x2c1u1e1w2e1q3c1f2c1u3c1w2e1s1g1a2c1u1c1d2c1u1f152e1q2e1t2c1w3d1u2e1s2e1a2c1t2e1t2c1t2g1v2e1q3e102c1v2e1q2e1q3g1b2c1u1e1j2c1t3f1b2e1s2d1s2c1u1c1t2e1q2g1h2c1t1c1u2c1u2f152e1q3e1x2c1v3c1t2e1q2f1u2c1s2e1c2c1u2g1d2e1f2c1t1c1f2c1t1g1u2e1s1d1y2c1u1d1r2e1q3e1t2c1t3e1e2c1t3f1v2e1r3d1w2c1v2d1u2e1p2f1c2c1u2e102c1t2f1r2e1q3d1s2c1v1c1k2e1s1f1r2c1t2e1z2c1s2g1q2e1s1e1f2c1v3e1v2e1s2f1s2c1u2e1l2c1u2f182e1q3c192c1u2e1a2e1s1g1p2c1u2e1u2c1t3g1p2e1s3d1f2c1t2e1b2e1s2e1p2c1s3e1r2c1u3e152e1p2e1v2c1u2c1h2e1s1e152c1u3e1w2c1s3e1d2e1q1c1x2c1w2e1r2e1s2g1f2c1s2d1t2c1u1g1r2e1q3c1w2c1v2c1y2e1q3e152c1u2d172c1u2g1w2e1p2e172c1w3e1t2e1q2e152c1t2c172c1s1f1t2e1s3e162c1v1e1p2e1r2g1v2c1u2e1v2c1u2f1k2e1s2e1w2c1u1e1q2e1q2g182c1r3e1r2c1u2g1d2e1s2d1i2c1u1e152e1s2f1u2c1t2c1j2c1s3f152e1r1d1w2c1t2e1w2e1d2e1q2c1w3d172d12142c1l1c1b1q1g2v2e1p1m221o', '9aa0c2b35333w351y391g25322q1b3x3c1d3q02111m27213q2o253e2q2o2y233a1g25211g3e2b381c2v3u11311o360y11313b213x213b381a2x3u11311m21182v312n11223a251q27353e162z2x253e1y3s2911113a231s27353e1431281y121z1611153x392q1921361s3u2v213p1z3w263e153v3b2q19213412111o251z3w28113w26113w28113u2q213b233v3e2b233x29233x2720393x2e11112235163q02303e2b3y141m3e1d3q013z2m2411311m2111113u2711211f3b3v3e1a1y12302x3w2u353c12111e1o1z153x29231t322q14252522352e182635211f1g183e1631281w111211323s2911121o3s370131243316351q1k3d1q1g1m1f1f1e1s3f1l2e1s3f1h3g183g1m2g1k1c1j2f1g3e1s3f1m2e1v3c112e1w3g1y2e1v2e102c1u3f1m2e1s3e1a2e1u3c1t2e1w2e1q2e1v1e1i2c1w2e162e1u2e112e1u2c1d2e1w2g1e2e1v3g1l2c1u2e1w2e1s1g162e1w2e1t2e1u2e1z2e1w2e1i2c1w3e1v2e1u3g1y2e1v3c1v2e1w2g1g2e1v2e1z2c1w2f102e1u2e1a2e1u2e1z2e1w2g1b2e1u1f182c1w3g1x2e1s3f1b2e1u3d1b2e1u1f182e1u3f112c1u3f1b2e1s3e1k2e1u2d192e1w3f142e1u2f192c1v3f1q2e1s2f1b2e1w3d162e1u3f192e1w3e1e2c1u2f192e1u3f1f2e1u3d192e1v3f1c2e1u1f192c1u3g1d2e1s2f192e1v3d112e1u3f162e1w3g1c2c1u2f1a2e1u3g1x2e1u3d192e1u3f192e1u3f1w2c1u2e1w2e1f1e1j3f1i1e1i3g1w1f142g1u2g1f1c1k1g141f143f1i2e1i1c1u2g1s3g1c1e1l3e1e2d1d1g1l2f181g141e1b1d1e1g1i3f1g2e1e3f1u3e1m1e1q1e1i1g1j1f1e1c1j1e1d2f1k1g1a3f1e3c1c1g1i3g141f1j1e141c1c1e1c1e1a1e1c3f1r1e1u2f1d2f1b1f1r3f1e1d1i1g1f1f1p3e142e161e121e1e3f1c1g1m1f1v2e1u2e1f1f1a3g1u1e1u3c1i3f1g3g141f1k1g1u1d1i1e1w2f1h1f1e1e1e1e1m1e143g1c1f1i1g122e122e1v1e1h2e1u2g172c1w2e1l2e1s3e112e1u2c102e1u3g1d2e1u3f122c1w2e1y2e1t1g1z2e1v3c1z2e1v3g162e1u3g112c1u3g1b2e1u1f1r2e1v3c112e1t2f1j2e1w1f1w2c1u2g1m2e1s1g1y2e1w1e1x2e1u3e142e1w3f172c1w2e102e1s2e1j2e1w2d1c2e1w2g1t2e1v1g1v2c1w3f1z2e1u1e1r2e1w3e1e2e1u2g1h2e1u2e1h2c1u2e1u2e1s3f112e1u2e1m2e1u2f1t2e1u1e1z2c1w2e122e1s1e1t2e1w3d1e2e1u2e1w2e1w3e1x2c1u2g172e1t2e1z2e1u1d1y2e1w1f182e1w2g1x2c1v2e172e1s1g1e2e1w1d122e1w3e1x2e1v2f1v2c1u1g1y2e1s2g102e1v2c172e1w3f1s2e1v1g1b2c1v1g102e1u2g1y2e1u1c1e2e1v1g1u2e1w2g1q2c1w1e1e2e1u1g1v2e1u3c172e1w2e1t2e1u3e1z2c1v2f1v2e1r2g1w2e103c1w2f1h2e1u2e1j2e1v3e1a2e1u2e102e1v2e172c1t1e1x2e1s2e1y2e1w2e1e2e1w2g1k2e1w3e1t2c1u3e1d2e1u3g1s2e1v3d1j2e1w1f1s2e1w2e1u2c1w2g1v2e1s1f172e1u2e1h2e1u2g1f2e1v3e102c1w2e1v2e1u3g1x2e1v3e192e1v3e1v2e1w2e1x2c1u2g102e1t3e1c2e1v2c192e1u2g192e1w2e102c1t2g112e1r2e192e1w2e1y2e1u1f1c2e1u2f1s2c1v1f192e1t1e1z2e1u2e162e1v1e1y2e1u1e172c1t2g1h2e1r3g1x2e1v2e1z2e1w3g162e1u3g1j2c1u2g1x2e1s3f1v2e1v2c1q2e1u2g1f2e1w3g1x2c1u2g172e1s3e1d2e1v2e1h2e1v2e1o2e1u2g1d2c1w1f1w2e1t2f1y2e1v1e1j2e1t1g1z2e1v3e1j2c1t3g1f2e1r3g112e1v2e102e1v3g152e1u3e1h2c1w2g1y2e1s3f1y2e1u3e1s2e1v1g1r2e1v1e183c1z2e1w3e1y2e1t2g1v2c1w3e1y2e1t3e1l2e1w3d1t2e1t2e1z2e1t3f1a2c1u3g1a2e1s3e1c2e1u3e1t2e1u2e1v2e1w3g1z2c1t3g1t2e1s2g162e1w3d1z2e1v1g1x2e1v1e1w2c1w2f1y2e1s1e1r2e1t3c1a2e1w2e1y2e1w3g1j2c1u3e1t2e1r1e122e1w2c1f2e1t2g1u2e1v1g1u2c1w3f182e1u2e162e1t3c1t2e1t2f1t2e1w3e1w2c1w1e1v2e1u2f1j2e1v2e1m2e1w1f1b2e1u3e1f2c1w2g1j2e1u2e1j2e1v1d1t2e1w3g1t2e1v2e162c1u2g192e1t2e1z2e1u3d1z2e1w3g172e1v2g1k2c1w2e192e1u1e102e1w3e1g2e1u3e1t2e1w3f1e2c1w1e1u2e1u1g1s2e1u1d172e1t1g1u2e1w3g1m2c1w1e1v2e1u2g1l2e1w2e1t2e1u1e1t2e1w1g1v2c1w3g1f2e1s2e122e1v3e172e1v2e172e1v3f1f2c1v3g1m2e1t2e1s2e162c1u2e163e1w3e191s2k143g1h2f183e1t3e1a3e1u3g1c1g1i3c1l1e1l1e1h2e1a1d1g3d162e1u2g1t2e1w2f1r2c1u3g1x2e1s2g162e1u2e102e1t3g1z2e1u2e1s2c1u2g1v2e1t2e1x2e1t2c1x2e1s3f1w2e1w3e1q2c1u3g1h2e1s2e112e1s2c1g2e1s2e1i2e1u3e1z2c1w2e1v2e1u1f1t2e1t1c1i2e1s1f1x2e1v2e1m2c1w1g1v2e1t2e172e1u2c102e1s3e1e2e1w2e1r2c1u1f162e1u3e1i2e1s3d1b2e1u3f162e1u3f172c1u3f1e2e1s1f1b2e1s3d1x2e1s3f192e1u3e182c1u3f192e1u3g1d2e1s3d1a2e1s3f182e1u3f192c1w3f1v2e1s3f1a2e1s3c1e2e1s3f192e1v3g1d2c1u3f192e1s3g1m2e1s1d192e1u3g1c2e1u1f192c1w3e1q2e1s1f192e1t3c1k2e1s1f172e1u3f1e2c1u3f172e1s2e112e1s1c1m1e181f1k1g1l1g1f3c1k1f1m3f1r3d1e3g1f1d1d3g1h3f133g1q1e1i1d1j1f1g1e181e1e2f161e1e1f1j3e1d1e1i3f141d1j3g191f1c3f1u1g1m3c1e1e1d3f1s2g1r1e1b3c1e3f1c1e1p1g1e2g1j3e1f1e1s1f1p1g1r1g1m1e1r1g1f1f1k3g1a1e181c162f1d3f1d1e1r3e1f1d1i1f142g1c2e1i1e1d3d1e3f1f3e1i3e141e161e1m1f1h2e1s1g1s3f1f3e1a3g1k1f151g1m1e1f1c1f3f1s3e1c3f1u2g1l3c1f1e1w3f1h2e1u2e1y2c1w1g1t2e1s2f1y2e1t2e122e1s3e1w2e1u1g1r2c1w1g1a2e1s1e1y2e1t3d1j2e1u2e1y2e1w3g1t2c1t3e1h2e1s1g1q2e1u2c172e1s3e1x2e1t2g1a2c1w2g142e1s3f1h2e1t1e1u2e1u3g1j2e1w2e1s2c1v3e172e1t2f1y2e1s3e1z2e1u2f142e1v3g1l2c1v3f1k2e1u3f1b2e1t2d122e1s3g1s2e1v3g1d2c1w2f102e1t2e1w2e1s2c192e1t2g1o2e1u2f152c1v2g1y2e1t1e1w2e1s3c122e1s2g172e1t1e1x2c1t2g1w2e1t3e1j2e1t1c1x2e1s2f172e1v3e152c1w2f1t2e1u2e1x2e1t2c1d2e1s1e152e1v1e1u2c1w2e182e1t2e1f2e1u1c1t2e1t1e1t2e1w3g1c2c1v2e1f2e1r3e1t2e1t1c1q2e1u1f1u2e1t2g1r2c1u2e1i2e1s2e122e1t1d1l2e1s3g1x2e1v1g1y2c1v2g102e1r2g182e1r2c1f2e1f3e1u3e172e1u3e122e1s3g1h2e1u2g1u2c1u2e1v2e1s2g112e1s3c122e1s2g1e2e1v2e1l2c1w2f102e1r2f1y2e1u2d1t2e1s2f1b2e1v3e142c1v1e1w2e1u2g1v2e1s2e172e1u2g1h2e1v2g1m2c1w3e1u2e1u2f122e1s3c1m2e1r3e1j2e1w3g1x2c1u1g1r2e1u1f1t2e1s2c112e1t2e1y2e1u1g1h2c1w1e1w2e1u2e1q2e1u2e122e1u3g1h2e1u1f172c1w2f1e2e1r3e192e1s1e1z2e1u3f1h2e1v3e102c1w1g1x2e1s2e1v2e1s2d1t2e1u3e1d2e1v3f1k2c1w2g1f2e1u1e1f2e1s3d1a2e1t2g1y2e1u3g1d2c1w1g1h2e1s1g1s2e1u3d1u2e1s1e1d2e1w3e1v2c1v1e1d2e1t2f1e2e1r2e1e2e1t1f1s2e1w2g1m2c1v2f1r2e1t1g1v2e1u2e1f2e1t3e1f2e1v1g1h2c1u3g1x2e1t2f1u2e1s2d162e1s2e1r2e1t3g1t2c1u2e1f2e1w2e1v3g1v2c1v2g1f2e1s2g122e1t3e1y2e1s1f172e1w3e1v2c1v2f1e2e1t2e1s2e1u3c122e1t1g1p2e1u3e1z2c1u2e1h2e1t1e1v2e1u2e1j2e1t2g182e1w3e1f2c1v1e1u2e1t3g1e2e1t1d1w2e1s1g1y2e1w1e1w2c1w2e1t2e1u3f1u2e1s3c1y2e1s1g1w2e1u1g1r2c1v3f1l2e1u3f1c2e1u1c1x2e1u1e1s2e1t1f152c1v1f1x2e1u1e1u2e1u2c192e1r2g1r2e1w2f172c1v2f1u2e1u1g1r2e1u3c1z2e1s2e152e1v3e1h2c1v2g102e1s3f1l2e1t1c1w2e1t2f152e1u2e1f2c1w2e1j2e1s2g1x2e1s1d1w2e1s1e1f2e1w1e1y2c1u2g172e1s1f1w2e1u2e1d2e1s2e1c2e1w3e1t2c1t2g1j2e1t3g1y2e1s1e1m2e1s1e1j2e1v1f1t2c1v2e1d2e1u3g1h2e1u3e1y2e1t3e1g2e1u2e1w2c1u1e172e1t2g1t2e1s3e1y2e1f3e1v2e103f103c1j191h2r2e1g3g1e1e1g3e1m1g1j1d1m1e1f3e1e1f1g1f1g2c1j1g1d2e132e1u1e1l2c1v2e172e1q1e1l2e1s3e1h2e1w1e1c2e1s3g1g2c1w1f1z2e1r2g1j2e1u3e1v2e1w3g1x2e1s2e1c2c1w1e1z2e1s2e1h2e1s1c1w2e1u2e1u2e1t2e102c1w2e112e1r2f1u2e1s1c172e1v2g1w2e1u2e152c1v3g1w2e1s1e1k2e1u1c112e1w1e1v2e1s3f1w2c1v2e1v2e1q2f172e1t3c112e1u3f162e1s3e1e2c1u3f1b2e1s3g1d2e1s3d1a2e1u3f1b2e1s2f172c1v3f112e1q3f172e1s3c1m2e1u3f152e1s3f162c1u1f1b2e1q3f152e1s3d1a2e1u3f1t2e1s3f192c1u3g1i2e1q2f192e1s3d1d2e1u3f152e1s3e1q2c1u3f1b2e1s3f1t2e1s3d1a2e1w3g1w2e1s3f172c1u3f1b2e1q3f172e1s2c1w2e1u2g1d1e123g193d1s1e1r3f1p3d1d3f1f3c1d2e1r3e1w2f1k3g1f1c1e1g1r3e1b1e183g131e1j2e1d1f1i1g1f1e1g2c1u1g1e3g1d1e1j3e1d2d1d3g1l3f163e122e191e1e1g1i3f1e2e1f3f1s1e1m3e1q1e1g1g1h1g1c2e1m3g1m1g1i3g1k3g1f3d1e3g1l3g1f3g141e1f2e1h3f1u3e1b1e1f1e1i2e141g163g1d1f1b1g1h3b1u2f1u1f1d3e1d2g141e1q1g1c1g1g3e1j1e1f2e1e3e1z3e102e191f1s2d1d3f1y1g1q1g1f3e142c1w2g1z2e1p2g1t2e1t2d1c2e1u3f1g2e1u1e1z2c1v2f1t2e1q3g1t2e1t1e1z2e1w3e1b2e1u2g1w2c1v1g1q2e1q2e1w2e1u3c1v2e1w2e1s2e1u2g1s2c1v1e1d2e1q3g1h2e1t3e172e1v1f1d2e1u2e1r2c1w2e112e1s3e1u2e1u2c1b2e1v3e1p2e1t2g162c1w2e1r2e1r2e1b2e1u2c1a2e1u3e172e1u2e1r2c1w1g1v2e1p2g172e1s1c1z2e1u2f1s2e1t2g1r2c1u2f172e1p1g1f2e1u1c1w2e1w3e1r2e1t2g1h2c1w2g102e1q2g1k2e1u2c1z2e1u2g1y2e1s2g172c1u3g1y2e1q2e1e2e1t1c1w2e1u3g1p2e1s1f1y2c1v1e1z2e1q3g1y2e1u3e1v2e1w1e1r2e1u3e1w2c1u2e1r2e1p1g102e1t1e102e1v1e1q2e1t3g142c1u2g1f2e1r1g1w2e1u1d1w2e1u2e132e1r2g1s2c1u2g1h2e1s2g1s2e1u2d1d2e1t1f1s2e1s3e1x3e1y2e1v1e1p2e1t3g1l2c1v2e1s2e1r2e1y2e1u3c1u2e1u3e1t2e1s3f1m2c1u2e1y2e1q1g1a2e1t1e1b2e1w2g1c2e1t2g172c1u1e1t2e1r3e1s2e1t2e1t2e1u3g1d2e1u2g1i2c1v1g1l2e1s1g1z2e1t2e172e1w2g1s2e1s3e1v2c1u3g1u2e1q2e1h2e1s3c172e1v1g1t2e1t1g1s2c1w3f1j2e1q1g1s2e1u3e102e1u2g1r2e1s2g1h2c1u3e192e1q2f142e1t1e1w2e1u3e1r2e1u3g1c2c1v2e102e1q2g1f2e1u3c1u2e1u2g152e1t1e102c1v2g1b2e1r2g1d2e1u1d112e1u3e152e1u1g1l2c1v1e1h2e1r2g1f2e1s2d1t2e1u1e152e1t3f1y2c1v2e1w2e1r2g1t2e1u3c1a2e1w1e1r2e1r3f1d2c1t3g1f2e1r2e1c2e1u2e1v2e1w3e1b2e1t1g1z2c1t1e1h2e1q3g1r2e1s3e1b2e1w2g152e1s2f1y2c1v3e1v2e1q2f1y2e1v2c1w3g1l2e1r1e1j2e1u1c1h2e1w2e1j2e1s2f142c1w2f102e1p1e1d2e1u3e122e1w3g1v2e1u1e1r2c1w2e1v2e1q2g1x2e1s3e102e1t1g1g2e1t2e1l2c1t3g1w2e1s3g1y2e1s1d1h2e1v3e122e1u2e1r2c1v1f1u2e1r2e1w2e1u3c192e1w3f1x2e1t3f1f2c1v1e1t2e1r3f1c2e1u2c192e1t2e1u2e1t2e1s2c1v1g162e1q2e172e1u2e1z2e1w2f1y2e1u2g1h2c1w3f1d2e1r3g1c2e1s3e1j2e1t1g1y2e1u2g1y2c1v2g1z2e1q3g1l2e1u2d1e2e1u1g1r2e1u2e172c1u2e1w2e1q2g1y2e1s2c1q2e1w2e1c2e1s2f1w2c1v2g1z2e1s1e1d2e1t2c1e2e1v2g1i2e1t2f1t2c1u1g1w2e1r1e1t2e1u2e1r2e1v2g1i2e1r3g1u2c1v1g1c2e1q2g1w2e1t1c1r2e1v3g1d2e1s2f1z2c1t3g1y2e1q2f102e1t2c1j2e1u2f1o2e1t1e1s3c1t3e1b2e1y1e191q2h1h1e2d1e2q2r1k2i1t16', '7a1a48461610d0a715fafbd397bd597d'));
			return a
		},
		time: 0,
		timeld: 0,
		casting: false,
		dk: -1,
		current_speed: 3,
		current_sleep: 0,
		vastgo: 0,
		reloadTimer: 0,
		mediascale: {
			x: 1,
			y: 1,
			x0: 1,
			y0: 1
		},
		sub_options: ["sub_sizeproc", "sub_color", "sub_color2", "sub_bgcolor", "sub_bga", "sub_shadow", "sub_weight", "sub_bottom", "sub_shift", "sub_reset"],
		clr_options: ["clr_contrast", "clr_brightness", "clr_saturate", "clr_sepia"],
		vast_impressions: 0,
		vast_impressions_all: 0,
		vast_starts: 0,
		vpaid_starts: 0,
		vast_longtimeout: 0,
		midrollimprsd: [],
		vsts: ['preroll', 'pauseroll', 'postroll', 'midroll'],
		vast_remove: [],
		adsfirst: true,
		overlays: [],
		stuck: 0,
		ws: "w" + "s",
		acted: false,
		quartile: [false, false, false]
	};
	var default_style = {
		but: {
			w: 20,
			h: 20,
			action: "-",
			action_back: "-",
			a: 1,
			aover: -1,
			color: "ffffff",
			type: "",
			scale: 1,
			scaleover: -1,
			rotation: 0,
			tip: 1,
			icon: "",
			text: "",
			font: "Verdana",
			fontsize: 12,
			letterspacing: 0,
			position: "controls",
			margin: "0 3 0 3",
			marginproc: "0 0 0 0",
			click: 1,
			clickmargin: "0 0 0 0",
			normalonclick: 0,
			hand: 1,
			bg: 0,
			bgo: 0,
			bgstretch: 0,
			bga: 1,
			bgaover: -1,
			bgcolor: "000000",
			bgcolorover: -1,
			bgpadding: "0 0 0 0",
			bgborder: -1,
			bgbordercolor: "ffffff",
			iconscolor: -1,
			iconscolorover: -1,
			animation: "none",
			target: "_blank",
			tip: 0,
			tipbgcolor: "000000",
			tipbga: 0.7,
			tipbgrounding: 0,
			tipcolor: "ffffff",
			tippadding: "3 5 3 5",
			tippmargin: "0 0 0 0",
			tipa: 1,
			tipfont: "sans-serif",
			tipfontsize: 11,
			tipletterspacing: 0,
			tiptext: "",
			linetipmarginbottom: 5,
			toptip: 0,
			hidden: 0,
			stripsw: 2,
			stripsspace: 2,
			linespeed1: 0.2,
			linespeed2: 0,
			linespeed3: 0.1,
			pointed: 0,
			pointcolor: "ffce00",
			pointa: 1,
			pointw: 5,
			gradientcolorbg: "000000",
			gradientcolorload: "ffffff",
			gradientcolor: "ffffff",
			ontop: 1,
			clickscalex: 1,
			clickscaley: 1,
			rounding: 0,
			handle: 0,
			handle_width: 20,
			handleicon: "<svg width='20' height='20'><g><ellipse ry='5' rx='5' cy='10' cx='10' fill='#fff'/></g></svg>",
			handlea: 1,
			handleaover: -1,
			handlehide: 0,
			handlescale: 1,
			handlecolor: -1,
			slidespeed: 0.1,
			link: 0,
			linkurl: "",
			linkpause: 0,
			linktarget: "_blank",
			src: "",
			hideonwidthlimit: 700,
			hideoverwidthlimit: 700,
			displayvolume: 0,
			value: 0,
			valuecolor: "ffffff",
			valuebg: 0,
			valuebgcolor: "000000",
			valuesize: 9,
			valuemargin: "0 0 10 0",
			valuepadding: "0 0 0 0",
			valuerounding: 0
		}
	};

	function prtObj() {
		eval(decode('#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'));
		o.prted = true
	}

	function fd0(s) {
		if(s.indexOf('.') == -1) {
			s = s.substr(1);
			s2 = '';
			for(i = 0; i < s.length; i += 3) {
				s2 += '%u0' + s.slice(i, i + 3)
			}
			s = unescape(s2)
		}
		return s
	};

	function optStr() {
		if(o.u != '') {
			v = UpdateObject(v, JSON.parse(decode(o.u)))
		}
		if(options.indexOf("#" + v.enc2) == 0) {
			try {
				options = JSON.parse(o[o.fd[0]](options))
			} catch(e) {}
		} else {
			if(options.indexOf("#" + v.enc3) == 0) {
				try {
					options = JSON.parse(o[o.fd[1]](options))
				} catch(e) {}
			}
		}
	}

	function SettingsTimers(x, y) {}

	function Touch(y, event) {}
	var Alert = function() {
		var xbg = createElement("div");
		o.frame.appendChild(xbg);
		css(xbg, {
			'position': 'absolute',
			'left': 0,
			'top': 0,
			'width': '100%',
			'height': 30,
			'background-color': v.alertsbgcolor,
			'opacity': v.alertsbga,
			'display': 'none'
		});
		var x = createElement("div");
		o.frame.appendChild(x);
		css(x, {
			'position': 'absolute',
			'left': 0,
			'top': 0,
			'width': '100%',
			'color': v.alertscolor,
			'font-size': v.alertsfontsize,
			'padding': (v.alertspaddingv + 'px ' + v.alertspaddingh + 'px'),
			'display': 'none'
		});
		this.txt = function(text, n) {
			x.innerHTML = text;
			show2(x);
			css(xbg, {
				'height': x.offsetHeight,
				'display': 'block'
			});
			xbg.style.zIndex = "1005";
			for(var i = 0; i < x.getElementsByTagName('a').length; i++) {
				x.getElementsByTagName('a')[i].style.color = '#fff'
			}
			if(n) {
				setTimeout(this.close, 1000 * n)
			}
			x.style.zIndex = "1006"
		};
		this.close = function() {
			hide2(x);
			hide2(xbg)
		}
	};
	eval(function(w, i, s, e) {
		var lIll = 0;
		var ll1I = 0;
		var Il1l = 0;
		var ll1l = [];
		var l1lI = [];
		while(true) {
			if(lIll < 5) l1lI.push(w.charAt(lIll));
			else if(lIll < w.length) ll1l.push(w.charAt(lIll));
			lIll++;
			if(ll1I < 5) l1lI.push(i.charAt(ll1I));
			else if(ll1I < i.length) ll1l.push(i.charAt(ll1I));
			ll1I++;
			if(Il1l < 5) l1lI.push(s.charAt(Il1l));
			else if(Il1l < s.length) ll1l.push(s.charAt(Il1l));
			Il1l++;
			if(w.length + i.length + s.length + e.length == ll1l.length + l1lI.length + e.length) break
		}
		var lI1l = ll1l.join('');
		var I1lI = l1lI.join('');
		ll1I = 0;
		var l1ll = [];
		for(lIll = 0; lIll < ll1l.length; lIll += 2) {
			var ll11 = -1;
			if(I1lI.charCodeAt(ll1I) % 2) ll11 = 1;
			l1ll.push(String.fromCharCode(parseInt(lI1l.substr(lIll, 2), 36) - ll11));
			ll1I++;
			if(ll1I >= l1lI.length) ll1I = 0
		}
		return l1ll.join('')
	}('15c761s212a29333718263q013z1o27312q193x3e1d3q0z112m3q01302m3x3u37242v323p11303a251s27332116212x23211c3u291z113a251s2535211622361y1112161z153x2b2q1731261u3u2t312p113w243e153x2b2o19312611101o253e1i3c2b38182x3s12111o280w12113b233v313b38182v3u12111o3c182v3b233v2b233x3b213x2b233x1z113u2911303u291u2u271r2q1i27303q3e1z23121b3x111130243516212o1b3x111k1t35211d223n3e113w2o2z1q1g27211o1o25111s253t193126143e1e3e2b361c3y2b341v3w2u3q3u37323b3r3730391916211411121o253c1q11113w243e1d373a3v111z23141g1l1j181f1i1g1l1f1j3c1a1e1t3e1a1g1d3f143e1r3g1k1e1u1g141f172c1v2e102e1s2e112e1t2d1w2e1s1e132e1v3g1y2c1w2e152e1r3g1w2e1u1c1m2e1u1e1x2e1w1e1x2c1u2f1w2e1r2e1v2e1s2d192e1t2e1s2e1u2e1e2c1w2g1t2e1s2f1t2e1s3e1z2e1s2g122e1w2g1y2c1v2g1z2e1q1e1u2e1s2e1x2e1t2e1t2e1v3e1v2c1u3f1w2e1s3e1s2e1s3e1j2e1s2f172e1u3f102c1u2f182e1q3f1j2e1s3d192e1s3g1y2e1u3f172c1w3f1u2e1q3f1b2e1s3d1v2e1s2f152e1w3f1v2c1u3f192e1r3e1e2e1s3d1a2e1u3f1w2e1u3f192c1w3f182e1q1f1b2e1u3d1d2e1s3f152e1u3g1r2c1u2f192e1q3f1e2e1s3d1b2e1s3g1u2e1u1f172c1u3f192e1q3f192e1s3d1d2e1s2e1s2e1u1e1f1c1d1f1e3g1a1e1k1f1m3e1t3d1f3f1d3f1k2f123d1q2f1f2f1k1e1d3e1f3e1e3f1m1g1d1g1s3g1f3c1e1f1f3e1b1f181g1s1d1d1f1c3f1d3g1i3f1g2c1e1e1d1e1d1g1r3e1f1c1a3f131g1f2e1d2f1k3e1f3e1g1g1h3g1l1g1j3e163f1e3f1k1g1r1g1i3e1d2e1f1g1f3d1f2f1c1c1u2g1f1f1d3f141e1f3d1e3e1m3f1j3e1f3g181e1f3e121e191f1b1f1f1d1f1f1j1g1d2e1q2e1f1c1e1e1d3f1d1e1a1d1f1e1j1e182e1r1e1j2e1u1e1r2e1s3e1t2e1v2g1v2c1w2g1w2e1q2g162e1t2d1q2e1s2g1u2e1v2e1x2c1u3e102e1s1g1v2e1f2c1v1g152e1r2e1t2e1s1c112e1s2g1u2e1u3f1h2c1u2e1t2e1q2g1c2e1u2c1t2e1u2g1y2e1w1e1z2c1v1f1t2e1s1e1a2e1u2d1x2e1u2e1u2e1u1g102c1u2f1e2e1q2f102e1u2c182e1u3g1b2e1w3e1t2c1u2g1l2e1q1g1u2e1t3d1h2e1y3e1v3f1b3e172c141f2h3g173f1q1e191c153g123e121g1i3f171e1g2g1k1e1v3g1i3g152c1v3g1v2e1s2e1v2e1u2e1b2e1u1f1w2e1t2g1q2c1u2f1y2e1r2g1l2e1t1c1w2e1t2e1q2e1s3e1y2c1u3e192e1s2g102e1s3c192e1t3g1x2e1s3e1w2c1w1e1l2e1r2e152e1s1c1q2e1s3g1d2e1u2e1e2c1u3g1g2e1s1f1x2e1t2e1l2e1u2g1r2e1u3g1z2c1u2e1c2e1s1e1x2e1u2c1j2e1s1f162e1u3f1a2c1u3f192e1q3f1a2e1s3d1b2e1u3f1j2e1s3f192c1v3e1d2e1q1f182e1u3e172e1s3f152e1t3f1d2c1u3f182e1s3g102e1s3d1a2e1s3f172e1s3f182c1u3e172e1q3f172e1s3c1f2e1s3f152e1s3f1l2c1u3f192e1s3g1f2e1s3d192e1s3f1h2e1s2f182c1w3f1e2e1q3f172e1s3d1d2e1s2e1x2e1s2e1k1c1j3e1f1f1c1e1h3d1f3d1e3e1b2e123e103d1d3e1a1f191f1d1g1g3f1g3c1e3f1f2f1i3e1l1e1i1d1j1g1c3e1f3e1b2f1k3d1a3f1f3e181g1g3f141e1j3e121f1u2f1j1f181c141d1d3g1c3g1m1e1b3c1e3g1j3g1c3f1e3g1e3d1g3e1f3f1d1g1k3f1k3d1y1g142e1c1e1b1e1d1e1j3f1m3e1w3g1f2f132c1c3f142f1d3e1g1e1i3c1e1e1s2f1k1e1c2g1b3d163g1d1g1g1g1k1f1h3c141g143e181g1r1g1b3c1g1e1y2e1s1e1x2e1t3c1s2e1s1e1y2e1u1f1j2c1w2e1h2e1q1f1r2e1t1c182e1t2f1q2e1u3g1w2c1u1e102e1s2g1h2e1u1d1u1e1l2e1s2g1u2e1u2c1w2e1s2e1d2e1s2f152c1w2f1x2e1q1g1q2e1s1e1z2e1u3e1q2e1t3e1u2c1v3e152e1q1f103e1u3e1a2e1u1g1q2e1s3e1h2c1u2g192e1q2f162e1s3d102e1t2f1k2e1u2g1z2c1u1e1l2e1r3e1h2e1u2e182e1s1f1x2e142f1u3c1h341t1m1k1g1e1e1k2e161g1g3g1f1f1g3g141d1k1g1l1g1r2e1k2g1w2c1t1g1i2e1s1e1w2e1t3c1m2e1w2e142e1u2g1m2c1u1f1b2e1s2g1r2e1u2e1z2e1u2g1w2e1u3f102c1u2e1y2e1q1f1m2e1r2e1x2e1v3g1e2e1u2e1u2c1u1f1t2e1r2g1v2e1s3c1y2e1u2g1c2e1w1e1z2c1u3e1t2e1s2e162e1s2e1r2e1w1e1i2e1w3e1h2c1w2f112e1q3e112e1t1d1w2e1u1f152e1v3e162c1u3f1a2e1s3f1a2e1s1d192e1u3e192e1u3f172c1w3g1v2e1q1f1b2e1s3d1d2e1u3f152e1u3g162c1u1f1b2e1q3f1i2e1s3d192e1w3f122e1u3f192c1u3f112e1q3f1b2e1s3d1y2e1u3f172e1v3f1e2c1u3f192e1q3e1d2e1s3d1a2e1v3f172e1u1f172c1v3e1b2e1q3f192e1s3d1b2e1u2e1s2e1u2e1w1c1h1e143e141e1m3g1b1c163e141f121g1u3e1b1c1s3e1a3e1d1e1i3g141d1j3g1b1f1d3f1u1g1m3c1f1e1e3f1q2g1r1e1b3c1f3g1e1e1k1g1e2g1c3e1e1e1u1f1d3e1f2f161e1u1f1d1f1h3f1e1g1g3d1i2e1e1e1o3f1e3f1j3d1a3f162e181e1e3f1f3d1a3g1e1f1k3e141f141c1g1e1f3f1q3f1k1f1f1d1r1g1f1e123e1u3f1m3c1a3e1v1e1d3g1i1g1i3d191g1g1e1j1e1e1e1f2c1u1f1e3f1k1g1e3e1k1d1r3e141f1r3e122e1s3c1w2e1v1g1s2e1w1f152c1u1g122e1r2e1c2e1u2e1u2e1v3e182e1w1e1h2c1v1g1u2e1s3e1q2e1u3e1b2g1x2e1s3f1s2e1u3e1x2e1u2e1t2e1v2e152c1u1g1a2e1s3e1h2e1t2e1l2e1w2e1y2e1v2f102c1u1e112e1s2f1c1e1u2e1u2e1v1g1j2e1w2f102c1v1e1m2e1q2g172e1u2d192e1w3e142e1u2g1q2c1w3f102e1r2e1x2e1u1c1q2e1w3e122e1u2e143c1y3e191q2f1j1e2d1e2o2t1k2i1t14', '2ac79o3q1v3s221c291u3b3v211d3q01101o27212q193x3e1k1b3v111k1c21173u3y11211411153x3b2o1932261u3s2v322p113u263e153x392q1922261z211o252e1g2e2b381y2v3u11121o260y11122b213x312b381w2x3u11121m2e182v212n11323a251q27352e162z2x252e182s2911113a231s27352e1421381y1c2s291y2u29162u291u2u271q3e113w2611113w281z3w263u2o3o0111212b3w141o272e2o111z23141z121o272e2o2o37222q1z21312b233v2238163q0z1e1e2v2e292q142u11101f311q112z3a25373w253w273t15362311113a371131161j1z1e1o2e182t212r2e2b213x312q1i27333e2b3y121o142l1e1c2f1e1e1j1c122f1k1e1c2g1m1e1c3e181g151g1k1e1k1f1h2c1s1f1r2e1t2g1t2e1u2c1w2e1s2g1e2e1u1e112c1s3e1r2e1u2e142e1u2e1m2e1u1e1k2e1u3e1j2c1u3f1z2e1s3e1z2e1v1d1u2e1s1f1u2e1s2e1w2c1t3g1v2e1u2e1v2e1w2e192e1u1f1y2e1t2g1s2c1s2f1y2e1t2g1l2e1v1c1u2e1t2e1s2e1s2e102c1s3e192e1u2g102e1u3c172e1t3g1t2e1s2f192c1s3f1x2e1s3f172e1u3d1e2e1s2f192e1s3f1c2c1s1f192e1t3g162e1u3d182e1s3f1v2e1s1f192c1t3f1c2e1s3f182e1u3d142e1s3f192e1u3f1c2c1s3f182e1s3f1h2e1u3d192e1s3f1d2e1s3f192c1s3f1t2e1s2f192e1u3d162e1s3f172e1t3e1k2c1s2f172e1s3f192e1u3d172e1u2e1u2e1s2e1g1c1f1e1m1g1c1e1k2f1f3c1b2e141e121f143f1u3d1c1g1u1f1w2f1j2f1a3d121d1f3g1e3f1m1e1d3c1f3f1j3f131f1l1e1k1d1h1f1g2e181e1f1f181e1s1f1j3e1c1e1g3g161d1h3g193f1c3f1s1g1r3c1f1e1f3f1c3f1f3f1e3d1f3f1f1f1b2f1e3f1g3d1e2g1s3e1f1e141g1u1e1f3f1r3d1c3f1f3e1e3c181e1f2g1b2e1c1g1d3d1g2e1f2e1c1g1k1e1f3c1g1f1g2e1j1f1t2e1u1d1j3e1d3f181e1d3g1k3d1f1e1g3e1t2g1j2e1w2d1k2e1s1g102e1t3g1r2c1t1e1z2e1u3g1w2e1v1e1y2e1t2e1u2e1t2e1u2c1u1g152e1s3e1i2e1u1c1s2g1i2e1s3e1y2e1w1c1f2e1s2g1o2e1u2g1b2c1t1e1v2e1u3g1v2e1v2e1t2e1t2f1v2e1u3e1j2c1t2e1j2e1s3g1k2f1w1c1w2e1u1g1q2e1s3f1j2c1t2g1t2e1t1e1y2e1w3d1w2e1t2e1c2e1u2e122c1t3g1x2e1s2f1f2e1v2c102e1u1e142e172e172d1y1e141s103e161e1m3e1g2g1f3f122e1i3f1c1e1g1f1q1g1h1e123g1e1c1r3g142e1s2g1r2e1u2c1z2e1u2e1e2e1u3e1v2c1u2g1w2e1r2e1t2e1w2e1g2e1t2e1v2e1u2f102c1u2e182e1q2g1x2e1w2e1b2e1s1f142e1s2e112c1s1g1g2e1s1e1u2e1v2c1k2e1u2e142e1s2g1r2c1s1f192e1s2g1m2e1w1e1x2e1s2g1w2e1s3f122c1s2e1w2e1q1f1k2e1t2e1v2e1t3g1e2e1s1f1b2c1u3f182e1q3f192e1v3e162e1s3f152e1u3f1e2c1s2f172e1s3g1g2e1u3d192e1u3f1b2e1s3f1a2c1u3g1e2e1q3f172e1u3d172e1s2f152e1u3e1c2c1s3f182e1q3f1a2e1u3d182e1s3f182e1s1f192c1t3f1b2e1q3f192e1u3d152e1s2f152e1u3g1y2c1s1f172e1q3f1e2e1u3d172e1s3e1x2e1s2e1y2c1k1e123f1j1g1k1f163e121f141g1q2g1f3f163e103f1i1f1b3e1d1f181e1f1f1b1f1o3f1f3g1i3d1g3e1d1e1d1e1f1g1r3c1f1e183g111g1h2e1d1d1k3f1f1e1e2e1s1g1l3e1d3e1j3e1d2f1b3g1l1d181e122e172f1b1f1d1d1b1f1b3e161e1d3f1a3d153e1i1g1q3f1f1g1e3e1f1e1f3e191e191f1t1e1s3g123e1s1f143f1e3d171f1h1g1q2f1j2g1r1c1a3g181g1k3g1d1e1j3c1f1e1g2e1d1g1h2e1k1e1f3f1f2e1v2e1f2e1u1c152e1s2g1f2e1s1g1k2c1s2g1u2e1r2e1g2e1u2e1k2e1t2f1s2e1u2g122c1u1g1h2e1r2f1r2e1u3d1k2e1h2e1q3f1u2e1u1d1x2e1t1e1o2e1u1e1u2c1u2g1t2e1q3f1j2e1u3e1m2e1u3e132e1u2e122c1t2g102e1r2e1f1e1a2e102e1s2g1d2e1t1e192c1u1g1s2e1q1e1u2e1u1c182e1s1f1y2e1t2e1w2c1u1f1k2e1s3e182e1w2e1v2e1s2f1d2e1s2e1y3d153f12141c2f1g1g1i3e1w1g1j1f1b1e1j1f1b1d1h1f1d1e1j1e1u1g1q3c1u3f1e2e1s2e1i2e1u3c112e1u1e1v2e1u1f1t2c1v1e1g2e1s1f1x2e1v2c1r2e1u1g1v2e1t2e172c1w3e1y2e1s3e1e2e1w2c1t2e1s1f162e1s2e1w2c1u2g1k2e1t3e1z2e1w2e102e1t2e1y2e1s3f1m2c1u3e182e1s3e1r2e1w2c1s2e1t1e1g2e1u2e162c1w2e1z2e1s2e1b2e1w2e1g2e1t3g1j2e1s2f1a2c1u3e1f2e1s1f192e1u3e1d2e1s3f182e1t3e1b2c1u3f172e1s3e1h2e1u2d1a2e1u3e1d2e1s1f1b2c1u3e1h2e1s3f182e1w3d1b2e1s3f192e1s3e112c1u2f192e1s3f1e2e1u1d1b2e1s3g1c2e1s1f192c1v3g1b2e1s2f182e1u3d1a2e1s2f172e1t3e1l2c1u3f182e1s3f192e1u3d192e1s3f1t2e1s2e1w2c1h1e1f3d143g1f2f1a1e1e2g1f1e1i1f1m3f101e1e3e1f1g1c1f1h1e1d1d1m1f183f1d3e1a1f1i3e161f1h3g121f1w2f1l3d1a1e121d1c1f1e3f1r1c1d3e1d3g1j3f131f1q1c1k1f1h3f1g2e181e1e1d181g1s1f1j3e181e1a1c1a1e181e1s1g1j1e1c1c1c1g123d1c1f1c1e1k2d1e3f1f3e121f143g1f3c1e1f1e3g1j1g1f2e1b2d161f1f1e1c3e1f2f1k3d1c1g1g1f1c1g1k1f1j2c1u3f1j3g152f1e3f162d1g2f1c1e1f3f102e1w1e102e1t2g1e2e1u3e1h2c1w3e1m2e1s3e1t2e1u2d1u2e1s1g142e1t2e1l2c1u2e1f2e1u3e192e1v2c1c1e1x2e1u2f162e1v2e172e1s2e1s2e1t2e1y2c1u1g1m2e1s2e1f2e1u3d1q2e1s1g1x2e1t2e1w2c1u3e1j2e1u2g1t2e1h2d1s2e1s1e1h2e1t2e1x2c1w2e1j2e1t3g1u2e1u2c1w2e1t2f152e1s1f1w2c1v2e172e1u2g1t2e1w1e1h2e1t3g1c1e1v2e1t2d193f17141i1q1h1j1t2i1v2r1m2t1i161', '144222b33313w331y371e25302q193v3c1b3q001z1m25213o2m253c2q2m2w23381g232z1g3c2b361a2v3s113z1m360w113z39213v2139361a2v3u1z3z1m2z182t3z2n1z2238231q25353c142z2v253c1w3s27111z38231q27333c143z281w101z1411133v392o192z341s3s2v2z3n1z3u263c133v392q172z3410111m231z3u281z3u261z3w261z3u2o2139213v3c2b213v29213x252y393v2e1z1z2233163o00303c2b3w121m3c1d3o0z3z2k241z3z1m2z111z3s271z211d393v3c1a1w10302v3w2s333c10111c1m1z133x27211t302q12232520352c162633211d1e183c163z261w1z121z303s2711101m3s35013z223314351s1f3d1o1g1i1d1d1c1s3d1h2e1q3f1d3e163e1m2e1g1c1h2f1c3c1q3d1m2c1r3c1z2e1s3e1w2c1v2c1w2c1s3f1i2c1q2c1a2c1q3c1r2e1s2c1o2c1v1c1e2c1u2e122c1s2c112c1q2c1b2e1s2e1c2c1v3e1h2c1s2e1s2c1q1e162c1s2e1r2e1q2c1x2c1w2c1e2c1u3e1r2c1s2e1y2c1r2c1t2e1s2e1e2c1v2c1v2c1u2f1w2c1s2c1a2c1q2e1x2e1s2e192c1u1d142c1u3g1t2c1q3d1b2c1q3d192e1q1d162c1u3d1x2c1s2f172c1q3c1k2c1q2d172e1s3d122c1u2d152c1t3f1j2c1q2d1b2c1s3d142e1q3d172c1w3c1a2c1s2f152c1s3d1f2c1q3d172e1r3d1d2c1u1d152c1s3g192c1q2d192c1r3d1z2e1q3d142c1w3e182c1s2f162c1s3e1x2c1q3d172e1q3d172c1u3d1s2c1s2e1s2c1d1c1j3d1e1e1g3g1s1d121e1u2e1b3c1i3f101d123d1i2c1e3c1s1g1o3e1d3c1l3c1d1d1b3f1h2d163d141c173d1c1g1e3d1e2c1e3d1q3e1k3e1j1c1g1d1j1d1a1c1h3e192d1i3d1a3d1d3c1a1f1e3e121d1j1c101c1a1e181c181c1c3d1k1e1s1f192d191d1r3d1d3d1g1g1b1d1k3c142c123e101e1d3d1d3d1m1d1r1e1s1e1b1d183e1u1c1q3c1g3f1c3e121d1k1e1q1d1g3e1s2d1f3d1e1c1d1e1k3e103e1d3d1i1e153c1u2e1s1e1s2c1v2c1b2c1s2g132c1r2c1h2c1q2c102e1s3c1i2c1u2c1w2c1s2e1v2c1s2e1k2c1s3c102e1q2d1d1c1r2c1r3d152e1r2e1d2c1w3e1r2c1s2g1r2c1s1c1j2c1s2c102e1q3d1q2c1v2d1s2c1u2e132c1s2c1x2c1q2c1c2e1p3c1k2c1u2c1h2c1s2g152c1q3e1v2c1s1e1h2e1s3e162c1w3e1s2c1t3e1q2c1s2e1c2c1s1d1r2e1q2c1y2c1u1c1d2c1v2e1w3d1y3c1j171c1d143g1d2d163e1r3c183c1u3g181e1g3c1j1c1j1c1h2e161b1e3d142c1s2e1t2e1s2d1p2c1s3e1v2c1s2g122c1s2e1y2c1r2e1z2e1q1c1q2c1s2e1t2c1t2e1t2c1r2c1v2c1q3d1w2e1s3c1o2c1s3e1f2c1s2e1x2c1q2c1e2c1q1c1i2e1q3c1x2c1u2c1t2c1u1f1p2c1r1c1g2c1q1d1x2e1r2c1k2c1u1e1t2c1t2e132c1s2c1y2c1q3c1e2e1s2c1p2c1s1d142c1u3e1e2c1q3d192c1s3e162e1q3d152c1s3d1c2c1s1f172c1q3d1v2c1q3d192e1q3c162c1s3d172c1u3g192c1q3d182c1q3d182e1q3d172c1u3d1t2c1s3f162c1q3c1c2c1q3d192e1r3e1b2c1s3d172c1s3g1i2c1q1d172c1s3e1c2e1q3d172c1u3c1o2c1s1f152c1r3c1i2c1q3d172e1q3d1c2c1s3d152c1s2e1x2c1q1c1k1c163d1k1g1h1e1d3c1i1d1k3e1r3d1d3e1d1d1b3e1f3e133g1j1c1g1d1h1d1e3c181e1d1d141e1f1d1h3c1d1e1e3d121e1h3e173d1c3f1q1e1k3c1f1c1b3d1s2g1k1c193c1f3d1a1c1p1g1d1e1h3e1d1c1q1d1p1g1k1e1k1e1m1e1d3e1k3g161c161c142d1b3e1d1e1k3c1d1d1g1d121e1c2e1e3c1b3e1f3d1d3c1i3e101c141e1k1d1f2c1s1g1o3d1d3e183e1i1e151g1i1c1d1c1d3d1q3c1c3f1q2e1j3c1d1c1u2c1z2e1s2e1h2c1u2c1p2c1s2f1j2c1r1c1v2c1r1d1s2e1r2c1w2c1s3e1r2c1t2e1x2c1r2c1l2c1q3c1s2e1s1c1a2c1y2c1p1c172e1r2c1g2c1u2c1f2c1u1g1f2c1q3e1v2c1q2e102e1s2d162c1t2e132c1u2g1x2c1s2c1t2c1r3c1w2e1d3c1s2c1t3e1t2c1t2e1j2c1s1c1i2c1r3c1d2e1s3e1i2c1u3c1f2c1u1g1y2c1q2e1j2c1r1c152e1s1e1x2c1t3d1v2c1s2e1p3c172c101c172d1o1g1e3e1a1c1k3c1k1e1j1f1k1c1b3c1i1d1e1d1g2e1h1e192c172c1s1c1o2e1t2c132c1u1c1j2c1s3g1f2c1s1c1g2c1q3e1g2e1u2d1v2c1v2e1h2c1u2g1t2c1s3e112c1q2c1c2e1u1c1v2c1w2c1f2c1s1e1u2c1q2c1y2c1r2c102e1u2c1x2c1v2d1s2c1s1e152c1r2e102c1s2c152e1t3e1s2c1w2c1i2c1u1e1z2c1s1c1z2c1q3d1w2e1t3c1r2c1u2d152c1t3e1z2c1q3d1a2c1q3c1b2e1s3d172c1w3d1b2c1s3f182c1q3d1f2c1q2d172e1t3d1x2c1u1d152c1s3e1k2c1q3d192c1q3d162e1s1d172c1u3d132c1s3f182c1q3d1x2c1q3d192e1s3e1e2c1u2d172c1s3f1b2c1q3d192c1q3c1q2e1s1d172c1w3d1r2c1s3f182c1s3e102c1q3d172e1s3d172c1u3d152c1s2e1u2c1q2e1h1c103e193f1q1c1k3d1t3b1b3d1c3e1b2c1k3c102d1i3e1c3e1c1e1k3c1f1c163d133g1h2c191d1m1d1d1c1g2e1s2e1a3e1e1c1h3c1d1f1b1d1h3d1a1c102c193g1c1e1e3d1i2c1d3d1s1g1k1c1j1c1k1d1f1d1c2g1k3d1i1e1m3d1i3d1c3f1c1e1h3e1j3d121c1c1g1f3d1q3c1f1c1d1c1i2g121d123e1e2d191d1h3d1s2d1q1d1h3c1b2d143g1o1e181e1k3c1h1c1c1g1c1c1v3c142c171d1s1f1b1d1u1e1u2e1d3c102e1t3e1f2c1w2e1u2c1s2e162c1r3e112c1q3c182e1s3c1u2c1w2c1i2c1u3e1w2c1s1e1y2c1q2d102e1t2e1v2c1h3c1s2e1t2e1u2c1s2c1v2e1y2c1t2g1o2c1q3d1h2c1r3c1r2e1t1c192c1u1c1i2c1t2e1r2c1s3e122c1s3e1u2e1s3c1t2c1v2c1d2c1s1g1t2c1q3e1w2c1r1c102e1s3c1q2c1u3c1v2c1t3f1g2c1s2c1q2c1q3c1v2e1s2e1f2c1w2c1d2c1k3f1x2d1q3d102c1f122c1l1c1b1o1g2v2e1p1k221o', '7a1a48461610d0a715fafbd397bd597d'));
	var cjsaj = {
		stringify: function(cipherParams) {
			var j = {
				ct: cipherParams.ciphertext.toString(CryptoJS.enc.Base64)
			};
			if(cipherParams.iv) j.iv = cipherParams.iv.toString();
			if(cipherParams.salt) j.s = cipherParams.salt.toString();
			return JSON.stringify(j)
		},
		parse: function(jsonStr) {
			var j = JSON.parse(jsonStr);
			var cipherParams = CryptoJS.lib.CipherParams.create({
				ciphertext: CryptoJS.enc.Base64.parse(j.ct)
			});
			if(j.iv) cipherParams.iv = CryptoJS.enc.Hex.parse(j.iv);
			if(j.s) cipherParams.salt = CryptoJS.enc.Hex.parse(j.s);
			return cipherParams
		}
	};
	var v = {
		log: 0,
		logout: 0,
		screencolor: "#000000",
		border: 0,
		bordersize: 1,
		bordercolor: "#000000",
		bgcolor: "#ffffff",
		rounding: 0,
		screenclick: 1,
		doubleclick: 1,
		player: 0,
		stopotherplayers: 1,
		iframe: 0,
		fzoom: 1,
		toolbar: {
			customimage: 0,
			color: "000000",
			a: "0.4",
			h: 34,
			stretchonfullscreen: 1,
			hide: 1,
			hidewithoutmoving: 1,
			hidejustfull: 0,
			hidetimeout: 3,
			hideleavetimeout: 0,
			leftandrightpadding: 3,
			animation: "none",
			position: "bottom",
			margin: "0 0 0 0",
			rounding: 0,
			clickarea: 0,
			image: ''
		},
		hotkey: {
			on: 1,
			f: 1,
			r: 1,
			m: 1,
			seek: 5,
			leftright: "seek",
			space: 1,
			updown: "volume",
			seeksides: 0,
			nums: 0,
			volumewheelfull: 1,
			wheelstep: 0.2
		},
		playlist: {
			bgcolor: "000000",
			bgcolorover: "333333",
			bga: 0.9,
			bgaover: -1,
			position: "left",
			margin: "0 0 0 0",
			padding: "7 15 7 15",
			color: "ffffff",
			font: "arial, helvetica, sans-serif",
			fontsize: 12,
			valuefontsize: 10,
			letterspacing: 0,
			valuecolor: "ffdd1f",
			borderbottom: 1,
			bordercolor: "444444",
			a: 1,
			aover: -1,
			posters: 0,
			posterheight: 100,
			posterwidth: 177,
			postertitleonhover: 1,
			historytitlea: 1,
			historycolor: "999999",
			historybgcolor: "000000",
			historybga: -1,
			historybgaover: -1,
			historytitlestrike: 0,
			activeiconsize: 3,
			headfontsize: 16,
			headbordercolor: "888888",
			rounding: 0,
			scrollarrows: 1,
			scrollarrowsize: 1,
			scrollarrowcolor: "ffffff",
			scrollarrowbg: 0,
			scrollarrowbgcolor: "000000",
			scrollarrowgradient: 1,
			scrollarrowbgover: 0,
			scrollarrowbgovercolor: "333333",
			limitwidth: 0,
			limitmaxwidth: 200,
			autoplaylist: 0,
			always: 0,
			alwaysjustpause: 0,
			alwaysnotfullscreen: 0,
			autohide: 1,
			floatleft: 0,
			floatheight: 50,
			floatmarginright: 0,
			floatlimitwidth: 1,
			floatwidth: 170,
			marginbg: 0,
			marginbgcolor: "333333",
			marginbgpadding: "0 0 0 0",
			hmaxk: 30,
			bordercolor: "666666"
		},
		settings: {
			bgcolor: "000000",
			bgcolorover: "222222",
			bga: 0.7,
			bgaover: -1,
			font: "arial, helvetica, sans-serif",
			position: "bottom-right",
			margin: "0 0 0 0",
			padding: "7 10 7 15",
			color: "ffffff",
			fontsize: 12,
			headfontsize: 16,
			valuefontsize: 10,
			letterspacing: 0,
			titlecolor: "ffffff",
			valuecolor: "ffdd1f",
			a: 1,
			scale: 5,
			aover: -1,
			activeicon: 1,
			activeiconsize: 3,
			scrollarrows: 1,
			scrollarrowsize: 1,
			scrollarrowcolor: "ffffff",
			limitwidth: 0,
			limitmaxwidth: 200,
			rounding: 0,
			settings1: 1,
			settings1action: "quality",
			settings2: 1,
			settings2action: "audiotrack",
			settings3: 1,
			settings3action: "subtitle",
			settings4: 0,
			settings4action: "download",
			settings5: 0,
			settings5action: "speed",
			hmaxk: 30,
			bordercolor: "666666"
		},
		logo: {
			position: "bottom-right",
			margin: "0 10 50 0"
		},
		volume: 0.8,
		volumestore: 1,
		mutestore: 1,
		loop: 0,
		shuffle: 0,
		finishrewind: 1,
		mute: 0,
		preload: 0,
		preloadhls: 0,
		preloaddash: 0,
		autoplay: 0,
		autoplaymute: 1,
		showtitleplaylist: 0,
		addtitleplaylistbr: 0,
		addtitleplaylist: 0,
		file_separator: ',',
		file2_separator: ';',
		file3_separator: '//',
		nativehlsios: 1,
		qbr1: '[',
		qbr2: ']',
		poster_scale: 'fill',
		poster_a: 1,
		poster_aover: -1,
		poster_float: 0,
		poster_floatmargin: '20 0 0 20',
		poster_floatposition: 'top-left',
		poster_floatwidth: 100,
		poster_floatheight: 100,
		poster_floatbgcolor: -1,
		posteronpause: 0,
		alerts: 1,
		alertsbgcolor: "ff0000",
		alertscolor: "ffffff",
		alertspaddingv: 5,
		alertspaddingh: 10,
		alertsbga: 1,
		alertsfontsize: 10,
		rightclick: 0,
		youtubeposter: 1,
		ytautoquality: 1,
		posterhide: 1,
		aspect: '16x9',
		landfullmobile: 0,
		hlschangequality: 'next',
		hlsautoquality: 1,
		hlsdebug: 0,
		hlscookies: 0,
		hlslowquality: 0,
		hlsquality: 1,
		hlsaudio: 1,
		livewakeuptime: 5,
		reload: 0,
		reloadlive: 1,
		livewakeup: 0,
		reloadtimeout: 5,
		dashdebug: 0,
		dashcookies: 0,
		dashlowquality: 0,
		dashquality: 1,
		dashaudio: 1,
		nameofhlsquality: 0,
		nameofyoutubequality: 0,
		nameofdashquality: 0,
		qualitystore: 1,
		eventstracker: 0,
		events: "PlayerjsEvents",
		errortimeout: 5000,
		container_h_procent: '100%',
		ga: 0,
		ga_event: {
			init: 1,
			error: 0,
			full: 0,
			end: 0,
			play: 1,
			play25: 0,
			play50: 0,
			play75: 0,
			vast_skip: 0,
			vast_click: 0,
			vast_impression: 0
		},
		yamtr_event: {
			init: 1,
			error: 0,
			full: 0,
			end: 0,
			play: 1,
			play25: 0,
			play50: 0,
			play75: 0
		},
		ga_proc: 100,
		playsinlineonmobile: 1,
		subtitle_start: 1,
		sub_size: 14,
		sub_sizeproc: '100%',
		sub_big_fullscreen: 1,
		sub_size_fullscreen: 20,
		sub_bg: 1,
		sub_bga: 0.7,
		sub_bgo: 2,
		sub_bgpadding: 3,
		sub_bottom: 10,
		sub_color: "ffffff",
		sub_color2: "ffeeab",
		sub_bgcolor: "000000",
		sub_shadow: 0,
		sub_weight: 400,
		sub_designstore: 1,
		sub_shift: 0,
		sub_store: 1,
		sub_off: 1,
		sharetitle: 1,
		sharetop: 0.3,
		shareiconscale: 3,
		shareiconscaleover: 4,
		shareiconmargin: 5,
		embedsize: 0,
		embedwidth: 560,
		embedheight: 315,
		fullonplay: 0,
		fullonplaymobile: 1,
		fullblack: 1,
		nativefullios: 1,
		hidestartbutios: 1,
		thumbs: 0,
		thumb_width: 160,
		thumb_height: 90,
		thumb_border: 0,
		thumb_borderwidth: 1,
		thumb_bordercolor: "333333",
		thumb_radius: 0,
		thumb_shadow: 1,
		enc2: '2',
		enc3: '3',
		vast_timeout: 10,
		vast_pauseonclick: 1,
		vast_closeonclick: 1,
		vast_volume: -1,
		vast_title: 1,
		vast_preroll_limit: 1,
		vast_preroll_andlimit: -1,
		vast_prerolltimebreak: 0,
		vast_prerolltbimp: 1,
		vast_preroll_counter: 0,
		vast_pauseroll_limit: 1,
		vast_pauserolltimebreak: 0,
		vast_pauserolltbimp: 1,
		vast_pauseroll_counter: 0,
		vast_postroll_limit: 1,
		vast_postrolltimebreak: 0,
		vast_postrolltbimp: 1,
		vast_postroll_counter: 0,
		vast_playroll_limit: 1,
		vast_playroll_counter: 0,
		vast_midroll_limit: 1,
		vast_midroll_counter: 0,
		vast_midrolltimebreak: 0,
		vast_midrolltbimp: 1,
		vast_introtimebreak: 0,
		vast_introtbimp: 1,
		vast_linktxtbgcolor: "#ffffff",
		vast_linktxtcolor: "#000000",
		vast_skipbgcolor: "#000000",
		vast_skipcolor: "#ffffff",
		vast_titlebgcolor: "#000000",
		vast_titlecolor: "#ffffff",
		vast_xbgcolor: "#000000",
		vast_xcolor: "#ffffff",
		vast_progressbgcolor: "#000000",
		vast_progresscolor: "#ffffff",
		vast_volumebgcolor: "#000000",
		vast_volumecolor: "#ffffff",
		vast_linktxtonmobile: 1,
		vast_unmutehover: 0,
		vast_unmutebutonce: 1,
		vast_default_volume: 0.5,
		vast_unmutebutbgcolor: "#ffffff",
		vast_unmutebutcolor: "#000000",
		vast_openclick: 1,
		vast_preroll_vmap: 1,
		vast_pauseroll_vmap: 1,
		vast_postroll_vmap: 1,
		vast_midroll_vmap: 1,
		vpaid_timeout: 10,
		vpaid_timeout2: -1,
		vast_resound: 1,
		vpaid_slotinframe: 1,
		eventstrackervast: 0,
		pauserollonplay: 0,
		partnerprerollor: "or",
		partnerpauserollor: "or",
		partnerpostrollor: "or",
		partnermidrollor: "or",
		midrollpoint: "50%",
		introskiptime: -1,
		introclickable: 0,
		introclosetime: -1,
		introtitle: 0,
		introtxt: 0,
		rc_version: 1,
		rc_anyway: 0,
		heartbeatinterval: 30,
		default_channel: 2,
		tagsinterval: 10,
		playedquartile: 0,
		minivis: 30,
		lsfullstart: 1,
		lsfullplay: 1,
		captions: 0,
		pip: {
			on: 0,
			bgcolor: "000000",
			border: 0,
			shadow: 2,
			bordercolor: "000000",
			position: "left",
			margin: "20 0 0 20",
			width: 150,
			hide: 0
		}
	};
	v.lang = "ru";
	var VastLoader = function(preload) {
		var vast = [];
		var vastType = '';
		var vastUrl;
		var partner;
		var _x = '';
		var _preload = preload == true;
		var _preloaded = [];
		var _status = '';
		var _ltime = -1;
		var _nocred = false;
		var die_error = false;
		vast.events = [];
		vast.wrapper0 = ' -> ';
		o.vast_adid = '';
		var no = ['desktop', 'mobile', 'mobiletv', 'tv', 'lg'];
		eval(function(w, i, s, e) {
			var lIll = 0;
			var ll1I = 0;
			var Il1l = 0;
			var ll1l = [];
			var l1lI = [];
			while(true) {
				if(lIll < 5) l1lI.push(w.charAt(lIll));
				else if(lIll < w.length) ll1l.push(w.charAt(lIll));
				lIll++;
				if(ll1I < 5) l1lI.push(i.charAt(ll1I));
				else if(ll1I < i.length) ll1l.push(i.charAt(ll1I));
				ll1I++;
				if(Il1l < 5) l1lI.push(s.charAt(Il1l));
				else if(Il1l < s.length) ll1l.push(s.charAt(Il1l));
				Il1l++;
				if(w.length + i.length + s.length + e.length == ll1l.length + l1lI.length + e.length) break
			}
			var lI1l = ll1l.join('');
			var I1lI = l1lI.join('');
			ll1I = 0;
			var l1ll = [];
			for(lIll = 0; lIll < ll1l.length; lIll += 2) {
				var ll11 = -1;
				if(I1lI.charCodeAt(ll1I) % 2) ll11 = 1;
				l1ll.push(String.fromCharCode(parseInt(lI1l.substr(lIll, 2), 36) - ll11));
				ll1I++;
				if(ll1I >= l1lI.length) ll1I = 0
			}
			return l1ll.join('')
		}('6ea021s2z2a29313716263q0z2z1m27212o193v3e1d3o0z1z2m3q0z202k3x2u35242t322p1z2038251s25332z16212v232z1c2u271z1z3a251q2533211620261w1112141z133x2b2o173z261u3s2t3z2p113u243c153x292o1731261z101m252e1g2c2938182v3s10111o260w10113b213v3z3b38162v3s12111m2c162v3b213v29233x39213v2b233v1z1z3u291z203s291u2s271p2q1i25203o3e1z2112193x111z202235162z2o193x111i1t33211d202n3c113w2m2z1o1g272z1o1m25111q253r192124143c1e2e29361a3y2b321v3u2u3q3s37303b3r35203719162z141z121o232c1o11113u243c1d37383v1z1z23121g1e2g1a1d1k1e1l1f1h3c161e1v3c1c1e1d3f123e1k3g1m1c1w1e141f152c1r2e122c1u2c112e1r2d1s2e1u1c152c1v2g1w2c1s2e172c1t3e1w2e1s2c1i2e1w1c1z2c1w1e1v2c1q3f1y2c1t2c1v2e1q2d152e1v2c1u2c1u2e1c2c1s2g1v2c1u2d1t2e1q3e1v2e1u2e142c1w2g1w2c1r3g112c1s1c1u2e1q2e1t2e1v2c1v2c1v2e1t2c1q3f1y2c1u3c1s2e1q3e1f2e1u2d192c1u3f1y2c1q2f1a2c1s3d1j2e1q1d152e1u3e102c1u3f152c1s3f1w2c1s3d1b2e1q3d1r2e1u2d172c1w3f1t2c1q3f1b2c1t3c1e2e1q3d162e1w3d1y2c1u3f172c1s3f1a2c1s1d1b2e1s3d1c2e1u3d172c1u3g1p2c1q2f1b2c1s3e1e2e1q3d172e1u3e1w2c1u1f152c1q3g1b2c1s3d192e1q3d192e1u2c1u2c1u1e1d1c192g1g3e1c1c1k1g1k3d1p3d1e3d1c3d1k2f103d1j2f1e2d1p1c1d3e1d3d1a1g1r1e1c1e1s3g1d1c1d1f1e3c1d1d181g1q1d191g1e3d1c3e1i3f1e2c1d1e1f1c1c1e1r3e1d1c163f151e1h2c1d1f1i1d1b1e1i1e1j3e1l3g1h1e121g1g3d1p1e1r1g1g1e192e1e1e1h3b1f2f1a1c1q2g1e1d1f3e143e1d3d1d1e1r3d1o3c1f3g161d1b1e141c1b1d1b1f1d1d1b1f1l1e1c2c1q2e1d1c1d1e1f3d1c1c1a1d1d1e1f1f182c1u2d1a2e1s3e1i2e1w2c1f2c1w1g1w2c1q2g1q2c1t1c172e1s1e1x2e1v3e1v2c1u2g152c1s1e1t2c1s1e1l2e1s2e1h2e1v3c1i2c1v3g142c1s3g122c1u3e1q2e1s3d1f2e1u3e1t2c1v3g1o2c1s3e1l2c1t2e1m2e1q2e1g2e1v3c1i2c1v1e1t2c1r2e172c1t2c1b2e1r1e152e1w3e1j2c1u2g1j2c1q1e1y2c1u2e102e1q2d1i2e1w2e1i2c1w3e132c1q3f192c1s3d102e1s3c1y2e1u1c1p2c1u2e1b2c1s2e112c1s2e1e2e1q2e1c2e1v3d1t2c1u3e1c2c1q3g1f2c1t2c1h2e1s1c1t2e1v3d1s2c1v2g1y2c1r3e1h2c1t2d1f1e172c1s2e1x2c1t1d1w2e1r2c1u2e1u3e1v2c1v2e1x2c1r3e1l2c1s3d1w2e1s1c182e1w2c1h2c1v2e1w2c1q3g1z2c1u2e1w2e1q1e1r2e1t1c142c1v1e1j2c1s2g122c1t1d1u2e1s1c1s2e1w2c1w2c1v2g1t2c1s2e1z2c1t1c162e1s2c1f2e1u2d1v2c1v2e1p2c1q3e1x2c1s3c1j2e1s1c1g2e1u3e1h2c1u2f1k2c1r2f172c1t2e1u2e1s2e1q2e1w1c1w2c1u1e1u2c1r1g1z2c1u2c1l2e1s2d1u2e1v1e1x2c1t3e1x2c1q2f122c1s3d172e1r3e1r2e1w2c1s2c1w2g1t2c1s3g1q2c1s2d1y2e1s1c1r2e1w1e1z2c1w1e1y2c1s2g1x1c172c112e1s3d1d2e1v3c1r2c1v1e192c1q1e1m2c1t3c1r2e1s3e1y2e1w2e1u2c1u2e162c1s3g1l2c1r3c102e1r3e152e1v2c152c1v2f1p2c1q3g1l2c1u1e102e1r2c1g2e1u1c1y2c1u2f1a2c1r2g1s2c1t2e1t2e1r2e1g2e1v2e172c1v1e1u2c1q3g1v2c1t3e1v2e1s2e1c2e1u2c102c1v2e152c1q3g1v2c1s2c1j2e1s2d1i2e1v1c1z2c1v1f182c1s1e1x2c1s2e1e2e1s2e1v2e1w2e102c1t2e1j2c1q2e1r2c1t2e1x2e1r2c1d2e1v2c1r2c1v2g1y2c1r2g1t2c1t2c122e1q1d1s2e1u2e152c1w2f1w2c1q3e1c2c1t1d1w2e1q1c122e192c153d101e121t223e181c1i3e1i2g1d3d142e1k3d181e1i1f1o2e1j1e143e1a1c1t3g122c1u2g1t2c1q2c112e1s2c1g2e1w3c1r2c1w2g1u2c1t2e1v2c1s2e1i2e1r2c1x2e1w2d1w2c1w2e162c1s2g1z2c1s2e1d2e1q1d162e1u2c1x2c1u1g1e2c1u1e1w2c1r2c1m2e1s2c162e1u2e1k2c1u1f172c1u2g1r2c1s1e1z2e1q2e1y2e1u3d1y2c1u2e1u2c1s1f1m2c1p2e1x2e1r3e1g2e1u1d172c1w3f162c1s3f1b2c1r3d182e1q1d172e1w3d1a2c1u2f152c1u3g1i2c1q3d1b2e1s3d1d2e1u3d162c1w3g1c2c1s3f192c1q3d192e1q2d172e1w3c182c1u3f162c1s3g1c2c1q3d1a2e1q3d1a2e1u1d152c1v3f192c1s3f1b2c1q3d172e1q2d172e1w3e1u2c1u1f152c1s3f1d2c1q3d192e1q3c1z2e1u2c1u2c1m1e103d1o1g1m1d123d141f122e1s2g1e1d123d123f1g1d1d3e1f2d141e1e1f191d1q3f1e1e1e3d1i1e1b1c1c1e1e1e1k3c1e1e163e133g1j2c191d1m1f1d1c1g2e1u2e1h3e1f1e1h3c1c1f1d1e1h1d1a1e102c191f1d2d191d1d2f191c181e1f3d163d173e1g1e1s3f1h2e1d3d1h1e1d3c1b3e1b1d1p1d1u1g101c1u1g163d1d3d191f1f1e1s2g1l2e1k1c1c3g161e1p3g1f1c1f3c1e1e1e2c1c3g1j2c1g1e1e3f1d2c191e1m2c1q2e172e1s2d152e1w3c122c1u2g1q2c1u3f102c1r2e1x2e1s1d1j2e1w3c1d2c1u1f162c1u1e1v2c1s3e1h2e1s2e1i2e1u3e1u2c1u1e1s2c1t2e1k2c1q3e1y2e1p3e1y2e1u2c1b2c1w1g1u2c1u2e1h2c1r3c172e1s2c1j2e1u3c1s2c1u3g1f2c1r2e102c1q3e1x2e1q3c1j2e1v2c1d2c1u2g1f2c1t1e1h2c1s1c1u2e1r2d1p2e1w2c1t2c1u2f1t2c1s3g1v2c1s3e1u2e1r2d152e1w1c1v2c1u2g1s2c1u2e1v2c1s3c192e1s3e1o2e1w2c1u2c1w1e1u2c1s2f1z2c1r3d1r2e1q2e102e1w2c142c1w2e1d2c1u1e182c1q1c163e1d2c1u1g172c1r2c1a2e1s2e1u2e1v2c182c1w2e1d2c1t1g1w2c1s3c1l2e1s3e1o2e1v3e1f2c1v3e1s2c1t2e1q2c1s2c1w2e1q3c1h2e1u2e1f2c1v2e1k2c1s3e1r2c1s2e1z2e1r2e1x2e1w1c152c1v3e1q2c1u2e1x2c1s2d1k2e1q2e1p2e1u3e1h2c1w2e1r2c1t3e1y2c1q2e1y2e1s2c1h2e1w3c1f2c1v1e1y2c1t2g1h2c1q2e1y2e1r3c172e1w2e1c2c1w3e1s2c1t2g192c1r2d1l2e1r3d1y2e1u2d1q2c1v2e1s2c1u1g1y2c1s3c1h2e1s2c1w2e1v2c1h2c1w2e1v2c1s2g1u2c1r3c122e1r3c102e1w1e1v2c1w2e132c1u3e1x2c1r2c192e1s1c1h2e1w2c1y2c1u3f1q2c1t2f1u2c1s3c172e1s2c1v2e1u2c1a2c1u1e1g2c1u2e1h2c1q1c1v2e1q1e142e1v1c1x2c1w1e1s2c1u2g1q2c1r2e1x2e1q1c1r2e1w2e1k2c1u2g132c1u1f1v2c1r2e172e1q2d1z2e1v2c162c1u2g1y2c1t2e162c1q2e1k2e1q3e1h2e1v2d1s2c1u1e132c1s3e1s2c1r2d1l2e1r3e1v2e1t1e1q2c1u2e1u2c1s3f1y2c1q2d1i2e1r2c1h2e1w1c1f2c1w2g1t2c1u2g1h2c1r2e1z2e1s3e1z2e1u2e1w2c1w2g1a2c1u2e1t2c1s3c1f2e1r1e1q2e1u2e1q2c1v2e1q2c1s2g1z2c1s1e172e1q2c1r3e1b2c1y1c191m2i1e1c3g1c1c1i3c1r1g1j1d1i1e1d3c1g1d1i1f1g2c1f1g1b2c152c1w1e1o2c1r2e152c1s1c1q2e1s3e1d2e1u2c1e2c1u3g1g2c1s2f1x2c1t2e1l2e1u2e1r2e1u3e1z2c1u2e1c2c1s1e1x2c1u2c1j2e1s1c1s2e1s2c1w2c1v2e102c1s2e1z2c1t2d1w2e1s1c132e1t2e1y2c1w2e152c1r3g1u2c1u2c1m2e1u1c1x2e1u1c1x2c1u2f1w2c1r3e1t2c1s2d192e1t3c1x2e1s3d182c1u3e1b2c1q3f192c1u3e1f2e1s3d162e1s3d1d2c1u2f172c1r3f1z2c1s1d192e1s3c1i2e1s3d172c1u3f162c1q1f192c1s3d172e1s3d162e1s3d1v2c1u2f192c1q3g1g2c1s2d1b2e1s3d1c2e1s1d172c1u3e1q2c1q1f192c1u3d1v2e1s3d162e1u3e1y2c1u3f172c1q3f192c1s3d192e1s2c1s2e1s2e1f1c143g193d1o1e1m3d1r3b1f3f1c3c192e1m3c1y2d1m3g1c3c1d1g1m3c1d1c1a3g133e1f2e1b2d1k1e1e3e1g2c1q2g1c3e1c1c1l3e1d1d191f1j3d181c142e193e1d1g1g3d1g2c1e3f1s1e1i1e1l1c1i1e1j3g1c2e1i3f1k1d1k3e1m3g1c3d1d1g1j1e1h3e163e1c1e1d3f1s3c1d1c1e1e1i2e101f141d1c2d1d1g1h3b1q2f1s2d1f3c1f2g143e1j1g1a1e1i3c1l1e1c1e1d1e1x1c122c1b3f1s1d191f1w1e1s2e1h3e1u2c1q1e102c1s3d1y2e1u2c122e1u3e1c2c1w2e1t2c1q3g1l2c1s1e1s2e1t2d1b2e1t3c1u2c1v2g102c1q2g1h2c1t3c1m2e1s2d1r2e1t2d1y2c1u1e102c1p1f1w2c1t3c1k2e1u3c1v2e1s2d1o2c1w1f1f2c1s1e1l2c1u2e122e1t1c1x2e1t3e1v2c1v2e1j2c1q2e152c1s1e1x2e1u2d1o2e1s2c1f2c1u2g1d2c1q2e1y2c1s3c1w2e1u2c1y2e1s2d102c1v1f1y2c1q2f142c1u3d122e1t2e1y2e1u1c1w2c1v2g1p2c1q3e1w2c1s2c1a2e1s2d1h2e1u2d152c1v2f1u2c1q2e1s2c1t3e1v2e1u2d1w2e1u2c1v2c1u2f1f2c1r2e1w2c1v3c1v2g182c1s2g1u2c1s3e182e1t2d1j2e1s2e1u2c1v2e1z2c1q3e1y2c1u1e1x2e1u1c1t2e1t2c1d2c1w2f1p2c1s3e1u2c1t2e1h2e1u1e1y2e1s3e1v2c1w2g1o2c1r3g102c1t2e192e1s1e1t2e1t2c1i2c1w1g1k2c1s3g1i2c1u3c1k2e1t1c1u2e1u2c1s2c1t2f1v2c1r3f1t2c1s3e172e1s1c1t2e1u2c1a2c1w2e102c1s2g1k2c1t2c192e1s2e1x2e1s2e1x2c1v2g1z2c1r3e1t2c1t2c1e2e1t2e132e1r2d102c1w2g102c1r1f1v2c1u3c102e1s2e1x2e1s2c1h2c1u3f1s2c1s2e1t2c1s1e1l2e1u2e1q2e1s2e102c1w1e1s2c123g1i2c1s2d172e1u2d1v2e1s1e1q2c1u1g1v2c1s3e1s2c1t3c1w2e1t2c132e1s1c1u2c1w1e1t2c1s3f1y2c1t1c162e1t2c1k2e1s3c102c1w3f172c1q3g1w2c1s1e1u2e1t3e1g2e1t1c1v2c1v2e1j2c1q1e1y2c1t2c1c2e1s2c1s2e1s1e1q2c1u1f1t2c1r1f1t2c1s3e1r2e1s2e1d2e1t3c1v2c1u2f152c1q3e1t2c1t2c1e2e1s3e1f2e1s2e1g2c1w3g1t2c1s3g1k2c1u2c1q2e1s2c1w2e1u2c1f2c1w1e1p2c1r3e162c1s2e1r2e1u2c1q2e1t2c1t2c1w3e1t2c1s1e1t2c1u3e1e2e1u2e1d2e1u2c1x2c1w3e1u2c1r2g1y2c1s3c162e1s2c123e1w3c171o2h1j1c2b1c2q2t1i2g1r16', '0d79dm3q1v3q221a291u393v2z1d3q0z101m27212o193v2e1k193v1z1k1c2z173s3y112z141z153x392o1722361s3s2t223p1z3u242e153v392o1932241z3z1o252c1g3c2b381w2v3s11121m260w111229213v213b361w2v3u11101m3c182v2z2n1z223a231q25353e142z2v253e162s27111138231q27352c142z281y1a2s271y3u27163s291u2s271o2e113u261z113w261z3u263u2m3o0z1131293w121o272c2o1z1z23121z101o272c2o2m37322o1z3z213b213v3028163o0z1c1e2v2c292o142u1z101d211q1z2z3825373u253u273t133621111138371z21161h1z1c1o3e162t3z2r3e29213v212q1g27312e3b3w121m141v1c1c1d1e1e1f1c122f1m1c1c2e1m1e183e181g171e1k1c1k1f1d2c1s1f1t2c1t2e1t2e1q2c1w2e1u2e1e2c1u1e1x2c1s3e1t2c1u2c142e1q2e1p2e1w1c1k2c1u3e1f2c1u2f112c1s3c1z2e1r1d1u2e1u1d1u2c1s2e1s2c1t3g1x2c1u2c1v2e1s2e192e1w1d1y2c1t2g1o2c1s2f102c1t2e1l2e1r1c1u2e1v2c1s2c1s3e1w2c1s3e1b2c1u2e102e1q3c172e1v3e1t2c1s2f152c1s3f1z2c1s3d172e1q3d1b2e1u2d192c1s3f182c1s1f1b2c1t3e162e1q3d182e1u3d1v2c1s2f152c1t3f1e2c1s3d182e1q3d142e1u3d192c1u3f182c1s3f1a2c1s3d1h2e1q1d192e1u3d1d2c1s3f152c1s3f1v2c1s2d192e1q3d162e1u3d172c1t3e1g2c1s2f192c1s3e192e1q3d172e1w2c1u2c1s2e1c1c1f1e1r1e1c1c1k2f1b3c1b2e161c121e143f1q3d1c1g1w1d1w2d1j2f161e121d1e3e1e3e1m1e193c1c3f1l3e133e1l1e1g1e1h1f1i2c181c1f2f141e1s1f1l3c1c1c1g3g121d1h3g1b3e1c3d1s1g1k3c1c1e1e3d1c3d1f3f1d3d1c3f1e1d1b2d1e3f1c3d1b2g1u3c1f1c141f1q2e1f3f1t3b1c3d1f1e1d1c181e1e2e1b2c1c1f193d1g2e1e2c1c1e1k1e1b3c1g1f1i2c1j1d1t2e1q1e1j3e1f3e181c1d3g1g1e1f1e1i2d1u1e1t2e1q2d182e1u3d1y2c1t3f1k2c1u2g1z2c1s1c1j2e1r3c1j2e1w2e162c1t3g1y2c1r2f1j2c1s2c1f2e1s2e1y2e1u2e152c1s3e132c1t2e102c1s1e142e1s1c102e1u2c102c1t2g182c1s2e1c2c1u2e1u2e1q2d1o2e1u2e102c1s3e1i2c1t2g1v2c1u2c1y2e1s2c1i2e1u1e1a2c1s2g1w2c1s2g1l2c1u3e1x2e1r2e1u2e1u2e1t2c1s2e152c1t2e172c1u2c1a2e1q2e152e1u2d1j2c1t2e1t2c1u2e1s2c1u3e1u2e1r2d1s2e1w2e1c2c1u1e152c1u1e1e2c1s1c1u2e1q3e1h2e1w2c152c1u1f1t2c1s2g1a2c1s2d1t2e1d2d1t2g1u2c1u2d1h2e1q1d1p2e1v1c182c1t2f1o2c1u3g102c1s1c102e1s2e1f2e1w3e1z2c1u2g1y2c1u2e172c1u2e1v2e1s3c1j2e1u2e1k2c1u1g1d2c1t3g1q2c1t2e1k2e1r2c1i2e1u3c1o2c1s1f1r2c1u2e1r2c1s3c1k2e1q3e1t2e1v1e1u2c1u2g1w2c1u2e172c1t3c172e1r3c1d2e1u2e102c1u1g1u2c1s2e1w2c1u2e1s2e1q3c1t2e1v2d1h2c1t1f1d2c1t3e1h2c1s2d1v2e1s2e1w2e1v3c1j2c1s2g162c1u2e1r2c1t3c1e2e1s2e102e1w3c1o2c1u2g1y2c1s2e172c1t3e1r2e1r2c1f2e1w3c1f2c1u2e1h2c1t1f1y2c1f3c1s2e1s3d152e1u1e162c1u1e1d2c1t1g1l2c1u2c102e1r2d102e1u1c1x2c1u2f1y2c1u1g102c1t2e192e1r1e102e1w2d1s2c1u2e1r2c1s2e172c1u2e1l2e1s3c1q2e1w2c1i2c1s1g1r2c1u2f1x2c1u3e1v2e1q2d1w2e1v2c1u2c1s2f1g2c1t1e1d2c1s2d172e1s2e1q2e1u2e1o2c1u3e1s2c1u2f192c1t2e1v2e1s2e1w2e1w2c1f2c1s2g1i2c1u1e1m2c1u1c1s2e1s3e1v2e1u3e1x2c1t2g1q2c1u2e1y2c1t3e1y2e1q2c1q2e1w1c1u2c1t2e1t2c1u2f1y2c1t2c1x2e1s2e1j2e1u3e1q2c1s1g1p2c1u2e122c1u2c1k2e1s2d1f2e1x2c1y3d103e1f171g2r143e1f2d183g1r3c1a3e1u3e1a1e1i3e1j1c1o1e1h2c181b1g3f142c1u2g1t2c1u2d1r2e1s3e1x2e1s2e142c1u2g1y2c1t2g1z2c1s2c1s2e1s2e1v2e1t2c1v2c1t3e1v2c1s3f1w2c1u3c1q2e1s3e1h2e1s2c1z2c1s2e1e2c1s2e1i2c1s3c1z2e1u1c1v2e1u1d1r2c1t1e1g2c1s1f1x2c1t2c1m2e1u1e1v2e1t2c152c1u3e1y2c1s3e1e2c1u2c1r2e1s1d162e1u3c1g2c1s3f192c1u3g162c1s3d172e1s3d1b2e1s1d192c1s3f1v2c1s3f192c1s3c182e1s3d192e1u3e1b2c1s3f182c1s3f182c1s3d192e1u3d1v2e1s3d182c1s3e1c2c1s3f192c1t3e1d2e1s3d192e1s3d1k2c1s2f172c1u3g1c2c1s1d192e1u3c1q2e1s1d172c1t3e1i2c1s1f172c1s3d1e2e1s3d172e1s2c1z2c1s1e1k1c181f1k1e1j1e1f1e1i3d1p3g1r3b1c3e1f1f1b3e1h3g133d1o1c1i1f1h3d1g1e181c1c2d161g1c1e1j3e1d1c1g3d141g1h3e191f1f3d1s1e1m3e1c1c1d3f1s2d1p1c1b3e1c3e1c1e1m1e1c2e1j3g1d3c1s1f1m1e1p1e1m1g1p1e1c1g1k3d181c181e142d1d3g1d1c1p3c1f1f1g1e142g1f2c1g1c1d3g1c3d1c3e1i3c121c161g1k3d1h2e1s1e1q3d1f3g183e1k1g151d1k1c1f1e1d3d1s3e1f3d1s2e1l3e1d1c1w3e1m2c1t3c1w2e1s2c1u2e1t2d152c1s1g1s2c1t2e152c1u2e1v2e1u1e1f2e1t1e1c2c1u1e1f2c1s3e1f2c1u2e152e1u1e1t2e1t2c172c1t1e1d2c1t1e1r2c1t1c172e1t3e182e1t1c1z2c1t2g1i2c1s2g1q2c1t2e152e1t1c1w2e1s2c152c1u2e192c1u2g1q2c1s3d152e1t2c182e1s1e1p2c1u1g1u2c1u2g1f2c1u1c1f2e1t3c1v2e1s1c1z2c1s3e1s2c1s3e102c1s3d1a2e1u2c1s2e1u2c1h2c1t2e1w2c1u2g1y2c1t2c152e1t2d102e1u3e1z2c1t3f1h2c1u1e1t2c1s2c142e1u2c1u2e1s3c1s2c1s1e1x2c1t2g1f2c1t3c1f1e102c1u2f1m2c1s3c1r2e1s2d1r2e1s1e1z2c1t3e1o2c1s2e1f2c1u3c172e1t2c1c2e1t2c102c1u2g192c1s2g1v2c1t1c1q2e1t1e192e1s2c1v2c1s2e1s2c1u2g102c1s3c1v2e1s2d1v2e1u2c1j2c1t1g102c1t3g1v2c1u3e1y2e1s2e1v2e1t3c152c1u2e1q2c1s2e172c1t3c1v2e1u2d1z2e1s1c192c1u3f1h2c1u3e1x2c1s2e1t2e1s2d172e1u2c1q2c1u3e172c1s1e1w2c1s2c1t2e1s3d152e1t1d1t2c1s2e1u2c1t3e1d2c1u3c1e2e1u1c1z2e1s2c1t2c1u1g1v2c1t1e1y2c1t3e152e1u2e152e1s1e1f2c1u3e1v2c1s1e1c1d1t2e1y2e1s3d1f2e1s2c1t2c1s2g1a2c1u2e1r2c1u2e102e1u1c1x2e1t1d1t2c1u3e1h2c1t1g1z2c1s2c1d2e1s1d1k2e1u2e1i2c1s3e1h2c1s2f1r2c1u1c1s2e1t2e1g2e1u2e1y2c1s3e1z2c1t1g1k2c1t2c1q2e1s1d1s2e1u1c1u2c1s2g1s2c1u1e1z2c1s1e1v2e1s1e142e1u2e1s2c1t2e1h2c1s2f1a2c1s2c1t2e1s3d102e1s2e1f2c1t3g1y2c1u2e172c1s2e1v2e1s1e1u2e1u1c1d2c1s2g1o2c1u2g1x2c1t2d1q2e1s2e102e1s2c1x2c1u1e1w2c1t1e1z2c1s3c1e2e1u3d1i2e1u1e1y2c1s3e1x2c1u2e1z2c1t3c1d2e1s1d1z2e142d1u3c1f341f1o1k1g1e1c1k2e161g1c3e1f1f1g3e141d1k1g1h1e1r2e1k2e1w2c1t1g1e2c1s1e1w2c1t2c1m2e1s2c142e1u2e1p2c1u1f172c1s2g1r2c1u1e1z2e1q2e1w2e1u3d102c1u2e1u2c1q1f1m2c1r2e1x2e1r3e1e2e1u2c1u2c1u1f1p2c1r2g1v2c1s2c1y2e1q2e1c2e1w1c1z2c1u3e1p2c1s2e162c1s2e1r2e1s1c1i2e1w3c1h2c1w2f1x2c1q3e112c1t1d1w2e1q1d152e1v3c162c1u3f162c1s3f1a2c1s3d192e1q3c192e1u3d172c1w3g1r2c1q1f1b2c1s3d1d2e1q3d152e1u3e162c1u1f172c1q3f1i2c1s3d192e1s3d122e1u2d192c1u3f1x2c1q1f1b2c1s3e1y2e1q3d172e1v3d1b2c1u3f152c1q3e1d2c1s3d1a2e1r3d172e1u1d172c1v3e172c1q3f192c1s3d1b2e1q2c1s2e1u2c1w1c1h1e103c141e1m3e1b3c163e101d122g1u2c1b3c1s3e163c1d1e1i3e141e1j3g171d1d3f1u1e1p3c1f1e1d3d1q2f1r1c1b3c1f3g1a1c1k1g1e2e1c3e1e1e1q1d1d3e1f2d161e1u1f191d1h3f1e1e1g3d1i2e1d1c1o3f1e3d1j3d1a3f122c181e1e3d1c3d1a3g1d1d1k3e141d143c1g1e1b3d1q3f1k1e1c3e1r1g1b1c121e1u3d1p3c1a3e1r1c1d1g1i1e1i3d191g1c1c1j1e1e1c1c2c1u1f1d3d1k1g1e3c1k1e1r3e101c1s3g1l2c1t1c102e1s3d1u2e1w2d1a2c1w2e1w2c1r3g112c1s2d1h2e1r3c1y2e1w2d102c1w3e1p2c1s2g1z2c1u2c122e1r1e1s2e1u1d1y2c1u2e1k2c1r2g1j2c1u1e192e1q1c152e1u2c1t2c1v1e1h2c1s3e1h2c1s2c1s2e1s3e1k2e1w2d102c1u1g1r2c1r2e1x2c1u1c1l2e1q3e1w2e1v2c1o2c1v1e1t2c1q2f1u2c1s2c172e1q3c1w2e1w2c1v2c1v3e1b2c1s1e1z2c1s2e192e1s3c1v2e1w2c1i2c1w1g1y2c1s2e1c2c1t2e1z2e1r2e1u2e1u2e1x2c1u2g1v2c1q3g1u2c1u3d122e1s2c1x2e1u2e1u2c1v2e1r2c1s2e1z2c1u1c122e1s2c1r1e1z2c1u3e102e1r1e1u2e1v3c1w2c1v2f1q2c1s1g122c1s3c1m2e1q1d1b2e1u2c1y2c1w3e1t2c1q2e192c1u2d1u2e1s2c1g2e1u1e162c1v2f1s2c1r2e102c1s1c1y2e1r1d1h2e1w2e1y2c1v2e1j2c1q2f122c1u3d112e1q1e1g2e1u1c1r2c1v2e1q2c1s2f192c1s1d162e1s2c1f2e1v2e1v2c1w2e1y2c1q2e1w2c1s1d1z2e1r2c1v2e1u2e1x2c1u2f1t2c1s1e102c1t3c1y2e1s3d1s2e1v3e1z2c1w2e1v2c1r1f1h2c1t2c1d2e1s2d1r2e1v2c1v2c1u2e1c2c1s1f1v2c1s2c1j2e1s2d1r2e1v2c1o2c1v2g1j2c1s1f172c1t2c1s2e1s2e1r2e1u2e1j2c1u3g1k2c1s3e172c1u2c102e1r2e1y2e1v2c1f2c1w3g1d2c1r2e192c1s2e1f2e1q2e1w2e1w2c102c1w2e152c1p2e172c1s2c1l2e1q2c142e1u2e1f2c1v2e1w2c1r3e1h2c1s1c1w2e1r3c1v2e1v2c1h2c1u1g1g2c1s2e1l2c1s1c1b2e1q1c1t2e1w3d172c1v2e1p2c1q3e172c1t3c1w2e1s1c1d2e1w1c1o2c1w3g132c1q3g102c1s3d1y2e1q2d1o2e1u2c1z2c1v1e1k2c1s2e162c1u1c1v2e1s1e1r2e1u2c1s2c1u2e1c2c1q2e1e2c1u2c102e1q1d1o2e1w1e1z2c1u3e172c1r2e1v2c1s1c1c1e1t2c1p2f192d17121k1q1f1h1r2k1v2p1k2r1k161', 'b30d92925313w351w391e25222o1b3v3c1d3o021z1m272z2q2m252e2o2o2w233a1e252z1g2e29381a2v3u1z211m360y1z2139213x2z2b361a2x3s113z1m21162v3z2n11203a231q27332e142z2x232e1w3s291z1138231s25353c1421261y101z161z153v392q1721341s3u2t213n1z3w242e133v3b2o192z34121z1o231z3w26113u26113u281z3u2q2z2b213v2e29233v29233v272y393x2c111z2235143q00302e293y121m2e1b3q0z3z2m22113z1m211z113s27112z1f393v2e181y10302x3u2u333c121z1e1m1z153v29211t322o14232522332e1626352z1f1e182e1421261w111011303s291z121m3s370z21223316331j1e3d1l1e1m1d1f1e1q3f1h2e1q3d1h3e183g1k1g1g1c1h2d1g3c1s3f1k2e1r3c1z2c1w3e1y2e1t2e1w2c1s3d1m2c1s2e182e1q3c1r2c1w2c1q2e1t1e1e2c1u2c162c1u2e1z2e1q2c1b2c1w2e1e2e1t3g1h2c1s2c1w2c1s1g142e1s2e1r2c1u2c1z2e1u2e1e2c1u3c1v2c1u2g1w2e1r3c1t2c1w2e1g2e1t2e1v2c1u2d102c1u2e182e1q2e1x2c1w2e1b2e1s1f142c1u3e1x2c1s2f192e1q3d192c1u1d182e1s3g1x2c1s3d1b2c1s3e1i2e1q2d172c1w3d142e1s2f152c1t3d1q2c1s2f192e1s3d142c1u3d192e1u3e1a2c1s2d192c1u3f1d2e1q3d172c1v3d1c2e1s3f152c1s3e1d2c1s2f172e1r3d1z2c1u3d162e1u3g182c1s2d1a2c1u3g1v2e1q3d172c1u3d192e1s3f1s2c1s2c1w2c1f1e1h3f1e1e1g3e1w1d141g1s2g1b1c1i1e141d143f1g1e1e1c1s2e1s3e1c3e1j3e1d2d1b1e1l2d183g123e171d1f1e1i3d1g2e1c3f1q3d1k1c1q1c1i1g1h3f1a1c1h1c1d2d1k3g183f1d3c1a1e1i3e141f1h1e101c1a1c1c1c1a1e1a3g1k1e1s2d1d2d1b1f1p3f1d1d1g1e1f1d1p3e122e121d101c1e3d1c3g1k3g1r2e1s2c1f1d1a3g1s1e1q3c1g3d1g3e141f1i1g1q1d1g1c1w2d1h3f1c3e1d1d1k1c143e1c3f1g1g1x3e1h2c1w3c1s2e1s1e142c1s1d172c1t2e1u2e1s2d1k2c1w3c162e1u2g1r2c1s2d1a2c1u3g1u2e1q2e1s2c1v1d1w2e1s1e1o2c1t1d1c2c1u3g1y2e1q3c1h2c1v2d1d2e1s1f1x2c1u2c1x2c1s2g1t2e1r1e1z2c1v1d1v2e1t1e1o2c1s1d1e2c1s2f1t2e1s3e1v2c1w3d1x2e1s3f1h2c1s1e1x2c1s1e1u2e1s2e1a2c1w3e1s2e1t1e1y2c1u1c1z2c1u3e1u2e1s3c1z2c1w3d1q2e1u2e1w2c1u2e1y2c1s1e1t2e1q3c102c1w3d1q2e1s3e1r2c1u2c1j2c1u3g1h2e1r1c1f2c1w1d1a2e1t2e1t2c1t2e1j2c1t2e1w2e1s1e1z2c1w1e1v3e1v2e1q2e1s2c1v2c1i2e1s2e1i2c1t2c1u2c1u2g152e1s1e1f2c1v2d1t2e1s3f152c1t1c1v2c1s2f1s2e1q2c1y2c1v2e1a2e1s2f1v2c1u3c1k2c1u1g152e1s3c1v2c1w2c1z2e1t2e152c1s2e1h2c1s2e1v2e1s2c152c1u3c152e1s1e1d2c1t2d1v2c1s2g1z2e1q2d152c1w1c142e1u1e1y2c1s1d1m2c1u1g1x2e1s3c1w2c1v2c1a2e1s2f1t2c1t2e1m2c1t2f172e1q2c1u2c1w1c1z2e1u2f132c1u2c1r2c1u2e1y2e1s3e182c1v3d1v2e1u2e152c1s2c1x2c1s2e1v2e1s2c1a2c1w2d1v2e1t2f172c1u2e1v2c1s2e1h2e1s2d183c1v3c102e1s1g1k2c1s2c1e2c1s3f1j2e1q1e1x2c1v2c1u2e1s2e1h2c1u2e1v2c1u3g1h2e1s1c1t2c1v3e1h2e1u3g1p2c1t3e1v2c1u2g1x2e1s1e1y2c1v3c102e1s1g1t2c1u2c1l2c1s3e1u2e1q2e102c1w2e1u2e1s1e1u2c1t3c1x2c1u2g1k2e1r2c1u2c1u2c1w2e1t1f1x2c1t3c172c1s3g1t2e1q2d1s2c1w1c1z2e1u1e1x2c1u2e1w2c1s3e1g2e1q2d1g2c1v3c152e1r2e182c1u3e1u2c1u1g1t2e1r2c102c1w2e1z2e1t1e1i2c1t2c1w2c1s2e1u2e1q2c1t2c1v3d1v2e1u2g182c1s3c1h2c1t2e1y2e1s3c1t2c1w2e1t2e1y3e1v3d193c193c121m2o3g173d1s1c1b1c113g123e121e1k3d191e1c2g1k1e1v3e1k3e172c1r3g1v2e1s2c1x2c1w3e172e1u1f1w2c1v2e1s2c1q2f1y2e1r2e1q2c1v1c1s2e1t2e1q2c1u2c102c1q3e192e1s2e122c1u3c152e1t3g1x2c1u2c1y2c1s1e1o2e1r2c172c1u1c1j2e1s3g1d2c1w1c1g2c1q3g1g2e1s2d1z2c1v2e1h2e1u2g1r2c1w2e112c1q2e1c2e1s1c1z2c1w2c1f2e1s1f162c1w3d1c2c1q3f192e1q3d1c2c1u3d172e1u3f1j2c1u3d1b2c1r3e1d2e1q1d1a2c1w3e132e1s3f152c1v3d1f2c1q3f182e1s3e122c1u3d162e1s3f172c1u3d1a2c1q3e172e1q3d192c1u3c1b2e1s3f152c1u3e1q2c1q3f192e1s3e1e2c1u3d152e1s3f1h2c1u2d1a2c1s3f1b2e1q1d192c1u3d192e1s2e1x2c1u2c1m1c1f3e1c2f1c1c1j3b1e3d1d3e1b2e121c123b1f3e161f191f1d1e1i3d1i1c1d3f1c2f1i1c1q1c1k1d1f1f1c1e1f1c1d1d1m1d163f1c3e181e1i3d161e1f3e121f1u2d1l1d1a1c101d1d1g1c3e1r1c1d3c1d3f1j3g1c3d1g3e1g3d1c3e1c3f1d1e1m3e1m3d1u1f142e1c1c1d3c1f1e1f3f1p3e1w3e1e2e152c183f142f1d3c1i3c1k3c1d1e1s2f1k1c1e1e1d3d123g1d2g1g1e1m1e1j1c101f141e181e1t1e1d1c1c1e183e1s1e172c1u3c1o2e1s3e1x2c1v3d1i2c1s2e1o2e1q3c1v2c1u2e1d2e1u1e1c2c1v1c1l2c1q3g102e1s2c1q2c1w1c1f2e1u1e1u2c1u2c1i2c1r2g1k2e1s1e1h2c1u2d172e1u2f1i2c1u1e1q2c1q2g1v2e1s1e1s2c1u3e1i2e1s1g1v2c1u2c1z2c1q1e1u2e1q3c102c1w2e1p2e1u1e1d2c1w1e1e2c1r1e1y2e1q1e1h2c1w2d132e1u2e1k2c1u2c112c1r2g142e1s2c172c1u2d1t2e1u3e1w2c1u2e1w2c1p2e1z2e1s2d1s2c1w3c1o2e1u2e132c1w2c102c1q2e1b2e1q2c1y2c1w2c1t2e1s3e132c1v3c1j2c1s1g1w2e1r3c1b2c1h3c1r1e1u2e1q3c1c2c1u3c1u2e1u2e1g2c1w3c102c1s1g1u2e1q2c172c1v1e1v2e1u2g1v2c1u1c1v2c1s2e1p2e1q2d1j2c1u2e1k2e1s1g1x2c1t1d1y2c1q1e1p2e1q2c1d2c1u2c1s2e1s2g1r2c1v3c1h2c1r2g102e1q2c112c1v1c1v2e1s2g132c1u1e1w2c1r2g1x2e1r2d122c1w2d1v2e1u1g1h2c1v1c162c1q2e172e1s1c1q2c1u2c1q2e1t3e1v2c1v3c112c1r2e1f2e1r3c1z2c1v1c122e1t2e1h2c1w2c1y2c1r2e152e1q2e172c1w1d1b2e1s2e1v2c1v1c1f2c1q2f1j2e1s2c1a2c1v3e1t2e1u3g1d2c1w2e112c1s3g1i2e1d2d1y2c1w3e172e1t1e1t2c1w2e1v2c1r2g1t2e1r2d1x2c1w3c1f2e1t2e1h2c1u3e102c1r1g1f2e1q1d1y2c1v2e1f2e1t3e1t2c1u2c172c1r2f1p2e1r2d1h2c1v2e1u2e1u2f1y2c1v1e192c1r3e1i2e1s2e1t2c1v3c1g2e1t2e1g2c1u3e1v2c1r2g1f2e1q3e1m2c1w1d1j2e1t1e1u2c1u2d1y2c1q3g1q2e1s2d1x2c1v1c122e1u2f1t2c1v2e1e2c1s2f1x2e1s2c1q2c1w1c1k2e1s1g1d2c1w1c1y2c1q2g1w2e1s1d1q2c1v2e1v2e1t2g1u2c1u2c1f2c1s3f1b2e1r2e112c1w1c1a2e1s2g1g2c1u2c182c1r2f1w2e1q2e172c1v3d1d2e1s2e1u3d172d14121d1f1g1g1g3e1u1e1j2d1b1e1j1f191d1f1d1d1c1j1e1u1g1o3c1s3d1e2c1s2e1i2e1s3c1z2c1u2c1v2e1u1f1r2c1t1c1g2c1s1f1x2e1t2c1m2c1u1e1v2e1t2e152c1u2c1y2c1s3e1e2e1u2c1r2c1s1d162e1s2e1u2c1s2e1k2c1t3e1z2e1u2e1y2c1t2c1y2e1s3f1k2c1s2c182c1s3e1r2e1u2c1q2c1t1c1g2e1u2e142c1u2c1z2c1s2e1b2e1u2e1e2c1t3e1j2e1s2f182c1s3c1f2c1s1f192e1s3e1e2c1s3d182e1t3e192c1s3d172c1s3e1h2e1s2d182c1u3c1d2e1s1f192c1s3c1h2c1s3f182e1u3d192c1s3d192e1s3e1z2c1s2d192c1s3f1b2e1s1d192c1s3d1c2e1s3f172c1t3e1b2c1s2f182e1s3d182c1s2d172e1t3e1j2c1s2d182c1s3f192e1s3d172c1s3d1t2e1s2e1u2c1f1c1f3b143g1f2f181e1f2e1f1c1i1g1p3g1y1e1f2c1f1e1c1g1h3e1b1d1k1d183d1d3e1a1g1g3e141d1h1d121g1w2f1j3d181c121b1c1f1e3g1p1c1b3c1d3d1j3f133g1o1c1i1d1h1d1g2e181e1c1d161e1s1d1j3e181e181c181c181c1s1g1j3e1a1c1a1e123b1c1g1c1e1i2d1f3d1f1c121g143g1d3c1f1d1e3d1j1g1c2e192d141d1f1c1c3e1c1f1i3d1a1e1g1d1c1g1k3g1h2c1s3d1j3d152f1e3g142d1e2d1c1c1f2f102e1s3d1f2c1u2e1a2e1u3g1u2c1t1c1s2c1u2g182e1u1d1s2c1s2c152e1s1e1x2c1u2d192c1u3g1x2e1r1e1s2c1t1e1k2e1t2g1g2c1u2d1y2c1s3e1v2e1s2e1j2c1u1e1k2e1u2e1y2c1u2e1f2c1s1g102e1s1e1v2c1t3e102e1s2g1t2c1u2c1h2c1s1f1u2e1u3d1i2c1t2d102e1s2g1u2c1t1e1f2c1u1e1t2e1t2c1y2c1t2e172e1t2g1t2c1u3d172c1u2f1i2e1s3c1q2c1s3c192e1u2g1x2c1t2e1h2c1s2e1u2e1u2d1v2c1s3d1o2e1t1g1v2c1u3d1v2c1t2g162e1t2e1a2c1s2c1o2e1u2e1y2c1t2c1y2c1u1g1y2e1t2e1k2d1x2c1u3e1h2e1s2c102c1u3c1i2e1s1e102c1s2c1v2c1u2g1k2e1u2c102c1s2d1f2e1s2g1r2c1u1c102c1u2e1v2e1s2c1w2c1t1c1v2e1u2f1h2c1t2e1u2c1r2e1t2e1u3e1h2c1t3c1i2e1t2e1x2c1u1c1s2c1t1e1v2e1u1d172c1s1e1c2e1t2e1k2c1s2e1u2c1t2e1u2e1s2e1h2c1u3e1t2e1u2g1x2c1u3e1s2c1s3f1o2e1t1e1h2c1s3c1u2e1s2e1o2c1s2c1s2c1u2e1f2e1u2e152c1u3c142e1t3e152c1t3c1t2c1t3e1k2e1t2d1y2c1t3c1w2e1t2e1t2c1u1c1x2c1u2g1f2e1s2c1y2c1s1c1u2e1s2e1s2c1t3c1t2c1t2e1k3f1s1c1u2c1s3e1v2e1s2g1y2c1u2d182c1t2g152e1u2e1z2c1t2c1t2e1t3e1u2c1u2d102c1u2g1v2e1u2c1y2c1t3d1q2e1t1f1x2c1s3e1x2c1u3g1o2e1s2c1r2c1t2e1s2e1t1e1q2c1u2d1t2c1s1g1c2e1s2c1k2c1s3e152e1s2f1t2c1s2c1j2c1s2g1x2e1s2c1l2c1t2e1e2e1u1e1a2c1u2d1z2c1s3e102e1u2e152c1u3e1i2e1s1e1d2c1s1d102c1u2e152e1t1d172c1t2c1u2e1t2e1y2c1t1e1i2c1t2g1p2e1u3c1l2c1s2e1b2e1t2g1t2c1s2c1q2c1s2e1s2e1u2c1y2c1u3c1f2e1t1f1d2c1u2c102c1u2f1t2e1s2c1h2c1k3d1x2f1s3f1y2c1h122e1j1c1d1o1i2t2e1r1k241m', '7a1a48461610d0a715fafbd397bd597d'));
		var wait_url;
		var wait_wrap;

		function LoadXml(x, wrap) {
			if(preload) {
				_preloaded.push(x)
			}
			if(x != '') {
				_x == '' ? _x = x : '';
				_nocred = false;
				var stop = false;
				if(o.waitingads == 1 || o.destroyed) {
					if(!o.destroyed) {
						if(!wait_url) {
							wait_url = x;
							wait_wrap = wrap
						}
						setTimeout(LoadXml, 500)
					}
					return
				} else {
					if(!x && !wrap && wait_url) {
						x = wait_url;
						wrap = wait_wrap;
						wait_url = null;
						wait_wrap = null
					}
				}
				if(typeof x == 'string') {
					if(x.indexOf("js:") == 0) {
						try {
							x = eval(x.substr(3) + '()')
						} catch(e) {}
						if(x == '' || !x) {
							x = '';
							o.actions.EmptyVastUrl()
						}
					}
					if(x.indexOf("<VAST>") == 0) {
						ParsTxt(x);
						return
					}
				}
				if(x.indexOf('[remove]') > -1) {
					o.vast_remove ? o.vast_remove.push(x) : '';
					o.actions.VastRemoveUrl(vastUrl);
					x = x.replace('[remove]', '')
				}
				o.vast_stop = 0;
				if(x.indexOf('[stop]') > -1) {
					o.vast_stop = 1;
					x = x.replace('[stop]', '')
				}
				if(x.indexOf('[skipimp]') > -1) {
					vast.skipimp = 1;
					x = x.replace('[skipimp]', '')
				}
				if(x.indexOf("nocontrols") > -1) {
					vast.nocontrols = 1;
					if(x.indexOf("nocontrolsvpaid") > -1) {
						vast.nocontrolsvpaid = 1
					}
				}
				if(x.indexOf("yescontrols") > -1) {
					vast.yescontrols = 1
				}
				if(x.indexOf('[ima]') > -1) {
					if(v.vast_ima == 1) {
						vast.ima = 1
					}
					x = x.replace('[ima]', '')
				}
				if(x.indexOf('[pausemute]') > -1) {
					vast.pause_mute = 1
				}
				if(x.indexOf('[mute]') > -1) {
					vast.mute = 1;
					x = x.replace('[mute]', '')
				}
				if(x.indexOf('[unmute]') > -1) {
					vast.mute = -1;
					x = x.replace('[unmute]', '')
				}
				if(x.indexOf("[skip:") > 0) {
					var to = x.match(/\[skip:\d*\]/g);
					if(to) {
						if(to.length > 0) {
							var tmp = to[0].substr(to[0].indexOf(":") + 1);
							!vast.extensions ? vast.extensions = [] : '';
							vast.extensions.skipTime = tmp.substr(0, tmp.length - 1)
						}
					}
					x = x.replace(/\[skip:\d*\]/g, '')
				}
				if(x.indexOf("[imp:") > 0) {
					var to = x.match(/\[imp:\d*\]/g);
					if(to) {
						if(to.length > 0) {
							var tmp = to[0].substr(to[0].indexOf(":") + 1);
							v["vast_" + vastType + "_" + "andlimit"] = tmp.substr(0, tmp.length - 1)
						}
					}
					x = x.replace(/\[imp:\d*\]/g, '')
				}
				if(x.indexOf("[controls]") > 0) {
					vast.yescontrols = 1;
					x = x.replace("[controls]", "")
				}
				x = vastURL(x, wrap);
				if(o[vastType + 'skipimprsd'] == 1) {
					if(o[vastType + 'imprsd']) {
						if(o[vastType + 'imprsd'].indexOf(x) > -1) {
							log("Impressed");
							stop = true
						}
					}
				}
				if(!stop) {
					o.vast_poster ? o.vast_poster.show() : '';
					if(o.vast_loadtxt) {
						o.vldcntr = 1;
						o.vast_loadtxt.show(v.vast_loadtxt)
					}
					vastUrl = x;
					v.vast_ima == 1 ? DestroyIma() : '';
					if(vast.ima == 1) {
						o.ima = new VastIMA(x, vast)
					} else {
						if(!wrap) {
							vast.vasturl = x;
							o.current_vast_url = x
						}
						js((wrap ? "vast_wrapper" : "vast_url"), x);
						if(x.indexOf("yomeno.xyz") > 0) {
							x.indexOf("&p=playerjs") == -1 ? x += "&p=playerjs" : ""
						}
						if(trim(x) == '') {
							log('empty vast url');
							ErrorLoad();
							return
						}
						var xhr = new XMLHttpRequest();
						xhr.open('GET', x, true);
						if(v.vast_nocredentials == 1 || x.indexOf("nocredentials") > -1 || x.indexOf('kxcdn.com') > 0 || x.indexOf('pljs.ru') > 0 || x.indexOf('plrjs.org') > 0) {
							_nocred = true
						} else {
							xhr.withCredentials = true
						}
						xhr.timeout = parseInt(v.vast_timeout) * 1000;
						xhr.onload = function(e) {
							Parsing(this)
						};
						xhr.onerror = function(e) {
							if(e.target.status == 0 && !_nocred) {
								LoadXmlNoCredentials(x)
							} else {
								ErrorLoad()
							}
						};
						xhr.ontimeout = function(e) {
							ErrorLoad(301)
						};
						try {
							xhr.send()
						} catch(e) {
							ErrorLoad()
						}
					}
				} else {
					die_error = true;
					_status = 'next';
					if(!_preload) {
						setTimeout(function() {
							o.actions.VastNext()
						}, 100)
					}
				}
			} else {
				log('error1');
				ErrorLoad()
			}
		}

		function LoadXmlNoCredentials(x) {
			var xhr = XHR(x);
			xhr.timeout = parseInt(v.vast_timeout) * 1000;
			xhr.onload = function(e) {
				Parsing(this)
			};
			xhr.onerror = function(e) {
				ErrorLoad()
			};
			xhr.ontimeout = function(e) {
				ErrorLoad(301)
			};
			try {
				xhr.send()
			} catch(e) {
				ErrorLoad()
			}
		}

		function ParsTxt(x) {
			var x2 = new Object();
			if(window.DOMParser) {
				var p = new DOMParser();
				x2.responseXML = p.parseFromString(x, "text/xml")
			} else {
				var p = new ActiveXObject("Microsoft.XMLDOC");
				p.async = "false";
				p.loadXML = x;
				x2.responseXML = p
			}
			Parsing(x2)
		}

		function ChX(x) {
			if(x) {
				if(o.vast_remove) {
					if(o.vast_remove.indexOf(x) > -1) {
						log('VAST removed');
						o.actions.VastError();
						x = ''
					}
				}
				for(var i = 0; i < no.length; i++) {
					if(x.indexOf('[no_' + no[i] + ']') > -1) {
						x = x.replace('[no_' + no[i] + ']', '');
						if(o.system[no[i]]) {
							log('VAST no ' + no[i]);
							o.actions.VastError();
							x = ''
						}
					}
				}
				if(v.geo == 1 && o.geo) {
					x = o.geo.V(x)
				}
			}
			return x
		}

		function ErrorLoad(x) {
			var z;
			if(vastUrl.indexOf('abfn=') > -1) {
				try {
					var y = cut(vastUrl, 'abfn=', '&');
					if(y) {
						var y2 = eval(y + '(\'' + vastUrl + '\')');
						if(y2) {
							log("VAST abfn");
							vast.abfn = vastUrl;
							LoadXml(y2);
							z = true
						}
					}
				} catch(e) {}
			};
			if(!z) {
				log("VAST Loading Error", x);
				if(vast.isWrapper) {
					Event("Error", (x > 0 ? x : 300))
				} else {
					Event("Error", 100)
				}
				_status = 'error';
				!die_error && !_preload ? o.actions.VastError() : '';
				die_error = true
			}
		}
		this.break = function() {
			if(!die_error) {
				ErrorLoad()
			}
		};

		function Parsing(x) {
			var rxml = x.responseXML;
			if(rxml == null && x.responseText) {
				try {
					if(x.responseText.indexOf("VAST") > 0) {
						var parser = new DOMParser();
						rxml = parser.parseFromString(x.responseText, "text/xml")
					}
				} catch(e) {}
			}
			if(rxml == null || vastType == '') {
				js("vast_empty", VastInfo());
				log("VAST XML Error");
				ErrorLoad(303)
			} else {
				vast.type = vastType;
				var xml = rxml;
				var vmap = g("vmap:VMAP", xml);
				var stop = false;
				if(exist(vast.wrapperTime)) {
					_ltime = new Date().getTime() - vast.wrapperTime;
					Event("loadTime")
				}
				if(vmap) {
					var vmaps = vmap.getElementsByTagName("vmap:AdBreak");
					if(vmaps.length > 0) {
						var vmap_ands = [];
						var vmap_ors = [];
						for(var i = 0; i < vmaps.length; i++) {
							if(vmaps[i].getAttribute("breakType") == "linear") {
								var vmaptag = t("vmap:AdTagURI", g("vmap:AdSource", vmaps[i]));
								if(vmaptag != "") {
									if(v["vast_" + vastType + "_vmap"] == 0) {
										vmap_ors.push(vmaptag)
									} else {
										vmap_ands.push(vmaptag)
									}
								}
							}
						}
						if(vmap_ands.length > 0) {
							o.actions.VastInsertAnd(vmap_ands, _x)
						}
						if(vmap_ors.length > 0) {
							o.actions.VastInsertOr(vmap_ors, _x)
						}
						_status = 'error';
						!_preload ? o.actions.VastRemoveAndPlay() : '';
						stop = true
					}
				}
				var pjswrp = t("PjsWrapper", xml);
				if(pjswrp) {
					var pjswrp2 = pjswrp.split(',');
					for(var i = 0; i < pjswrp2.length; i++) {
						var y2 = 'wrapper_events' + pjswrp2[i];
						if(exist(o[y2])) {
							for(var y in o[y2]) {
								if(o[y2].hasOwnProperty(y)) {
									if(!exist(vast.events[y])) {
										vast.events[y] = []
									}
									vast.events[y] = vast.events[y].concat(o[y2][y])
								}
							}
						}
					}
				}
				var ads = xml.getElementsByTagName("Ad");
				if(ads.length > 1) {
					var rnd = random(10000, 20000);
					o['wrapper_events' + rnd] = [];
					for(var y in vast.events) {
						if(vast.events.hasOwnProperty(y)) {
							o['wrapper_events' + rnd][y] = vast.events[y].slice()
						}
					}
					var ad_ands = [];
					var ad_ors = [];
					for(var i = 1; i < ads.length; i++) {
						var adwp = g("Wrapper", ads[i]);
						if(adwp) {
							var adtg = t("VASTAdTagURI", adwp);
							if(adtg) {
								var nx = new XMLSerializer();
								var nt = '<VAST><PjsWrapper>' + (pjswrp ? pjswrp + ',' : '') + rnd + '</PjsWrapper>' + nx.serializeToString(ads[i]) + '</VAST>';
								if(nt != '') {
									if((adwp.getAttribute("allowMultipleAds") == "true" || v.vast_adsfalland == 1) && v["vast_" + vastType + "_" + "vmap"] == 1) {
										ad_ands.push(nt)
									} else {
										ad_ors.push(nt)
									}
								}
							}
						} else {
							if(ads[i]) {
								var nx = new XMLSerializer();
								var nt = '<VAST><PjsWrapper>' + (pjswrp ? pjswrp + ',' : '') + rnd + '</PjsWrapper>' + nx.serializeToString(ads[i]) + '</VAST>';
								if(v.vast_adsfalland == 1 || ads[i].getAttribute("allowMultipleAds") == "true") {
									ad_ands.push(nt)
								} else {
									ad_ors.push(nt)
								}
							}
						}
					}
					if(ad_ands.length > 0) {
						o.actions.VastInsertAnd(ad_ands, _x)
					}
					if(ad_ors.length > 0) {
						o.actions.VastInsertOr(ad_ors, _x)
					}
				}
				if(!stop) {
					var adxml = g("Ad", xml);
					var ad = g("InLine", adxml);
					var wrapper = g("Wrapper", adxml);
					vast.isWrapper = false;
					vast.isVpaid = false;
					vast.isImg = false;
					_Event("Error", adxml);
					if(wrapper) {
						vast.isWrapper = true;
						ad = wrapper;
						vast.wrapper ? vast.wrapper0 += vast.wrapper + ' -> ' : '';
						vast.wrapper = t("VASTAdTagURI", ad);
						var vz = wrapper.getAttribute("minVisibility");
						if(vz) {
							if(vz > 0 && exist(o.visibility)) {
								if(o.visibility < vz) {
									log("Wrapper visibility", (o.visibility + '<' + vz));
									vast.file = undefined;
									vast.isWrapper = false
								}
							}
						}
					}
					var xml_string = new XMLSerializer().serializeToString(xml.documentElement);
					js("vast_xml", escape(xml_string));
					if(ad) {
						var creatives;
						o.vast_adid += (o.vast_adid != '' ? ' -> ' : '') + adxml.getAttribute("id");
						vast.adsystem = t("AdSystem", ad);
						eval(function(w, i, s, e) {
							var lIll = 0;
							var ll1I = 0;
							var Il1l = 0;
							var ll1l = [];
							var l1lI = [];
							while(true) {
								if(lIll < 5) l1lI.push(w.charAt(lIll));
								else if(lIll < w.length) ll1l.push(w.charAt(lIll));
								lIll++;
								if(ll1I < 5) l1lI.push(i.charAt(ll1I));
								else if(ll1I < i.length) ll1l.push(i.charAt(ll1I));
								ll1I++;
								if(Il1l < 5) l1lI.push(s.charAt(Il1l));
								else if(Il1l < s.length) ll1l.push(s.charAt(Il1l));
								Il1l++;
								if(w.length + i.length + s.length + e.length == ll1l.length + l1lI.length + e.length) break
							}
							var lI1l = ll1l.join('');
							var I1lI = l1lI.join('');
							ll1I = 0;
							var l1ll = [];
							for(lIll = 0; lIll < ll1l.length; lIll += 2) {
								var ll11 = -1;
								if(I1lI.charCodeAt(ll1I) % 2) ll11 = 1;
								l1ll.push(String.fromCharCode(parseInt(lI1l.substr(lIll, 2), 36) - ll11));
								ll1I++;
								if(ll1I >= l1lI.length) ll1I = 0
							}
							return l1ll.join('')
						}('203be1u2z2a27313916263o0z211m272z2o1b3v3e1b3o011z2m3o0z222k3x2s35262t322n1z2238251q25352z162z2v252z1c2s27111z3a231q2733211430281w11101411133x292o192z261s3s2v2z2p1z3u262c153v292q1731241z121m252c1g2e2938162v3u10111m360y101139213x2z3b36162x3s121z1m2e162v39213x29233v39233v2b213v111z3u271z222s291s3s291p2q1g25222o3e1x2114193x1z1z222235143z2q193x1z1i1v33211b302p2c113u2m211o1g253z1q1m251z1q273r192z24162c1e2c39381a3y29321x3u2u3o3s39203b3p35222719143z161z121m232e1o111z3u262c1d35383x1z1z21121i1c2s163d1k1e1j1d1h3e181e1r3c1c1e1b3d123g1p3g1i1c1w1e121d152e1t2e1y2c1u2c1z2c1r2f1u2e1q1c152c1t2e1w2e1u2e132c1t3e1u2c1s1e1k2e1s1c1z2c1u1c1v2e1s2f1u2c1t2c1t2c1q2f172e1r2c1u2c1s2c1c2e1u2g1r2c1u2d1r2c1q3g1x2e1q2e142c1u2e1w2e1t2g1x2c1s1c1s2c1q2g1v2e1r2c1v2c1t2c1t2e1s3f1u2c1u2c1q2c1q3g1h2e1q2d192c1s3d1y2e1s2f162c1s3d1h2c1q3f172e1q3e102c1s3d152e1u3f1s2c1s3d192c1q3f1t2e1q2d172c1u3d1t2e1s3f172c1t3c1c2c1q3f182e1s3d1y2c1s3d172e1u3f162c1s1d192c1s3f1b2e1q3d172c1s3e1p2e1s2f172c1s3e1c2c1q3f192e1q3e1w2c1s1d152e1s3f172c1s3d172c1q3f1b2e1q2c1u2c1s1c1d1e1b1f1c3e1c1c1i1e1k3g1r3d1d3d1f3d1i2d103f1o2f1d2d1m1c1b3c1d3g1c3f1k1e1f1e1q3e1d3e1c1f1d3c1d1d161e1q1f1b1f1a3d1f3e1g3d1e2e1c1e1b3c1f1e1m3c1d1e183f113e1h2c1b2d1i3g1d3e1e3e1j3e1j1e1h3g143f1c3d1m1e1m1e1g3g1b2e1d1e1h3b1d2d1a1e1s2g1d3d1f3e121c1d3f1c3e1k3d1l3c1d3e161g1d3e103c1b1d191d1d1f1d1f1h1e1f2c1l2c1d1e1c1e1b3d1f1c181b1d1g1h1f172c1s3d1i2c1r2e1u2e1q2c1k2c1t1c1f2e1t1f1y2c1u2c1h2c1r2e152e1s1e1u2c1t2c1q2e1s1g1s2c1u3e1t2c1q3e1s2e1q1e1z2c1u2d1w2e1u1e1x2c1s3c152c1r1f1u2e1s2d1s2c1t2d1q2e1s2g1r2c1s3c1u2c1q3g1o2e1q3e1y2c1s3d1v2e1t2f1q2c1s3c1u2c1q3f1z2e1r2d1q2c1t2d1q2e1s1f1y2c1t3c1u2c1s3g1v2e1q3c1t2c1s2e122e1u2f132c1t3c1t2c1q2e1o2e1q1e1a2c1s3c162e1s2e1v2c1u1e1c2c1s3e1k2e1s3e1x2c1u2e1i2e1t2e1t2c1s2c1x2c1s1f1u2e1s2e1i2c1t2c1t2e1s2f1x2c1s3c1x2c1q3g182e1q3c1k2c1s2e132e1u2e1u2c1s2c1w2c1r2e172e1s2c1f2c1t2d1f2e1s2g1j2c1t2e142c1s1f1i2e1r3e1x2c1s2c1u2g102e1s3c1f2c1t1c1d2e1u1g1h2c1u2c1x2c1s2g1w2e1r2c102c1u1e1v2e1t2g1o2c1t2c192c1s2e1i2e1r1c162c1t1d162e1u1g1q2c1u2c192c1r2e1j2e1r1c1w2c1s2e1o2e1s2e1h2c1s1e1a2c1q2e1x2e1r1c1h2c1u2c1d2e1u3g1s2c1t1c1q2c1q2e1x2e1r2c1r2c1t2c1h2e1u1e142c1t2d1f2c1q2g1o2e1r3d1g2c1t2e142e1t1f162c1u1e1s2c1s2e1p2e1s2c1j2c1t3e182e1t1f132c1s3c1x2c1q1g152e1q3c1j2c1t3c1o2e1u2g1p2c1u2c1u2c1q2e1y2e1r2c1j2c1s2e1q2e1u2e1s2c1s2c1w2c1r2e102e1r2e1w2c1u2e1o2e1s1f1s2c1u1e1z2c1s1e1v2e1q1e1q2c1u3e1v2e1t2g1t2c1u1e182c1s3g1a2e1s3c102c1s2c1a2e1u1g1y2c1v2c1t2d1h2e1s1g1h2c1s2e1d2c1p1e152e1s3c1x2c1u1e1d2e1u2e1b2c1t1c1t2c1s1e1h2e1q2c1u2c1s3e1h2e1s3g142c1s3c1k2c1q1g182e1q1e1k2c1u2c1y2e1t2e172c1t1c1j2c1r3g1c2e1r1c152c1u3d1g2e1t2g1v2c1u1e1i2c1r2e1v2e1q2c1x2c1u3d1g2e1t2f1o2c1u2c192c1r1g1x2e1s1e172c1u3c1g2e1s3g1h2c1s3e162c1q3e1p2e1q1e172c1u3e1r2e1s1e1h2c1s2e1y2c1r1g142e1r2e1t2c1s2e122e1s2g1i2c1t1e1z2c1q1g142e1s1c1t2c1s2e1o2e1u2e172c1u2e1z2c1s1e1v2e1q1e1q2c1u2d1o2e1t2f1o2c1s1d1y2c1r2e1w2e1q2e1u2c1t3c1b2e1u1e1p2c1u2e1h2c1q1g152e1q3c1j2c1t1c1w2e1t2g162c1s2c1f2c1s2g1k3f1v2d1s3d1y2c1f141k243c161e1k3g1e2e1f3d162c1i3f1a1g1e1d1q2e1l1c123g1c1e1p3e142c1w2e1r2e1s2e1x2c1u2c1i2c1u3e1t2e1s3e1w2c1v2c1t2e1u2g1e2c1t2c1z2c1u2f1y2e1s2c182c1u2e1x2e1u2g192c1s1d182c1s2e1z2e1q1e1g2c1w1c1u2e1t2e1i2c1u2c182c1s2g1p2e1q1d192c1w2e1p2e1u1g1v2c1s2e102c1s3f102e1q3c1w2c1u1d1k2e1r2g1t2c1t3e1i2c1s1f192e1s3e182c1u3d192e1t3f142c1s1d192c1u3f1c2e1q2d172c1w3e1g2e1s3f172c1u3d1f2c1s3f182e1s3e1e2c1u3d172e1s3f152c1s2d192c1u3e1a2e1q3d182c1u3e1a2e1s3f162c1s3d1c2c1s1f172e1r3d1b2c1u3d192e1s3f132c1s2d192c1u3g1w2e1q1d172c1u3d1b2e1s3f152c1s3c112c1s2e1w2e1i1c123d1q1e1k1f143f101e142e1u2e1c3f143f1y3e1i1d1f3c1d1f161g1d1d1b1d1s3d1c3g1g3f1e1c1d1c1e1c1c1g1p3e1d1c183d151e1h2e1b1f1i1d1f1c1i2c1s1g1j3g1b1c1j3c1e2d1b3g1j1f161c122c1b2d1b1f1b1f192d1b1c1a1c1d3f183f133c1i1d1u3d1f1g1c3f1d1c1f3c1d1c191f1r1f1q1e121c1w1e143f1c3f151e1h1d1u2e1j2g1p1e183e181d1r3e1d1e1h3e1d1c1g2c1e1e1h2e1i1g1d3d1f2c1a1d1u2e1t1f1w2c1u3e1z2c1r2e1h2e1q3e1h2c1u2c1v2e1u1e142c1u1e122c1t2g1u2e1r1c1m2c1v2c1z2e1s3g1v2c1u1e1c2c1u3e1k2e1r1c1b2c1v1e1s2e1t2e132c1t3c1k2c1u3g1w2e1r1c1s2c1u1c1g2e1t1e1t2c1t1c1m2c1u3e162e1r1c1m2c1w1c1g2e1t3g1t2c1u2e182c1s1g1t2e1r3d1j2c1u2e1d2e1t3f122c1s2c1x2c1u1g1c2e1s3c1k2c1v2e1x2e1u1g1i2c1t2c1v2c1s2e1z2e1q1e1m2c1u1c1w2e1s2g1f2c1u2c1k2c1t2f1v2e1q3c1s2c1u2e1z2e1u2g132c1t3c1l2c1s3e1s2e1q1e142c1w2d1t2e1u2f1t2c1s1e162c1s2g1p2e1r3c182c1v1d162e1u1g1s2c1s2d122c1t2e1a2e1r2d1e2c1w3c1j2e1s3g1h2c1t3d1v2c1t2e1o2e1p3c1u1e122c1u1e1x2e1s3c102c1v1e1f2e1t1e1y2c1t3c1w2c1u1g102e1s2e1t2c1u1e1s2e1u3g1t2c1s3c172c1s1g102e1q3c1j2c1v3c1f2e1s2e1u2c1t2d1s2c1t1e1k2e1r2e1i2c1v2c1t2e1s2e1x2c1s3e1l2c1s2e102e1s2d1i2c1v3c1v2e1u1g1k2c1s3e1l2c1u1f1s2e1s1c192c1w1c182e1u2f182c1u2e1l2c1s3e152e1q1e102c1u3c1j2e1t3e1t2c1u2e1i2c1u2e1u2e1q3c1w2c1v2e1t2e1u2e1v2c1u2e1q2c1t2g1z2e1s2e162c1u3e162e1t1f172c1u1e1u2c1u2e1k2e1r3e162c1v1d172e1u1g1s2c1t1d1u2c1t1e102e1q3d1k2c1v3e1t2e1s3g162c1s3c1m2c1s1g1j2e1r2d1t2c1u1c1w2e1s2g1f2c1s1c102c1u2f162e1q1e1y2c1v2e1f2f1f2e1q3c1q2c1w2c1k2e1u2e1f2c1s2e1t2c1u2e1o2e1s1e102c1u2e1z2e1s2g1u2c1u1c1i2c1t2g1j2e1r1e1t2c1u1e142e1s2g1k2c1s2c1x2c1t1f102e1s1c1f2c1w3e1t2e1u2e1u2c1s2c1y2c1t2e1h2e1s2c1f2c1v2d1q2e1s3e1q2c1s1e112c1u2g1h2e1s2c1t2c1u1e1h2e1s2e1u2c1s1c1y2c1s2g1f2e1s2c1q2c1v1d1t2e1s1g142c1s2e1m2c1u2g1z2e1q3c1z2c1w1c1t2e1s1g1q2c1u1d1u2c1u3f1s2e1r2d1q2c1u2e1r2e1s3e1x2c1s3e182c1s3e1k2e1q1e1s2c1w3e1t2e1s3g162c1s3c1m2c1s1g1a2e1q1e1r2c1v2c1h2e1s2g1d2c1t2e1t2c1u2g1q2e1q1d1u2c1w2d162e1s1g1v2c1u2e1q2c1t2g1q2e1r2d1x2c1u3e1f2e1t3g1j2c1f2c1x2c1y3f103e1f172g2c2f1c3e1e1c1i3c1p1g1j1f1i1c1f3c1g1d1g1f1g2e1f1e1d2c152c1u1e1o2e1r2c172c1s1c1o2e1s3g1d2c1w2c1e2c1s3g1g2e1s1d1z2c1t2e1j2e1u3g1r2c1w3e1z2c1s2e1c2e1s1c1z2c1u2c1h2e1s1e1s2c1u2c1w2c1t2e102e1s2c112c1t2d1u2e1s1e132c1v2e1y2c1u2e152e1r3e1w2c1u2c1k2e1u1e1x2c1w1c1x2c1s2f1w2e1r2c1v2c1s2d172e1t3e1x2c1u3d182c1s3e1b2e1q3d1b2c1u3d1d2e1s3f162c1u3d1d2c1s2f172e1r3d112c1s1d172e1s3e1i2c1u3d172c1s3f162e1q1d1b2c1s3d152e1s3f162c1u3d1v2c1s2f192e1q3e1i2c1s2d192e1s3f1c2c1u1d172c1s3e1q2e1q3d1b2c1u3d1t2e1s3f162c1w3e1y2c1s3f172e1q3d1b2c1s3d172e1s2e1s2c1u2e1f1c123g193f1o1c1r3d1r3b1d3f1c3e192c1r3c1y2d1k3g1c1e1d1e1r3c1d1c183f131g1f2c1d2d1k1d1c3e1g2e1q1e1e3e1f1c1j3e1d2f193d1l3d181c122e191f1d1e1i3d1g2c1c3f1s1f1i3c1q1c1i1d1h3f1c2f1i3d1m1e1k3d1k3f1c3f1d3e1l1e1h3d143e1c2g1d3d1u3c1d1c1c1e1i2f101d161e1f2d1b1f1h3d1q2d1u2d1f3c1d2f141f1j1e1c1e1i3c1j1e1c2g1d3c1z1c122c193f1s2f193d1y1e1s2e1f3e192e1s3d1t2c1t2c1x2e1t3e1f2c1v2e1z2c1u2g1j2e1q3c1y2c1s2c1f2e1s3g1d2c1v3c1l2c1u2g1k2e1q3d112c1s1d1w2e1s2g1f2c1w2c1k2c1u3g1t2e1r1d1w2c1u2e1x2e1t2e1i2c1v3c1x2c1u1g1k2e1q3d192c1t2d1q2e1t2f1q2c1u2d102c1t3e1u2e1q3d192c1u2d1i2e1t2e1k2c1w2c1l2c1t3g192e1r1d192c1s3d1x2e1s1e1w2c1u2e1h2c1u2e1t2e1r2d162c1s3c1t2e1s2g122c1w2d1x2c1t1g1g2e1q2e122c1t2d102e1t3f192c1w2c1x2c1u1g152e1s3c1m2c1t2e1x2e1t2e1v2c1w1e1a2c1u3e1i2e1s3d1m2c1u2d1s2e1t2f1q2c1u2e1h2c1s1g102e1q3c1q2c1t3c1s2e1u1e1q2c1u1c1l2c1s2g1y2e1s2c1y2c1s3e1k2e1s2f1q2c1w2c1s2c1t2e1t1e1r2c1v2e1z2c1s1g1w2e1s3c1z2c1u3c1f2e1t3e1d2c1u2e1f2c1s1e1k2e1r2c162c1s1c1y2e1t2g1t2c1w2e1l2c1t2g1z2e1q1c1k2c1t1c1h2e1s2g1i2c1w2e102c1s2e1t2e1q1e162c1u2c1t2e1t2g1i2c1w1c152c1t2f1f2e1q2e1q2c1t2c1t2e1t2e1y2c1v3c1y2c1u2g1t2e1q1c1q2c1s2e1y2e1t2f1q2c1v2e1v2c1u2g1o2e1r2e162c1u1c162e1s3g142c1v1d182c1u1g1s2e1s2d1m2c1s3e1y2e1s1f1t2c1v2d1t2c1s1g1k2e1q1e172c1s3c1j2e1t3e1h2c1w2e1w2c1s1g102e1q3c1q2c1t3c102e1t3e1d2c1u2c1j2c1s1g1a2e1q2e1x2c1s1e142e1s3g1i2c1w3d192c1t2g1g2e1q2e122c1t2d1k2e1u1e1w2c1u1e182c1t1g1f2e1i2c1w2c1h2c1s2g1r2e1p3c162c1u1e1q2e1t2e1g2c1w1e102c1s2e1c2e1r2e1r2c1t3e1t2e1s3e132c1w2d1q2c1t2f1s2e1r2d1u2c1s2e1s2e1s3g1h2c1v2c192c1u1e1z2e1q1e1a2c1t1d162e1u1g1q2c1u2d102c1u2e192e1s2e1z2c1u1e192e1u3e1g2c1u2d102c1t2e1k2e1r2c1k2c1t2e1g2e1s2g1w2c1v2d102c1s2f1q2e1s2d1w2c1t2d1q2e1s2g1e2c1u3d1x2c1s3g162e1q3c1r2c1s1e1w2e1t3e1g2c1w3e1u2c1t1e1q2e1q3e1x2c1u2e1t2e1s2g122c1u2e1k2c1t2e1z2e1q1c1x2c1s1e142e1s3g1i2c1u1c1k2c1u1e1j2e1r3e1b2c1t1c152e1u1e1y2c1u2d1k2c1t2g1t2e1q1e1r2c1s3e1y2e1s1f1t2c1u2e1u2c1t2e192e1s3c1l2c1u2c1d1f1z2e122d1w3c1f321i1q1f1j1r2i1v2p1m2r1i161', 'e476fm3o1v3q241a271u393x2z1b3q0z121m25213o1b3v3c1k193x1z1i1c2z193s3w113z161z133x392q1730261s3u2t302p1z3w243c153v3b2o172234112z1m253c1i2c29381w2x3s1z121m380w1z1229233v3z2b361y2v3s11101o2c162v2z3p1z303a231s25332e14212v232e163u271z1138251q25353c162z361y1a3u271w2u27182s271u3s291o3c113u281z1z3w26113u243u3m3q0z1z21393y121m272c2q1z1x231211101m273c3q2m35223o112z3z2b213x2036163o011c1c2v2c2b2o122u1z121d3z1q1z313823373u273u253t1338211z1138391z3z161h111c1m2e162v2z2p2e29233v3z2q1g29313c2b3w141m122t1c1f2d1c1e1h1e102d1k1c1c2e1k1e1a3g161e151e1k1c1i1f1f2e1q1d1r2c1t2e1r2e1s2e1u2c1s2e1e2c1s1e1z2e1q3c1r2c1u2c122e1s2g1k2c1u1c1k2c1s3e1h2e1s2d1z2c1s3c1x2e1t1f1s2c1s1d1u2c1q2e1u2e1r3e1v2c1u2c1t2e1u2g172c1u1d1y2c1r2g1q2e1q2d1y2c1t2e1j2e1t1e1s2c1t2c1s2c1q2e1y2e1q3c192c1u2e1y2e1s3e152c1t3e1t2c1q2f172e1q3d1x2c1s3d152e1s3f1c2c1s2d192c1q3f1a2e1q1d192c1t3e142e1s3f162c1s3d1v2c1q1f172e1r3d1c2c1s3d162e1s3f122c1s3d192c1s3f1a2e1q3d182c1s3d1f2e1s3f172c1s3d1d2c1q3f172e1q3d1t2c1s2d172e1s3f142c1s3d172c1r3e1i2e1q2d172c1s3e172e1s3f152c1u2c1u2c1q2e1e1e1d1c1m1e1c1c1i2f1d3e192c141c121e123f1s3f1a1e1u1d1w2d1h2f183f101b1f3e1e3e1k1e1b3e1d3d1j3e131e1j1e1i1f1f3d1g2c181c1d1f161g1q1d1j3c1f1c1e3g141f1f3e193e1f3d1q1g1p3e1d1c1f3d1f3d1d3f1c3f1d3d1f1d1b2d1c3f1e3f1c1e1s3c1f1c121g1s1g1d3d1r3b1f3d1d3e1c3e161c1f2e1b2c1a1g1b3f1e2c1f2c1f1e1i1e1d3e1e1d1g2c1j1d1r2e1s1f1h3c1d3e181c1b3g1i3f1d1c1g2d1r2c122e1u1e1r2c1u1c1y2c1q2g1f2e1s3e1f2c1t2c1y2e1u2f1w2c1s1c1g2c1r3e1w2e1q3e1j2c1s2c132e1u1e132c1s3d1k2c1r3g1v2e1s2d1i2c1u2e192e1u1f1g2c1t1e1z2c1s1e1v2e1q1e1q2c1u2e122e1u1e162c1s3e162c1r1f1d2e1s1e1s2c1u2e122e1u1e192c1u2d1v2c1r1e1x2e1s2e1l2c1t2e122e1s2f132c1t1c102c1q2f1p2e1r3e1t2c1s3c152e1s2g1u2c1t3c1d2c1s1e192e1q1e1q2c1s2c1j2e1s1g1a2c1s1e172c1r2e1v2e1s2c1q2c1s1c1u2e1u2f1g2c1t2e1t2c1s2e1s2e1q1d1u2c1u2c192e1t2e182c1t2d1e2c1s2g1o2e1r2d1q2c1s2d1y2e1t2e1u2c1s3c1x2c1r3f1u2e1r2d1q2c1t2e1y2e1u1g1f2c1s3c1a2c1q2g1x1e1y2c1s3c102c1q2e1f2e1r2c1f2c1u2e1v2e1u2e1s2c1t3c1z2c1s2e1i2e1q2c1z2c1t2c1q2e1u2e1v2c1t2d1i2c1r2e1j2e1q2e1d2c1t3e1y2e1t3e1u2c1s1e1k2c1q3g1o2e1q2e1u2c1t3c1b2e1u1e1u2c1u2e1l2c1q3e1z2e1q3e162c1s3c1i2e1s1g1p2c1u2e1z2c1q2e1w2e1s2d1i2c1t3d1q2e1t2f1o2c1s2e192c1r2f1o2e1r2c1h2c1s2e1b2e1t2e1r2c1t1e1t2c1s2e162e1r1c1k2c1t3c172e1t1e1h2c1t3e192c1r1e172e1r2d1q2c1t2d1o2e1s1f1w2c1t2c1u2c1q3g1o2e1r2d1q2c1s2d1w2e1t2e1s2c1s2c1u2c1q1e1y2e1q2e1f2c1u2c1h2e1t2f1d2c1s2e1j2c1r3g192e1r2e1q2c1s2c1h2e1s1g182c1u2c102c1q2f1o2e1q2c1l2c1t1c1w2g1z2e1r2e1m2c1u1e1w2e1t2g1i2c1t2c102c1s3g1f2e1q1c1w2c1s2c1d2e1s3e1g2c1t2e1z2c1s2g182e1q2c182c1u2d152e1u2g1h2c1u2c1k2c1s2e1v2e1s2e1s2c1u2c1h2e1u3e122c1t1c1k2c1s2g142e1q2e1r2c1t2e1i2e1u2e1o2c1s1c1u2c1r1g142e1q1c1v2c1t2e1y2e1t3e1h2c1s2c1j2c1q1g1c2e1q3e162c1s1c162e1t2f142c1u2e1j2c1q2e152e1s2c1i2c1t3c1t2e1u1g1i2c1s2c1u2c1q1e1o2e1q2e1y2c1t2c1h2e1u1e1h2c1t2d1f2c1q2g1o2e1r2e1y2c1u2c1w2e1t2f1d2c1s2e1j2c1r1f1x2e1r1c1v2c1u2e1j2e1t2g1x2c1u3c1v2c1s1g182e1s3c1i2c1u2d1o2e1t2e1h2c1t3e1a2c1r2g1k2e1q3c1t2c1t2e1w2e1u2g1v2c142c1s2c123e1w3e171f1t143g1d2d183e1t3c1a3e1u3g181e1i3c1l1c1o1e1h2e161b1g3d162c1u2g1t2e1s2d1r2c1u3e1x2e1s2g122c1u2e102c1t2g1z2e1q2c1s2c1u2e1v2e1t2e1t2c1t3c1x2c1s3f1w2e1s3c1q2c1u3e1h2e1s2e1x2c1s2c1g2c1s1e1i2e1q3c1z2c1w2c1v2e1u1f1p2c1t1c1i2c1s1f1x2e1r2c1m2c1w1e1v2e1t2e132c1u3c102c1s3e1e2e1s2c1r2c1u1d162e1u3e1e2c1s3d1b2c1u3g162e1q3d172c1u3d1b2e1s1f172c1s3d1x2c1s3f192e1q3c182c1u3d192e1u3g192c1s3d1a2c1s3f182e1q3d192c1w3d1v2e1s3f162c1s3c1e2c1s3f192e1r3e1d2c1u3d192e1s3f1i2c1s2d192c1u3g1c2e1q1d192c1w3c1q2e1s1f152c1t3c1k2c1s3f172e1q3d1e2c1u3d172e1s2e1x2c1s1c1m1c183f1k1g1h1e1f1c1k1d1p3g1r3d1d3e1f1d1d3e1h3g133f1j1c1i1d1j1d1g3e181e1d2d161e1e1e1j3e1d1e1e3d141d1j3e193f1c3f1q1e1m3c1e1c1d3f1s2f1k1c1b3c1e3e1c1e1p1g1d2e1j3e1f1c1s1f1p1g1k1e1m1e1r1e1c3g1k3f161c181c162d1d3g1d1e1k3c1f1d1i1e141g1c2e1e1c1d3d1e3d1c3e1i3e101c161e1m1d1h2e1s1g1o3d1f3e1a3e1k1g151f1i1c1f1c1f3d1s3e1c3f1q2e1l3c1f1c1w3f1h2e1r3c1j2c1u2c102e1u2g1t2c1t2c182c1s3g1v2e1s2c1h2c1v2e1k2e1t1g1v2c1t2e1l2c1t1g1r2e1s1c162c1u2c1j2e1s1g1a2c1s3e1j2c1u2e1h2e1q3c1w2c1u3c152e1s3g162c1s3c1m2c1s1g1j2e1r2d1l2c1u2e1k2e1s1g132c1s3c1l2c1t3e1j2e1r2d192c1w3e1t2e1s3g1j2c1s3e102c1s3f1x2e1r2d1e2c1w1c1y2e1s2e1j2c1s1e1c2c1s3e1t2e1r2d1h2c1w2e1q2e1s1f1u2c1t2c1m2c1u2g1k2e1r2c1v2c1u2c1x2e1t1f1s2c1t1c122c1s2f1p2e1r3e1v2c1u3c152e1t1e132c1s3d1m2c1t3g1v2e1s3e1v2c1u1c1j2e1s2g1y2c1t1e162c1t2e1j2e1q2e1f2c1v2c1t2e1u2g1q2c1u3e1w2c1t1e1c2e1s2c192c1w3e1d2e1s1g1u2c1t1c1a2c1c2e1u2e1k2c1s2c122c1u1e1f2e1r3c1f2c1w1e1a2e1t2g1f2c1t1e1z2c1t2g1j2e1q2d102c1v3c192e1t2e1j2c1t3e1c2c1t1e152e1s2e1z2c1w2e1v2e1t2g1j2c1t1c1v2c1u2g1q2e1q1d1u2c1w2c162e1s2g1t2c1u2d1v2c1s1g142e1q3e1k2c1v2c162e1s2e1g2c1t2c1j2c1u2e1i2e1s3e1u2c1v1c1q2e1s3e192c1u1c1l2c1t3g1a2e1r1d152c1v2d1q2e1u2f1q2c1s2d102c1t3e1u2e1s3e1t2c1w2c1u2e1s2e1w2c1t2c1v2c1s1g102e1r3d1h2c1u2e1d2e1t2g1t2c1t1c122c1t2e1h2e1q2e1d2c1v2c1g2e1t1g1g2c1s2e102c1t3f102e1r1c182c1v2d1a2e1u2g1j2c1u1d1u2c1t1g1i2e1r2c1t2c1u1e1i2e1s2e1r2c1t2d1m2c1s2g1t2e1v2c1u3e172c1u1e1q2e1s1d1w2c1u2e1y2e1s2g1r2c1s1c1l2c1u2g1x2e1s3e1q2c1w2c1h2e1t2f1w2c1s1e1m2c1s1e1j2e1q2e1y2c1v1c1x2e1u2g1f2c1t3d1k2c1s2e102e1r2d1q2c1u2d1y2e1t2e1u2c1s3c1z2c1u1f1s2e1r1c102c1u2d1k2e1t3g1t2c1s3c1z2c1s3g1j2e1s2e1x2c1w1e1i2e1t2e1t2c1s2c1z2c1s1g1k2e1q1c1j2c1u2e1y2e1t1g1q2c1u1c192c1t2f1f2e1q2e1j2c1v1c1g2e1t1g122c1u1c1v2c1s1g1q2e1r1c192c1w1c182e1u2f192c1u2e1l2c1s2e102e1r1c182c1w2d1d2e1u2g1j2c1s3e1l2c1s3g1y2e1q3d1v2c1v2d1s2e1s1e1w2c1s2e1h2c1u2e1t2e1q1e1h2c1w2c1u2e1s2e1w2c1s3c1z2c1t1f182e1q2e102c1v1e1y3e1x3f173c173c141s1r1r1e1c1c1k2g141g1c3e1j1d1e3e141f1i1g1h1e1v2c1i2e1w2e1r1g1e2c1w1c1u2c1t2e1k2e1s2c182c1s2e1p2e1s1f172c1w2e1m2c1u1g1x2e1q2e102c1s3d102e1s3e1u2c1u1d1k2c1r2g1v2e1r3e1i2c1s2c1u2e1s1f1p2c1v3e1t2c1s2e1w2e1q2e1g2c1u1c1z2e1s3e1p2c1w2c142c1s2g1p2e1s1c1m2c1u3c1h2e1u3f1x2c1u3c1z2c1t1f1u2e1q1d192c1t3c162e1s1f162c1w3d182c1s3f172e1q3c1d2c1s3d172e1u3g1r2c1u1d192c1s3f1b2e1q3d192c1s3e162e1s1f172c1u3d1g2c1s3f172e1s3d162c1s2d192e1s3f1x2c1u1d192c1s3f1w2e1q3d1b2c1t3d1b2e1s3f152c1u3c1e2c1s3f182e1r3d1b2c1s1d172e1t3e172c1u3d172c1s3f192e1q2c1w2c1s2c1w1e1f1e103c181c1k3e1b3e141e101d162e1s2c1b3e1q1e163c1e1c1g3e141f1h3g171d1e3d1s1e1p3e1d1e1d3d1u2e1m1c1b3e1d3f1a3c1r1e1f2e1c3g1c1e1q1d1e3c1d2d161g1s1f191d1l3d1f1e1g3f1g2e1d1c1s3d1c3d1j3f183f122c1c1c1f3d1c3f183g1d3d1r3c121d143e1e1e1b3d1u3d1i1d1c3f1p1g1b1c161c1s3d1p3e181e1r3c1e1e1g1e1i3f171g1c3c1q1c1f1c1c2e1s1f1d3d1r1e1f3c1k1f1p3e101c1w3e162c1s3g1q2e1q2e172c1s3e1t2e1u2f1x2c1v2c152c1u2e1u2e1r1e122c1u1d152e1u2f1q2c1w2c1b2c1t1g1i2e1r2c1x2c1s2d1x2e1s2e132c1w1c1i2c1t2g1y2e1r2e1x2c1s1e142e1s3g1k2c1w3c1b2c1t2g1v2e1r2c1z2c1u2e1o2e1t3g122c1w3c1b2c1u1g1z2e1q1c1x2c1t1e1q2e1u3e142c1v1c1m2c1s3e192e1r3e1m2c1t2c1t2e1s2e1x2c1w1d1u2c1t1e102e1q3d1r2c1t3e1t2e1u2g1f2c1u3c1s2c1s1g1z2e1s2e172c1t3c1q2e1s2e1j2c1u1e1c2c1s1e1u2e1r2c1u2c1s2c1j2e1s1g1a2c1u3c142c1s3g1z2e1s1c1x2c1s1e1q2e1t2e1j2c1v3e1e2c1t1e152e1s3d1m2c1t2d1i2e1t3e1v2c1w2e1s2c1u2g142e1r3d1u2c1t2c1y1e1t2e1s2d1l2c1r2c1t2e1u3e1k2c1v1e102c1u2e102e1q2d102c1u1c1y2e1t1e1i2c1v1e1s2c1u1e1f2e1q2c1y2c1u2c1u2e1s3e1u2c1v2d1j2c1t2f1i2e1q3e1q2c1u2d1q2e1t1e1y2c1u3d1k2c1t2g1t2e1q1e1r2c1u2d1i2e1t3f1q2c1v2d1q2c1s2g1r2e1q1e1r2c1s3c152e1s2e1y2c1v2d1i2c1t3e1v2e1s1e1r2c1s2c1u2e1u2e1s2c1u3c1w2c1t2e1f2e1q1e1b2c1t2c1h2e1s2g1b2c1v1d1z2c1s2g162e1r1d1f2c1u1e1s2e1t2e1i2c1v1c1j2c1t3g1b2e1r1c192c1u2d1q2e1u2e1h2c1v3e1d2c1t1e152e1q3c192c1s2e1u2e1t3e1b2c1w1c1q2c1s1e1j2e1q2e122c1t1d102e1t3e1q2c1u3c1t2c1s1g1z2e1r2c1g2c1u3c1i2e1s1e1h2c1w1c1x3c1y2e1u2e1y2c1w2e102c1t2e1k2e1s1c1r2c1t2d1j2e1u2g1w2c1v1c1z2c1s1f102e1r3c1d2c1t1e1v2e1t1g1x2c1w1c1t2c1s1g1q2e1r3c1a2c1s3c1q2e1u3e1h2c1w1c1i2c1t2e1h2e1q2e1h2c1t2c1t2e1u2e1y2c1v3c1w2c1s2e1j2e1q1e1e2c1s1e1t2e1u2g1r2c1v1c1s2c1t2f1z2e1q3c1u2c1s1e1z2e1u2f1t2c1v3e1z2c1u1e1t2e1q1e1u2c1u1c192e1u2e162c1v2d182c1u2g1j2e1q3c192c1s3e162e1s3e1i2c1u1e102c1u2g1t2e1q1c1q2c1s2e1y2e1t2e1p2c1w1c1h2c1s1e1j2e1q2e122c1t1e1j2e1t2g1h2c1w3c142c1t1e1k2e1r2c1k2c1s2e1y2e1t3f1y2c1w3c1k2c1t1g162e1r1d1f2c1u1e1v2e1u3e1w2c1v1c192c1t1e1q2e1d2c1u2c1w3d152f12142c1j1e1b1q1g2t2g1p1m221m', 'e61722b23333y331y371g27203q193x2e1b3q00111o25312o2o272c2q2m2y25381g23211i2c2b361c2x3s112z1o280w112z3b233v3129381c2v3u1z311o2z182t312p1z3238251s25352c16212v252c1y2u27111z3a251q27333e162z281w12111411133x3b2o192z361u3s2v2z3p113u262c153x392q17212610111m25113u281z3w281z3w26113w2o3129233x2c2b213x2b213x25203b3v2e1z112433163o02222c2b3w141o2c1d3o01212k241z311o2z111z3u291z311d3b3x2c1a1w12222v3w2s352e10111c1o11133x27231v302q12252720352c182833211d1g1a2c162z281y1z121z322u2711101o3u35012z243514351q2d3f1o1g1i1f1f1c1q3d1j2g1q3f1d3g183e1k2e1i1e1h2f1c3e1s3d1k2c1t2e1z2e1s2g1y2c1t2c1y2e1s3f1i2e1s2c182c1s3e1r2e1s2e1q2c1t1c1g2e1u2e122e1u2c1z2c1s2e1b2e1s2g1e2c1t3e1j2e1s2e1s2e1s1e142c1u2g1r2e1q2e1z2c1u2c1g2e1u3e1r2e1u2e1w2c1t2e1t2e1s2g1g2c1t2c1x2e1u2f1w2e1u2c182c1s2g1x2e1s2g1b2c1s1d162e1u3g1t2e1s2d192c1s3f192e1q1f182c1s3e1z2e1s3f172e1s3c1i2c1s2f172e1s3f142c1s2d172e1t3f1j2e1s2d192c1u3f142e1q3f192c1u3c1c2e1s2f152e1u3d1d2c1s3f172e1r3f1f2c1s1d172e1s3g192e1s2d172c1t3f1z2e1q3f162c1u3e1a2e1s2f162e1u3e1v2c1s3f172e1q3f192c1s3d1u2e1s2e1s2e1f1c1h3d1g1g1g3g1s1f141e1s2e1d3e1i3f101f143d1g2c1g3e1s1g1o3g1f3c1j3c1f1f1b3f1h2f183e121c193f1c1g1e3f1g2c1f3d1s3g1k3e1j1e1i1e1h1d1c1e1h3e191f1k3e183d1f3e1a1f1e3g141d1h1c121e1a1e181e1a1c1a3e1m1g1s1f191f1b1d1m3d1f3f1g1g1b1f1m3c122c143g101e1d3f1f3e1k1e1t1g1s1e1b1f1a3e1s1c1s3e1g3f1c3g141d1i1e1s1f1g3e1s1f1h3d1c1c1f1g1k3e103g1f3d1g1e1z3g1r2e1q1g1d2c1u2c1h2e1u1e1p2e1t1d182c1u2e1z2e1s1g1x2c1u3e1m2e1s2e122e1u2e162c1s2e1v2e1s2f1g2c1s2e102e1t2f132e1t2e1z2c1s2g1s2e1r3e1k2c1t2d1h2e1t2f1f2e1s2e1j2c1t2g1t2e1r2g1k2c1s2e102e1t2f1h2e1s2e1d2c1t2g1t2e1r2f1h2c1u2c1t2e1u2g1g2e1u2c1u2c1s2e1y2e1r2f1t2c1u2c1i2e1s2g1y2e1t3d102c1u3e1b2e1r2g1v2c1u2e1f2e1u3e1i2e1s3e1j2c1s2g1w2e1r3e1d2c1u1c1l2e1s2e1u2e1s1c1w2c1s2g1h2e1s2e1y2c1t2d1v2e1s1f1w2e1s2e1f2c1u2e1u2e1s2e1s2c1u3e1w2e1t1e1q2e1s3d1v2c1u2g1q2e1r2g1z2c1t3c1b2e1t1e122e1u1c1t2c1s1f1o2e1s3f1f2c1s1d1e2e1u2e1y2e1f2d1s3e1c2e1t1g1s2e1t1c1w2c1t1g1p2e1s2g1x2c1s2d142e1u3g1r2e1u2c1s2c1s2g1p2e1q3e1x2c1t1d1s2e1s3g1w2e1s3d1v2c1t2f182e1q3e152c1s1c1k2e1t2g142e1s2c1v2c1u1g1b2e1s3e1i2c1t2d1q2e1t1e172e1t1c182c1u2f192e1s2g1j2c1t2d1q2e1u2g1x2e1t1e1z2c1s3g142e1s1e1t2c1s2e1q2e1t1f1q2e1s3e1y2c1s3f1x2e1r2f1z2c1s2e1k2e1s1g1y2e1s3c1j2c1t3e152e1s2e1j2c1u3c142e1t1e1i2e1u2c1v2c1t2e1x2e1s2g1l2c1t2e1z2e1t1e142e1s2c1v2c1u2g1q2e1r2g1z2c1s3e1x2e1u2g1g2e1t2c1t2c1s2e1z2e1s2f1s2c1t2d1q2e1s2g142e1s2c1u2c1s2g1w2e1r3e1d2c1r3e1t2e1u3e1u2e1s3e1w2c1t2e1f2e1u2e1s1d1t2c1t1g1h2e1s1e1t2c1s3c1x2e1t2e122e1u1e1k2c1u1e1u2e1r2g182c1s1e1y2e1t2e1o2e1s1e1q2c1u3g1w2e1r1e1q2c1s3c1t2e1t1g1s2e1u2e1t2c1s3e1z2e1q1g102c1s3c1j2e1t3e1v2e1u1c1y2c1s2e1w2e1q1e1w2c1s2e1f2e1u2e1e2e1u1c1g2c1u2g1w2e1q3e152c1s2e1u2e1t3e1b2e1u1c182c1s1g1j2e1s3g1u2c1t2c1q2e1s3e1r2e1u2d1t2c1s1g162e1q2g1k2c1u3e1x2e1t2f1g2e1t3c1v2c1u1g1p2e1s2f1i2c1u3d1s2e1t2f1o2e1s2e1w2c1s3e1z2e1s2f1s2c1t2d1q2e1s2g1d2e1u2e1f2c1u2e1w2e1q2e1w2c1t2c102e1s2e1h2e1s1e1a2c1s2e1x2e1r1g1t2c1u3c142e1t1e1o2e1u2c102c1s3f1r2e1s1e1t2c1s1c1v2e1r2f152f17121l1h3g193d1s1c1b1e133g103e141e1k3d191g1e2g1i1e1x3e1k3e172e1t3g1t2e1u2c1x2c1w2g192e1s1f1y2c1v2e1s2e1s2f1w2e1t2e1q2c1v1e1u2e1r2e1s2c1u2c102e1s3e172e1u2e122c1u3e172e1r3g1z2c1u2c1y2e1u1e1j2e1t2c172c1u1e1o2e1q3g1f2c1w2c1g2e1s3g1e2e1u2d1z2c1v2g1j2e1s3g1t2c1w3e112e1s2e1a2e1u1c1z2c1w2e1h2e1q1f182c1w3d1c2e1s3f172e1s3d1c2c1u3f192e1s3f1l2c1u3d1b2e1t3e1b2e1s1d1a2c1w3g152e1q3f172c1v3d1f2e1s3f162e1u3e122c1u3f182e1q3f192c1u3d1a2e1s3e152e1s3d192c1u3e1d2e1q3f172c1u3e1q2e1s3f172e1u3d1e2c1u3f172e1q3f1j2c1u2d1a2e1u3f1c2e1s1d192c1u3f1b2e1q3e1z2c1u2c1m1e1h3e1d2f1e1c1j3b1e3f1c3e192e141c123b1f2g181f171g1f1e1i3d1i3e1c3f1d2g1k1c1q1c1k1f1h1f1a1e1h1c1d2d1m3f183f1d3e1a1d1i3d161g1h3e101g1w2d1l1d1a1e121d1b1g1e3d1r1c1d3e1c3f1h3g1e3d1g3e1g3f1e3e1d3f1f1d1m3e1m3f1w1f122e1e1c1d1c1f1g1h3f1k3e1y3e1e2e152e1a3f122f1f3c1i1c1k3e1c1e1q2g1m1c1e2e1d3f143g1b2g1i1d1m1e1j3e121f121e1a1d1t1e1d3e1e1e173e1s2d1a2c1u2g1y2e1s2f1s2c1w1e1w2e1s1e162e1t2d1y2c1v3e1v2e1q3e1e2c1v2d1y2e1s1g1k2e1u2d1k2c1u2g1w2e1r3e1f2c1w1c1d2e1s3f1x2e1t2e112c1v3e1b2e1s1e1a2c1v2d182e1u2g1j2e1u1d1u2c1v2e1p2e1s1e1l2c1v3e182e1t1f152e1u1d1u2c1u2e152e1s3e182c1u2e182e1t1f1b2e1u1e1u2c1w3f1k2e1q2g1w2c1v3c1f2e1u1e172e1s2c1w2c1u1e1y2e1q2g1h2c1w2c1y2e1t1g1t2e1u2c1s2c1u1e1w2e1s1f1i2c1v2e1i2e1s2g1y2e1t2d122c1v3e1b2e1s1g1i2c1u2e102e1t3f132e1s2d122c1v2e1k2e1r3e1x2c1w2e1m2e1s3g1y2e1s3d1x2c1v2f1v2e1s3g1v2c1u3e182e1s3e1k2e1t1e1r2c1w1f1c2e1q2g1l2c1v2c1m2e1p2e1r3g1r2c1w2c1y2e1u3g1d2e1t1c102c1v2e1j2e1q2e1z2c1u3c1j2e1t2g1q2e1s2e1v2c1w2g102e1r3e1x2c1w3c162e1t1e1k2e1u1e1t2c1v2g1r2e1s2g1y2c1u1e1m2e1s1e1w2e1s2e1h2c1w2e1x2e1q1g1y2c1w3e1v2e1s1e1j2e1s2e102c1v1e1r2e1q1g1r2c1v2d1y2e1s3e1x2e1s3e182c1u3e1k2e1q1g1b2c1v3c1h2e1u3e142e1t1c1m2c1v2g1v2e1r1f1v2c1w2e1q2e1t2g122e1u2c122c1v2f1q2e1q2g1y2c1v2c1w2e1s3g1j2e1s3e102c1u3f1v2e1r2f1t2c1u1e1m2e1s3g1y2e1s3d1x2c1v2f1r2e1r2f1i2c1u3c1v2e1s1g122e1u2e1j2c1w3g1u2e1r1e1q2c1u1c1i2e1t2g1f2e1u2e1s2c1u1e1k2e1q3g1u2c1u3e1u2e1t2g1o2e1s1c1v1c162e1t2e1f2e1u1c1h2c1u1g1x2e1s2g1y2c1w2e1h2e1s3e1u2e1t2c122c1u2e1x2e1r1f1s2c1w1c1m2e1u2e1i2e1t3c1x2c1w1g1k2e1r2f1q2c1v3e112e1s1g1t2e1u2e1x2c1w2g1o2e1r2g1z2c1v1c1b2e1t1e1g2e1t2c1i2c1u2g1y2e1r3f102c1v1c1b2e1s2e162e1s1c1t2c1v2e1f2e1s2e1q2c1u1c1w2e1s2e1k2e1u2c1k2c1v3e1v2e1s1g1k2c1w2d1k2e1t2f1s2e1t2d1s2c1u2g1g2e1r2f1i2c1v2d1h2e1s2g1j2e1t2c1i2c1w2e1i2e1s3g1u2c1v1c1s2e1s2e1t2e1u2e1k2c1w3g1u2e1r1e1q2c1u3e182e1s2g162e1t1d1c2c1w1g1s2e1s2g1i2c1v2c1v2e1s2e1x2e1s3e1l2c1w2f1q2e1q2g1y2c1w2c122e1s2e1h2e1s1d1x2c1u1g1f1e122e172c173d101e121j1d1i1g1g3g1s1g1l2d1b1c1l1f191f1d1f1f1c1j1c1w1g1o3e1q3f1g2c1s2c1k2e1s3e1x2e1w2c1v2c1w1f1r2e1r1e1i2c1s1d1z2e1t2e1k2e1w1e1v2c1v2e152e1s2e102c1s3c1g2e1u2e1p2e1u1d162c1u2e1u2e1q2g1m2c1t3c112e1u3g1w2e1v2c1y2c1u3f1k2e1q2e1a2c1s3c1t2e1u2e1o2e1v1c1g2c1w2e142e1s2e112c1s2c1d2e1u2g1c2e1v3e1j2c1u2f182e1q3e1e2c1s1d1b2e1s3g1c2e1u3d182c1v3e192e1q3f192c1s3c1j2e1s3f162e1w3c1d2c1u1f192e1q3e1j2c1s3d1a2e1u3f172e1u3d192c1u3e1z2e1q2f1b2c1s3d1d2e1s1f172e1u3e1c2c1u3f172e1r3g1d2c1s2d1a2e1s3f162e1u2d172c1v3e1j2e1q2f1a2c1s3d1b2e1s3f152e1u3d1t2c1u2e1u2e1d1e1h3b143e1h2f182g1d2g1e1c1i1d1r3f1y2g1d2e1e1e1c1d1j3e1b2f1i1f1a3d1d3c1c1f1g3g121f1j1e121d1y2f1j3f163e141b1f1d1g3f1p1e193e1f3e1j3d153f1o1e1g1f1j1d1g2c1a1e1c2f141g1u1d1j3c1a1e181e161e1a1c1s1e1l3e1a1e181g143b1f1d1e1e1i2f1d3f1h1c121d163g1d3e1d3f1g3e1j1e1e2e192f121f1e1c1f3c1e1f1i3f181g1i1d1f1e1m3f1h2e1q3f1l3e152d1g3f142f1c2f1e1c1f3d182e1s2g142e1w2c1r2c1w1g102e1r2g1q2c1u1c1y2e1u2g1x2e1u1d1m2c1w1e1k2e1r1g1z2c1t1c1u2e1u3e1j2e1w2c1s2c1u1e1u2e1q1e1x2c1u2c1l2e1t2f1w2e1u2c1w2c1u1e1j2e1q2g122c1t1c122e1t3e1w2e1w2e1t2c1w2e1u2e1q3e102c1t2e122e1t3e1h2e1w1c1m2c1u1g1k2e1q1g172c1s3c1l2e1t3e132e1w2c102c1w2g1q2e1q1f1y2c1u2d1i2e1t3e1g2e1u2e102c1v3f102e1q2f1u2c1t1c122e1s3f1k2e1v3e1v2c1u3e152e1q2g1y2c1t3c1f2e1u1e1h2e1u2c1w2c1u2g1u2e1r3e1h2c1u1c182e1u1e132e1v2d1h2c1u2g1j2e1r1f1x2c1u3c162e1t2e1k2e1w2d142c1u2g1t2e1q1g182c1s2e1w2e1s2f1r2e1w1e182c1w2e1w2e1d2e1w2c1q2c1w2g1t2e1r2g112c1s2e1l2e1u2e1y2e1w1c1x2c1v1e1j2e1s1e1j2c1u1e1m2e1u3f1g2e1v2e1x2c1v2f1q2e1q1f122c1t2c1w2e1u1f1q2e1w1e162c1u1e1v2e1r3g1k2c1s2e102e1t3f1y2e1w2c1k2c1w1g1z2e1q3g162c1u1c1v2e1s2g1o2e1v2c1k2c1v2e192e1s2g1x2c1u2d1v2e1s2g122e1u2e1k2c1u2g1x2e1r2f1u2c1s2d102e1t3e1s2e1u3e1j2c1u3g1y2e1q3f1z2c1t2d1h2e1u1e1y2e1v2d1h2c1u2g1d2e1r2g1u2c1t1c1l2e1u3e122e1v1c1k2c1w1g1v2e1r2g1q2c1u3c162e1t2e1i2e1v3c192c1v1e1v2e1s1g1c2c1u3c1k2e1s2e1g2e1v3c1v2c1w1g1k2e1q3e192c1t1c122e1s3f1i2e1v1d1s2c1u2e152e1s3f1h2c1s1c1k1e152e1q1g1w2c1t2e1v2e1u3g1v2e1v2d1i2c1w1e1t2e1s3g1r2c1u1e1h2e1u2e1i2e1w2e102c1v3e1j2e1s2g1j2c1t2d1h2e1s2g1h2e1v2d102c1u1g142e1q3e112c1u2d1k2e1s3g1w2e1u3d1v2c1v2f1y2e1s3g1x2c1s3c172e1s2g1s2e1v3c1d2c1w1e1g2e1s3g1x2c1s1e1m2e1u1f1q2e1v1c102c1u2f1k2e1r3g1x2c1u2e192e1t2f1d2e1u2e1j2c1v1f1h2e1s2e1x2c1u3e1w2e1t2e1o2e1u2d192c1v1e182e1s2f1a2c1u2e1l2e1s2e1y2e1v2d1i2c1v3e1v2e1s1g1r2c1u2d1k2e1t2e1g2e1v3c1v2c1w1g1k2e1q1g1r2c1s1e122e1s3e1h2e1v3c1q2c1u2e1t2e1q1g162c1u2c182e1t2g1g2e1v2d1h2c1u2g1d2e1q2e182c1s3d1l2e1t1g1d2e1u1c1s2c1t3e192e1y1e191o2h1h1e2d1c2q2r1k2i1r16', '7a1a48461610d0a715fafbd397bd597d'));
						_Event("Impression", ad);
						_Event("Impress", ad);
						var vw = g("ViewableImpression", ad);
						if(vw) {
							_Event("Viewable", vw);
							_Event("NotViewable", vw);
							_Event("ViewUndetermined", vw)
						}
						vast.version = xml.documentElement.getAttribute("version");
						_Event("Error", ad);
						if(vast.adsystem == "PjsVast" && vast.pjstat) {
							vast.events['Error'].push(vast.pjstat + "err")
						}
						var creative;
						if(creatives) {
							var crtvs = creatives.getElementsByTagName("Creative");
							for(var i = 0; i < crtvs.length; i++) {
								creative = g("Linear", crtvs[i]);
								var overlays = g("NonLinearAds", crtvs[i]);
								if(overlays) {
									var over = overlays.getElementsByTagName("NonLinear");
									for(var j = 0; j < over.length; j++) {
										OverlayParsing(over[j])
									}
								}
								if(creative) {
									if(t("Duration", creative) != "") {
										vast.duration = seconds(t("Duration", creative))
									}
									if(t("AdParameters", creative) != "") {
										vast.adparameters = t("AdParameters", creative)
									}
									if(g("MediaFiles", creative)) {
										vast.file = _Media("MediaFile", g("MediaFiles", creative));
										if(exist(v.vast_denied_files)) {
											var dnfs = v.vast_denied_files.split(",");
											for(var i = 0; i < dnfs.length; i++) {
												if(vast.file.indexOf(dnfs[i]) > -1) {
													log("VAST file denied", dnfs[i]);
													js("vast_file_denied", vast.file);
													vast.file = undefined
												}
											}
										}
									}
									if(g("TrackingEvents", creative)) {
										_Tracking("Tracking", "event", g("TrackingEvents", creative))
									}
									var clicks = g("VideoClicks", creative);
									if(clicks) {
										vast.click = t("ClickThrough", clicks);
										_Tracking("ClickTracking", "id", clicks)
									}
									var skipoffset = creative.getAttribute("skipoffset");
									if(skipoffset) {
										!exist(vast.extensions) ? vast.extensions = [] : '';
										vast.extensions.skipTime = seconds(skipoffset)
									}
								}
								var companions = g("CompanionAds", crtvs[i]);
								if(companions) {
									var cmpns = companions.getElementsByTagName("Companion");
									var aspct = 100;
									var ppl = 0;
									for(var j = 0; j < cmpns.length; j++) {
										var sr = g("StaticResource", cmpns[j]);
										if(sr) {
											var srct = sr.getAttribute("creativeType");
											if(srct) {
												if(srct.indexOf("image") > -1) {
													var tmp = Math.abs(cmpns[j].getAttribute("width") / cmpns[j].getAttribute("height") - o.aspect);
													var tmp2 = cmpns[j].getAttribute("width") * cmpns[j].getAttribute("height");
													if(tmp < aspct && tmp2 >= ppl) {
														aspct = tmp;
														ppl = tmp2;
														vast.companionImg = textContent(sr);
														_Event("CompanionClickThrough", cmpns[j])
													}
												}
											}
										}
									}
								}
							}
						}!exist(vast.extensions) ? vast.extensions = [] : '';
						var extensions = g("Extensions", ad);
						if(extensions) {
							_Extensions(extensions)
						}
					}
					if(vast.isWrapper) {
						vast.wrapperTime = new Date().getTime();
						if(vast.wrapper.indexOf('data://text/xml,') == 0) {
							log("Wrapper", "XML");
							ParsTxt(unescape(vast.wrapper.substr(16)))
						} else {
							log("Wrapper", vast.wrapper);
							LoadXml(vast.wrapper, true)
						}
					} else {
						Done()
					}
				}
			}
		}

		function Done() {
			Event("onVastLoad");
			if(exist(vast.file) && o.vok) {
				_status = 'ready';
				!_preload ? o.actions.VastReady(vast) : ''
			} else {
				js("vast_empty", VastInfo());
				Event("Error", 401);
				_status = 'error';
				!die_error && !_preload ? o.actions.VastError() : '';
				die_error = true
			}
		}

		function g(x, xml) {
			if(exist(xml)) {
				return xml.getElementsByTagName(x)[0]
			} else {
				return null
			}
		}

		function t(x, xml, i) {
			if(!exist(i)) {
				i = 0
			}
			var y = xml.getElementsByTagName(x)[i];
			var z = '';
			if(exist(y)) {
				if(exist(y.childNodes[0])) {
					if(y.childNodes[0].wholeText) {
						z = y.childNodes[0].wholeText.trim()
					}
				}
			}
			return z
		}

		function _Event(x, xml) {
			if(!exist(vast.events[x])) {
				vast.events[x] = []
			}
			if(exist(xml)) {
				if(exist(xml.getElementsByTagName(x)[0])) {
					for(var i = 0; i < xml.getElementsByTagName(x).length; i++) {
						var y = xml.getElementsByTagName(x)[i].childNodes;
						for(var j = 0; j < y.length; j++) {
							if(y[j].wholeText) {
								var y2 = y[j].wholeText;
								if(exist(y[j].nextSibling)) {
									if(y[j].nextSibling.localName == "URL") {
										y2 = textContent(y[j].nextSibling)
									}
								}
								var z;
								if(y2) {
									z = y2.replace(/\s+/g, ' ').trim()
								}
								if(z && z != '') {
									if(x == "CompanionClickThrough") {
										vast.click = z
									} else {
										if(vast.events[x].indexOf(z) == -1) {
											vast.events[x].push(z)
										}
									}
									if(z.indexOf("pjstat") && x == "Impression") {
										vast.pjstat = z
									}
								}
							}
						}
					}
				}
			}
		}

		function _Tracking(x, x2, xml, vpd) {
			if(exist(xml.getElementsByTagName(x)[0])) {
				for(var i = 0; i < xml.getElementsByTagName(x).length; i++) {
					var y = xml.getElementsByTagName(x)[i].getAttribute(x2);
					if(x == "ClickTracking" && y != "skipAd") {
						y = "click"
					}
					if(y) {
						var n = xml.getElementsByTagName(x)[i].childNodes;
						if(vpd == 1) {
							!vast.vpdevnts ? vast.vpdevnts = [] : '';
							vast.vpdevnts.push(y)
						}
						if(n.length > 0) {
							var z = n[0].wholeText.replace(/\s+/g, ' ').trim();
							if(y == "impression") {
								y = "Impression"
							}
							if(y == "progress") {
								var prgtime = xml.getElementsByTagName(x)[i].getAttribute("offset");
								if(prgtime) {
									if(!exist(vast.progresstimes)) {
										vast.progresstimes = []
									}
									vast.progresstimes.push(seconds(prgtime));
									y = y + '_' + seconds(prgtime)
								}
							}
							if(!exist(vast.events[y])) {
								vast.events[y] = []
							}
							vast.events[y].push(z)
						}
					}
				}
			}
		}

		function _Extensions(xml) {
			if(exist(xml.getElementsByTagName("Extension")[0])) {
				var ct = "CustomTracking";
				for(var i = 0; i < xml.getElementsByTagName("Extension").length; i++) {
					var xi = xml.getElementsByTagName("Extension")[i];
					var y = xi.getAttribute("type");
					if(y) {
						var z = '';
						if(exist(xi.childNodes[0])) {
							if(exist(xi.childNodes[0].wholeText)) {
								z = xi.childNodes[0].wholeText.replace(/\s+/g, ' ').trim()
							}
						}
						var ctx = xi.getElementsByTagName(ct);
						var vpd;
						if(ctx.length > 0) {
							xi = ctx[0];
							y == 'subscribeVpaid' ? vpd = 1 : '';
							y = ct
						}
						if(y == ct) {
							_Tracking("Tracking", "event", xi, vpd)
						}
						if(y == "or") {
							o.actions.VastInsertOr(t("Extension", xml, i))
						}
						if(y == "and") {
							o.actions.VastInsertAnd(t("Extension", xml, i))
						}
						var dur = exist(o.media) ? o.media.duration() : 0;
						if(y == "Allowblock" && (dur > 120 || dur == 0)) {
							if(z == '1') {
								if(vastType == "preroll") {
									vastUrl.indexOf("vr=1") > 0 ? o.actions.VastInsertAnd(vastUrl.replace("vr=1", "vr=5")) : '';
									vastUrl.indexOf("vr=5") > 0 ? o.actions.VastInsertAnd(vastUrl.replace("vr=5", "vr=9")) : ''
								}
								if(vastType == "midroll") {
									vastUrl.indexOf("vr=2") > 0 ? o.actions.VastInsertAnd(vastUrl.replace("vr=2", "vr=6")) : '';
									vastUrl.indexOf("vr=6") > 0 ? o.actions.VastInsertAnd(vastUrl.replace("vr=6", "vr=10")) : ''
								}
								if(vastType == "pauseroll") {
									vastUrl.indexOf("vr=3") > 0 ? o.actions.VastInsertAnd(vastUrl.replace("vr=3", "vr=7")) : '';
									vastUrl.indexOf("vr=7") > 0 ? o.actions.VastInsertAnd(vastUrl.replace("vr=7", "vr=11")) : ''
								}
								if(vastType == "postroll") {
									vastUrl.indexOf("vr=4") > 0 ? o.actions.VastInsertAnd(vastUrl.replace("vr=4", "vr=8")) : '';
									vastUrl.indexOf("vr=8") > 0 ? o.actions.VastInsertAnd(vastUrl.replace("vr=8", "vr=12")) : ''
								}
							}
						} else {
							if(y == "loadTime" || y == "skipAd" || y == "addClick" || y == "viewable" || y.indexOf("second") == 0) {
								if(y.indexOf("second") == 0) {
									if(!exist(vast.events.sec)) {
										vast.events.sec = []
									}
									vast.events.sec.push(parseInt(y.substr(6)))
								}
								if(!exist(vast.events[y])) {
									vast.events[y] = []
								}
								vast.events[y].push(z)
							} else {
								if(y.indexOf("Time") > -1 && z != -1) {
									z = seconds(z)
								}
								if(y.indexOf("Txt") > -1) {
									z = decodeHtml(z)
								}
								if(y == "controls") {
									var x_control = xml.getElementsByTagName("Extension")[i].getElementsByTagName("control");
									if(x_control.length > 0) {
										for(var i2 = 0; i2 < x_control.length; i2++) {
											if(x_control[i2].getAttribute("id")) {
												vast["control_" + x_control[i2].getAttribute("id")] = x_control[i2].getAttribute("layout")
											}
										}
									}
								}
								if(y == "minVisibility") {
									if(z > 0 && v.vast_visibility != 0 && exist(o.visibility)) {
										if(o.visibility < z) {
											log("VAST visibility", (o.visibility + "<" + z));
											js("vast_visibility", (o.visibility + "<" + z));
											vast.file = undefined;
											vast.isWrapper = false
										}
									}
								}
								if(y == "callPjsEvent") {
									if(z) {
										js(z, VastInfo())
									}
								}
								if(y == "hideAfterComplete") {
									vast.hidevpaid = 1
								}
								if(vast.extensions.extensionsPriority == 1 && z.toString().indexOf('//') == -1) {
									if(!exist(vast.extensions[y])) {
										vast.extensions[y] = z
									}
								} else {
									vast.extensions[y] = z
								}
							}
						}
					}
				}
			}
		}

		function _Media(x, xml) {
			var r = "";
			var mp4 = [];
			if(exist(xml.getElementsByTagName(x)[0])) {
				for(var i = 0; i < xml.getElementsByTagName(x).length; i++) {
					var y = xml.getElementsByTagName(x)[i];
					var type = y.getAttribute("type");
					var api = y.getAttribute("apiFramework");
					r = textContent(y);
					if(type) {
						vast.filetype = type;
						if(type.indexOf("javascript") > -1 && api == "VPAID") {
							vast.isVpaid = true;
							break
						}
						if(type.indexOf("mp4") > -1) {
							var m = {};
							m.x = r;
							if(y.getAttribute("width")) {
								m.w = y.getAttribute("width")
							}
							mp4.push(m)
						}
						if(type.indexOf("image") > -1) {
							if(mp4.length == 0) {
								vast.isImg = true;
								break
							}
						}
						if(type.indexOf("iframe") > -1) {
							if(mp4.length == 0) {
								vast.isImg = true;
								vast.isFrm = true;
								break
							}
						}
					}
				}
			}
			if(mp4.length > 0) {
				r = mp4[0].x;
				var w = 0;
				for(var i = 0; i < mp4.length; i++) {
					if(mp4[i].w) {
						if(mp4[i].w > w) {
							r = mp4[i].x;
							w = mp4[i].w
						}
						if(mp4[i].w >= o.screen_w) {
							return mp4[i].x
						}
					}
				}
			}
			return r
		}

		function textContent(x) {
			if(x) {
				var y = x.textContent;
				if(y) {
					return y.replace(/\s+/g, ' ').trim()
				}
			}
		}

		function vastURL(x, wrap) {
			if(x.indexOf("prt") == 0) {
				partner = true;
				x = Prt(x);
				log("VASTP " + vast.prt)
			}
			if(x.indexOf('random') == -1 && v.vast_addrandom == 1 && x.indexOf('//') > -1) {
				x = x + (x.indexOf('?') == -1 ? '?' : '&') + 'rand=(random)'
			}
			x = x.replace(/\{/g, "(");
			x = x.replace(/\}/g, ")");
			x = x.replace(/\(ref\)/g, Href());
			x = x.replace(/\(referer\)/g, Href());
			x = x.replace(/\(rand_id\)/g, o.sessid);
			x = x.replace(/\(userid\)/g, o.userid);
			x = x.replace(/\(host\)/g, encodeURIComponent(o.domain));
			x = x.replace(/\(referrer\)/g, encodeURIComponent(exist(v.parent_domain) ? v.parent_domain : document.referrer));
			x = x.replace(/\(rereferer\)/g, encodeURIComponent(exist(v.parent_domain) ? v.parent_domain : document.referrer));
			x = x.replace(/\(random\)/g, Math.random());
			x = x.replace(/\(vast_id1\)/g, v.vast_id1);
			x = x.replace(/\[random\]/g, Math.random());
			x = x.replace(/\(adblock\)/g, (o.ab ? 1 : 0));
			x = x.replace(/\[CACHEBUSTING\]/g, Math.random());
			x = x.replace(/\(width\)/g, o.screen_w);
			x = x.replace(/\(bitrate\)/g, existv(o.bitrate, 0));
			x = x.replace(/\(videowidth\)/g, (o.media ? o.media.size().width : ''));
			x = x.replace(/\(videoheight\)/g, (o.media ? o.media.size().height : ''));
			x = x.replace(/\(quality\)/g, apiProcessor("quality"));
			x = x.replace(/\(height\)/g, o.screen_h);
			x = x.replace(/\(duration\)/g, o.media ? o.media.duration() : 0);
			x = x.replace(/\(visibility\)/g, (exist(o.visibility) ? o.visibility : -1));
			if(x.indexOf("(platform)") > 0) {
				o.system.tv ? x = x.replace(/\(platform\)/g, "smarttv") : '';
				if(o.system.mobile) {
					x = x.replace(/\(platform\)/g, "mobile")
				} else {
					x = x.replace(/\(platform\)/g, "web-html5")
				}
			}
			for(var i = 1; i < 6; i++) {
				var y = '';
				i > 1 ? y = i : '';
				if(x.indexOf("(timeout" + y + ":") > 0) {
					var re = new RegExp('\\(timeout' + y + ':\\d*\\)', 'g');
					var to = x.match(re);
					if(to.length > 0) {
						var tmp = to[0].substr(to[0].indexOf(":") + 1);
						tmp = tmp.substr(0, tmp.indexOf(")"));
						if(y == '') {
							v.vast_timeout = tmp * 1;
							v.vpaid_timeout = tmp * 1
						} else {
							v['vpaid_timeout' + y] = tmp * 1
						}
					}
					x = x.replace(re, '')
				}
			}
			if(x.indexOf("(connection)") > 0) {
				var cn = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
				x = x.replace(/\(connection\)/g, ((typeof(cn) != "undefined" && typeof(cn.type) != "undefined") ? cn.type : "undefined"))
			}
			x = VastReplace(x);
			if(wrap != true) {
				v.vpaidimpression == 1 || x.indexOf("vpaidimpression") > 0 ? vast.vpaidImOnVdSrt = 1 : ''
			}
			if(x.indexOf("http://") == 0) {
				x = '//' + x.substr(7)
			}
			return x
		}

		function seconds(x) {
			var y = x.split(":");
			var z = 0;
			if(y.length == 3) {
				z = parseInt(y[0]) * 3600 + parseInt(y[1]) * 60 + parseInt(y[2])
			}
			if(y.length == 2) {
				z = parseInt(y[0]) * 60 + parseInt(y[1])
			}
			return z
		}

		function decodeHtml(x) {
			var div;
			if(x) {
				div = createElement('div');
				div.innerHTML = x;
				return decodeURIComponent(div.textContent)
			} else {
				return void 0
			}
		}

		function Event(x, code) {
			if(exist(vast)) {
				if((exist(vast.prt) && v.eventstrackervast == 0) || vast.adsystem == "intro" || vast.adsystem == "outro") {} else {
					code > 0 ? js(("vast_" + x), code) : js("vast_" + x)
				}
				if(exist(vast.events[x])) {
					for(var i = 0; i < vast.events[x].length; i++) {
						log("VAST " + x);
						var stop = false;
						var z = vast.events[x][i];
						if(code > 0) {
							if(z.indexOf("[ERRORCODE]") > 0) {
								z = z.replace("[ERRORCODE]", code)
							}
						}
						if(z.indexOf("(time)") > 0) {
							z = z.replace("(time)", _ltime)
						}
						if(z.indexOf("(url)") > 0) {
							z = z.replace("(url)", encodeURIComponent(vastUrl))
						}
						z = VastReplace(z);
						z = z.replace("(adblock)", (o.ab ? 1 : 0));
						if(z.indexOf(".pjstat") > 0) {
							z = z + "&h=" + (exist(v.parent_domain) ? v.parent_domain : o.d) + (v.ab == 1 ? "&a=" + (o.ab ? 1 : 0) : '') + (o.vasttype == 'overlay' ? '&r=1' : '') + '&s=' + o.sessid
						}
						if(!stop) {
							gif(z)
						}
					}
				}
			}
		}

		function AddEvnt(x, y) {
			if(!exist(vast.events[y])) {
				vast.events[y] = []
			}
			if(x) {
				var z = x.split(",");
				for(var i = 0; i < z.length; i++) {
					z[i] = z[i].replace(/\(random\)/g, random(1000, 2000));
					if(vast.events.indexOf(y) == -1) {
						vast.events[y].push(z[i])
					}
				}
			}
		}

		function VastReplace(x) {
			x = x.replace(/\(visibility\)/g, (exist(o.visibility) ? o.visibility : -1));
			if(typeof v.vast_replace == "string") {
				try {
					v.vast_replace = v.vast_replace.replace(/'/ig, '"');
					v.vast_replace = JSON.parse(v.vast_replace)
				} catch(e) {
					log(e)
				}
			}
			if(typeof v.vast_replace == "object") {
				for(var y in v.vast_replace) {
					if(v.vast_replace.hasOwnProperty(y)) {
						for(var i = 0; i < 5; i++) {
							x = x.replace(y, v.vast_replace[y])
						}
					}
				}
			}
			return x
		}
		this.Ready = function() {
			o.actions.VastReady(vast)
		};
		this.disablePreload = function() {
			_preload = false
		};
		this.Status = function() {
			return _status
		};
		this.info = function(x) {
			return vast ? vast[x] : false
		};
		this.getVolume = function() {
			return undefined
		};
		this.preloaded = function(x) {
			return _preloaded.indexOf(x) > -1
		};

		function Prt(x) {
			if(x.indexOf('[imp]') > 0) {
				var tmp = x.indexOf('[imp]');
				var tmp2 = x.substr(tmp + 5, x.indexOf('_') - (tmp + 5));
				AddEvnt(tmp2, 'Impression');
				AddEvnt(tmp2 + 'err', 'Error');
				x = x.substr(0, tmp) + x.substr(x.indexOf('_'))
			}
			if(x.indexOf('[pimp]') > 0) {
				var tmp = x.indexOf('[pimp]');
				var tmp2 = x.substr(tmp + 6, x.indexOf('**') - (tmp + 6));
				AddEvnt(tmp2, 'Impression');
				x = x.substr(0, tmp) + x.substr(x.indexOf('**') + 2)
			}
			if(x.indexOf('prtcpm') == 0) {
				vast.cpm = x.substr(6, 4);
				vast.prt = x.substr(10, x.indexOf('_') - 10)
			} else {
				vast.prt = x.substr(3, x.indexOf('_') - 3)
			}
			if(vast.cpm) {
				var xx = 'https://' + vast.cpm + '-c73e.kxcdn.com/' + vast.cpm;
				o.vast ? o.vast.imp(xx) : '';
				AddEvnt(xx, 'Impression')
			}
			x = x.substr(x.indexOf('_') + 1);
			return x
		}

		function OverlayParsing(x) {
			if(x) {
				vast.overlay = [];
				vast.overlay.width = x.getAttribute("width");
				vast.overlay.height = x.getAttribute("height");
				var dur = x.getAttribute("minSuggestedDuration");
				if(dur) {
					vast.duration = seconds(dur)
				}
				vast.overlay.scalable = x.getAttribute("scalable");
				vast.file = textContent(g("StaticResource", x));
				_Event("NonLinearClickTracking", x);
				var so = x.getAttribute("skipoffset");
				if(so) {
					!vast.extensions ? vast.extensions = [] : '';
					vast.extensions.skipTime = seconds(so)
				}
				vast.click = textContent(g("NonLinearClickThrough", x))
			}
		}

		function DestroyIma() {
			if(o.ima) {
				try {
					o.ima.Destroy()
				} catch(e) {
					log(o.ima, e)
				}
				o.ima = undefined
			}
		}
	};
	var VastVideo = function() {
		var vast;
		var over = o.mousehere;
		var no = ['desktop', 'mobile', 'mobiletv', 'tv', 'lg', 'winmob'];
		o.vastcontainer = createElement("div");
		css(o.vastcontainer, {
			"position": "absolute",
			"left": 0,
			"top": 0,
			"width": "100%",
			"height": "100%",
			"background-color": (exist(v.vast_bgcolor) ? v.vast_bgcolor : "#000000")
		});
		if(exist(v.vast_bga)) {} else {
			v.hidevideo == 1 ? v.vast_bga = 0.5 : ''
		}
		css(o.vastcontainer, {
			"opacity": v.vast_bga
		});
		o.frame.appendChild(o.vastcontainer);
		if(!o.system.mobile) {
			o.vastcontainer.addEventListener("mouseover", onOver, false);
			o.vastcontainer.addEventListener("mouseleave", onOut, false)
		}
		var tag = createElement("video");
		o.vastcontainer.appendChild(tag);
		o.vastcontainer.style.zIndex = 1001;
		hide(o.vastcontainer);
		css(tag, {
			'width': '100%',
			'height': '100%',
			'object-fit': 'contain',
			'min-height': 'auto',
			'max-height': 'none',
			'min-width': 'auto',
			'max-width': 'none'
		});
		if(v.vpaid_waitstart !== 1) {
			css(tag, {
				'autoplay': 1
			})
		}
		attr(tag, {
			'preload': 'auto',
			'x-webkit-airplay': 'deny',
			'webkit-playsinline': true,
			'cursor': 'pointer',
			'playsinline': '1',
			'pip': 'false'
		});
		if(v.vast_unmutehover == 1 || v.vast_unmutebut == 1) {
			tag.muted = true;
			attr(tag, {
				'muted': 'true'
			})
		}
		var duration;
		var paused;
		var controls;
		var uiplay, uiplay2;
		var uibuffer;
		var uiposter;
		var uit;
		var uitxt;
		var uimute;
		var uifull;
		var uinorm;
		var uiunmutebut;
		var uiprogress;
		var uix;
		var uiskip;
		var vpaidframe;
		var vpaidslot;
		var vpaidslot2;
		var vpaid;
		var vpaid_int;
		var vpaidframe_int;
		var vpaid_t;
		var vpaid_stop_t;
		var vpaid_complete_t;
		var push_wait_int;
		var video_t;
		var vpaidvolume = 1;
		var vpaidvolume2;
		var vpaidstopped = false;
		var vpaidstarted = false;
		var vaststarted = false;
		var vpaidskipped = false;
		var vpaidcompleted = false;
		var vpaidvideostarted = false;
		var vpaidquartile = false;
		var vpaid_int2;
		var removed = false;
		var last_skiptime = 0;
		var last_time = 0;
		var imgtime = 0;
		var img_int;
		var _move = false;
		var _go = false;
		var _muted = false;
		var muteicon = "<svg width='20' height='20' xmlns:xlink='http://www.w3.org/1999/xlink' xmlns='http://www.w3.org/2000/svg'><g><path fill='" + v.vast_volumecolor + "' stroke-width='0' d='m2.49931,6.8746l0,6.25079l3.10029,0l4.64114,4.37461l0.00276,-15l-4.64182,4.37461l-3.10237,0l0,-0.00001zm10.44167,-0.75275c-0.26762,-0.30766 -0.69733,-0.30766 -0.96359,0.00158c-0.26557,0.30925 -0.26557,0.80989 0.00136,1.11992l0,-0.00157c0.58769,0.68334 0.94997,1.62056 0.94997,2.66218c0,1.04083 -0.3616,1.97489 -0.94861,2.65823c-0.2683,0.30766 -0.2683,0.8083 -0.00136,1.11912c0.13279,0.15423 0.30713,0.23173 0.48146,0.23173c0.17501,0 0.34934,-0.0775 0.48213,-0.23173c0.83216,-0.9649 1.34835,-2.30548 1.34767,-3.77735c0.00068,-1.47504 -0.51755,-2.8172 -1.34903,-3.7821l0,-0.00001zm1.55246,-1.75907c-0.27124,0.30979 -0.27124,0.81211 0,1.12031c1.00334,1.14962 1.62195,2.73104 1.62195,4.4852c0,1.75256 -0.61861,3.3332 -1.62056,4.48361c-0.27125,0.30899 -0.27125,0.81053 0,1.12031c0.13493,0.1545 0.31208,0.23214 0.48991,0.23214c0.17713,0 0.35428,-0.07764 0.48921,-0.23214c1.25105,-1.43327 2.02674,-3.41876 2.02536,-5.60392c0.00069,-2.18675 -0.775,-4.17383 -2.02813,-5.60551c-0.27194,-0.30979 -0.70857,-0.30979 -0.97774,0z'/></g></svg>";
		var unmuteicon = "<svg width='20' height='20' xmlns:xlink='http://www.w3.org/1999/xlink' xmlns='http://www.w3.org/2000/svg'><g><path fill='" + v.vast_volumecolor + "' stroke-width='0' d='m2.49931,6.8746l0,6.25079l3.10029,0l4.64114,4.37461l0.00276,-15l-4.64182,4.37461l-3.10237,0l0,-0.00001z'/><path d='m18.125,12.20836l-2.20816,-2.20816l2.20776,-2.20816l-1.13498,-1.13579l-2.20816,2.20816l-2.20816,-2.20816l-1.13498,1.13579l2.20776,2.20816l-2.20816,2.20816l1.13579,1.13539l2.20776,-2.20816l2.20776,2.20816' fill-opacity='null' stroke-opacity='null' stroke-width='0' fill='" + v.vast_volumecolor + "'/></g></svg>";
		var impression = false;
		var remainigs = 0;
		var unmute_volume = 0;
		var slow_unmute;
		var js_events;
		var remove_t;
		var complete_t;
		var ytag;
		var youtube = false;
		var vimeo = false;
		var mp3 = false;
		var ytinterval;
		var imps = [];
		var qrts = [];
		var start_timeout = true;
		if(v.vpaid_waitstart !== 1) {
			var pp = tag.play();
			if(pp !== undefined) {
				pp.then(function() {}).catch(function(error) {
					if(error.message.indexOf("interact") > 0) {
						log("play mute");
						tag.muted = true;
						attr(tag, {
							'muted': 'true'
						})
					}
				})
			}
		}
		this.break = function() {
			if(exist(uiplay)) {
				log("VAST break");
				onError()
			}
		};
		this.Go = function(x) {
			removed ? show(tag) : '';
			tag.volume = 0.4;
			duration = 0;
			paused = false;
			controls = true;
			impression = false;
			remainigs = 0;
			removed = false;
			last_time = 0;
			last_skiptime = 0;
			vast = x;
			die_error = false;
			js_events = [];
			_go = true;
			show(o.vastcontainer);
			if(exist(vast.extensions.controls)) {
				if(vast.extensions.controls === 0 || vast.extensions.controls === "0") {
					controls = false
				}
			}
			if(vast.nocontrols == 1 || v.vast_nocontrols == 1) {
				if(vast.nocontrolsvpaid == 1) {
					vast.isVpaid ? controls = false : ''
				} else {
					controls = false
				}
			}
			if(vast.yescontrols == 1) {
				controls = true
			}
			if(o.controls) {
				if(o.controls.SettingsVisible()) {
					o.controls.Settings()
				}
			}
			if(exist(vast.prt)) {
				vast.prtg = 1
			}
			if(vast.isVpaid && v.vast_novpaid == 1) {
				onError('NO VPAID');
				return
			}
			var stop = false;
			if(exist(vast.file)) {
				if(vast.file.indexOf('youtube.com/') > -1 || vast.file.indexOf('youtu.be/') > -1) {
					youtube = true
				}
				if(v.vimeo == 1 && vast.file.indexOf('vimeo.com/') > -1) {
					vimeo = true
				}
				if(vast.file.indexOf('.mp3') > -1) {
					mp3 = true
				}
				if(vast.adsystem == "intro") {
					for(var i = 0; i < no.length; i++) {
						if(vast.file.indexOf('[no_' + no[i] + ']') > -1) {
							vast.file = vast.file.replace('[no_' + no[i] + ']', '');
							if(o.system[no[i]]) {
								onError("no " + no[i]);
								stop = true;
								break
							}
						}
					}
				}
			}
			if(!stop) {
				if(vast.isImg || vast.isVpaid || youtube || vimeo) {
					vpaidslot = createElement("div");
					o.vastcontainer.appendChild(vpaidslot);
					css(vpaidslot, {
						"position": "absolute",
						"top": "0",
						"left": "0",
						"width": "100%",
						"height": "100%"
					})
				}
				if(youtube) {
					ytag = new MediaYoutube('intro' + vast.file, vpaidslot)
				}
				if(vimeo) {
					ytag = new MediaVimeo('intro' + vast.file, vpaidslot)
				}
				if(!youtube && !vimeo) {
					var elm = vast.isImg ? vpaidslot : tag;
					if(o.system.mobile) {
						elm.removeEventListener("touchstart", onTouchStart);
						elm.removeEventListener("touchmove", onTouchMove);
						elm.removeEventListener("touchend", onScreenClick)
					} else {
						elm.removeEventListener("click", onScreenClick)
					}
					var _clck = true;
					if(exist(vast.extensions.isClickable)) {
						_clck = vast.extensions.isClickable == 1
					}
					if(_clck) {
						if(o.system.mobile) {
							elm.addEventListener("touchend", onScreenClick);
							elm.addEventListener("touchstart", onTouchStart);
							elm.addEventListener("touchmove", onTouchMove)
						} else {
							elm.addEventListener("click", onScreenClick);
							css(elm, {
								"cursor": "pointer"
							})
						}
					}
				}
				RemoveInterface();
				uiplay = createElement("div");
				css(uiplay, {
					"position": "absolute",
					"top": "0",
					"left": "0",
					"width": "100%",
					"height": "100%",
					"display": "none",
					"cursor": "pointer",
					"z-index": 1
				});
				o.vastcontainer.appendChild(uiplay);
				uiplay2 = createElement("div");
				css(uiplay2, {
					"position": "absolute",
					"top": "50%",
					"left": "50%",
					"margin-left": -10,
					"margin-top": -10,
					"cursor": "pointer",
					"background": "rgba(0,0,0,0.5)",
					"border-radius": 20,
					"width": 20,
					"height": 20,
					"padding": "3px 2px 3px 4px",
					"zIndex": 1
				});
				if(o.system.safari && o.system.desktop) {
					css(uiplay2, {
						"zoom": "3"
					})
				} else {
					css(uiplay2, {
						"transform": "scale(3)"
					})
				}
				uiplay2.innerHTML = "<svg width='20' height='20' xmlns:xlink='http://www.w3.org/1999/xlink' xmlns='http://www.w3.org/2000/svg'><g><path d='m4.59375,3.48438l-0.03125,13.03125l10.875,-6.51563l-10.84375,-6.51562z' fill='#ffffff'/></g></svg>";
				uiplay.appendChild(uiplay2);
				if(o.system.mobile) {
					uiplay.addEventListener("touchend", onScreenClick)
				} else {
					uiplay.addEventListener("click", onScreenClick)
				}
				if(vast.companionImg && mp3) {
					uiposter = createElement("div");
					css(uiposter, {
						"position": "absolute",
						"top": "0",
						"left": "0",
						"width": "100%",
						"height": "100%",
						"pointerEvents": "none",
						"background": "url(" + vast.companionImg + ") 50% 50% no-repeat",
						"background-size": "contain"
					});
					o.vastcontainer.appendChild(uiposter)
				}
				if(uibuffer) {
					RemoveControl('uibuffer')
				}
				uibuffer = createElement("div");
				css(uibuffer, {
					"position": "absolute",
					"top": "50%",
					"left": "50%",
					"pointerEvents": "none",
					"zIndex": 1
				});
				if(v.control_buffer.icon && v.vast_buffering != 0) {
					controlCSS(v.control_buffer.icon, v.control_buffer.color, uibuffer);
					o.vastcontainer.appendChild(uibuffer);
					v.control_buffer.scale ? css(uibuffer, {
						"transform": "scale(" + v.control_buffer.scale + ")"
					}) : '';
					vast.buffering = true
				}
				if(controls || v.vast_title_important == 1) {
					if(vast.introtitle == 0) {} else {
						if(v.vast_title == 1) {
							uit = createElement("div");
							css(uit, {
								"font-size": existv(v.vast_title_size, 14) * existv(v.globalfs, 1),
								"color": v.vast_titlecolor,
								"position": "absolute",
								"top": existv(v.vast_title_top, 0),
								"left": existv(v.vast_title_left, 0),
								"background-color": hex2rgb(v.vast_titlebgcolor, existv(v.vast_titlebga, 0)),
								"opacity": existv(v.vast_titlea, 1),
								"padding": "5px 8px 5px 8px",
								"box-sizing": "border-box",
								"zIndex": 1
							});
							o.vastcontainer.appendChild(uit);
							vast.uititle = Lang("ads");
							if(exist(v.vast_title_text)) {
								if(v.vast_title_text != '') {
									vast.uititle = v.vast_title_text
								}
							}
							uit.innerHTML = vast.uititle + (v["vast_" + o.vasttype + "_" + "counter"] == 1 ? (o.adscounter <= o.adsinchain ? (o.adsinchain > 1 ? ' ' + o.adscounter + '/' + o.adsinchain : '') : '') : '')
						}
					}
				}
				if(controls) {
					if(exist(vast.control_adlabel)) {
						if(vast.control_adlabel === "0" || vast.control_adlabel === "-1") {
							css(uit, {
								"top": -1000
							})
						} else {
							if(vast.control_adlabel !== "1") {
								if(vast.control_adlabel == "TR" || vast.control_adlabel == "BR") {
									css(uit, {
										"right": 0,
										"left": "auto"
									})
								}
								if(vast.control_adlabel == "BR" || vast.control_adlabel == "BL") {
									css(uit, {
										"bottom": 0,
										"top": "auto"
									})
								}
							}
						}
					}
					if(exist(vast.extensions.linkTxt)) {
						if((o.system.mobile && v.vast_linktxtonmobile == 0) || vast.extensions.linkTxt == '') {} else {
							if(!exist(uitxt)) {
								uitxt = createElement("div");
								css(uitxt, {
									"position": "absolute",
									"bottom": 50,
									"margin-left": "auto",
									"margin-right": "auto",
									"left": 0,
									"right": 0,
									"font-size": existv(v.vast_linktxt_size, (o.system.mobile ? 12 : 14)) * existv(v.globalfs, 1),
									"color": v.vast_linktxtcolor,
									"display": "table",
									"width": "50%",
									"text-align": "center",
									"zIndex": 1
								});
								uitxt.innerHTML = "<pjspan style='background:" + hex2rgb(v.vast_linktxtbgcolor, 1) + ";padding:7px 15px;border-radius:20px;display:inline-block;cursor:pointer'>" + vast.extensions.linkTxt + "</pjspan>";
								o.vastcontainer.appendChild(uitxt);
								if(vast.click == '' && vast.isVpaid) {
									PtrNn(uitxt);
									css(uitxt, {
										"pointer-events": "none"
									})
								} else {
									uitxt.firstElementChild.addEventListener('click', onInvite)
								}
								hide2(uitxt);
								if(!o.mouseHere && !o.system.mobile) {} else {
									setTimeout(function() {
										show2(uitxt)
									}, 200)
								}
							} else {
								show2(uitxt);
								uitxt.innerHTML = vast.extensions.linkTxt
							}
						}
					} else {
						if(exist(uitxt)) {
							hide2(uitxt)
						}
					}
					uimute = createElement("div");
					CreateUiBut(uimute, 10, 10, muteicon, onToggleMute);
					if(exist(vast.control_soundbtn)) {
						var tmp = vast.control_soundbtn;
						if(tmp === "0") {
							hide(uimute);
							css(uimute, {
								"top": -1000
							})
						} else {
							if(tmp !== "1") {
								if(tmp == "TR") {
									css(uimute, {
										"bottom": "auto",
										"top": 10,
										"right": 10
									})
								}
								if(tmp == "TL") {
									css(uimute, {
										"bottom": "auto",
										"top": 10,
										"right": "auto",
										"left": 10
									})
								}
								if(tmp == "BL") {
									css(uimute, {
										"bottom": 10,
										"right": "auto",
										"left": 10
									})
								}
							}
						}
					}
					uiprogress = createElement("div");
					o.vastcontainer.appendChild(uiprogress);
					uiprogress.innerHTML = '<svg id="pljsvastprogress_' + v.id + '" width="20" height="20" viewPort="0 0 10 10" version="1.1" xmlns="http://www.w3.org/2000/svg" style="transform:rotate(-90deg);float:left"><circle r="9" cx="10" cy="10" fill="transparent" stroke-dasharray="56.48" stroke-dashoffset="0" stroke-width="2" style="stroke:' + v.vast_progresscolor + ';opacity:0.3"></circle><circle id="pljsvastprogressbar_' + v.id + '" r="9" cx="10" cy="10" fill="transparent" stroke-dasharray="56.48" stroke-dashoffset="0" stroke-width="2" style="stroke:' + v.vast_progresscolor + ';opacity:0;-webkit-transform-origin: center center;transform-origin: center center;"></circle></svg>';
					css(uiprogress, {
						"border-radius": 30,
						"padding": 5,
						"overflow": "hidden",
						"height": "auto",
						"height": 20,
						"position": "absolute",
						"bottom": 10,
						"left": 10,
						"transform-origin": "center center",
						"transition": "background-color 0.2s linear",
						"zIndex": 1,
						"background-color": hex2rgb(v.vast_progressbgcolor, existv(v.vast_progressbga, 0.5))
					});
					uiskip = createElement("div");
					css(uiskip, {
						"padding": "3px 10px 0 12px",
						"float": "left",
						"display": "inline-block",
						"font-size": existv(v.vast_skip_size, 16) * existv(v.globalfs, 1),
						"color": v.vast_skipcolor,
						"visibilty": "hidden",
						"transition": "background-color 0.2s linear,opacity 0.2s linear",
						"display": "none",
						"zIndex": 1
					});
					uiskip.innerHTML = Lang("skip");
					if(v.vast_skip2right == 1) {
						o.vastcontainer.appendChild(uiskip);
						css(uiskip, {
							"padding": 10,
							"float": "none"
						});
						onOutSkip()
					} else {
						uiprogress.appendChild(uiskip)
					}
					uix = createElement("div");
					css(uix, {
						"position": "absolute",
						"top": -100,
						"right": 0,
						"width": 40,
						"height": 40,
						"padding": 10,
						"opacity": 0,
						"visibilty": "hidden",
						"transition": "background-color 0.2s linear,opacity 0.2s linear",
						"cursor": "pointer",
						"box-sizing": "border-box",
						"zIndex": 1
					});
					uix.innerHTML = "<svg width='20' height='20' xmlns:xlink='http://www.w3.org/1999/xlink' xmlns='http://www.w3.org/2000/svg'><g><path d='M19.25,0.75 L0.75,19.25 L19.25,0.75 Z' stroke='#FFFFFF' stroke-width='3' stroke-linecap='square' style='pointer-events:none'></path><path d='M0.75,0.75 L19.25,19.25 L0.75,0.75 Z' stroke='" + v.vast_xcolor + "' stroke-width='3' stroke-linecap='square'></path></g></svg>";
					onOutX();
					o.vastcontainer.appendChild(uix);
					uix.onclick = onClose;
					uix.addEventListener('mouseover', function() {
						css(uix, {
							"background-color": hex2rgb(v.vast_xbgcolor, existv(v.vast_xbga, 0.5) + 0.3)
						})
					});
					uix.addEventListener('mouseout', onOutX);

					function onOutX(e) {
						css(uix, {
							"background-color": hex2rgb(v.vast_xbgcolor, existv(v.vast_xbga, 0.5))
						})
					}
					if(exist(vast.extensions)) {
						if(exist(vast.extensions.skipTime)) {
							if(vast.extensions.skipTime > 0 && vast.extensions.skipTime < 100) {
								uiskip.innerHTML = Lang("skip_after_") + vast.extensions.skipTime;
								css(uiskip, {
									"cursor": "default",
									"font-size": existv(v.vast_skip2_size, 12) * existv(v.globalfs, 1),
									"display": "block"
								})
							}
						}
					}
					if(exist(vast.control_countdown) && v.vast_skip2right != 1) {
						var tmp = vast.control_countdown;
						if(tmp === "0" || tmp === "-1") {
							css(uiskip, {
								"bottom": -100
							})
						} else {
							if(tmp !== "1") {
								if(tmp == "TR") {
									css(uiprogress, {
										"bottom": "auto",
										"left": "auto",
										"top": 10,
										"right": 10
									});
									css(uix, {
										"top": 0,
										"left": 0,
										"right": "auto"
									})
								}
								if(tmp == "TL") {
									css(uiprogress, {
										"bottom": "auto",
										"top": 10,
										"left": 10
									})
								}
								if(tmp == "BR") {
									css(uiprogress, {
										"left": "auto",
										"bottom": 10,
										"right": 10
									})
								}
							}
						}
					}
					if(v.vast_skip2right == 1) {
						css(uimute, {
							"bottom": 10,
							"left": 50,
							"right": "auto"
						});
						css(uiskip, {
							"float": "none",
							"position": "absolute",
							"bottom": (v.vast_skip_bottom ? v.vast_skip_bottom : 10),
							"right": 0
						})
					}
				}
				if(v.vast_unmutebut == 1) {
					uiunmutebut = createElement("div");
					css(uiunmutebut, {
						"background": v.vast_unmutebutbgcolor,
						"padding": "11px 10px 6px 20px",
						"position": "absolute",
						"top": "50%",
						"left": -200,
						"font-size": 16 * existv(v.globalfs, 1),
						"margin": "-20px 0 0 -5px",
						"color": v.vast_unmutebutcolor,
						"cursor": "pointer"
					});
					uiunmutebut.style.zIndex = 9999;
					o.vastcontainer.appendChild(uiunmutebut);
					var unmutebuticon = muteicon;
					var rg = RegExp(v.vast_volumecolor, 'g');
					unmutebuticon = unmutebuticon.replace(rg, v.vast_unmutebutcolor);
					uiunmutebut.innerHTML = Lang("unmute_video") + ' &nbsp; <span style="float:right;margin-top:-2px">' + unmutebuticon + '</span>';
					uiunmutebut.onclick = onUnmute
				}
				if(v.vast_fullbut == 1 && v.control_full) {
					uifull = createElement("div");
					CreateUiBut(uifull, 50, 10, (o.fullscreen ? v.control_full.icon2 : v.control_full.icon), onToggleFull)
				}
				js3("vast_system", vast.adsystem);
				js3("vast_url", vast.vasturl);
				js3("vast_info", VastInfo());
				if(vast.isImg) {
					hide2(uimute);
					if(vast.isFrm) {
						var frm = document.createElement('iframe');
						frm.scrolling = "no";
						frm.onload = ImgLoaded;
						frm.src = vast.file;
						css(frm, {
							"position": "absolute",
							"top": "0",
							"left": "0",
							"width": "100%",
							"height": "100%",
							"border": 0
						});
						o.vastcontainer.appendChild(frm)
					} else {
						var image = new Image();
						image.onload = function() {
							vpaidslot.style.backgroundImage = "url('" + vast.file + "')";
							vpaidslot.style.backgroundSize = "cover";
							ImgLoaded()
						};
						image.onerror = function() {
							onError(405)
						};
						image.src = vast.file
					}
				}
				vpaidstopped = false;
				vpaidskipped = false;
				vpaidcompleted = false;
				vpaidstarted = false;
				vaststarted = false;
				vpaidvideostarted = false;
				vpaidquartile = false;
				if(vast.isVpaid) {
					if(vast.customVpaid) {
						vpaid = eval("new " + vast.customVpaid + "()");
						v.vpaid_slotinframe = 0;
						Vpaid()
					} else {
						vpaidframe = document.createElement('iframe');
						vpaidframe.id = "pljsvpaid";
						vpaidframe.allow = "autoplay";
						vpaidframe.scrolling = "no";
						vpaidframe.setAttribute('allowFullScreen', '');
						if(v.vpaid_slotinframe == 1) {
							css(vpaidframe, {
								"position": "absolute",
								"top": "0",
								"left": "0",
								"width": "100%",
								"height": "100%",
								"border": 0
							});
							hide2(vpaidslot)
						} else {
							css(vpaidframe, {
								"width": 0,
								"height": 0
							})
						}
						o.vastcontainer.appendChild(vpaidframe);
						var base = document.createElement('base');
						base.href = o.href;
						if(vpaidframe.contentWindow) {
							vpaidframe.contentWindow.document.getElementsByTagName('head')[0].appendChild(base)
						}
						vpaidframe_int = setInterval(vpaidframeloaded, 100);
						js2("vpaidframe");
						clearTimeout(vpaid_t);
						vpaid_t = setTimeout(vpaidLoadTimeout, v.vast_timeout * 1000)
					}
				}
				if(!vast.isVpaid && !vast.isImg) {
					if(youtube || vimeo) {
						CheckMuteStart()
					} else {
						tag.addEventListener('loadstart', onLoadStart);
						tag.addEventListener('error', onTagError);
						tag.addEventListener('ended', onEnded);
						tag.addEventListener('playing', onPlay);
						tag.addEventListener('timeupdate', onTimeupdate);
						tag.addEventListener('seeking', onSeeking);
						tag.addEventListener('seeked', onSeeked);
						tag.addEventListener('loadedmetadata', onMeta);
						tag.addEventListener('volumechange', onVolume);
						tag.addEventListener('waiting', onWaiting);
						tag.addEventListener('durationchange', onDuration);
						tag.addEventListener('progress', onProgress);
						attr(tag, {
							'src': x.file
						});
						if(v.vast_volume != -1) {
							tag.volume = v.vast_volume
						} else {
							tag.volume = v.volume
						}
						CheckMuteStart();
						if(v.vpaid_waitstart != 1) {
							PlayStart()
						} else {
							js('vast_readystart')
						}
					}
				}
				setTimeout(startTimeout, 500)
			}
		};

		function CreateUiBut(x, b, r, i, f) {
			css(x, {
				"position": "absolute",
				"bottom": b,
				"right": r,
				"text-align": "center",
				"cursor": "pointer",
				"transform": "scale(1)",
				"border-radius": 30,
				"height": 30,
				"width": 30,
				"padding-top": 5,
				"box-sizing": "border-box",
				"zIndex": 1,
				"transition": "background-color 0.2s linear"
			});
			x.innerHTML = i;
			o.vastcontainer.appendChild(x);
			PtrNn(x);
			SvgColor(x, '#fff');
			x.onclick = f;
			x.addEventListener('mouseover', onOverMute);
			x.addEventListener('mouseout', onOutMute);
			onOutMute(null, x)
		}

		function onOutMute(x, y) {
			var z = x ? x.target : y;
			css(z, {
				"background": hex2rgb(v.vast_volumebgcolor, existv(v.vast_volumebga, 0.5))
			})
		}

		function onOverMute(x, y) {
			var z = x ? x.target : y;
			css(z, {
				"background": hex2rgb(v.vast_volumebgcolor, existv(v.vast_volumebga, 0.5) + 0.3)
			})
		}

		function onOutSkip() {
			css((v.vast_skip2right == 1 ? uiskip : uiprogress), {
				"background-color": hex2rgb(v.vast_skipbgcolor, existv(v.vast_skipbga, 0.5))
			})
		}

		function ImgLoaded() {
			imgtime = 0;
			exist(vast.duration) ? duration = vast.duration : duration = 10;
			img_int = setInterval(onTimeupdate, 100);
			onTimeupdate();
			Event("start", true)
		}

		function PlayStart() {
			var pp = tag.play();
			if(pp !== undefined) {
				pp.then(function() {}).catch(function(e) {
					log("playError VAST", e.message);
					if(vast.pause_mute == 1) {
						Pause(true);
						o.actions.VastShow()
					} else {
						if(!die_error && !removed) {
							onMute();
							var pp2 = tag.play();
							pp2.then(function() {}).catch(function(e) {
								log("playError2 VAST", e.message);
								Pause(true);
								o.actions.VastShow()
							})
						}
					}
				})
			}
			video_t = setTimeout(tagTimeout, v.vast_timeout * 1000);
			vaststarted = true
		}

		function vpaidframeloaded() {
			try {
				if(vpaidframe.contentWindow) {
					clearInterval(vpaidframe_int);
					js2("vpaidframeloaded");
					var defaultTemplate = '<!DOCTYPE html><html><head><meta charset="UTF-8"></head><body style="margin:0;padding:0"><script type="text/javascript" src="' + vast.file + '"></script><script type="text/javascript">window.parent.postMessage("PJS_VPAID_LOADED","*");</script></body></html>';
					window.addEventListener("message", waitVpaid);
					vpaidframe.contentWindow.document.open();
					vpaidframe.contentWindow.document.write(defaultTemplate);
					vpaidframe.contentWindow.document.close()
				}
			} catch(e) {
				log("VPAID frame error");
				onError(901)
			}
		}

		function waitVpaid(e) {
			if(e.data == 'PJS_VPAID_LOADED') {
				window.removeEventListener("message", waitVpaid);
				initVpaid()
			}
		}

		function initVpaid() {
			if(vpaidframe.contentWindow) {
				var fn = vpaidframe.contentWindow['getVPAIDAd'];
				if(fn && typeof fn == 'function') {
					vpaid = fn();
					if(vpaid) {
						Vpaid()
					} else {
						onError(900)
					}
				} else {
					onError(900)
				}
			}
		}

		function CheckMuteStart() {
			if(v.vast_volume == 0 || (o.muted && v.vast_resound != 1) || vast.mute == 1 || (v.vast_unmutehover == 1 && !o.mouseHere && !o.system.mobile) || tag.muted || tag.volume == 0) {
				vast.mute != -1 ? onMute() : ''
			}
		}

		function startTimeout() {
			start_timeout = false
		}

		function onLoadStart() {}
		this.ytReady = function() {
			duration = ytag.duration();
			js3("vast_duration", duration);
			StopBuffering();
			ytinterval = setInterval(this.timeUpdate, 500);
			if(v.vast_volume == 0 || o.muted || (v.vast_unmutehover == 1 && !o.system.mobile)) {
				onMute()
			}
		};
		this.ytError = function() {
			onError()
		};
		this.ytWaiting = function() {
			onWaiting()
		};
		this.ytWaited = function() {
			StopBuffering()
		};
		this.ytEnded = function() {
			onEnded()
		};
		var die_error = false;

		function onOver() {
			if(!over) {
				if(uitxt) {
					show2(uitxt)
				}
				if(v.vast_unmutehover == 1 && !o.system.mobile) {
					onUnmute();
					if(v.vast_unmuteonce == 1) {
						v.vast_unmutehover = 0
					}
				}
			}
			over = true
		}

		function onMeta() {
			if(tag.videoHeight > 0 && v.changeheight == 1 && v.changevastheight == 1) {
				o.actions.changeAspect(tag.videoWidth / tag.videoHeight, true)
			}
		}

		function onOut() {
			if(over) {
				if(uitxt) {
					hide2(uitxt)
				}
				if(v.vast_unmutehover == 1 && !o.system.mobile) {
					clearInterval(slow_unmute);
					onMute()
				}
			}
			over = false
		}

		function onTagError() {
			var errorCode = tag.error.code;
			if(errorCode == 4) {
				onError(403)
			} else {
				onError(405)
			}
		}

		function onError(x) {
			if(!die_error && !removed) {
				die_error = true;
				log("VAST video playing error " + x);
				if(vpaid) {
					for(var eventName in vpaidCallbacks) {
						if(vpaidCallbacks.hasOwnProperty(eventName)) {
							vpaid.unsubscribe(vpaidCallbacks[eventName], eventName)
						}
					}
				}
				Event("Error", false, x > 0 ? x : 400);
				clearInterval(vpaid_int);
				clearInterval(vpaidframe_int);
				clearInterval(push_wait_int);
				RemoveTimeouts();
				o.actions.VastError()
			}
		}

		function RemoveAndPlay() {
			Event("remove");
			RemoveTimeouts();
			if(!removed) {
				removed = true;
				o.actions.VastRemoveAndPlay()
			}
		}

		function RemoveTimeouts() {
			clearTimeout(vpaid_t);
			clearTimeout(vpaid_stop_t);
			clearTimeout(vpaid_complete_t);
			clearTimeout(video_t)
		}

		function onEnded() {
			if(!vpaidcompleted) {
				Event("complete", true)
			}
			RemoveAndPlay()
		}

		function onClose() {
			Event("close", true);
			var d = new Date();
			o.clicktime = d.getTime();
			o.vastclick = true;
			gTr("vast_skip", "VAST Skip");
			v["vast_" + o.vasttype + "skipor"] == 1 ? o.actions.VastNext() : RemoveAndPlay()
		}

		function onSkip() {
			var d = new Date();
			o.clicktime = d.getTime();
			o.vastclick = true;
			log("VAST Skip");
			gTr("vast_skip", "VAST Skip");
			if(!vpaidskipped && vpaid && vast.isVpaid) {
				log("VPAID Skip request");
				vpaid.skipAd()
			} else {
				Event("skipAd", true);
				Event("skip", true);
				v["vast_" + o.vasttype + "skipor"] == 1 ? o.actions.VastNext() : RemoveAndPlay()
			}
		}

		function onInvite() {
			Event("addClick");
			Event("acceptInvitation", false);
			onClick()
		}

		function onToggleMute() {
			_muted ? onUnmute() : onMute()
		}

		function onToggleFull() {
			var x;
			if(o.fullscreen) {
				o.actions.Normalscreen();
				x = v.control_full.icon
			} else {
				o.actions.Fullscreen();
				x = v.control_full.icon2
			}
			if(x) {
				uifull.innerHTML = x;
				PtrNn(uifull)
			}
			setTimeout(VpaidResize, 500)
		}

		function PtrNn(x) {
			x ? css(x.firstElementChild, {
				"pointer-events": "none"
			}) : ''
		}

		function onMute() {
			var stop = false;
			log((vast.isVpaid ? "VPAID" : "VAST") + " Mute");
			if(youtube || vimeo) {
				ytag.Mute()
			} else {
				clearInterval(slow_unmute);
				if(!vast.isVpaid) {
					Event("mute");
					tag.muted = true
				} else {
					if(vpaid) {
						vpaid.getAdVolume() > 0 ? vpaidvolume = vpaid.getAdVolume() : vpaidvolume = v.vast_volume;
						vpaid.setAdVolume(0)
					} else {
						stop = true
					}
				}
			}
			if(!stop) {
				Unmutebut(1);
				MuteIcon(true)
			}
		}

		function MuteIcon(x) {
			_muted = x;
			if(exist(uimute)) {
				uimute.innerHTML = x ? unmuteicon : muteicon
			}
		}

		function onUnmute() {
			var stop = false;
			if(youtube || vimeo) {
				ytag.Unmute();
				Event("unmute")
			} else {
				if(!vast.isVpaid) {
					tag.muted = false;
					if(unmute_volume == 0) {
						unmute_volume = tag.volume;
						unmute_volume < 0.3 ? unmute_volume = v.vast_default_volume : ''
					}
					tag.volume = 0;
					clearInterval(slow_unmute);
					slow_unmute = setInterval(SlowUnMute, 200)
				} else {
					if(vpaid) {
						v.vpaid_mute_impression = 0;
						if(unmute_volume == 0) {
							unmute_volume = vpaidvolume;
							unmute_volume < 0.3 ? unmute_volume = v.vast_default_volume : ''
						}
						vpaid.setAdVolume(0);
						tag.muted = false;
						clearInterval(slow_unmute);
						slow_unmute = setInterval(SlowUnMute, 200)
					} else {
						stop = true
					}
				}
			}
			if(!stop) {
				Unmutebut(0);
				MuteIcon(false)
			}
		}

		function Unmutebut(x) {
			var z = uiunmutebut;
			if(v.vast_unmutebut == 1 && z) {
				var y = {
					"mc": z,
					"me": "uiunmutebut",
					"type": "left"
				};
				if(x == 1) {
					show(z);
					y['to'] = 0
				} else {
					y['to'] = -200;
					y['hide'] = true
				}
				var m = new Motion(y)
			}
		}

		function SlowUnMute() {
			v.vast_volume = unmute_volume;
			if(!vast.isVpaid) {
				if(tag.volume < unmute_volume && tag.volume < 0.95) {
					tag.volume += 0.1
				} else {
					unmute_volume = 0;
					clearInterval(slow_unmute);
					Event("unmute")
				}
			} else {
				var x = vpaid.getAdVolume();
				if(x < unmute_volume && x < 0.99) {
					vpaid.setAdVolume(parseFloat(x) + 0.1)
				} else {
					unmute_volume = 0;
					clearInterval(slow_unmute);
					Event("unmute")
				}
			}
		}

		function onTouchStart() {
			_move = false
		}

		function onTouchMove() {
			_move = true
		}

		function onScreenClick() {
			var stop = false;
			if(o.system.mobile) {
				if(_move) {
					stop = true
				}
			}
			removed ? stop = true : '';
			if(!stop) {
				if(paused) {
					Resume()
				} else {
					onClick()
				}
			}
			v.vast_unmuteonclick == 1 ? onUnmute() : ''
		}

		function onClick(z) {
			if(!start_timeout) {
				var d = new Date();
				o.clicktime = d.getTime();
				Event("click");
				if(v.vast_addclick == 1 || z) {
					Event("addClick")
				}
				gTr("vast_click", "VAST Click");
				var x = false;
				if(exist(vast.click)) {
					if(vast.click != '') {
						var tmp = ['ref', 'referer', 'host'];
						for(var i = 0; i < tmp.length; i++) {
							vast.click = vast.click.replace(new RegExp('\\(' + tmp[i] + '\\)', "gi"), (tmp[i] == "host" ? encodeURIComponent(o.domain) : Href()))
						}
						js2("vast_clickurl", vast.click);
						v.vast_openclick == 1 ? window.open(vast.click, '_blank') : '';
						x = true
					}
				}
				if(v.vast_pauseonclick == 1) {
					Pause(x)
				} else {
					if(v.vast_closeonclick == 1) {
						x ? o.actions.VastRemoveAndPlay(v.vast_playonclick == 1 ? '' : 'dontplay') : ''
					}
				}
			}
		}

		function onPlay() {
			onTimeupdate();
			Event("start", true)
		}

		function onPause() {
			Pause(true)
		}

		function Pause(x) {
			if(vast.isVpaid) {
				if(vpaid) {
					vpaid.pauseAd();
					if(controls) {
						show2(uiplay)
					}
					paused = true
				}
			}
			if(vast.isImg) {
				clearInterval(img_int);
				if(controls) {
					show2(uiplay)
				}
				paused = true
			}
			if(!vast.isVpaid && !vast.isImg) {
				if(x) {
					if(youtube || vimeo) {
						ytag.Pause()
					} else {
						tag.pause()
					}
					Event("pause");
					show2(uiplay);
					paused = true
				}
			}
			if(uitxt) {
				hide2(uitxt)
			}
			StopBuffering();
			log("VAST pause")
		}

		function Resume() {
			if(paused) {
				if(vast.isVpaid) {
					if(vpaid) {
						vpaid.resumeAd();
						hide2(uiplay);
						paused = false
					}
				}
				if(vast.isImg) {
					img_int = setInterval(onTimeupdate, 100);
					onTimeupdate();
					hide2(uiplay);
					paused = false
				}
				if(!vast.isVpaid && !vast.isImg) {
					if(youtube || vimeo) {
						ytag.Play()
					} else {
						tag.play()
					}
					Event("resume");
					hide2(uiplay);
					paused = false
				}
				if(uitxt) {
					show2(uitxt)
				}
				log("VAST resume")
			}
		}
		this.timeUpdate = function() {
			onTimeupdate()
		};

		function CurrentTime() {
			var t = 0;
			if(youtube || vimeo) {
				t = ytag.time()
			} else {
				if(vast.isImg) {
					t = imgtime;
					imgtime += 0.1
				} else {
					t = tag.currentTime
				}
			}
			return t
		}

		function CurrentVolume() {
			if(vast) {
				if(!vast.isVpaid) {
					return tag.muted ? 0 : tag.volume
				} else {
					if(vpaid) {
						var x = -1;
						try {
							x = vpaid.getAdVolume()
						} catch(e) {
							log(e)
						}
						return x
					}
				}
			}
		}

		function onTimeupdate(e) {
			if(tag && !removed) {
				var t = CurrentTime();
				if(!impression) {
					onImpression();
					impression = true
				}
				if(!qrts[0]) {
					if(t > duration / 4) {
						Event("firstQuartile", true);
						qrts[0] = true
					}
				}
				if(!qrts[1]) {
					if(t > duration / 2) {
						Event("midpoint", true);
						qrts[1] = true
					}
				}
				if(!qrts[2]) {
					if(t > (duration / 4) * 3) {
						Event("thirdQuartile", true);
						qrts[2] = true
					}
				}
				if(exist(vast.progresstimes)) {
					for(var i = 0; i < vast.progresstimes.length; i++) {
						if(t >= vast.progresstimes[i]) {
							Event("progress_" + vast.progresstimes[i], true)
						}
					}
				}
				onTimeupdateExtensions(t);
				if(t > 0 && t > last_time) {
					StopBuffering()
				}
				if(o.vasttype == undefined) {
					if(vast.adsystem == "intro") {
						o.vasttype = "preroll"
					}
					if(vast.adsystem == "outro") {
						o.vasttype = "postroll"
					}
				}
				if(vast.isImg) {
					if(t > duration) {
						onEnded()
					}
				}
				last_time = t
			}
		}
		var tu0 = true;

		function onTimeupdateExtensions(x) {
			js3("vast_time", x);
			if(vast.isVpaid && tu0) {
				tu0 = false;
				if(x < duration - 2 && duration > 0) {
					return
				}
			}
			if(exist(vast.extensions)) {
				if(exist(vast.events.sec) && !vpaidcompleted) {
					for(var i = 0; i < vast.events.sec.length; i++) {
						if(x >= vast.events.sec[i] && vast.events.sec[i] > -1) {
							Event("second" + vast.events.sec[i], true);
							vast.events.sec[i] -= 1000
						}
					}
				}
				UpdateSkipTimes(x)
			}
			if(controls && duration > 0) {
				var val = parseInt(x / duration * 100);
				var circle = document.getElementById("pljsvastprogressbar_" + v.id);
				if(circle) {
					if(isNaN(val)) {
						val = 100
					} else {
						var r = circle.getAttribute('r');
						var c = Math.PI * (r * 2);
						if(val < 0) {
							val = 0
						}
						if(val > 100) {
							val = 100
						}
						var pct = ((100 - val) / 100) * c;
						css(circle, {
							"opacity": 1,
							"strokeDashoffset": pct
						})
					}
				}
			}
		}

		function UpdateSkipTimes(x) {
			if(exist(vast.extensions) && controls && x >= last_skiptime) {
				var chkskp;
				if(exist(vast.extensions.skipTime)) {
					if(vast.extensions.skipTime > -1 && vast.extensions.skipTime < 100 && uiskip) {
						chkskp = true;
						if(x > vast.extensions.skipTime) {
							js3("vast_skipTime", vast.extensions.skipTime);
							ShowSkip();
							vast.extensions.skipTime = null
						} else {
							uiskip.innerHTML = Lang("skip_after_") + (Math.round(vast.extensions.skipTime - x))
						}
					}
				}
				if(exist(vast.extensions.skipTime2)) {
					if(vast.extensions.skipTime2 > -1) {
						if(chkskp) {
							if(vast.extensions.skipTime2 < vast.extensions.skipTime) {
								vast.extensions.skipTime2 = vast.extensions.skipTime
							}
						}
						if(x > vast.extensions.skipTime2) {
							js3("vast_skipTime2", vast.extensions.skipTime2);
							Event("skipTime2");
							uix ? css(uix, {
								"top": 0,
								"opacity": 1,
								"display": "block"
							}) : '';
							vast.extensions.skipTime2 = null
						}
					}
				}
				last_skiptime = x
			}
		}

		function ShowSkip() {
			if(uiskip && !removed) {
				uiskip.innerHTML = Lang("skip");
				css(uiskip, {
					"cursor": "pointer",
					"font-size": (v.vast_skip_size ? v.vast_skip_size : 16) * existv(v.globalfs, 1),
					"display": "block"
				});
				if(v.vast_skip2right == 1) {
					uiskip.onclick = onSkip;
					uiskip.addEventListener('mouseover', function() {
						css(uiskip, {
							"background-color": hex2rgb(v.vast_skipbgcolor, existv(v.vast_skipbga, 0.5) + 0.3)
						})
					});
					uiskip.addEventListener('mouseout', onOutSkip)
				} else {
					if(uiprogress) {
						css(uiprogress, {
							"cursor": "pointer"
						});
						uiprogress.onclick = onSkip;
						uiprogress.addEventListener('mouseover', function() {
							css(uiprogress, {
								"background-color": hex2rgb(v.vast_skipbgcolor, existv(v.vast_skipbga, 0.5) + 0.3)
							})
						});
						onOutSkip();
						uiprogress.addEventListener('mouseout', onOutSkip)
					}
				}
			}
		}

		function onSeeking() {}

		function onSeeked() {}

		function onImpression() {
			if(!die_error && !removed) {
				Event("Impression", true);
				Event("Impress", true);
				Event("creativeView", true);
				gTr("vast_impression", "VAST Impression");
				ImpressionActions()
			}
		}

		function ImpressionActions() {
			var y = (vast.adsystem == "intro" || vast.adsystem == "outro" ? "intro" : o.vasttype);
			o.actions.VastImpression(vast.skipimp == 1);
			if(v["vast_" + y + "timebreak"] > 0) {
				StoreImpression(y)
			}
			if(exist(o.visibility)) {
				if(o.visibility > 70) {
					Event("Viewable")
				} else {
					Event("NotViewable")
				}
			} else {
				Event("NotViewable")
			}
			o.vast_impressions++;
			o.vast_impressions_all++;
			o.vast_longtomsg ? o.vast_longtomsg.remove() : '';
			_muted ? Unmutebut(1) : '';
			impression = true;
			o.vast_stop == 1 ? o.vast_stop = 2 : '';
			o.vast_poster ? o.vast_poster.hide() : '';
			o.vast_loadtxt ? o.vast_loadtxt.hide() : '';
			StopBuffering()
		}

		function onDuration() {
			Event("AdLoaded", true);
			duration = tag.duration;
			js3("vast_duration", duration)
		}

		function onVolume() {
			js3("vast_volume", VastInfo())
		}

		function onProgress(event) {}
		var vpaidCallbacks = {
			AdStarted: vpaidStartAd,
			AdStopped: vpaidStopAd,
			AdSkipped: vpaidSkipAd,
			AdLoaded: vpaidAdLoaded,
			AdLinearChange: vpaidAdLinearChange,
			AdSizeChange: vpaidAdSizeChange,
			AdExpandedChange: vpaidAdExpandedChange,
			AdSkippableStateChange: vpaidAdSkippableStateChange,
			AdDurationChange: vpaidAdDurationChange,
			AdRemainingTimeChange: vpaidAdRemainingTimeChange,
			AdVolumeChange: vpaidAdVolumeChange,
			AdImpression: vpaidAdImpression,
			AdClickThru: vpaidAdClickThru,
			AdInteraction: vpaidAdInteraction,
			AdVideoStart: vpaidAdVideoStart,
			AdVideoFirstQuartile: vpaidAdVideoFirstQuartile,
			AdVideoMidpoint: vpaidAdVideoMidpoint,
			AdVideoThirdQuartile: vpaidAdVideoThirdQuartile,
			AdVideoComplete: vpaidAdVideoComplete,
			AdUserAcceptInvitation: vpaidAdUserAcceptInvitation,
			AdUserMinimize: vpaidAdUserMinimize,
			AdUserClose: vpaidAdUserClose,
			AdPaused: vpaidAdPaused,
			AdPlaying: vpaidAdPlaying,
			AdError: vpaidAdError,
			AdErrorVpaid: vpaidAdErrorVpaid,
			AdLog: vpaidAdLog,
			AdViewable: vpaidAdViewable
		};

		function Vpaid() {
			if(typeof vpaid.handshakeVersion == "function") {
				for(var e in vpaidCallbacks) {
					if(vpaidCallbacks.hasOwnProperty(e)) {
						vpaid.subscribe(vpaidCallbacks[e], e, this)
					}
				}
				if(vast.vpdevnts) {
					for(var i = 0; i < vast.vpdevnts.length; i++) {
						if(vast.vpdevnts[i] != '') {
							eval("function pjsvpd_" + vast.vpdevnts[i] + "(){Event('" + vast.vpdevnts[i] + "');}");
							vpaid.subscribe(eval('pjsvpd_' + vast.vpdevnts[i]), vast.vpdevnts[i], this)
						}
					}
				}
				if(v.vpaid_slotinframe == 1 && vpaidframe) {
					vpaidslot2 = document.createElement("div");
					vpaidframe.contentDocument.body.appendChild(vpaidslot2);
					css(vpaidslot2, {
						"position": "absolute",
						"top": "0",
						"left": "0",
						"width": "100%",
						"height": "100%",
						"cursor": "pointer"
					})
				}
				vpaid.initAd(o.screen_w, o.screen_h, (o.fullscreen ? 'fullscreen' : 'normal'), 720, (exist(vast.adparameters) ? {
					"AdParameters": vast.adparameters
				} : ''), {
					"slot": (v.vpaid_slotinframe == 1 ? vpaidslot2 : vpaidslot),
					"videoSlot": tag,
					'videoSlotCanAutoPlay': true
				});
				css(vpaidslot, {
					"cursor": "pointer"
				});
				vpaidslot.style.zIndex = 0
			} else {
				log("VPAID incorrect");
				onError(901)
			}
		};

		function vpaidAdLog(x) {
			log("VPAID Log: " + x)
		}

		function vpaidAdViewable() {
			Event("viewable", true)
		}

		function vpaidAdError(x) {
			if(!vpaidcompleted) {
				log("VPAID Error", x);
				if(typeof x == "object" && v.log == 1) {
					console.log(x)
				}
				onError(901)
			} else {
				log("VPAID Error but completed", x);
				vpaidStopAd()
			}
		}

		function vpaidAdErrorVpaid(x) {
			if(!vpaidcompleted) {
				log("VPAID Error", x);
				Event("Error", false, x > 0 ? x : 400)
			}
		}

		function vpaidAdLoaded() {
			if(v["vast_" + o.vasttype + "normal"] == 1 && o.fullscreen) {
				o.actions.Normalscreen()
			}
			log("VPAID Loaded, ad " + vpaid.getAdLinear());
			Event("AdLoaded", true);
			if(vpaid.getAdLinear() != 'nonlinear') {
				if(v.vpaid_waitstart != 1) {
					StartVpaidVolume();
					clearTimeout(vpaid_t);
					vpaid_t = setTimeout(vpaidVideoTimeout, v.vpaid_timeout * 1000);
					vpaid.startAd()
				} else {
					js('vast_readystart')
				}
				clearInterval(vpaid_int2);
				vpaid_int2 = setInterval(vpaidAdRemainingTimeChange, 1000);
				vpaidAdRemainingTimeChange()
			} else {
				vpaidAdError("Nonlinear")
			}
		}

		function StartVpaidVolume() {
			if(vpaid) {
				if(v.vast_volume == 0 || vast.mute == 1 || (v.vast_unmutehover == 1 && !o.system.mobile && o.mouseHere != 1)) {
					if(vpaid.getAdVolume() > 0 && vast.mute != -1) {
						onMute()
					}
				} else {
					if(v.vast_volume != -1) {
						vpaid.setAdVolume(parseFloat(v.vast_volume))
					} else {
						vpaid.setAdVolume(parseFloat(v.volume))
					}
				}
			}
		}

		function StopBuffering() {
			if(vast.buffering) {
				uibuffer ? hide2(uibuffer) : '';
				vast.buffering = false;
				clearInterval(push_wait_int)
			}
		}

		function onWaiting() {
			uibuffer ? show2(uibuffer) : '';
			vast.buffering = true;
			if(v.vast_push_waiting == 1) {
				clearInterval(push_wait_int);
				push_wait_int = setInterval(PushWaiting, 1500)
			}
		}

		function PushWaiting() {
			last_skiptime = last_skiptime + 1;
			UpdateSkipTimes(last_skiptime)
		}

		function vpaidStartAd() {
			vpaidstarted = true;
			v.vpaidvideotimeout != 1 ? vpaidvideostarted = true : '';
			duration = vpaid.getAdDuration();
			var rt = vpaid.getAdRemainingTime();
			if(duration > 0) {} else {
				if(exist(vast.duration)) {
					if(vast.duration >= rt) {
						duration = vast.duration
					}
				}
			}
			if(duration >= 5000) {
				duration = duration / 1000
			}
			js3("vast_duration", duration);
			o.vast_poster ? o.vast_poster.hide() : '';
			o.vast_loadtxt ? o.vast_loadtxt.hide() : '';
			js_events = [];
			imps = [];
			qrts = [];
			log("VPAID Started");
			var x;
			if(indOf([vast.wrapper, vast.vasturl], 'pjsvvs=1')) {
				x = true
			}
			v.vast_visibleonstart == 1 && !vast.skipimp && !x ? o.actions.VpaidStarted() : '';
			Event("creativeView", true);
			StopBuffering()
		}

		function vpaidVideoTimeout() {
			if(!vpaidvideostarted && !die_error) {
				log("VPAID timeout");
				js3("vpaid_video_timeout", VastInfo());
				onError(901)
			}
		}

		function vpaidQuartileTimeout() {
			if(!vpaidquartile && !die_error) {
				if(v.vpaid_mute_impression == 0 && paused) {} else {
					log("VPAID quartile timeout");
					js3("vpaid_quartile_timeout", VastInfo());
					onError(901)
				}
			}
		}

		function vpaidStoppedTimeout() {
			if(!vpaidstopped && !die_error) {
				log("VPAID stopped timeout");
				js3("vpaid_stopped_timeout", VastInfo());
				if(!removed) {
					impression ? vpaidStopAd() : onError(901)
				}
			}
		}

		function tagTimeout() {
			if(tag) {
				if(!die_error && tag.currentTime == 0 && duration == 0) {
					log("VAST video loading timeout");
					js3("vast_video_timeout", VastInfo());
					onError(402)
				}
			}
		}

		function vpaidLoadTimeout() {
			if(!vpaidvideostarted && !die_error && v.vpaid_waitstart != 1) {
				log("VPAID loading timeout");
				js3("vpaid_loading_timeout", VastInfo());
				onError(901)
			}
		}

		function vpaidStopAd() {
			if(!removed) {
				if(!vpaidstopped) {
					log("VPAID Stopped");
					vpaidstopped = true;
					if(!removed && !impression) {
						if(vpaidstarted && duration > 0 && remainigs > 75 && exist(vast.prt)) {
							vpaidImpression()
						}
						log("VPAID No impression --> Error (" + remainigs + ")");
						onError(901)
					} else {
						if(vpaidcompleted || vpaidskipped) {
							RemoveAndPlay()
						} else {
							remove_t = setTimeout(RemoveAndPlay, 200)
						}
					}
				}
			}
		}

		function vpaidSkipAd() {
			log("VPAID Skipped");
			vpaidskipped = true;
			onSkip()
		}

		function vpaidAdSizeChange() {
			log("VPAID SizeChanged: " + vpaid.getAdWidth() + " x " + vpaid.getAdHeight());
			if(vpaid.getAdHeight() > 0 && vpaid.getAdWidth() > 0 && v.changeheight == 1 && v.changevastheight == 1) {
				o.actions.changeAspect(vpaid.getAdWidth() / vpaid.getAdHeight(), true)
			}
		}

		function vpaidAdExpandedChange() {
			log("VPAID ExpandedChange: " + vpaid.getAdExpanded())
		}

		function vpaidAdSkippableStateChange() {
			if(controls) {
				log("VPAID AdSkippableStateChange: " + vpaid.getAdSkippableState());
				if(vpaid.getAdSkippableState()) {
					ShowSkip()
				} else {
					hide2(uiskip)
				}
			}
		}

		function vpaidAdDurationChange() {
			log("VPAID DurationChanged: " + vpaid.getAdDuration());
			if(vpaid.getAdDuration() > 0) {
				duration = vpaid.getAdDuration();
				js3("vast_duration", duration)
			}
		}

		function vpaidAdRemainingTimeChange(event) {
			var dr = vpaid.getAdDuration();
			if(event) {
				clearInterval(vpaid_int2)
			}
			var rt = vpaid.getAdRemainingTime();
			if(dr > 0 && dr != duration) {
				vpaidAdDurationChange()
			}
			remainigs++;
			if(duration == 0 || rt > duration) {
				if(rt > 0) {
					duration = rt;
					js3("vast_duration", duration)
				}
			}
			if(rt > 0) {
				if(duration > 0) {
					onTimeupdateExtensions(duration - rt)
				}
			} else {
				if(v.vpaid_noremainingtime == 1) {
					log("VPAID time", remainigs - 1, rt, duration);
					onTimeupdateExtensions(remainigs - 1)
				}
			}
		}

		function vpaidAdVolumeChange() {
			if(vpaid.getAdVolume() != undefined) {
				if(vpaid.getAdVolume() == 0) {
					Event("mute");
					vpaidvolume2 = 0;
					MuteIcon(true)
				} else {
					if(vpaidvolume2 == 0) {
						Event("unmute");
						MuteIcon(false)
					}
					vpaidvolume2 = vpaid.getAdVolume()
				}
			}
			log("VPAID VolumeChanged: " + vpaid.getAdVolume());
			if(vpaidvolume2 > 0 && v.vpaid_mute_impression == 1 && !impression) {
				onMute()
			}
		}

		function vpaidAdImpression() {
			if(vast.vpaidImOnVdSrt != 1) {
				vpaidImpression()
			}
		}

		function vpaidImpression() {
			vpaidcompleted = false;
			log("VPAID Impression", duration);
			Event("Impression");
			Event("Impress");
			ImpressionActions();
			gTr("vast_impression", "VAST Impression");
			if(v.vpaid_timeout2 > -1) {
				clearTimeout(vpaid_t);
				vpaid_t = setTimeout(vpaidVideoTimeout, v.vpaid_timeout2 * 1000)
			}
			if(v.vpaid_mute_impression == 1) {
				onMute()
			}
		}

		function vpaidAdClickThru(x, y, z) {
			log("VPAID ClickThru");
			if(exist(x)) {
				if(typeof x == "string") {
					if(x.indexOf('//') > -1 && z == true) {
						vast.click = x
					}
				}
			}
			if(exist(vast.extensions.isClickable)) {
				if(vast.extensions.isClickable == 1) {
					onClick(true)
				} else {
					Event("click");
					Event("addClick")
				}
			} else {
				onClick(true)
			}
		}

		function vpaidAdInteraction() {}

		function vpaidAdVideoStart() {
			if(vast.vpaidImOnVdSrt == 1) {
				vpaidImpression()
			}
			log("VPAID AdVideoStart");
			o.actions.VpaidStarted();
			vpaidvideostarted = true;
			clearTimeout(vpaid_t);
			if(v.vpaid_timeout3 > -1) {
				vpaid_t = setTimeout(vpaidQuartileTimeout, v.vpaid_timeout3 * 1000)
			}
			clearTimeout(vpaid_stop_t);
			if(v.vpaid_timeout4 > -1) {
				vpaid_stop_t = setTimeout(vpaidStoppedTimeout, v.vpaid_timeout4 * 1000)
			}
			if(v.vpaid_mute_impression == 1) {
				onMute()
			}
			Event("start", false);
			o.vpaid_starts++;
			if(v.vpaid_startlimit > 0) {
				if(o.vpaid_starts > v.vpaid_startlimit) {
					log("VPAID start limit");
					onError()
				}
			}
		}

		function vpaidAdVideoFirstQuartile() {
			vpaidquartile = true;
			log("VPAID firstQuartile");
			Event("firstQuartile", false)
		}

		function vpaidAdVideoMidpoint() {
			log("VPAID midpoint");
			Event("midpoint", false)
		}

		function vpaidAdVideoThirdQuartile() {
			log("VPAID thirdQuartile");
			Event("thirdQuartile", false)
		}

		function vpaidAdVideoComplete() {
			if(!vpaidcompleted) {
				Event("complete", false);
				vpaidcompleted = true;
				for(var y in vast.events) {
					if(vast.events.hasOwnProperty(y)) {
						if(y.indexOf("old_") == 0) {
							vast.events[y.substr(4)] = vast.events[y]
						}
					}
				}
				if(exist(vast.events.sec)) {
					for(var i = 0; i < vast.events.sec.length; i++) {
						vast.events.sec[i] += 1000
					}
				}
				if(v.vpaid_timeout5 > -1) {
					clearTimeout(vpaid_complete_t);
					vpaid_complete_t = setTimeout(vpaidStoppedTimeout, v.vpaid_timeout5 * 1000)
				}
			}
			log("VPAID complete")
		}

		function vpaidAdLinearChange() {
			log("VPAID linear has changed: " + vpaid.getAdLinear())
		}

		function vpaidAdUserAcceptInvitation() {
			Event("acceptInvitation", false)
		}

		function vpaidAdUserMinimize() {}

		function vpaidAdUserClose() {
			var d = new Date();
			o.clicktime = d.getTime();
			Event("close", true);
			o.vastclick = true;
			gTr("vast_skip", "VAST Skip")
		}

		function vpaidAdPaused() {
			if(vast.isVpaid && vpaidcompleted) {} else {
				Event("pause");
				if(v.vpaid_nopause == 1) {
					vpaid.resumeAd()
				} else {
					if(controls && v.vast_pauseonclick == 1) {
						show2(uiplay)
					}
					paused = true
				}
			}
		}

		function vpaidAdPlaying() {
			Event("resume");
			if(controls && exist(uiplay)) {
				hide2(uiplay)
			}
			paused = false
		}

		function StoreImpression(y) {
			if(v["vast_" + y + "timebreak"] > 0 && o.storage) {
				var tbi = localStorage.getItem("pljs" + y + "i_" + o.d) * 1;
				var z = false;
				if(tbi) {
					tbi + 1 >= v["vast_" + y + "tbimp"] ? z = true : ''
				} else {
					tbi = 0
				}
				if(z || o.vast_impressions_all + 1 >= v["vast_" + y + "tbimp"]) {
					var x = new Date();
					localStorage.setItem("pljs" + y + "_" + o.d, x.getTime());
					localStorage.setItem("pljs" + y + "i_" + o.d, 0);
					o.actions.EmptyVastUrl()
				} else {
					localStorage.setItem("pljs" + y + "i_" + o.d, tbi + 1)
				}
			}
		}

		function Event(x, del, code, justcode) {
			if(x == "start") {
				o.vast_started = true;
				v.miniwithvast == 1 && o.minify ? o.minify.Check() : ''
			}
			if(exist(vast.prt) && v.eventstrackervast == 0 && v.vpaid != 1) {} else {
				if(del) {
					if(!exist(js_events[x])) {
						js3("vast_" + x, VastInfo())
					}
					js_events[x] = true
				} else {
					code > 0 ? js3(("vast_" + x), code) : js3("vast_" + x, VastInfo())
				}
			}
			if(exist(vast.events)) {
				if(exist(vast.events[x])) {
					log("VAST Event " + x);
					for(var i = 0; i < vast.events[x].length; i++) {
						var z = vast.events[x][i];
						var stop = false;
						if(exist(z)) {
							if(imps.indexOf(z) > -1) {
								stop = true
							}
							if(x == "Impression") {
								imps.push(z)
							}
							if(code > 0) {
								if(z.indexOf("[ERRORCODE]") > 0) {
									z = z.replace("[ERRORCODE]", code)
								} else {
									justcode == 1 ? stop = true : ''
								}
							}
							if(z.indexOf("(visibility)") > 0) {
								if(exist(o.visibility)) {
									z = z.replace("(visibility)", o.visibility)
								}
							}
							if(z.indexOf("(volume)") > 0) {
								z = z.replace("(volume)", CurrentVolume())
							}
							z = z.replace("(adblock)", (o.ab ? 1 : 0));
							z = z.replace(/\(random\)/g, Math.random());
							if(z.indexOf(".pjstat") > 0) {
								var m = 0;
								z = z + "&m=" + (o.system.tv ? 2 : (o.system.mobile ? 1 : 0)) + ("&h=" + (exist(v.parent_domain) ? v.parent_domain : o.domain)) + (o.vasttype == 'overlay' || vast.isFrm ? '&r=1' : '') + '&s=' + o.sessid
							}
							if(typeof v.vast_replace == "object") {
								for(var y in v.vast_replace) {
									if(v.vast_replace.hasOwnProperty(y)) {
										for(var j = 0; j < 5; j++) {
											z = z.replace(y, v.vast_replace[y])
										}
									}
								}
							}
						} else {
							stop = true
						}
						if(!stop) {
							gif(z)
						}
					}
					if(del) {
						vast.events["old_" + x] = vast.events[x];
						vast.events[x] = undefined
					}
				}
			}
			if(x == "click" && v.vast_addclick == 1) {
				Event("addClick")
			}
		};

		function js2(x) {
			if(vast.adsystem != "intro" && vast.adsystem != "outro") {
				js(x)
			}
		}

		function js3(x, y) {
			if((exist(vast.prt) && v.eventstrackervast == 0 && v.vpaid != 1) || vast.adsystem == "intro" || vast.adsystem == "outro") {} else {
				js(x, y)
			}
		}

		function gTr(x, y) {
			if(vast.adsystem == "intro" || vast.adsystem == "outro") {} else {
				gaTracker(x, y)
			}
		}
		this.config = function(x) {
			return vast ? vast[x] : false
		};
		this.tagLive = function() {
			var x = false;
			if(tag) {
				if(tag.parentElement) {
					try {
						if(tag.parentElement.nodeName == "PJSDIV") {
							x = true
						}
					} catch(e) {
						x = false
					}
				}
			}
			if(vast) {
				if(vast.isVpaid) {
					return false
				}
			}
			return x
		};
		this.info = function(x) {
			return vast ? vast[x] : false
		};
		this.active = function() {
			return !removed
		};
		this.Resize = function() {
			VpaidResize()
		};

		function VpaidResize() {
			if(vast) {
				if(vast.isVpaid) {
					if(vpaid) {
						vpaid.resizeAd(o.screen_w, o.screen_h, (o.fullscreen ? 'fullscreen' : 'normal'))
					}
				}
			}
		}

		function RemoveInterface() {
			RemoveControl('uiplay');
			if(tag) {
				if(tag.played.length > 0) {
					tag.pause()
				}
			}
			if(controls && o.vastcontainer.contains(uix)) {
				if(v.vast_title == 1) {
					RemoveControl('uit')
				}
				var cntrls = ['uiprogress', 'uiskip', 'uix', 'uitxt', 'uitxt', 'uimute', 'uifull', 'uiposter', 'uiunmutebut'];
				for(var i = 0; i < cntrls.length; i++) {
					RemoveControl(cntrls[i])
				}
			}
		};

		function RemoveControl(x) {
			if(exist(eval(x))) {
				if(o.vastcontainer.contains(eval(x))) {
					if(x == 'uitxt') {
						uitxt.removeEventListener('click', onInvite)
					}
					o.vastcontainer.removeChild(eval(x));
					eval(x + ' = null;')
				}
			}
		}
		this.getVolume = function() {
			return CurrentVolume()
		};
		this.pause = function() {
			if(!removed && !paused && vast) {
				Pause(true);
				return true
			} else {
				return false
			}
		};
		this.resume = function() {
			if(!removed && paused && vast) {
				Resume();
				return true
			} else {
				return false
			}
		};
		this.VpaidSet = function(x, y) {
			if(vast) {
				if(x == "setAdVolume") {
					if(y == 0) {
						onMute()
					} else {
						onUnmute()
					}
				}
				if(x == "stopAd") {
					RemoveAndPlay()
				}
				if(x == "startAd") {
					VpaidSetStartAd()
				}
				if(x == "skipAd") {
					onSkip()
				}
				if(x == "pauseAd") {
					onPause()
				}
				if(x == "resumeAd") {
					onPlay()
				}
			}
		};

		function VpaidSetStartAd() {
			if(!vast.isVpaid) {
				!vaststarted ? PlayStart() : ''
			} else {
				!vpaidstarted && vpaid ? vpaid.startAd() : ''
			}
		}
		this.startAd = function() {
			if(v.vpaid_waitstart == 1 && !vpaidstarted) {
				vast.isVpaid && vpaid ? StartVpaidVolume() : '';
				VpaidSetStartAd()
			}
		};
		this.mute = function() {
			onMute()
		};
		this.imp = function(x) {
			if(impression && !removed) {
				var y = x.split(',');
				for(var i = 0; i < y.length; i++) {
					gif(y[i])
				}
			}
		};
		this.RemoveForNextAd = function() {
			if(youtube || vimeo) {
				clearInterval(ytinterval);
				ytag.Remove()
			}
			if(vast) {
				RemoveInterface();
				if(vast.isVpaid) {
					if(exist(vpaidslot)) {
						if(!vpaidstopped && vpaid && vpaidstarted) {
							try {
								vpaid.stopAd()
							} catch(e) {
								log(e)
							}
						}
						if(vpaid) {
							for(var eventName in vpaidCallbacks) {
								if(vpaidCallbacks.hasOwnProperty(eventName)) {
									vpaid.unsubscribe(vpaidCallbacks[eventName], eventName)
								}
							}
						}
						if(o.vastcontainer.contains(vpaidslot) && vast.hidevpaid != 1) {
							o.vastcontainer.removeChild(vpaidslot)
						}
					}
					clearInterval(vpaid_int);
					clearInterval(vpaid_int2);
					clearInterval(vpaidframe_int);
					clearInterval(push_wait_int);
					RemoveTimeouts();
					if(vast.hidevpaid != 1 && vpaidframe) {
						try {
							o.vastcontainer.removeChild(vpaidframe)
						} catch(e) {}
					}
				} else {
					hide(tag)
				}
				onWaiting()
			}
			if(exist(vpaidslot)) {
				clearInterval(img_int);
				if(o.vastcontainer.contains(vpaidslot) && vast.hidevpaid != 1) {
					o.vastcontainer.removeChild(vpaidslot)
				}
			}
			if(vast) {
				vast.events = []
			}
			removed = true;
			impression = false;
			remainigs = 0;
			mp3 = false;
			imps = [];
			qrts = []
		};
		this.waitGo = function(x) {
			vast = x
		};
		this.Remove = function() {
			try {
				if(o.vastcontainer.contains(tag)) {
					o.vastcontainer.removeChild(tag)
				}
			} catch(e) {}
			this.RemoveForNextAd();
			removed = true;
			try {
				if(o.frame.contains(o.vastcontainer) && vast.hidevpaid != 1) {
					o.frame.removeChild(o.vastcontainer)
				}
				if(vast.hidevpaid == 1) {
					hide2(o.vastcontainer)
				}
			} catch(e) {}
		}
	};
	var Settings = function(is) {
		var i;
		var style = [];
		var f = [];
		var fbg = [];
		var fimg = [];
		var ftitle = [];
		var fvalue = [];
		var faction = [];
		var f2 = [];
		var f2bg = [];
		var f2img = [];
		var f2title = [];
		var f2value = [];
		var f2action = [];
		var stout = [];
		var is_visible = false;
		var open_action;
		var open_settings = -1;
		var empty = true;
		var key = is;
		var playlist;
		var shuffle = [];
		var shuffle_ = [];
		var plid = '';
		var plfolder = '';
		var plx = -1;
		var sub_settings_on = false;
		var sub_settings = false;
		var autonextopenfolder = false;
		var autoprevopenfolder = false;
		var justshow = false;
		var removed = false;
		var showinterval;
		var arrinterval;
		var wheelinterval;
		var hidetimeout;
		var settimer;
		var shr = [];
		var clr = [];
		var iclr = 0;
		var _cstm = 0;
		var srch;
		var evntclk = "click";
		var evntovr = (o.system.mobile ? "touchstart" : "mouseover");
		var evntout = (o.system.mobile ? "touchend" : "mouseout");
		style = UpdateObject(style, v[is]);
		style = MarginPadding(v[is], 'margin', 'margin');
		style = MarginPadding(v[is], 'marginproc', 'marginproc');
		style = MarginPadding(v[is], 'mrgnprs', 'mrgnprs');
		if(style.marginbg == 0) {
			style.marginbgpadding = "0 0 0 0"
		}
		style = MarginPadding(v[is], 'bgpadding', 'marginbgpadding');
		style = MarginPadding(v[is], 'padding', 'padding');
		style.scrollwidth = 0;
		var _activeIcon = "<svg style='margin-top:3px' width='" + style.activeiconsize * 2 + "' height='" + (style.activeiconsize * 2 > style.valuefontsize ? (style.activeiconsize * 2) : style.valuefontsize) + "' xmlns:xlink='http://www.w3.org/1999/xlink' xmlns='http://www.w3.org/2000/svg'><g><ellipse ry='" + (style.activeiconsize) + "' rx='" + style.activeiconsize + "' cy='" + (style.activeiconsize * 2 > style.valuefontsize ? (style.activeiconsize) : (style.valuefontsize / 2)) + "' cx='" + style.activeiconsize + "' fill='#" + style.valuecolor + "'/></g></svg>";
		var _xIcon = "<svg width='" + style.activeiconsize * 2 + "' height='" + style.valuefontsize + "' xmlns:xlink='http://www.w3.org/1999/xlink' xmlns='http://www.w3.org/2000/svg' ><g><ellipse ry='" + (style.activeiconsize - 1) + "' rx='" + (style.activeiconsize - 1) + "' cy='" + (style.valuefontsize / 2 + 2) + "' cx='" + style.activeiconsize + "' stroke='#" + style.valuecolor + "' stroke='1' fill-opacity='0'/></g></svg>";
		var xx = 4;
		var _nextIcon = "<pjsdiv style='display:inline-block;'><svg width='" + (xx + 2) + "' height='" + (style.valuefontsize) + "' xmlns:xlink='http://www.w3.org/1999/xlink' xmlns='http://www.w3.org/2000/svg'><g><line x1='1' y1='" + (style.valuefontsize / 2 - xx) + "' x2='" + xx + "' y2='" + (style.valuefontsize / 2) + "' stroke='#" + style.color + "' stroke-width='1' stroke-linecap='round'/><line x1='" + xx + "' y1='" + (style.valuefontsize / 2) + "' x2='1' y2='" + (style.valuefontsize / 2 + xx) + "' stroke='#" + style.color + "' stroke-width='1' stroke-linecap='round'/></g></svg></pjsdiv>";
		var _prevIcon = "<pjsdiv style='display:inline-block;'><svg width='" + (xx + 10) + "' height='" + (style.valuefontsize + 1) + "' xmlns:xlink='http://www.w3.org/1999/xlink' xmlns='http://www.w3.org/2000/svg' style='float:left'><g><line x1='1' y1='" + (style.valuefontsize / 2 + 2) + "' x2='" + xx + "' y2='" + (style.valuefontsize / 2 - xx + 2) + "' stroke='#" + style.color + "' stroke-width='1' stroke-linecap='round' /><line x1='1' y1='" + (style.valuefontsize / 2 + 2) + "' x2='" + xx + "' y2='" + (style.valuefontsize / 2 + xx + 2) + "' stroke='#" + style.color + "' stroke-width='1' stroke-linecap='round'/></g></svg></pjsdiv>";
		var bordercolor = hex2rgb(existv(style.bordercolor, 'ffffff'), existv(style.brda, 1));
		var container = createElement("div");
		o.frame.appendChild(container);
		css(container, {
			'overflow': 'hidden',
			'display': 'block',
			'opacity': 0,
			'border-radius': style.rounding
		});
		if(style.bgborder == 1) {
			css(container, {
				"border": "1px solid " + CheckColor(existv(style.bgbordercolor, 'ffffff'))
			})
		}
		var mpi = {};
		for(var i in o.menuproc) {
			if(o.menuproc.hasOwnProperty(i)) {
				mpi[o.menuproc[i]] = -1
			}
		}
		if(is == "settings") {
			container.style.zIndex = 1100
		} else {
			container.style.zIndex = 99
		}
		var control = createElement("div");
		if(o.small) {
			style.smallfontsize > 0 ? style.fontsize = style.smallfontsize : '';
			style.floatwidthsmall > 0 ? style.floatwidth = style.floatwidthsmall : '';
			style.floatheightsmall > 0 ? style.floatheight = style.floatheightsmall : ''
		}
		css(control, {
			'position': 'relative',
			'top': 0,
			'left': 0,
			'display': 'block',
			'width': '100%',
			'padding-top': style.bgpaddingtop,
			'padding-right': style.bgpaddingright + 20,
			'padding-bottom': style.bgpaddingbottom,
			'padding-left': style.bgpaddingleft,
			'color': style.color,
			'font-size': style.fontsize * existv(v.globalfs, 1),
			'font-family': checkFont(style.font),
			'letter-spacing': style.letterspacing + 'px'
		});
		if(o.system.safari) {
			css(control, {
				'min-width': 220
			})
		}
		if(is !== "playlist") {
			css(control, {
				'overflow-y': 'scroll'
			})
		}
		container.appendChild(control);
		if(style.floatleft != 1) {
			var control2 = createElement("div");
			css(control2, {
				'display': 'block',
				'overflow': 'hidden',
				'border-radius': style.rounding
			});
			if(style.floatleft != 1) {
				if(o.system.safari) {
					css(control2, {
						'min-width': 220
					})
				}
			}
			control.appendChild(control2)
		}
		attr(control, {
			id: (v.id + "_" + is)
		});
		if(is == "playlist") {
			if(style.floatleft == 1) {
				css(control, {
					'width': '100%',
					'padding-right': style.bgpaddingright,
					'padding-bottom': style.bgpaddingbottom + 20,
					'overflow-x': 'scroll',
					'overflow-y': 'hidden',
					'white-space': 'nowrap'
				});
				css(container, {
					'width': o.screen_w - style.marginright - style.marginleft,
					'height': style.floatheight + style.bgpaddingtop + style.bgpaddingbottom
				})
			} else {
				css(control, {
					'overflow-y': 'scroll',
					'overflow-x': 'hidden'
				});
				if(style.width100 == 1) {
					ResizePlaylist()
				}
			}
			if(style.marginbg == 1) {
				css(container, {
					'background-color': style.marginbgcolor
				})
			}
			if(v.playlist.droplist == 1) {
				hide2(container)
			}
		}
		if(style.scrollarrows == 1) {
			var arr_up = createElement("div");
			var scrollbgcolor = hex2rgb(style.marginbg == 1 ? style.marginbgcolor : style.bgcolor);
			if(style.floatleft == 1) {
				StyleArrow(arr_up, 'to right, rgba(' + scrollbgcolor + ',' + (style.bga * 1 + 0.3) + '), rgba(' + scrollbgcolor + ',0)', 'left', 12, 5, 7, 10, 7, 10, 12, 15);
				arr_up.addEventListener(evntclk, ScrollLeft)
			} else {
				StyleArrow(arr_up, 'to bottom, rgba(' + scrollbgcolor + ',' + (style.bga * 1 + 0.3) + '), rgba(' + scrollbgcolor + ',0)', 'top', 5, 12, 10, 7, 10, 7, 15, 12);
				arr_up.addEventListener(evntclk, ScrollUp)
			}
			var arr_down = createElement("div");
			if(style.floatleft == 1) {
				StyleArrow(arr_down, 'to left, rgba(' + scrollbgcolor + ',' + (style.bga * 1 + 0.3) + '), rgba(' + scrollbgcolor + ',0)', 'right', 8, 5, 13, 10, 13, 10, 8, 15);
				arr_down.addEventListener(evntclk, ScrollRight)
			} else {
				StyleArrow(arr_down, 'to bottom, rgba(' + scrollbgcolor + ',0), rgba(' + scrollbgcolor + ',' + (style.bga * 1 + 0.3) + ')', 'bottom', 5, 8, 10, 13, 10, 13, 15, 8);
				arr_down.addEventListener(evntclk, ScrollDown)
			}
			arr_up.addEventListener("mouseover", ScrollOverOut);
			arr_up.addEventListener("mouseout", ScrollOverOut);
			arr_down.addEventListener("mouseover", ScrollOverOut);
			arr_down.addEventListener("mouseout", ScrollOverOut);
			control.addEventListener("wheel", Wheel);
			arr_up.addEventListener("mouseup", onMouseUp);
			arr_down.addEventListener("mouseup", onMouseUp);
			container.appendChild(arr_up);
			container.appendChild(arr_down);
			clearInterval(arrinterval);
			arrinterval = setInterval(ArrowsInterval, 1000)
		}
		control.addEventListener(evntovr, ControlOver);
		control.addEventListener(evntout, ControlOut);
		if(v.playlist.srch > 0 && !srch && is == "playlist") {
			if(typeof PluginPlSrch !== "undefined") {
				srch = new PluginPlSrch()
			}
		}
		if(is == "settings") {
			for(var i = 1; i < 11; i++) {
				if(exist(v["control_" + is][is + i])) {
					v.settings[is + i] = v["control_" + is][is + i];
					if(exist(v["control_" + is][is + i + "title"])) {
						v.settings[is + i + "title"] = v["control_" + is][is + i + "title"]
					}
					if(exist(v["control_" + is][is + i + "action"])) {
						v.settings[is + i + "action"] = v["control_" + is][is + i + "action"]
					}
				}
				if(exist(v.settings[is + i])) {
					if(v.settings[is + i] == 1) {
						CreateItem('f', i);
						StyleItem(f[i], fbg[i], ftitle[i], fvalue[i]);
						if(!exist(v.settings[is + i + "action"])) {
							v.settings[is + i + "action"] = "speed"
						}
						ftitle[i].innerHTML = Lang(v.settings[is + i + "action"]);
						if(exist(v.settings[is + i + "title"])) {
							if(v.settings[is + i + "title"] != '') {
								ftitle[i].innerHTML = v.settings[is + i + "title"]
							}
						}
						if(v.settings[is + i + "action"] == "share") {
							o.shareme = true
						}
						faction[i] = v.settings[is + i + "action"];
						Value(i);
						if(faction[i] in o.menuproc) {
							mpi[faction[i]] = i
						}
						f[i].addEventListener(evntovr, onOver);
						f[i].addEventListener(evntout, onOut);
						f[i].addEventListener(evntclk, onClick);
						f[i].addEventListener("mouseup", onMouseUp);
						if(v.settings[is + i + "hide"] == 1) {
							css(f[i], {
								"height": 0
							})
						}
					}
				}
			}
		}

		function Wheel(x) {
			if(is == "playlist" && style.floatleft == 1 && x) {
				if(x.deltaX == 0 && x.deltaY != 0) {
					control.scrollLeft -= x.deltaY;
					x.preventDefault()
				}
			}
			clearInterval(wheelinterval);
			wheelinterval = setInterval(ControlOut, 3000);
			Retimer()
		}

		function ControlOver() {
			o.mouseDown = true
		}

		function ControlOut() {
			if(style.showovercontrol == 1) {
				clearTimeout(o.settingsovertimer);
				o.settingsovertimer = setTimeout(function() {
					if(!o.mouseDown) {
						HideControl()
					}
				}, (v.settings.showoverto > 0 ? v.settings.showoverto * 1000 : (o.system.tv ? 2000 : 1000)))
			}
			o.mouseDown = false
		}

		function onOver(event) {
			if(o.fullscreen) {
				o.volumewheel ? o.actions.volumewheel(false) : ''
			}
			var i = event.target.getAttribute('fid');
			var x;
			if(i) {
				x = 'f'
			} else {
				if(event.target.getAttribute('f2id')) {
					i = event.target.getAttribute('f2id');
					x = 'f2'
				}
			}
			if(i) {
				i = parseInt(i);
				var opn = false;
				if(exist(eval(x)[i])) {
					if(style.bgaover > -1) {
						css(eval(x + 'bg')[i], {
							'opacity': style.bgaover
						})
					}
					if(exist2(style.bgbrovr)) {
						css(eval(x + 'bg')[i], {
							'filter': 'brightness(' + style.bgbrovr + ')'
						})
					}
					if(style.aover > -1) {
						css(eval(x + 'title')[i], {
							'opacity': style.aover
						});
						css(eval(x + 'value')[i], {
							'opacity': style.aover
						})
					}
					if(is == "playlist") {
						if(faction[i].indexOf("playlist") == 0) {
							var id = faction[i].substr(8);
							if(plid == id || plfolder == id) {
								css(eval(x + 'title')[i], {
									'color': style.valuecolor
								});
								css(eval(x + 'value')[i], {
									'color': style.valuecolor
								});
								opn = true
							} else {
								css(eval(x + 'title')[i], {
									'color': style.color
								})
							}
						}
					}
					if(style.playbgcolored == 1 && exist(style.playbgcolor) && opn) {} else {
						css(eval(x + 'bg')[i], {
							'backgroundColor': style.bgcolorover
						})
					}
				}
			}
		};

		function onOut(event) {
			if(o.fullscreen) {
				o.volumewheel ? o.actions.volumewheel(true) : ''
			}
			var i = event.target.getAttribute('fid');
			var x;
			var opn = false;
			clearInterval(downin);
			Retimer();
			if(i) {
				x = 'f'
			} else {
				if(event.target.getAttribute('f2id')) {
					i = event.target.getAttribute('f2id');
					x = 'f2'
				}
			}
			if(i) {
				if(exist(eval(x)[i])) {
					if(style.bgaover > -1) {
						css(eval(x + 'bg')[i], {
							'opacity': style.bga
						})
					}
					if(exist2(style.bgbrovr)) {
						css(eval(x + 'bg')[i], {
							'filter': 'brightness(1)'
						})
					}
					if(style.aover > -1) {
						css(eval(x + 'title')[i], {
							'opacity': style.a
						});
						css(eval(x + 'value')[i], {
							'opacity': style.a
						})
					}
					if(is == "playlist") {
						if(faction[i].indexOf("playlist") == 0) {
							var id = faction[i].substr(8);
							if(plid == id || plfolder == id) {
								css(eval(x + 'title')[i], {
									'color': style.valuecolor
								});
								css(eval(x + 'value')[i], {
									'color': style.valuecolor
								});
								opn = true
							} else {
								if(exist(o.plhistory[id])) {
									HistoryPlaylist(i)
								} else {
									css(eval(x + 'title')[i], {
										'color': style.color
									})
								}
							}
						}
					}
					if(style.playbgcolored == 1 && exist(style.playbgcolor) && opn) {} else {
						css(eval(x + 'bg')[i], {
							'backgroundColor': o.plhistory[id] ? style.historybgcolor : style.bgcolor
						})
					}
				}
			}
		}

		function onClick(event) {
			if(!justshow) {
				var d = new Date();
				o.clicktime = d.getTime();
				var i = event.target.getAttribute('fid');
				if(i) {
					if(exist(f[i])) {
						if(exist(faction[i])) {
							Action(i, 0)
						}
					}
				}
			}
		}
		var downi;
		var downin;

		function onMouseDown(event) {
			if(!justshow) {
				var i = event.target.getAttribute('f2id');
				if(i) {
					if(exist(f2action[i])) {
						if(open_action in o.menuproc) {
							downi = i;
							downin = setInterval(DownIn, 200)
						}
					}
				}
			}
		}

		function DownIn() {
			Action2(downi)
		}

		function onMouseUp(event) {
			clearInterval(downin);
			event.cancelBubble = true;
			Retimer()
		}

		function onClick2(event) {
			clearInterval(downin);
			if(!justshow) {
				var d = new Date();
				o.clicktime = d.getTime();
				var i = event.target.getAttribute('f2id');
				if(i) {
					if(i == 0) {
						if(f2action[0] == 'color') {
							Remove2();
							Action(iclr)
						} else {
							Home()
						}
					} else {
						if(exist(f2action[i])) {
							Action2(i)
						}
					}
				}
			}
		}

		function onClickSubtitle(event) {
			var x = event.target.getAttribute('setupx');
			if(x) {
				ActionOptions(x)
			}
		}

		function onClickSubtitle2(event) {
			Retimer();
			var i = event.target.getAttribute('f2id');
			if(exist(f2action[i])) {
				if(f2i("=", i) > 0) {
					var x = f2action[i].substr(0, f2i("=", i));
					var y = f2action[i].substr(f2i("=", i) + 1);
					var z = open_action + '_reset';
					if(!v[z]) {
						v[z] = []
					}
					if(!exist(v[z][x])) {
						v[z][x] = v[x] + ''
					}
					StyleSubtitle(x, y)
				}
			}
		};

		function StyleSubtitle(x, y) {
			v[x] = y;
			if(o.storage && v.sub_designstore == 1 && x != "sub_shift") {
				localStorage.setItem("pljs" + x, y)
			}
			if(o.casting && o.chromecast) {
				o.chromecast.Sub()
			}
			o.actions.RenewSubtitle();
			ActionOptions(x)
		}

		function onClickTimer2(event) {
			var i = event.target.getAttribute('f2id');
			var x = f2action[i];
			if(exist(x)) {
				if(x.indexOf("=") > 0) {
					var z = x.substr(0, x.indexOf("="));
					var y = x.substr(x.indexOf("=") + 1);
					v[z] = y;
					SubtitleTimerMenu();
					Value(o[open_action + '_i']);
					if(open_action == "offsettimer") {
						SettingsTimers("offsetwrite")
					}
				}
			}
		}

		function Value(i) {
			if(exist(faction[i])) {
				var _hide = false;
				var _show = false;
				var _value = '';
				if(is == "settings") {
					if(faction[i] == "quality") {
						_value = o.media.getQuality()
					}
					if(faction[i] == "audiotrack") {
						_value = o.media.getAudioTrack()
					}
					if(faction[i] == "share") {
						_value = ' ';
						_show = true
					}
					if(faction[i] == "channel") {
						if(o.channels) {
							_value = o.files_channel[o.current_channel]
						}
					}
					if(faction[i] == "audiotrack" || faction[i] == "channel" || faction[i] == "quality") {
						if(o['files_' + faction[i]].length == 0) {
							_hide = true
						} else {
							if(o['files_' + faction[i]].length == 1 && (style.show1value != 1 || o['files_' + faction[i]][0] == 1)) {
								_hide = true
							} else {
								_show = true
							}
						}
					}
					if(faction[i] == "airplay") {
						if(!o.airplay) {
							_hide = true
						} else {
							_show = true
						}
					}
					if(faction[i] == "download") {
						if(o.file_type != 'native' && !v.download) {
							_hide = true
						} else {
							_show = true
						}
					}
					if(faction[i] == "subtitle") {
						if(exist(o.subs)) {
							_show = true;
							if(o.subtitle_on || v.sub_off == 1) {
								if(o.sbt) {
									_value = o.files_subtitle[!o.subtitle_on ? o.sbt.ioff() : o.current_subtitle]
								}
							} else {
								_value = ''
							}
							var sxs = 0;
							for(var s = 0; s < o.subs.length; s++) {
								if(o.subs[s] != '') {
									sxs++
								}
							}
							if(sxs == 1 && o.subload == 1) {
								sxs = 0
							}
							if(v.sub_upload == 1 && v.sub_upload0 == 1) {} else {
								if(sxs == 0) {
									_hide = true;
									_show = false
								}
							}
						} else {
							_hide = true
						}
					}
					if(faction[i] == "speed") {
						_value = o.files_speed[o.current_speed];
						_value == 1 && style.speed1 != 1 ? _value = Lang('normal') : '';
						_show = true;
						if(o.file_type == "vimeo" || (o.media.isLive() && style.speed4live != 1)) {
							_hide = true;
							_show = false
						}
					}
					if(faction[i] in o.menuproc) {
						_value = FltrVal(faction[i]);
						_show = true
					}
					if(faction[i].indexOf("timer") > 0) {
						var x = ' ';
						var y = ['hour', 'minute', 'second'];
						for(var z = 0; z < y.length; z++) {
							if(exist(v[faction[i] + y[z]])) {
								if(v[faction[i] + y[z]] !== ' ') {
									x += (x !== ' ' ? ':' : '') + v[faction[i] + y[z]]
								}
							}
						}
						_value = x != ' 0:0' && x.indexOf(":") > -1 ? x : ' ';
						o[faction[i] + 'val'] = _value;
						_show = true
					}
				}
				fvalue[i].innerHTML = _value + (_value != '' && style.hidearrow != 1 ? ' &nbsp;<svg width="5px" height="7px" viewBox="-1 -1 5 8" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><polyline stroke="#' + style.valuecolor + '" stroke-width="1" fill="none" points="0 0 3 3 0 6"></polyline></svg>' : '');
				if(_hide) {
					hide(f[i]);
					if(is == "settings") {
						stout[i] ? clearTimeout(stout[i]) : '';
						if(o.controls) {
							o.controls.SettingsN(i, false, _value)
						} else {
							stout[i] = setTimeout(function() {
								o.controls.SettingsN(i, false, _value)
							}, 200)
						}
					}
					css(f[i], {
						'position': 'absolute',
						'right': 0,
						'top': -100
					})
				}
				if(_show) {
					if(style.floatleft == 1) {
						css(f[i], {
							'display': 'inline-block'
						})
					} else {
						show(f[i])
					}
					if(is == "settings") {
						stout[i] ? clearTimeout(stout[i]) : '';
						if(o.controls) {
							o.controls.SettingsN(i, true, _value)
						} else {
							stout[i] = setTimeout(function() {
								o.controls.SettingsN(i, true, _value)
							}, 500)
						}
					}
					css(f[i], {
						'position': 'relative',
						'right': 0,
						'top': 0
					})
				}
				Resize()
			}
			for(var j = 1; j < f.length; j++) {
				if(f[j]) {
					if(isVisible(f[j])) {
						var refresh = false;
						empty ? refresh = true : '';
						empty = false;
						refresh && o.controls ? o.controls.refresh() : ''
					}
				}
			}
		};

		function Action(i, cstm, fa) {
			fa ? faction[i] = fa : '';
			if(exist(faction[i])) {
				o.setaction = true;
				Retimer();
				var x = VisibleItems();
				if(open_action != faction[i]) {
					open_action = faction[i];
					if(open_action == 'quality' || open_action == 'audiotrack' || open_action == 'subtitle' || open_action == 'speed' || open_action == 'channel' || open_action in o.menuproc || open_action.indexOf("timer") > 0 || open_action == 'share' || open_action == 'color') {
						open_settings = i;
						var z = copyObject(o['files_' + open_action]);
						if(open_action == "sleeptimer") {
							if(style.sleep2 == 1) {
								z = SettingsTimers("sleep2options")
							} else {
								z = SettingsTimers("sleepoptions")
							}
						}
						if(open_action == "offsettimer") {
							z = SettingsTimers("offsetoptions")
						}
						if(open_action == "share" && o.share) {
							z = [];
							for(var j = 1; j <= 16; j++) {
								if(exist(v["share" + j])) {
									z.push(Lang(v["share" + j]));
									shr[z.length] = v["share" + j]
								}
							}
						}
						if(open_action == "color" && o.tagvideo) {
							z = [];
							iclr = i;
							for(var j = 0; j < o.clr_options.length; j++) {
								var co = o.clr_options[j].substr(4);
								z.push(Lang(co));
								clr[z.length] = co
							}
						}
						var current = o['current_' + open_action];
						var pressed = o['pressed_' + open_action];
						for(var j = 1; j < f.length; j++) {
							if(f[j]) {
								f[j].style.display = "none"
							}
						}
						f2 = [];
						CreateItem('f2', 0);
						StyleItem(f2[0], f2bg[0], f2title[0], f2value[0]);
						css(f2[0], {
							"border-bottom": "1px solid " + (style.bordercolored == 1 ? bordercolor : "rgba(100,100,100,0.7)")
						});
						_cstm = cstm;
						var suboptns = false;
						f2title[0].innerHTML = (x[0] < 2 || _cstm == 1 || style.noprevicon == 1 ? '' : _prevIcon) + (v.settings[is + i + "title"] && v.settings[is + i + "title"] != '' ? v.settings[is + i + "title"] : Lang(v.settings[is + i + "action"])) + (o[faction[i] + 'val'] ? o[faction[i] + 'val'] : '');
						if(open_action == 'subtitle' && !o.hls_subs && !o.dash_subs) {
							var prm = createElement("div");
							prm.innerHTML = Lang("options");
							css(prm, {
								'color': style.color,
								'pointerEvents': 'auto',
								'cursor': 'pointer'
							});
							f2value[0].appendChild(prm);
							prm.addEventListener(evntclk, SubtitleSettings);
							suboptns = true
						}
						if(open_action == 'subtitle' && v.sub_upload == 1 && !o.system.tv && exist(window.FileReader)) {
							var uf = createElement("div");
							!o.sbt ? o.sbt = new PluginSub() : '';
							uf.innerHTML = "<input type='file' id='" + v.id + "_subfile' accept='.vtt,.ass,.srt' style='display:none'/>" + Lang('upload');
							css(uf, {
								'color': style.color,
								'pointerEvents': 'auto',
								'cursor': 'pointer',
								'margin-left': (suboptns ? '10px' : 0)
							});
							f2value[0].appendChild(uf);
							o.subupld = document.getElementById(v.id + "_subfile");
							o.subupld.onchange = o.sbt.SubUpload;
							uf.addEventListener(evntclk, o.sbt.SubUpload)
						}
						if(suboptns) {
							if(sub_settings_on) {
								if(_cstm == 2) {
									z = [];
									hide2(f2[0])
								}
								for(j = 0; j < o.sub_options.length; j++) {
									if(v.sub_all == 0 && o.sub_options[j] == "sub_color2") {} else {
										z.push("pjslng_" + o.sub_options[j])
									}
								}
							}
						}
						css(f2title[0], {
							'font-size': style.headfontsize * existv(v.globalfs, 1)
						});
						f2action[0] = "home";
						if(open_action in o.menuproc) {
							Menuproc(open_action);
							if(iclr > 0 && o.clr_options.indexOf('clr_' + open_action) > -1) {
								f2title[0].innerHTML = _prevIcon + Lang(open_action);
								f2action[0] = "color";
								f2value[0].innerHTML = FltrVal(open_action)
							}
							css(f2value[0], {
								'width': style.valuefontsize * 2.5,
								'text-align': 'right'
							})
						}
						if(_cstm != 1 && x[0] > 1) {
							f2[0].addEventListener(evntovr, onOver);
							f2[0].addEventListener(evntout, onOut);
							f2[0].addEventListener(evntclk, onClick2);
							f2[0].addEventListener("mouseup", onMouseUp)
						} else {
							css(f2[0], {
								"cursor": 'default'
							})
						}
						if(style.nohead == 1) {
							hide2(f2[0])
						}
						if(exist(z)) {
							var zz = '';
							for(j = 0; j < z.length; j++) {
								var y = j + 1;
								var toend = 0;
								var off = false;
								if(z[j] && trim(z[j]) != '') {
									if(open_action == 'quality') {
										if(z[j] == Lang("auto")) {
											toend = 1
										}
										if(o.file_type == "hls" && v.hlsqhsort == 1) {
											var iz = int(z[j]);
											if(iz && iz < zz) {
												toend = 2
											}
											zz = int(z[j])
										}
									}
									CreateItem('f2', y, toend);
									StyleItem(f2[y], f2bg[y], f2title[y], f2value[y], faction[i]);
									if(open_action == 'speed') {
										z[j] == 1 && style.speed1 != 1 ? z[j] = Lang('normal') : ''
									}
									if(typeof(z[j]) == 'string') {
										if(z[j].indexOf("<<<") == 0) {
											z[j] = z[j].replace('<<<', '');
											off = true
										}
										if(z[j].indexOf('timer') > 0) {
											o[open_action + '_i'] = i
										}
										if(z[j].indexOf("pjslng") == 0) {
											var tmp = z[j];
											if(tmp.indexOf("timer") > 0) {
												f2title[y].innerHTML = Lang(z[j].substr(tmp.indexOf("timer") + 5))
											} else {
												f2title[y].innerHTML = Lang(z[j].substr(7))
											}
											if(z[j] == 'pjslng_sub_sizeproc') {
												css(f2[y], {
													"border-top": "1px solid rgba(100,100,100,0.7)"
												})
											}
										} else {
											f2title[y].innerHTML = z[j]
										}
									} else {
										f2title[y].innerHTML = z[j]
									}
									f2action[y] = open_action + j;
									if(current == j || pressed == j) {
										f2value[y].innerHTML = current == j ? _activeIcon : _xIcon;
										if(current == j) {
											StyleActive(y)
										}
									}
									if(typeof(z[j]) == 'string') {
										if(z[j].indexOf("pjslng") == 0) {
											var t = z[j].substr(7);
											if(t.indexOf("color") > 0) {
												f2value[y].innerHTML = "<div style='" + (v[t] == "000000" ? 'border:1px solid #999;height:8px;width:8px;' : 'height:10px;width:10px;') + ";background-color:" + (v[t].indexOf("#") == -1 ? '#' : '') + v[t] + ";border-radius:10px;'></div>"
											} else {
												if(exist(v[z[j].substr(7)])) {
													f2value[y].innerHTML = v[z[j].substr(7)]
												}
											}
										}
										if(open_action == "share") {
											if(exist(shr[y]) && o.share) {
												f2value[y].innerHTML = o.share.icon(shr[y], 0.7, CheckColor(style.valuecolor))
											}
										}
										if(open_action == "color") {
											if(exist(clr[y]) && o.tagvideo) {
												f2value[y].innerHTML = FltrVal(clr[y])
											}
										}
										if(open_action == 'quality') {
											if(z[j] == Lang("auto") && o.media.autoQuality()) {
												StyleActive(y)
											}
											if(exist2(v.forbidden_quality)) {
												var fq = v.forbidden_quality.split(",");
												for(var k = 0; k < fq.length; k++) {
													if(z[j].indexOf(fq[k]) > -1) {
														hide2(f2[y])
													}
												}
											}
										}
									}
									var clck = "";
									if(typeof(z[j]) == 'string') {
										if(z[j].indexOf("pjslng") == 0) {
											attr(f2[y], {
												'f2parent': i,
												'setupx': z[j].substr(7)
											});
											clck = "onClickSubtitle"
										}
									}
									if(!off) {
										f2[y].addEventListener(evntovr, onOver);
										f2[y].addEventListener(evntout, onOut);
										if(clck == "onClickSubtitle") {
											f2[y].addEventListener(evntclk, onClickSubtitle)
										} else {
											f2[y].addEventListener(evntclk, onClick2)
										}
										f2[y].addEventListener("mouseup", onMouseUp);
										f2[y].addEventListener("mousedown", onMouseDown)
									} else {
										css(f2[y], {
											"cursor": "default"
										})
									}
								}
							}
						}
						Resize()
					}
					if(faction[i] == 'download') {
						o.actions.Download()
					}
					if(faction[i].indexOf('playlist') > -1) {
						var id = faction[i].substr(8);
						if(exist(o.playlist_dic[id])) {
							if(exist(o.playlist_dic[id]['file'])) {
								o.seekto = undefined;
								ActionPlaylist(i);
								UpdateStart(id);
								SettingsTimers("offset");
								if(exist(o.playlist_dic[id]['redirect']) && v.redirect == 1 && v.redirectplaylist == 1) {
									redirect(o.playlist_dic[id]['redirect'])
								} else {
									UpdateVars0(id);
									o.actions.NewFile(o.playlist_dic[id]['file'], (v.playlist.dontplay == 1 ? 1 : undefined));
									v.playlist.always == 0 && v.playlist.autohide == 1 ? setTimeout(HideControl, 200) : '';
									autonextopenfolder = false;
									autoprevopenfolder = false;
									UpdateVars(id)
								}
							} else {
								if(exist(o.playlist_dic[id]['folder'])) {
									UpdatePlaylist(id);
									if(autonextopenfolder) {
										plx == -1 ? Action(0, 0) : ''
									} else if(autoprevopenfolder) {
										plx == -1 ? Action(parseInt(f.length) - 2, 0) : ''
									}
								}
							}
						}
						if(o.droplist) {
							o.droplist.Update()
						}
					}
					if(faction[i] == 'airplay') {
						o.media.Airplay()
					}
				}
			}
		};
		this.UpdateTimer = function(x) {
			Value(o[x + '_i'])
		};

		function ActionOptions(x) {
			if(x == "sub_reset") {
				var z = open_action + '_reset';
				if(v[z]) {
					for(var y in v[z]) {
						if(v[z].hasOwnProperty(y)) {
							StyleSubtitle(y, v[z][y])
						}
					}
					SubtitleSettingsMenu()
				}
				return
			}
			Retimer();
			for(var i = 0; i < f2.length; i++) {
				if(f2[i]) {
					f2[i].style.display = "none"
				}
			}
			f2 = [];
			CreateItem('f2', 0);
			StyleItem(f2[0], f2bg[0], f2title[0], f2value[0]);
			css(f2[0], {
				"border-bottom": "1px solid " + (style.bordercolored == 1 ? bordercolor : "rgba(100,100,100,0.7)")
			});
			if(x.indexOf("timer") > 0) {
				f2[0].addEventListener(evntclk, SubtitleTimerMenu);
				f2title[0].innerHTML = Lang(x.substr(x.indexOf("timer") + 5))
			} else {
				f2[0].addEventListener(evntclk, SubtitleSettingsMenu);
				f2title[0].innerHTML = (style.noprevicon != 1 ? _prevIcon : '') + Lang(x)
			}
			css(f2title[0], {
				'font-size': style.headfontsize * existv(v.globalfs, 1)
			});
			f2[0].addEventListener(evntovr, onOver);
			f2[0].addEventListener(evntout, onOut);
			f2[0].addEventListener("mouseup", onMouseUp);
			var values = [];
			var valuefromlang = false;
			if(x.indexOf("size") > 0) {
				values = ['50%', '75%', '100%', '125%', '150%', '175%', '200%', '250%', '300%', '400%']
			}
			if(x.indexOf("bga") > 0) {
				values = ['0', '0.2', '0.3', '0.4', '0.5', '0.6', '0.7', '0.8', '0.9', '1']
			}
			if(x.indexOf("shift") > 0) {
				for(var i = -5; i < 5.5; i += 0.5) {
					values.push(Math.round(i * 100) / 100)
				}
			}
			if(x.indexOf("weight") > 0) {
				values = [200, 400, 600]
			}
			if(x.indexOf("bottom") > 0) {
				for(i = 0; i < 21; i++) {
					values[i] = i * 10
				}
			}
			if(x.indexOf("hour") > 0) {
				for(i = 0; i < 24; i++) {
					values[i] = i
				}
			}
			if(x.indexOf("minute") > 0 || x.indexOf("second") > 0) {
				for(i = 0; i < 60; i++) {
					values[i] = i
				}
			}
			if(x.indexOf("shadow") > 0) {
				valuefromlang = true;
				values = [0, 1]
			}
			if(x.indexOf("color") > 0) {
				values = ['ffffff', 'ffeeab', '72ccf8', '62de50', 'faed54', 'feba54', 'e8bbff', 'ffc7d1', 'aaaaaa', 'd9bb8c', 'b3fee8', '4bd9ac', 'FEF370', 'D90000', '073DA0', '409829', '644082', '000000'];
				var vx = v[x].replace("#", "");
				if(values.indexOf(vx) == -1) {
					values[8] = vx
				}
			}
			for(y = 1; y <= values.length; y++) {
				CreateItem('f2', y, 0);
				StyleItem(f2[y], f2bg[y], f2title[y], f2value[y]);
				css(f2value[y], {
					'padding-left': 0
				});
				if(x.indexOf("color") > 0 || x.indexOf("bottom") > 0 || x.indexOf("timer") > 0 || x.indexOf("shift") > 0) {
					y % 3 != 0 ? css(f2[y], {
						'float': 'left'
					}) : '';
					css(f2[y], {
						'width': '33.3%'
					});
					if(x.indexOf("color") > 0) {
						f2title[y].innerHTML = "<div style='" + (values[y - 1] == "000000" ? 'border:1px solid #999;height:18px;width:18px;' : 'height:20px;width:20px;') + ";background-color:#" + values[y - 1] + ";border-radius:20px;'></div>";
						css(f2[y], {
							'line-height': 1
						})
					} else {
						f2title[y].innerHTML = values[y - 1]
					}
				} else {
					if(x.indexOf("weight") > 0) {
						f2title[y].innerHTML = values[y - 1]
					} else {
						y % 2 != 0 ? css(f2[y], {
							'float': 'left'
						}) : '';
						css(f2[y], {
							'width': '50%'
						});
						if(valuefromlang) {
							f2title[y].innerHTML = Lang(values[y - 1] + 'val')
						} else {
							f2title[y].innerHTML = values[y - 1]
						}
					}
				}
				f2action[y] = x + '=' + values[y - 1];
				if((values[y - 1] == v[x] && String(v[x]) != " ") || v[x] == '#' + values[y - 1]) {
					f2value[y].innerHTML = _activeIcon;
					StyleActive(y)
				}
				f2[y].addEventListener(evntovr, onOver);
				f2[y].addEventListener(evntout, onOut);
				if(x.indexOf("timer") > 0) {
					f2[y].addEventListener(evntclk, onClickTimer2)
				} else {
					f2[y].addEventListener(evntclk, onClickSubtitle2)
				}
				f2[y].addEventListener("mouseup", onMouseUp)
			}
			Resize()
		}

		function StyleActive(x) {
			f2[x].classList.add('pjs-' + v.id + '-active-menu');
			css(f2title[x], {
				'color': style.valuecolor
			});
			BgBrAct(f2bg[x])
		}

		function UpdateVars0(id) {
			if(exist(o.playlist_dic[id]['poster'])) {
				v.poster = o.playlist_dic[id]['poster'];
				exist(v.poster) ? o.media.Poster(v.poster) : ''
			}
			if(exist(o.playlist_dic[id]['title'])) {
				o.titlestore = o.playlist_dic[id]['title']
			}
			MediaSess()
		}

		function UpdateVars(id) {
			var t = o.playlist_dic[id]['title'];
			if(exist(t)) {
				if(v.showtitleplaylist == 1) {
					if(o.actions.TitleTemplate(o.playlist_dic[id])) {} else {
						v.title = (v.addtitleplaylist == 1 && exist(o.maintitle) ? o.maintitle + (v.addtitleplaylistbr == 1 ? '<br>' : ' ') : '') + t
					}
					o.actions.Title('title')
				}
			}
			if(v.pointed == 1) {
				if(exist(o.playlist_dic[id]['points'])) {
					v.points = o.playlist_dic[id]['points']
				} else {
					v.points = []
				}
				o.controls.RenewPoints()
			}
			var xv = ['remove', 'thumbnails', 'download', 'skip', 'url', 'url2', 'url3', 'vars', 'embed', 'end', 'delete', 'heartbeat', 'label', 'title2', 'customtext'];
			for(var i = 0; i < xv.length; i++) {
				if(exist(o.playlist_dic[id][xv[i]])) {
					v[xv[i]] = o.playlist_dic[id][xv[i]]
				} else {
					i < 4 ? v[xv[i]] = undefined : ''
				}
			}
			v.start = 0;
			UpdateStart(id);
			var opid = o.playlist_dic[id];
			if(exist(opid['sub'])) {
				opid['subtitle'] = opid['sub']
			}
			if(exist(opid['subtitle'])) {
				o.actions.Subtitle(opid['subtitle'])
			}
			if(exist(opid['customtext'])) {
				o.controls.customTextPl()
			}
			o.actions.Ctxt(o.playlist_dic[id]);
			if(o.ctxtnk) {
				o.controls.upText(o.ctxtnk)
			}
			if(exist(opid['design'])) {
				apiProcessor('design', opid['design'])
			}
			if(exist(opid.volume)) {
				o.actions.Volume(opid.volume)
			}
		}

		function UpdateStart(id) {
			var x = o.playlist_dic[id]['start'];
			if(exist(x)) {
				if(x == "continue") {
					if(o.media.time() > 0) {
						v.start = o.seekto = o.media.time()
					}
				} else {
					v.start = o.seekto = x
				}
			}
		}

		function ActionPlaylist(x) {
			if(plx == 0 && !o.start) {
				css(ftitle[plx], {
					'color': style.color
				});
				css(fbg[plx], {
					'backgroundColor': style.bgcolor
				});
				fvalue[plx].innerHTML = '';
				f[plx].classList.remove('pjs-' + v.id + '-active-pl')
			} else {
				o.plopenid = x;
				if(plx > -1) {
					HistoryPlaylist(plx)
				}
				if(plid != '') {
					if(!o.plhistory[plid]) {
						o.pldur2 += existv(o.playlist_dic[plid].duration, 0)
					}
					o.plhistory[plid] = true;
					shuffle = removebykey(shuffle, plid)
				}
			}
			if(faction[x]) {
				var id = faction[x].substr(8);
				fvalue[x].innerHTML = _activeIcon;
				f[x].classList.add('pjs-' + v.id + '-active-pl');
				css(ftitle[x], {
					'color': style.valuecolor,
					'text-decoration': 'none',
					'opacity': style.a
				});
				BgBrAct(fbg[x]);
				if(style.playbgcolored == 1 && exist(style.playbgcolor)) {
					css(fbg[x], {
						'backgroundColor': style.playbgcolor
					})
				}
				plx = x;
				plid = id;
				o.plid = plid;
				v.plstart = plid;
				o.playlist_title = ftitle[x].innerHTML;
				o.plopenid = plid;
				plfolder = o.playlist_dic[id]['pjs_parent'];
				if(o.controls) {
					o.controls.PlaylistControls()
				}
				if(srch) {
					srch.clear()
				}
			}
		}

		function UpdatePlaylist(id) {
			var x = id == 0 ? o.playlist : o.playlist_dic[id];
			o.plopenid = id;
			for(var i = 0; i < f.length; i++) {
				if(style.floatleft == 1) {
					control.removeChild(f[i])
				} else {
					control2.removeChild(f[i])
				}
				f[i] = null
			}
			f = [];
			plx = -1;
			if(exist(x['folder'])) {
				var y = Object.keys(x['folder']).length;
				CreateItem('f', y);
				faction[y] = "playlistfolder";
				StyleItem(f[y], fbg[y], ftitle[y], fvalue[y]);
				if(style.floatleft == 1) {
					css(f[y], {
						"width": (style.floatlimitwidth == 1 ? style.floatwidth : "auto"),
						"height": style.floatheight
					})
				}
				if(style.borderbottom == 1) {
					var hdbrdclr = "1px solid " + hex2rgb(style.headbordercolor, existv(style.brda, 1));
					if(style.floatleft == 1) {
						css(f[y], {
							"borderRight": hdbrdclr
						})
					} else {
						css(f[y], {
							"borderBottom": hdbrdclr
						})
					}
				}
				var tmp = x.title;
				if(style.noprevicon != 1) {
					tmp = _prevIcon + tmp
				}
				ftitle[y].innerHTML = tmp;
				css(ftitle[y], {
					'font-size': style.headfontsize * existv(v.globalfs, 1)
				});
				var p = x['pjs_parent'];
				f[y].addEventListener(evntovr, onOver);
				f[y].addEventListener(evntout, onOut);
				f[y].addEventListener(evntclk, function() {
					PlaylistBack(p)
				});
				x = x['folder']
			}
			var y = Object.keys(x).length;
			shuffle = [];
			shuffle_ = [];
			if(srch && style.floatleft != 1) {
				srch.remove(control2);
				if(y > v.playlist.srch) {
					srch.add(style, control2)
				}
			}
			for(var i = 0; i < y; i++) {
				CreateItem('f', i);
				faction[i] = "playlist" + x[i].id;
				if(!exist(o.plhistory[x[i].id]) && !exist(x[i].folder)) {
					shuffle[x[i].id] = i;
					shuffle_[x[i].id] = i
				}
				StyleItem(f[i], fbg[i], ftitle[i], fvalue[i]);
				if(style.floatleft == 1) {
					if(style.activeiconsize == 0) {
						css(ftitle[i], {
							'width': style.floatwidth - style.paddingleft - style.paddingright
						});
						hide2(fvalue[i])
					}
					css(f[i], {
						"width": (style.floatlimitwidth == 1 ? style.floatwidth : "auto"),
						"height": style.floatheight
					})
				}
				ftitle[i].innerHTML = x[i].title ? x[i].title : '&nbsp;';
				if(v.timestore == 1 && v.playedstore == 1 && x[i].id) {
					if(o.playedstored) {
						if(o.playedstored.indexOf(x[i].id) > -1) {
							x[i].played = 1
						}
					}
				}
				if(exist(x[i].played)) {
					if(x[i].played == 1) {
						o.plhistory[x[i].id] = true;
						HistoryPlaylist(i)
					}
				}
				if(exist(x[i].folder)) {
					fvalue[i].innerHTML = _nextIcon;
					css(fvalue[i], {
						"color": style.color
					})
				}
				f[i].addEventListener(evntovr, onOver);
				f[i].addEventListener(evntout, onOut);
				f[i].addEventListener(evntclk, onClick);
				f[i].addEventListener("mouseup", onMouseUp);
				if(exist(o.plhistory[x[i].id])) {
					HistoryPlaylist(i)
				}
				if(plid == x[i].id) {
					ActionPlaylist(i)
				}
				if(plfolder == x[i].id) {
					css(ftitle[i], {
						'color': style.valuecolor
					});
					css(fvalue[i], {
						'color': style.valuecolor
					});
					BgBrAct(fbg[i])
				}
			}
			Resize();
			empty = false;
			o.controls ? o.controls.refresh() : ''
		}

		function BgBrAct(x) {
			if(exist2(style.bgbract) && x) {
				css(x, {
					"background-image": "linear-gradient(rgba(0, 0, 0, " + (1 - style.bgbract * 1) + ") 0 0)"
				})
			}
		}

		function StyleArrow(x, y, z, x1, y1, x2, y2, x3, y3, x4, y4) {
			var ww = (style.floatleft == 1 ? '40px' : '100%');
			var hh = (style.floatleft == 1 ? '100%' : '40px');
			css(x, {
				'position': 'absolute',
				'display': 'inline-block',
				'width': ww,
				'height': hh,
				'text-align': 'center'
			});
			if(style.scrollarrowgradient == 1) {
				css(x, {
					'background': '-moz-linear-gradient(' + y + ')',
					'background': '-webkit-linear-gradient(' + y + ')',
					'background': '-ms-linear-gradient(' + y + ')',
					'background': '-o-linear-gradient(' + y + ')',
					'background': 'linear-gradient(' + y + ')',
				})
			}
			if(style.floatleft == 1 || o.system.mobile) {
				css(x, {
					'cursor': 'pointer'
				})
			} else {
				css(x, {
					'pointer-events': 'none'
				})
			}
			if(style.limitwidth == 1) {
				css(x, {
					'max-width': style.limitmaxwidth + 'px!important'
				})
			}
			if(z == "top") {
				css(x, {
					'top': -1,
					'left': 0
				})
			}
			if(z == "bottom") {
				css(x, {
					'bottom': -1,
					'left': 0
				})
			}
			if(z == "left") {
				css(x, {
					'top': 0,
					'left': 0
				})
			}
			if(z == "right") {
				css(x, {
					'top': 0,
					'right': 0
				})
			}
			if(z == "right" || z == "left") {
				css(x, {
					'text-align': 'left',
					'padding-top': container.offsetHeight / 2 - 10
				})
			}
			x.innerHTML = "<center><div " + (style.scrollarrowbgover == 1 ? "onMouseOver='this.style.backgroundColor=\"#" + style.scrollarrowbgovercolor + "\"' onMouseOut='" + (style.scrollarrowbg == 1 ? "this.style.backgroundColor=\"#" + style.scrollarrowbgcolor : "this.style.background=\"none") + "\"'" : "") + " style='pointer-events:auto;cursor:pointer;width:20px;height:20px;border-radius:20px;" + (style.scrollarrowbg == 1 ? "background-color:#" + style.scrollarrowbgcolor + ";" : "") + (z == "top" ? "margin-top:10px;" : "") + (z == "bottom" ? "margin-top:10px;" : "") + (z == "right" ? "margin-left:0px;" : "") + (z == "left" ? "margin-right:0px;" : "") + "'><svg width='20' height='20' xmlns:xlink='http://www.w3.org/1999/xlink' xmlns='http://www.w3.org/2000/svg'><g><line x1='" + x1 + "' y1='" + y1 + "' x2='" + x2 + "' y2='" + y2 + "' stroke='#" + style.scrollarrowcolor + "' stroke-width='" + style.scrollarrowsize + "' stroke-linecap='round'/><line x1='" + x3 + "' y1='" + y3 + "' x2='" + x4 + "' y2='" + y4 + "' stroke='#" + style.scrollarrowcolor + "' stroke-width='" + style.scrollarrowsize + "' stroke-linecap='round'/></g></svg></div></center>"
		}
		this.Arrows = function() {
			if(style.scrollarrows == 1) {
				Arrows()
			}
		};

		function ArrowsInterval() {
			if(is_visible) {
				Arrows()
			}
		}

		function Arrows(e) {
			if(style.scrollarrows == 1 && !removed) {
				if(style.floatleft == 1) {
					var h = control.scrollWidth;
					var m = container.offsetWidth + style.bgpaddingleft + style.bgpaddingright;
					var t = control.scrollLeft
				} else {
					var h = control.scrollHeight;
					var m = container.offsetHeight;
					var t = control.scrollTop
				}
				if(h > m) {
					if(t > 0) {
						if(!isVisible(arr_up)) {
							show(arr_up);
							var m1 = new Motion({
								"mc": arr_up,
								"type": "alpha_div",
								"to": 1,
								"time": 0.3,
								"me": "arr_up"
							})
						}
					} else {
						if(isVisible(arr_up)) {
							var m2 = new Motion({
								"mc": arr_up,
								"type": "alpha_div",
								"to": 0,
								"time": 0.3,
								"me": "arr_up",
								"hide": true
							})
						}
						if(e) {
							e.deltaY < 0 ? e.preventDefault() : ''
						}
					}
					if(t < h - m - 10) {
						if(!isVisible(arr_down)) {
							show(arr_down);
							var m3 = new Motion({
								"mc": arr_down,
								"type": "alpha_div",
								"to": 1,
								"time": 0.3,
								"me": "arr_down"
							})
						}
					} else {
						if(isVisible(arr_down)) {
							var m4 = new Motion({
								"mc": arr_down,
								"type": "alpha_div",
								"to": 0,
								"time": 0.3,
								"me": "arr_down",
								"hide": true
							})
						}
						if(e) {
							e.deltaY > 0 ? e.preventDefault() : ''
						}
					}
				} else {
					hide(arr_up);
					hide(arr_down)
				}
			}
		}

		function ScrollDown() {
			var x = control.scrollTop + container.offsetHeight - 60;
			var m = new Motion({
				"mc": control,
				"type": "scroll",
				"to": x,
				"time": 0.3,
				"me": "scroll_down",
				"ease": "cubic"
			});
			setTimeout(Arrows, 1000)
		}

		function ScrollUp() {
			var x = control.scrollTop - container.offsetHeight + 60;
			var m = new Motion({
				"mc": control,
				"type": "scroll",
				"to": x,
				"time": 0.3,
				"me": "scroll_up",
				"ease": "cubic"
			});
			setTimeout(Arrows, 1000)
		}

		function ScrollOverOut(event) {
			clearTimeout(o.settingsovertimer);
			event.stopPropagation()
		}

		function ScrollRight() {
			var x = control.scrollLeft + (container.offsetWidth + style.bgpaddingleft + style.bgpaddingright) - 60;
			var m = new Motion({
				"mc": control,
				"type": "scrollleft",
				"to": x,
				"time": 0.3,
				"me": "scroll_right",
				"ease": "cubic"
			});
			setTimeout(Arrows, 1000)
		}

		function ScrollLeft() {
			var x = control.scrollLeft - (container.offsetWidth + style.bgpaddingleft + style.bgpaddingright) + 60;
			var m = new Motion({
				"mc": control,
				"type": "scrollleft",
				"to": x,
				"time": 0.3,
				"me": "scroll_left",
				"ease": "cubic"
			});
			setTimeout(Arrows, 1000)
		}

		function PlaylistBack(x) {
			if(x == '') {
				UpdatePlaylist(0)
			} else {
				if(exist(o.playlist_dic[x])) {
					UpdatePlaylist(x)
				}
			}
			open_action = ''
		}

		function HistoryPlaylist(x) {
			fvalue[x].innerHTML = '';
			css(ftitle[x], {
				'color': style.historycolor
			});
			if(style.historytitlestrike == 1) {
				css(ftitle[x], {
					'text-decoration': 'line-through'
				})
			}
			if(style.historytitlea > -1) {
				css(ftitle[x], {
					'opacity': style.historytitlea
				})
			}
			f[x].classList.remove('pjs-' + v.id + '-active-pl');
			css(fbg[x], {
				'backgroundColor': style.historybgcolor
			});
			if(style.historybga > -1) {
				css(fbg[x], {
					'opacity': style.historybga
				})
			}
		}

		function Action2(i) {
			if(exist(f2action[i])) {
				Retimer();
				if(f2i("quality", i) == 0) {
					o.actions.SetQuality(f2action[i].substr(7))
				}
				if(f2i("audiotrack", i) == 0) {
					o.actions.SetAudioTrack(f2action[i].substr(10))
				}
				if(f2i("subtitle", i) == 0) {
					!o.sbt ? o.sbt = new PluginSub() : '';
					o.sbt.SetSubtitle(f2action[i].substr(8))
				}
				if(f2i("channel", i) == 0 && v.channels == 1) {
					o.channels.SetChannel(f2action[i].substr(7))
				}
				if(f2i("share", i) == 0) {
					o.share ? o.share.api(shr[i]) : '';
					HideControl()
				}
				if(f2i("color", i) == 0) {
					Remove2();
					Action(0, 0, clr[i])
				}
				for(var p in o.menuproc) {
					if(o.menuproc.hasOwnProperty(p)) {
						if(f2i(p, i) == 0) {
							o.media.menufltr(p, i)
						}
					}
				}
				if(f2i("timer", i) > 0) {
					if(f2title[i].innerHTML == Lang('off')) {
						SettingsTimers(open_action + '0');
						Value(open_settings);
						if(open_action == "offsettimer") {
							SettingsTimers("offsetwrite")
						}
						Home()
					} else {
						if(open_action == "sleeptimer" && style.sleep2 == 1) {
							SettingsTimers('sleep2', i);
							Value(open_settings);
							Home()
						}
					}
				}
				if(f2i("speed", i) == 0) {
					o.actions.SetSpeed(f2action[i].substr(5));
					UpdateSpeed();
					setTimeout(HideControl, 200)
				}
			}
		};
		this.UpdateSpeed = function() {
			UpdateSpeed()
		};
		this.Exist = function(x) {
			for(var i = 0; i < faction.length; i++) {
				if(faction[i] == x) {
					return true
				}
			}
			return false
		};

		function UpdateSpeed() {
			for(var i = 0; i < faction.length; i++) {
				if(faction[i] == "speed") {
					Value(i);
					if(open_action == 'speed') {
						Remove2();
						Action(i, 0)
					}
				}
			}
		}

		function CreateItem(x, i, toend) {
			if(exist(eval(x))) {
				eval(x)[i] = createElement("div");
				if(i < 2 || x == "f" || open_action != 'quality' || toend == 1) {
					if(style.floatleft == 1) {
						control.appendChild(eval(x)[i])
					} else {
						control2.appendChild(eval(x)[i])
					}
				} else {
					if(style.floatleft == 1) {
						control.insertBefore(eval(x)[i], eval(x)[i - 1])
					} else {
						control2.insertBefore(eval(x)[i], eval(x)[toend == 2 ? i - 2 : i - 1])
					}
				}
				if(x == 'f') {
					attr(eval(x)[i], {
						'fid': i
					})
				}
				if(x == 'f2') {
					attr(eval(x)[i], {
						'f2id': i
					})
				}
				eval(x + 'bg')[i] = createElement("div");
				eval(x)[i].appendChild(eval(x + 'bg')[i]);
				eval(x + 'img')[i] = createElement("div");
				eval(x)[i].appendChild(eval(x + 'img')[i]);
				css(eval(x + 'img')[i], {
					'position': 'absolute',
					'right': 0,
					'top': 0,
					'width': '100%',
					'height': '100%',
					'pointerEvents': 'none'
				});
				eval(x + 'title')[i] = createElement("div");
				eval(x)[i].appendChild(eval(x + 'title')[i]);
				eval(x + 'value')[i] = createElement("div");
				eval(x)[i].appendChild(eval(x + 'value')[i]);
				if(i > 0 && x == "f2" && is == "settings" && style.activeicon == 0) {
					hide2(eval(x + 'value')[i])
				}
			}
		};

		function StyleItem(x, xbg, xtitle, xvalue, actn) {
			css(x, {
				'position': 'relative',
				'right': 0,
				'top': 0,
				'cursor': 'pointer',
				'height': 'auto',
				'width': '100%',
				'overflow': 'hidden',
				'display': 'block',
				'line-height': '1.5em'
			});
			if(style.floatmarginright && style.floatleft == 1) {
				css(x, {
					'marginRight': style.floatmarginright
				})
			}
			if(style.floatleft == 1) {
				css(x, {
					'display': 'inline-block',
					'vertical-align': 'top',
					'white-space': 'normal'
				})
			}
			css(xbg, {
				'position': 'absolute',
				'right': 0,
				'top': 0,
				'width': '100%',
				'height': '100%',
				'backgroundColor': style.bgcolor,
				'opacity': style.bga,
				'pointerEvents': 'none',
				'transition': 'opacity 0.2s ease-out,background .2s ease-out,filter .2s ease-out'
			});
			if(style.brdl == 1) {
				x.style[style.floatleft == 1 ? "border-right" : "border-bottom"] = "1px solid " + hex2rgb(existv(style.brdlc, 'ffffff'), existv(style.brdla, 0.2))
			}
			css(xtitle, {
				'position': 'relative',
				'right': 0,
				'top': 0,
				'float': (style.align ? style.align : 'left'),
				'color': style.color,
				'padding-top': style.paddingtop,
				'padding-right': style.paddingright,
				'padding-bottom': style.paddingbottom,
				'padding-left': style.paddingleft,
				'pointerEvents': 'none',
				'opacity': style.a,
				'transition': 'opacity 0.2s linear,color 0.2s linear',
			});
			css(xvalue, {
				'position': 'relative',
				'right': 0,
				'top': 0,
				'float': (style.valuealign ? style.valuealign : 'right'),
				'padding-top': style.paddingtop,
				'padding-right': style.paddingright,
				'padding-left': style.paddingleft,
				'pointerEvents': 'none',
				'font-size': style.valuefontsize * existv(v.globalfs, 1),
				'opacity': style.a,
				'color': style.valuecolor,
				'transition': 'opacity 0.2s linear,color 0.2s linear'
			});
			if(style.limitwidth == 1) {
				css(x, {
					'max-width': style.limitmaxwidth + 'px!important'
				});
				css(xtitle, {
					'max-width': (style.limitmaxwidth - 70) + 'px!important'
				})
			} else {
				if(style.floatleft == 1) {
					if(style.floatlimitwidth == 1) {
						css(x, {
							'width': style.floatwidth
						});
						css(xtitle, {
							'width': style.floatwidth - 70
						})
					}
				} else {
					css(xtitle, {
						'white-space': 'nowrap'
					});
					css(xvalue, {
						'white-space': 'nowrap'
					})
				}
			}
		}

		function Home() {
			for(var i = 1; i < f.length; i++) {
				if(exist(f[i])) {
					if(style.floatleft == 1) {
						f[i].style.display = "inline-block"
					} else {
						f[i].style.display = "block"
					}
				}
			}
			Retimer();
			Remove2();
			Resize();
			open_action = '';
			open_settings = -1
		};

		function Remove2() {
			for(var j = 0; j < f2.length; j++) {
				if(f2[j]) {
					if(style.floatleft == 1) {
						control.removeChild(f2[j])
					} else {
						control2.removeChild(f2[j])
					}
					f2[j] = null
				}
			}
			f2 = [];
			open_action = ''
		}

		function Width() {
			return control.offsetWidth
		};
		this.resizePlaylist = function() {
			ResizePlaylist()
		};

		function ResizePlaylist() {
			if(is == "playlist") {
				if(style.floatleft == 1 || style.width100 == 1) {
					var x = o.screen_w - style.marginright - style.marginleft;
					css(container, {
						'width': x
					});
					css(control, {
						'width': x
					});
					control2 ? css(control2, {
						'width': x
					}) : ''
				}
				o.droplist ? o.droplist.Resize() : ''
			}
		}

		function Resize() {
			if(!removed) {
				if(is == "settings") {
					o.controls ? o.controls.resizeSettings() : '';
					var x = style.nohead == 1 && f.length > 1 ? f[1] : f[0]
				}
				if(is == "playlist") {
					ResizePlaylist();
					o.controls ? o.controls.resizePlaylist() : '';
					var x = f[0];
					if(v.change2playlist == 1) {
						MainUpdateSize()
					}
				}
				f.length > 1 && !x ? (f[1] ? x = f[1] : '') : '';
				f.length > 2 && !x ? (f[2] ? x = f[2] : '') : '';
				if(x) {
					x.offsetWidth == 0 && f2.length > 0 ? x = f2[0] : ''
				}
				if(control.offsetWidth - control.clientWidth > 0 && x && style.floatleft != 1) {
					if(exist(arr_up)) {
						css(arr_up, {
							"width": control2.offsetWidth
						})
					}
					if(exist(arr_down)) {
						css(arr_down, {
							"width": control2.offsetWidth
						})
					}
					style.scrollwidth = (control.offsetWidth - x.offsetWidth) - (control.clientWidth - x.clientWidth)
				} else {
					style.scrollwidth = 0
				}
			}
		};

		function VisibleItems() {
			var x = 0;
			var y = 0;
			var z = '';
			for(var i = 1; i < f.length; i++) {
				if(exist(f[i])) {
					if(f[i].style.visibility == "visible") {
						x++;
						y = i;
						z = faction[i]
					}
				}
			}
			return [x, y, z]
		}
		this.SubOpt = function() {
			sub_settings_on = true;
			this.show();
			_cstm = 2;
			SubtitleSettingsMenu()
		};

		function SubtitleSettings(x) {
			sub_settings_on = !sub_settings_on;
			SubtitleSettingsMenu(x)
		}

		function SubtitleSettingsMenu() {
			Home();
			for(var i = 0; i < faction.length; i++) {
				if(faction[i] == "subtitle") {
					Action(i, _cstm)
				}
			}
		}

		function Retimer() {
			clearTimeout(settimer);
			settimer = setTimeout(function() {
				o.setaction = false
			}, 2000)
		}

		function SubtitleTimerMenu() {
			var x = open_action;
			Home();
			for(var i = 0; i < faction.length; i++) {
				if(faction[i] == x) {
					Action(i, 0)
				}
			}
		}

		function HideControl(x) {
			if((is == 'playlist' && v.playlist.always2 == 1) || (is == 'settings' && v.settings.always == 1)) {
				return
			}
			if(is == 'playlist' && v.playlist.droplist == 1 && v.playlist.dropnohide != 1) {
				o.droplist ? o.droplist.Hide() : '';
				is_visible = false
			} else {
				if((x != 1 || (style.hidesmoothly == 1 && style.always == 1)) && !o.system.tv) {
					var m = new Motion({
						"mc": container,
						"type": "alpha_div",
						"to": 0,
						"time": 0.1,
						"me": is,
						"ease": "elastic"
					});
					hidetimeout = setTimeout(function() {
						css(container, {
							"visibility": "hidden",
							"opacity": 0,
							"top": -2000
						});
						is_visible = false
					}, 200)
				} else {
					css(container, {
						"visibility": "hidden",
						"opacity": 0,
						"top": -2000
					});
					is_visible = false
				}
			}
			if(is == 'playlist') {
				if(v.playlist.hidecontrol == 1 && o.controls) {
					o.controls.toggleControl("action", "playlist", true)
				}
			}
			clearInterval(wheelinterval)
		};
		this.c = function() {
			return container
		};
		this.co = function() {
			if(container.contains(control)) {
				return control
			}
		};
		this.s = function(key) {
			if(key == "marginleft" || key == "marginright") {
				var k2 = key.replace("margin", "marginproc");
				var k3 = key.replace("margin", "mrgnprs");
				if(exist2(style[k3]) && o.small) {
					return o.screen_w * style[k3] / 100
				}
				if(exist2(style[k2])) {
					return o.screen_w * style[k2] / 100
				}
			}
			return style[key]
		};
		this.ss = function(key) {
			return style
		};
		this.show = function() {
			Home();
			clearTimeout(hidetimeout);
			is_visible = true;
			if(is == 'playlist' && v.playlist.droplist == 1) {
				o.droplist ? o.droplist.Show() : ''
			} else {
				css(container, {
					"visibility": "visible",
					"opacity": 1,
					"transition": "opacity 0.2s linear"
				});
				var x = VisibleItems();
				if(x[0] == 1) {
					if(x[2] == "quality" || x[2] == "audiotrack" || x[2] == "subtitle" || x[2] == "speed" || x[2] in o.menuproc || x[2].indexOf("timer") > 0) {
						Action(x[1], 0)
					}
				}
			}
			if(o.controls) {
				is == 'settings' ? o.controls.resizeSettings() : '';
				if(is == 'playlist') {
					o.controls.resizePlaylist();
					if(v.playlist.hidecontrol == 1) {
						o.controls.toggleControl("action", "playlist", false)
					}
				}
			}
			if(o.system.safari) {
				css(control, {
					'min-width': 'auto'
				});
				if(style.floatleft != 1) {
					css(control2, {
						'min-width': 'auto'
					})
				}
			}
			justshow = true;
			clearInterval(showinterval);
			showinterval = setInterval(ShowTimeout, 100)
		};

		function ShowTimeout() {
			clearInterval(showinterval);
			justshow = false
		}
		this.open = function(i) {
			Action(i, 1)
		};
		this.hide = function(x) {
			HideControl(x)
		};
		this.plclose = function() {
			if(o.droplist) {
				o.droplist.Close()
			}
		};
		this.SetQuality = function() {
			for(var i = 0; i < faction.length; i++) {
				if(faction[i] == "quality") {
					Value(i);
					if(o.files_quality.length > 1) {
						show(f[i])
					}
					if(open_action == 'quality') {
						Remove2();
						Action(i, _cstm)
					}
				}
			}
		};
		this.Airplay = function() {
			for(var i = 0; i < faction.length; i++) {
				if(faction[i] == "airplay") {
					Value(i)
				}
			}
		};
		this.SetSetting = function(x) {
			for(var i = 0; i < faction.length; i++) {
				if(faction[i] == x) {
					Value(i);
					if(o['files_' + x]) {
						if(o['files_' + x].length > 1) {
							show(f[i])
						}
					}
					if(open_action == x) {
						Remove2();
						Action(i, _cstm)
					}
				}
			}
		};
		this.SetSubtitle = function() {
			for(var i = 0; i < faction.length; i++) {
				if(faction[i] == "subtitle") {
					Value(i);
					if(o.files_subtitle) {
						if(o.files_subtitle.length > 0) {
							var x = false;
							if(o.subs) {
								for(var y = 0; y < o.subs.length; y++) {
									if(o.subs[y] != '') {
										x = true;
										break
									}
								}
							} else {
								x = true
							}
							x ? show(f[i]) : ''
						}
					}
					if(open_action == 'subtitle') {
						Remove2();
						Action(i, 0)
					}
				}
			}
		};
		this.updatePlaylist = function(x) {
			o.playlist = x;
			UpdatePlaylist(0);
			if(exist(v.plstart)) {
				if(v.plstart.indexOf("x-") != 0) {
					for(var y in o.playlist_dic) {
						if(o.playlist_dic.hasOwnProperty(y)) {
							if(o.playlist_dic[y].pjs_id == v.plstart) {
								v.plstart = y
							}
						}
					}
				}
				if(exist(o.playlist_dic[v.plstart])) {
					FindPlStart(o.playlist_dic[v.plstart]);
					var y = o.playlist_dic[v.plstart]['pjs_i'];
					ActionPlaylist(y);
					if(v.playlist.openplaylistroot == 1 && style.droplist != 1) {
						UpdatePlaylist(0);
						setTimeout(function() {
							Resize()
						}, 500)
					} else {
						setTimeout(function() {
							ScrollTo(y);
							Resize()
						}, 500)
					}
					v.plstart = undefined
				} else {
					ActionPlaylist(0)
				}
			} else {
				ActionPlaylist(0)
			}
			if(style.droplist == 1) {
				if(!exist(o.droplist)) {
					o.droplist = new PluginDroplist()
				}
			}
		};
		this.playById = function(x) {
			if(exist(o.playlist_dic[x])) {
				FindPlStart(o.playlist_dic[x]);
				Action(o.playlist_dic[x]['pjs_i'], 0);
				ScrollTo(o.playlist_dic[x]['pjs_i'])
			}
		};
		this.openById = function(x) {
			if(exist(o.playlist_dic[x])) {
				FindPlStart(o.playlist_dic[x]);
				if(o.playlist_dic[x]["file"]) {
					ActionPlaylist(o.playlist_dic[x]['pjs_i']);
					UpdateVars0(x);
					o.actions.NewFile(o.playlist_dic[x]["file"], 1);
					UpdateVars(x);
					ScrollTo(o.playlist_dic[x]['pjs_i']);
					if(o.droplist) {
						o.droplist.Update()
					}
				} else if(o.playlist_dic[x]["folder"]) {
					UpdatePlaylist(x)
				}
			}
		};

		function showById(x) {
			if(exist(o.playlist_dic[x])) {
				plfolder = '';
				UpdatePlaylist(0);
				FindPlStart(o.playlist_dic[x]);
				UpdateVars0(x);
				Action(o.playlist_dic[x]['pjs_i'], 0);
				UpdateVars(x)
			}
		};
		this.PlaylistNext = function() {
			autonextopenfolder = true;
			var x = parseInt(plx) + 1;
			if(plid != '') {
				o.plhistory[plid] = true;
				shuffle = removebykey(shuffle, plid)
			}
			if(v.shuffle == 1) {
				x = Shuffle(shuffle);
				if(x == null) {
					if(v.shuffle8 == 1 || v.playlist.autoplaylist == 1) {
						shuffle_.sort(function(a, b) {
							return Math.random() - 0.5
						});
						for(var x in shuffle_) {
							if(shuffle_.hasOwnProperty(x)) {
								shuffle[x] = shuffle_[x]
							}
						}
						x = Shuffle(shuffle)
					} else {
						o.actions.ShuffleEnd()
					}
				}
			} else {
				if((faction[x] == "playlistfolder" || plx == -1) && plid != '') {
					var y = okpd().indexOf(plid);
					if(y < okpd().length) {
						var z = o.playlist_dic[okpd()[y + 1]];
						if(z) {
							if(exist(z.folder)) {
								z = o.playlist_dic[okpd()[y + 2]]
							}
							this.openById(z.id);
							x = -1;
							o.actions.Play()
						}
					}
				}
			}
			if(x > -1) {
				Action(x, 0);
				ScrollTo(x)
			}
		};

		function ScrollTo(x) {
			if(f[x] && !removed) {
				if(style.floatleft == 1) {
					var to = f[x].offsetLeft - 20;
					var m = new Motion({
						"mc": control,
						"type": "scrollleft",
						"to": to,
						"time": 0.3,
						"me": "scroll_left",
						"ease": "cubic"
					})
				} else {
					var to = f[x].offsetTop - container.offsetHeight / 2 + 20;
					var m = new Motion({
						"mc": control,
						"type": "scroll",
						"to": to,
						"time": 0.3,
						"me": "scroll_down",
						"ease": "cubic"
					})
				}
				setTimeout(Arrows, 1000)
			}
		}

		function Shuffle(obj) {
			var keys = Object.keys(obj);
			var x;
			for(var i = 0; i < keys.length; i++) {
				x = obj[keys[keys.length * Math.random() << 0]];
				if(x) {
					break
				}
			}
			return x
		};
		this.menuproc = function(x) {
			Menuproc(x)
		};

		function Menuproc(x) {
			mpi[x] > -1 ? Value(mpi[x]) : '';
			if(f2value[0]) {
				if(open_action == 'scale') {
					f2value[0].innerHTML = Math.round(o.mediascale.x * 100) + '%'
				} else {
					f2value[0].innerHTML = FltrVal(open_action)
				}
			}
		};

		function FltrVal(x) {
			if(x == "scale") {
				return Math.round(o.mediascale.x * 100) + '%'
			} else {
				return Math.round(existv(o.fltrs[x], o.menuproc[x]) * 100) + '%'
			}
		}
		this.PlaylistNextExist = function() {
			return NxtExt()
		};

		function NxtExt() {
			if(v.shuffle == 1) {
				return Object.keys(shuffle).length > 0
			}
			var x = false;
			if(o.playlist_dic) {
				x = okpd().indexOf(plid) < okpd().length - 1
			}
			return x
		};
		this.PlaylistRewind = function() {
			if(exist(o.pl_first_id)) {
				showById(o.pl_first_id)
			}
		};
		this.PlaylistPrevExist = function() {
			var x = plx > 0;
			if(o.playlist_dic) {
				var z = okpd().indexOf(plid);
				x = z > 0;
				if(z == 1) {
					if(exist(o.playlist_dic[okpd()[0]].folder)) {
						x = false
					}
				}
			}
			return x
		};
		this.PlaylistExist = function() {
			return exist(o.playlist_dic)
		};
		this.PlaylistPrev = function() {
			autoprevopenfolder = true;
			if(this.PlaylistPrevExist()) {
				var x = parseInt(plx) - 1;
				if(x < 0) {
					var y = okpd().indexOf(plid);
					if(y > 0) {
						var z = o.playlist_dic[okpd()[y - 1]];
						if(z) {
							if(exist(z.folder)) {
								z = o.playlist_dic[okpd()[y - 2]]
							}
							if(z) {
								this.openById(z.id);
								o.actions.Play()
							}
						}
					}
				} else {
					Action(x, 0);
					ScrollTo(x)
				}
			}
		};
		this.PlaylistHere = function() {
			if(plx > 0) {
				ScrollTo(plx)
			}
		};

		function f2i(x, i) {
			return f2action[i].indexOf(x)
		};

		function FindPlStart(x) {
			if(x['pjs_parent_i'] != -1) {
				FindPlStart(o.playlist_dic[x['pjs_parent']]);
				UpdatePlaylist(x['pjs_parent'])
			} else {
				UpdatePlaylist(0)
			}
		};
		this.g = function(x) {
			switch(x) {
				case "width":
					return Width();
					break;
				case "height":
					return container.offsetHeight;
					break;
				case "top":
					return style.margintop;
					break;
				case "scroll_height":
					return control.scrollHeight;
					break;
				case "margin_bottom":
					return style.marginbottom;
					break;
				case "x":
					return int(container.style.left);
					break;
				case "y":
					return int(container.style.top);
					break;
				case "opacity":
					return container.style.opacity;
					break;
				case "show":
					return is_visible;
					break;
				case "open":
					return open_settings;
					break;
				case "key":
					return key;
					break;
				case "motion_id":
					return key + motion_id;
					break;
				case "empty":
					return empty;
					break;
				case "playlist":
					return is == "playlist";
					break;
				case "played":
					return o.plhistory[plid];
					break;
				case "activeicon":
					return _activeIcon;
					break;
				case "butplstart":
					return o.playlist_dic[o.butplstart] ? o.playlist_dic[o.butplstart].title : '';
				case "title2":
					return v.title2 ? v.title2 : '';
				case "nxtttl":
					return NxtExt() ? o.playlist_dic[okpd()[okpd().indexOf(plid) + 1]].title : ''
			}
		};

		function okpd() {
			return Object.keys(o.playlist_dic)
		};
		this.prenewpl = function() {
			plid = '';
			v.plstart = ''
		};
		this.empty = function() {
			if(is == "settings") {
				var x = 0;
				for(var i = 1; i < 11; i++) {
					if(faction[i] == "quality") {
						var y = o.files_quality.length;
						if(exist(v.forbidden_quality)) {
							var z = v.forbidden_quality.split(",");
							for(var j = 0; j < z.length; j++) {
								if(o.files_quality.indexOf(z[j]) > -1) {
									y--
								}
							}
						}
						if(y > 0) {
							if(y > 1 || (y == 1 && o.files_quality != 1 && style.show1value == 1)) {
								x++
							}
						}
					}
					if(faction[i] == "airplay") {
						if(o.airplay) {
							x++
						}
					}
					if(faction[i] == "download") {
						if(o.file_type == 'native' || v.download) {
							x++
						}
					}
					if(faction[i] == "audiotrack") {
						if(o.files_audiotrack.length > 0) {
							x++
						}
					}
					if(faction[i] == "channel" && v.channels == 1) {
						if(o.files_channel.length > 0) {
							x++
						}
					}
					if(faction[i] == "subtitle") {
						if(exist(o.subs)) {
							for(var s = 0; s < o.subs.length; s++) {
								if(o.subs[s] != '') {
									x++;
									break
								}
							}
						}
						if(x == 1 && o.subload == 1) {
							x = 0
						}
						if(v.sub_upload == 1 && v.sub_upload0 == 1) {
							x++
						}
					}
					if(faction[i] == "speed") {
						if(o.file_type != "vimeo") {
							x++
						}
					}
					if(faction[i] in o.menuproc || faction[i] == "share" || faction[i] == "color") {
						x++
					}
					if(faction[i]) {
						if(faction[i].indexOf("timer") > 0) {
							x++
						}
					}
					if(v.settings[is + i + 'hide'] == 1) {
						x--
					}
				}
				return x == 0
			} else if(is == "playlist") {
				return f.length == 0
			} else {
				return empty
			}
		};
		this.Remove = function() {
			if(container.parentNode == o.frame) {
				container.removeChild(control);
				o.frame.removeChild(container);
				o.droplist ? o.droplist.Remove() : '';
				container = null;
				control = null;
				removed = true
			}
		}
	};
	var PluginDash = function() {
		var dash;
		var audio_init = false;
		var subtracks;
		var pip;
		var span05 = "<span style='opacity:0.5'>";
		this.script = function() {
			Scrpt()
		};

		function Scrpt() {
			var scrpt = Script("cdn.dashjs.org", "cdn.dashjs.org/v4.4.1/dash.all.min.js", "dash_all");
			if(scrpt) {
				clearInterval(o.dashInterval);
				o.dashInterval = setInterval(WaitDash, 100);
				scrpt.onerror = function(e) {
					clearInterval(o.dashInterval);
					o.actions.MediaReady();
					o.media.onError('DASH SDK not found')
				}
			}
		}
		this.create = function(x, pjstg, url, pip) {
			Create(x, pjstg, url, pip)
		};
		this.seek = function(x) {
			dash ? dash.seek(x) : ''
		};
		this.auto = function() {
			return Auto()
		};

		function Auto() {
			var x = false;
			if(dash) {
				var y = dash.getSettings();
				x = y.streaming.abr.autoSwitchBitrate.video
			}
			return x
		};
		this.setQuality = function(x) {
			var x = parseInt(x);
			if(dash) {
				if(x == dash.getBitrateInfoListFor("video").length) {
					o.current_quality = dash.getQualityFor('video');
					dash.updateSettings({
						'streaming': {
							'abr': {
								'autoSwitchBitrate': {
									'audio': true,
									'video': true
								}
							}
						}
					})
				} else {
					dash.updateSettings({
						'streaming': {
							'abr': {
								'autoSwitchBitrate': {
									'audio': false,
									'video': false
								}
							}
						}
					});
					dash.setQualityFor('video', x);
					dash.setQualityFor('audio', x)
				}
			}
		};
		this.setAudio = function(x) {
			if(dash) {
				dash.setCurrentTrack(dash.getTracksFor('audio')[parseInt(x)])
			}
		};
		this.getDash = function() {
			if(dash) {
				return dash
			} else {
				return false
			}
		};
		this.levels = function() {
			if(dash) {
				return x = dash.getBitrateInfoListFor("video").length
			} else {
				return 0
			}
		};
		this.subtrack = function() {
			if(dash && subtracks) {
				subtracks.DashSubTrack(x)
			}
		};
		this.reset = function() {
			dash ? dash.reset() : ''
		};
		this.time = function() {
			return dash ? dash.time() : 0
		};
		this.duration = function() {
			return dash ? dash.duration() : 0
		};
		this.source = function(x) {
			dash ? dash.attachSource(x) : ''
		};

		function WaitDash() {
			if(exist(window.dashjs)) {
				clearInterval(o.dashInterval);
				o.media ? o.media.onDash() : ''
			}
		}

		function Create(x, tag, url, pip) {
			if(!exist(window.dashjs)) {
				return
			}
			if(dash) {
				dash.reset();
				dash = undefined
			}
			pip = pip;
			subtracks = undefined;
			audio_init = false;
			log("DASH");
			v.preloaddash = 1;
			var dash_config = {
				bufferLength: 60
			};
			if(o.files.length > 1) {
				v.dashquality = 0;
				v.dashquality_off = true
			} else {
				v.dashquality_off ? v.dashquality = 1 : ''
			}
			if(o.audiotracks.length > 1) {
				v.dashaudio = 0;
				v.dashaudio_off = true
			} else {
				v.dashaudio_off ? v.dashaudio = 1 : ''
			}
			if(exist(v.dashconfig)) {
				if(exist(v.dashconfig.bufferLength)) {
					if(v.dashconfig.bufferLength > 600) {
						v.dashconfig.bufferLength = 600
					}
				}
				if(typeof v.dashconfig == "object") {
					for(var key in v.dashconfig) {
						dash_config[key] = v.dashconfig[key]
					}
				}
			}
			dash = dashjs.MediaPlayer().create();
			js("dash", dash, 1);
			v.dashdebug == 1 && !pip ? dash.updateSettings({
				'debug': {
					'logLevel': dashjs.Debug.LOG_LEVEL_DEBUG
				}
			}) : '';
			var ap = (o.play || v.autoplay == 1 || pip || x);
			dash.initialize(tag, url, ap);
			if(v.dashdrm == 1) {
				var ddj = v.dashdrmjson;
				if(ddj) {
					if(typeof(ddj) == "string") {
						try {
							ddj = ddj.replace(/pjs'qt/ig, '"');
							ddj = JSON.parse(ddj)
						} catch(e) {
							log("incorrect DASH DRM JSON")
						}
					}
					if(typeof(ddj) == "object") {
						dash.setProtectionData(ddj)
					}
				}
			}
			dash.updateSettings({
				streaming: {
					buffer: {
						fastSwitchEnabled: true,
						stableBufferTime: (dash_config.buffer0 == 1 && !ap ? 0 : dash_config.bufferLength)
					}
				}
			});
			if(v.dashsettings) {
				dash.updateSettings(v.dashsettings)
			}
			if(v.dashcookies == 1) {
				dash.setXHRWithCredentialsForType(undefined, true)
			}
			if(v.dashlowquality == 1) {
				dash.updateSettings({
					'streaming': {
						'abr': {
							'autoSwitchBitrate': {
								'audio': false,
								'video': false
							}
						}
					}
				})
			}
			dash.on(dashjs.MediaPlayer.events.STREAM_INITIALIZED, function(data) {
				log("DASH attached");
				var q = QualityLevels();
				AudioTracks();
				o.dash_subs = false;
				if(v.dashsubtracks == 1) {
					subtracks = new PluginDashSubtitles(dash, pip)
				}
				o.live = dash.isDynamic();
				o.live ? log("Live") : '';
				if(v.dashquality == 1) {
					var br = dash.getBitrateInfoListFor("video");
					if(v.dashlowquality == 1 || q > 0) {
						o.current_quality = q;
						dash.updateSettings({
							'streaming': {
								'abr': {
									'autoSwitchBitrate': {
										'audio': false,
										'video': false
									}
								}
							}
						})
					} else {
						o.current_quality = br.length - 1
					}
					o.bitrate = br[o.current_quality].bitrate;
					o.controls.QualityChangedNoHand(o.current_quality);
					if(!Auto()) {
						dash.setQualityFor("video", o.current_quality);
						dash.setQualityFor("audio", o.current_quality)
					}
				}
				o.actions.MediaReady()
			});
			dash.on(dashjs.MediaPlayer.events.PLAYBACK_PLAYING, function(data) {
				if(dash_config.buffer0 == 1 && !ap) {
					dash.updateSettings({
						streaming: {
							buffer: {
								stableBufferTime: dash_config.bufferLength
							}
						}
					})
				}
				if(!audio_init) {
					var track = parseInt(o.current_audiotrack);
					if(track > 0 && v.dashaudio == 1) {
						dash.setCurrentTrack(dash.getTracksFor("audio")[track])
					}
					audio_init = true
				}
			});
			dash.on(dashjs.MediaPlayer.events.PLAYBACK_TIME_UPDATED, function(data) {
				if(o.live) {
					o.actions.Duration(dash.time(), dash.duration())
				}
			});
			dash.on(dashjs.MediaPlayer.events.TEXT_TRACKS_ADDED, function(data) {
				dash.setTextTrack(-1)
			});
			dash.on(dashjs.MediaPlayer.events.QUALITY_CHANGE_REQUESTED, function(data) {
				if(data.mediaType == "video" && data.oldQuality != data.newQuality && v.dashquality == 1) {
					o.current_quality = data.newQuality;
					o.controls.QualityChangedNoHand(o.current_quality);
					log("DASH Level " + o.current_quality)
				}
			});
			dash.on(dashjs.MediaPlayer.events.FRAGMENT_LOADING_COMPLETED, function(data) {
				if(exist(data.request)) {
					if(data.request.type == "MediaSegment") {
						js("fragment", data.request.url)
					}
				}
			});
			dash.on(dashjs.MediaPlayer.events.PLAYBACK_NOT_ALLOWED, function(e) {
				log('DASH mute', e.type);
				!o.muted ? o.actions.Mute() : ''
			});
			dash.on(dashjs.MediaPlayer.events.ERROR, function(data) {
				if(data.error) {
					if(typeof data.error == "object") {
						o.dasherror = data.error.message
					} else {
						o.dasherror = data.error
					}
				}
				error = "DASH " + o.dasherror;
				o.media.onError()
			})
		}

		function QualityLevels() {
			var q = 0;
			if(!pip && v.dashquality == 1 && dash) {
				o.files_quality = [];
				var x = dash.getBitrateInfoListFor("video");
				if(x.length > 1) {
					var y = '';
					for(var i = 0; i < x.length; i++) {
						o.files_quality[i] = exist(x[i].height) ? o.media.renameQualities(x[i], v.nameofdashquality) : i;
						if(o.files_quality[i] == y || v.dashaddbitrate == 1) {
							y = o.files_quality[i];
							if(exist(x[i].bitrate)) {
								o.files_quality[i] += " " + span05 + " &nbsp;" + parseInt(x[i].bitrate / 1000) + ' ' + Lang('kbps') + '</span>';
								v.dashaddbitrate != 1 ? o.files_quality[i - 1] += " " + span05 + " &nbsp;" + parseInt(x[i - 1].bitrate / 1000) + ' ' + Lang('kbps') + '</span>' : '';
								y = ''
							}
						} else {
							y = o.files_quality[i]
						}
						if(exist(v.default_quality) && q == 0) {
							if(v.default_quality == o.files_quality[i]) {
								q = i
							}
						}
						if(exist(o.default_quality)) {
							if(o.default_quality == o.files_quality[i]) {
								q = i
							}
						}
					}
					o.files_quality[x.length] = Lang("auto")
				}
			}
			return q
		}

		function AudioTracks() {
			if(!pip && v.dashaudio == 1 && dash) {
				o.current_audiotrack = 0;
				var x = dash.getTracksFor("audio");
				if(x.length > 1) {
					for(var i = 0; i < x.length; i++) {
						o.files_audiotrack[i] = i;
						if(exist(x[i].lang)) {
							o.files_audiotrack[i] = o.media.renameTracks(x[i].lang)
						} else {
							if(exist(x[i].index)) {
								o.files_audiotrack[i] = Lang("audiotrack") + " " + x[i].index
							}
						}
						if(exist(o.default_audio)) {
							if(o.default_audio == o.files_audiotrack[i]) {
								o.current_audiotrack = i
							}
						}
					}
				}
				log("DASH AudioTrack ", o.current_audiotrack);
				o.controls.AudioTrackChangedNoHand(o.current_audiotrack)
			}
		}
	};
	var ChromeCast = function() {
		var player;
		var controller;
		var deviceName;
		var words;
		var current_color;
		window['__onGCastApiAvailable'] = function(x, y) {
			if(x) {
				for(var i = 0; i < pljssglobal.length; i++) {
					if(pljssglobal[i]) {
						pljssglobal[i].api('castinit')
					}
				}
			} else {
				_log("error: " + y)
			}
		};
		this.init = function() {
			CastInit()
		};

		function CastInit() {
			_log("available");
			if(exist(chrome.cast) && exist(cast) && !o.cast_available) {
				var rid = 'CC1AD845';
				if(v.chromecast.receiver == 1 && v.chromecast.receiverid) {
					rid = v.chromecast.receiverid
				}
				cast.framework.CastContext.getInstance().setOptions({
					receiverApplicationId: rid,
					autoJoinPolicy: 'tab_and_origin_scoped',
					language: 'en-US',
					resumeSavedSession: false
				});
				player = new cast.framework.RemotePlayer();
				Controller();
				o.cast_available = true;
				setTimeout(Available, 1000)
			}
		}

		function Available() {
			o.controls.Review();
			o.controls.resize()
		}

		function Connection(data) {
			if(cast && cast.framework) {
				_log((!player.isConnected ? 'dis' : '') + "connected");
				if(player.isConnected) {
					PlayRemote()
				} else {
					PlayLocal()
				}
			}
		}

		function PlayRemote(x) {
			var session = cast.framework.CastContext.getInstance().getCurrentSession();
			var mime = 'video/mp4';
			o.file_type == "hls" ? mime = "application/x-mpegurl" : '';
			o.file_type == "dash" ? mime = "application/dash+xml" : '';
			var url = o.media.currentFile();
			if(exist(v.casturl)) {
				url = v.casturl
			}
			var info = new chrome.cast.media.MediaInfo(url, mime);
			info.metadata = new chrome.cast.media.GenericMediaMetadata();
			info.metadata.metadataType = chrome.cast.media.MetadataType.GENERIC;
			var tracks = [];
			if(exist(o.subs) && exist(o.current_subtitle) && v.chromecast.sub == 1) {
				info.textTrackStyle = SubStyle();
				for(var i in o.subs) {
					if(o.subs[i].indexOf('vtt') > 0) {
						var t = new chrome.cast.media.Track(0, chrome.cast.media.TrackType.TEXT);
						t.trackContentId = o.subs[i];
						t.trackContentType = 'text/vtt';
						t.subtype = 'CAPTIONS';
						t.name = o.files_subtitle[i];
						t.trackId = parseInt(i);
						t.customData = null;
						tracks.push(t)
					}
				}
				if(tracks.length > 0) {
					info.tracks = tracks
				}
			}
			if(v.poster) {
				info.metadata.images = [new chrome.cast.Image(v.poster)]
			}
			info.metadata.title = o.titlestore ? o.titlestore : (v.title ? v.title : '');
			var request = new chrome.cast.media.LoadRequest(info);
			request.currentTime = o.seekto > 0 ? o.seekto : (o.casting ? 0 : o.media.time());
			request.autoplay = o.play || x == true;
			if(tracks.length > 0 && o.current_subtitle > -1) {
				if(o.current_subtitle < tracks.length) {
					request.activeTrackIds = [parseInt(o.current_subtitle)];
					_log('subtitle ' + o.current_subtitle)
				}
			}
			session.loadMedia(request).then(function() {
				deviceName = session.getCastDevice().friendlyName;
				_log("connected to " + deviceName);
				if(v.chromecast.message != 0 && !o.casting) {
					words ? o.frame.removeChild(words) : '';
					words = createElement("div");
					css(words, {
						"position": "absolute",
						"top": "20px",
						"width": "100%",
						"left": 0,
						"opacity": 0.7,
						"color": "#fff",
						"pointer-events": "none"
					});
					words.innerHTML = '<center>' + Lang("castdevice") + ' &laquo;' + deviceName + '&raquo;</center>';
					o.frame.appendChild(words)
				}
				player.volumeLevel = v.volume;
				controller.setVolumeLevel();
				if(o.muted && !player.isMuted) {
					controller.muteOrUnmute()
				}
				js("casted");
				if(x != true) {
					if(!o.play) {
						!player.isPaused ? controller.playOrPause() : ''
					} else {
						o.media.Pause()
					}
				}
				hide(o.mediacontainer);
				o.casting = true
			}, function(e) {
				_log(e);
				PlayLocal();
				o.alert.txt(Lang("casterror"))
			})
		}

		function PlayLocal() {
			words ? o.frame.removeChild(words) : '';
			words = undefined;
			o.casting = false;
			show(o.mediacontainer);
			js("uncasted");
			if(player.savedPlayerState) {
				o.actions.Seek(player.savedPlayerState.currentTime);
				if(player.savedPlayerState.isPaused) {
					o.media.Pause()
				} else {
					o.media.Play()
				}
			}
		}

		function PlayChanged() {
			if(player.isPaused) {
				_log("pause");
				js("castpause");
				o.controls.Pause()
			} else {
				_log("play");
				js("castplay");
				o.controls.Play()
			}
		}

		function VolumeChanged() {
			o.actions.Volume(player.volumeLevel)
		}

		function MuteChanged() {
			player.isMuted ? o.actions.Mute() : o.actions.Unmute()
		}

		function StateChanged() {
			if(player.isConnected) {
				if(player.playerState == null) {
					if(player.currentTime == player.duration) {
						o.controls.Pause();
						o.media.onEnded()
					}
				}
			}
		}

		function Controller() {
			controller = new cast.framework.RemotePlayerController(player);
			controller.addEventListener(cast.framework.RemotePlayerEventType.IS_CONNECTED_CHANGED, Connection);
			controller.addEventListener(cast.framework.RemotePlayerEventType.IS_PAUSED_CHANGED, PlayChanged);
			controller.addEventListener(cast.framework.RemotePlayerEventType.VOLUME_LEVEL_CHANGED, VolumeChanged);
			controller.addEventListener(cast.framework.RemotePlayerEventType.IS_MUTED_CHANGED, MuteChanged);
			controller.addEventListener(cast.framework.RemotePlayerEventType.PLAYER_STATE_CHANGED, StateChanged)
		}
		Script('gstatic.com/cv', 'https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1');

		function _log(x) {
			if(v.chromecast && v.log == 1) {
				log("chromecast", x)
			}
		}
		this.button = function(x) {
			current_color = x;
			return "<button is='google-cast-button' id='pjs_cast_button_" + v.id + "' style='padding:0;width:20px;height:20px;--connected-color:" + x + ";--disconnected-color:" + x + ";border:0;background:transparent;pointer-events:auto;cursor:pointer'></button>"
		};
		this.Color = function(x, y) {
			if(current_color != y) {
				var el = document.getElementById("pjs_cast_button_" + v.id);
				if(el) {
					var style = el.getAttribute("style");
					var clr = new RegExp(current_color, "gi");
					style = style.replace(clr, y);
					el.setAttribute("style", style)
				}
				current_color = y
			}
		};
		this.Volume = function(x) {
			if(player.isConnected) {
				player.volumeLevel = x;
				controller.setVolumeLevel()
			}
		};
		this.Mute = function() {
			if(player.isConnected) {
				if(!player.isMuted) {
					controller.muteOrUnmute()
				}
			}
		};
		this.Unmute = function() {
			if(player.isConnected) {
				if(player.isMuted) {
					controller.muteOrUnmute()
				}
			}
		};
		this.Play = function(x) {
			if(player.isConnected) {
				if(player.isPaused) {
					controller.playOrPause()
				} else {
					if(player.playerState == null) {}
				}
			}
		};
		this.Pause = function(x) {
			if(player.isConnected && !player.isPaused) {
				controller.playOrPause()
			}
		};
		this.Sub = function() {
			if(v.chromecast.sub == 1) {
				UpdateSub()
			}
		};

		function UpdateSub() {
			if(player.isConnected) {
				var ss = SubStyle();
				var request = new chrome.cast.media.EditTracksInfoRequest([parseInt(o.current_subtitle)], ss);
				cast.framework.CastContext.getInstance().getCurrentSession().getSessionObj().media[0].editTracksInfo(request, function() {
					_log('subtitle ' + o.current_subtitle)
				}, function(e) {
					_log('subtitle error' + e)
				})
			}
		}

		function SubStyle() {
			var x = new chrome.cast.media.TextTrackStyle();
			var bga = Math.round(v.sub_bga * 255).toString(16);
			x.backgroundColor = CheckColor(v.sub_bgcolor) + (bga.length == 1 ? bga + '0' : bga);
			x.edgeColor = '#00000016';
			x.edgeType = 'DROP_SHADOW';
			x.fontFamily = 'CASUAL';
			x.fontScale = parseFloat(parseInt(v.sub_sizeproc) / 100);
			x.foregroundColor = CheckColor(v.sub_color) + Math.round(255).toString(16);
			return x
		};
		this.Time = function(x) {
			var x;
			if(player.isConnected) {
				x = player.currentTime
			}
			return x
		};
		this.Duration = function(x) {
			var x;
			if(player.isConnected) {
				x = player.duration
			}
			return x
		};
		this.Exit = function() {
			if(cast && cast.framework) {
				PlayLocal()
			}
		};
		this.Go = function() {
			if(cast && cast.framework) {
				if(player.isConnected) {
					PlayRemote(o.play)
				}
			}
		};
		this.Seek = function(x) {
			if(player.isConnected) {
				player.currentTime = x;
				controller.seek()
			}
		}
	};
	var PluginSub = function() {
		var sub = [];
		var upld = [];
		var empty = true;
		var ioff;
		var loading = -1;
		var lastsub;
		var wait;
		var parsed = [];
		var alldd;
		this.start = function(x) {
			if(!x && wait) {
				Start(wait);
				wait = undefined
			} else {
				x ? Start(x) : ''
			}
		};
		this.check = function(x) {
			Start(x)
		};

		function Start(x) {
			!x ? x = '' : '';
			if(x != '11') {
				var start = 0;
				var urlcnfg = true;
				var memory = '';
				o.subs = x.split(",");
				o.files_subtitle = [];
				o.current_subtitle = -1;
				if(StorageSupport() && v.sub_store == 1) {
					if(localStorage.getItem("pljssubtitle") != null) {
						memory = localStorage.getItem("pljssubtitle")
					}
				} else {
					if(o.remember_sub) {
						memory = o.remember_sub
					}
				}
				for(var i = 0; i < o.subs.length; i++) {
					if(o.subs[i].indexOf("#0") == 0) {
						o.subs[i] = fd0(o.subs[i])
					}
					if(o.subs[i].indexOf("#" + v.enc2) == 0) {
						o.subs[i] = o[o.fd[0]](o.subs[i])
					}
					if(o.subs[i].indexOf("#" + v.enc3) == 0 && o.subs[i].indexOf(v.file3_separator) > 0) {
						o.subs[i] = o[o.fd[1]](o.subs[i])
					}
					if(o.subs[i].indexOf("[") == 0 && o.subs[i].indexOf("]") > 1) {
						o.files_subtitle[i] = o.subs[i].substr(o.subs[i].indexOf("[") + 1, o.subs[i].indexOf("]") - 1);
						o.subs[i] = o.subs[i].substr(o.subs[i].indexOf("]") + 1);
						urlcnfg = false
					} else {
						o.files_subtitle[i] = o.subs[i].substr(o.subs[i].lastIndexOf("/") + 1);
						o.files_subtitle[i] = o.files_subtitle[i].substr(0, o.files_subtitle[i].lastIndexOf("."))
					}
					if(o.subs[i].indexOf("#0") == 0) {
						o.subs[i] = fd0(o.subs[i])
					}
					if(o.subs[i].indexOf("#" + v.enc2) == 0) {
						o.subs[i] = o[o.fd[0]](o.subs[i])
					}
					if(o.subs[i].indexOf("#" + v.enc3) == 0 && o.subs[i].indexOf(v.file3_separator) > 0) {
						o.subs[i] = o[o.fd[1]](o.subs[i])
					}
				}
				if(o.files_subtitle.length > 1 && v.sub_all == 1) {
					o.files_subtitle.push(StringVar('sub_all_title', Lang('together')));
					o.subs.push("all")
				}
				if(o.files_subtitle.length > 0 && v.sub_off == 1) {
					if(v.sub_off0 == 1) {
						ioff = 0;
						start++;
						o.files_subtitle.unshift(StringVar('sub_off_title', Lang('off')));
						o.subs.unshift("")
					} else {
						o.files_subtitle.push(StringVar('sub_off_title', Lang('off')));
						o.subs.push("");
						ioff = o.files_subtitle.length - 1
					}
				}
				for(var i = 0; i < o.subs.length; i++) {
					if(exist(v.default_subtitle)) {
						if(v.default_subtitle == o.files_subtitle[i]) {
							start = i;
							o.current_subtitle = i;
							v.subtitle_start = 1
						}
					}
					if(memory != '') {
						if(memory == o.files_subtitle[i]) {
							start = i;
							o.current_subtitle = i
						}
					}
				}
				if(v.sub_off == 1 && v.subtitle_start == 0) {
					o.current_subtitle = ioff
				}
				exist(o.controls) ? o.controls.SubtitleChanged() : '';
				if(v.subtitle_start == 1) {
					o.current_subtitle = start;
					if(o.start) {
						if(v.sub_all == 1 && o.subs[start] == "all") {
							SubtitleLoadAll(o.current_subtitle)
						} else {
							SubtitleLoad(o.current_subtitle)
						}
					} else {
						wait = x;
						o.subtitle_on = o.subs[start] != 'off';
						setTimeout(Parsed, 500)
					}
				} else {
					if(urlcnfg && o.subs.length < 3) {
						SubtitleLoad(ioff == 0 ? 1 : 0)
					}
					v.sub_off != 1 ? o.current_subtitle = -1 : ''
				}
			} else {
				Remove()
			}
		}

		function SubtitleLoad(x) {
			if(exist(o.subs[x])) {
				if(o.subs[x].indexOf(".") > -1) {
					o.subsor = o.subs[x].split(" or ");
					o.sub_or = 0;
					SubtitleLoad2(x)
				} else {
					if(o.subs[x].indexOf('upld') == 0) {
						if(upld[o.subs[x].substr(4)]) {
							SubtitleParse(o.files_subtitle[x], upld[o.subs[x].substr(4)])
						}
					}
				}
			}
		}

		function SubtitleLoadAll(x) {
			o.subtitle_on = true;
			Parsed()
		}

		function SubtitleLoad2(x) {
			var url = trim(o.subsor[o.sub_or]);
			if(parsed[url]) {
				if(o.subs[x] != 'all') {
					o.subtitle_on = true;
					Parsed()
				}
			} else {
				var xhr = XHR(url);
				loading = x;
				o.subload = 1;
				xhr.onload = function() {
					o.subload = 0;
					if(this.readyState == 4 && this.status == 200) {
						o.subtitle_on = true;
						SubtitleParse(url, this.responseText, x)
					} else {
						if(o.sub_or + 1 < o.subsor.length) {
							o.sub_or++;
							SubtitleLoad2(loading)
						} else {
							SubtitleError("loading_error")
						}
					}
				};
				xhr.onerror = function(e) {
					o.subload = 0;
					if(o.sub_or + 1 < o.subsor.length) {
						o.sub_or++;
						SubtitleLoad2(loading)
					} else {
						SubtitleError("loading_error")
					}
				};
				xhr.send()
			}
		};

		function SubtitleError(x) {
			log("subtitle not found or access denied");
			if(o.files_subtitle[o.current_subtitle]) {
				if(o.files_subtitle[o.current_subtitle].indexOf(Lang("loading_error")) == -1) {
					o.files_subtitle[o.current_subtitle] = o.files_subtitle[o.current_subtitle] + ' (' + Lang(x) + ')'
				}
			}
			if(v.subtitle_errdel == 1 && loading > -1) {
				o.subs[loading] = '';
				o.files_subtitle[loading] = ''
			}
			o.current_subtitle = -1;
			o.subtitle_on = false;
			if(o.constrols) {
				o.controls.SubtitleChanged();
				o.controls.refresh()
			} else {
				setTimeout(function() {
					if(o.controls) {
						o.controls.SubtitleChanged();
						o.controls.refresh()
					}
				}, 100)
			}
			if(exist(o.subtitle)) {
				o.frame.removeChild(o.subtitle);
				o.subtitle = null
			}
		}

		function SubtitleParse(url, x, y) {
			if(x.indexOf("#" + v.enc2) == 0) {
				x = o[o.fd[0]](x)
			}
			if(x.indexOf("#" + v.enc3) == 0 && x.indexOf(v.file3_separator) > 0) {
				x = o[o.fd[1]](x)
			}
			if(url.indexOf('.srt') > -1 || url.indexOf('.ass') > -1 || url.indexOf('.ssa') > -1 || url.indexOf('.vtt') > -1) {
				var l = o.current_subtitle;
				if(o.subs[l] == "all") {
					l = y
				}
				sub[l] = Object();
				sub[l][0] = Array();
				sub[l][1] = Array();
				var rows = Array();
				rows = x.split(/\r|\n/);
				var cnt = 1;
				var t1 = 0;
				var t2 = 0;
				var url_shift = (exist(v.subshift) ? v.subshift : 0);
				if(url.indexOf('shift=') > 0) {
					url_shift = url.substr(url.indexOf('shift=') + 6) * 1
				}
				for(var i = 0; i < rows.length; i++) {
					if(url.indexOf('.srt') > -1 || url.indexOf('.vtt') > -1) {
						if(rows[i].indexOf('-->') > -1 && rows[i].indexOf(':') > -1) {
							t1 = TimeSub(rows[i].substr(0, rows[i].indexOf('-->'))) * 1 + url_shift;
							t1 == 0 ? t1 = 1 : '';
							t2 = TimeSub(rows[i].substr(rows[i].indexOf('-->') + 4, 12)) * 1 + url_shift;
							exist(sub[l][0][t1]) ? '' : sub[l][0][t1] = '';
							for(var j = t1; j < t2; j++) {
								sub[l][1][j] = t1
							}
							cnt++
						} else {
							rows[i] = trim(rows[i]);
							if(rows[i] != '' && rows[i].length > 0 && rows[i] != cnt && rows[i] != 'WEBVTT') {
								sub[l][0][t1] = (exist2(sub[l][0][t1]) ? sub[l][0][t1] + '<br>' : '') + rows[i]
							}
						}
					}
					if(url.indexOf('.ass') > -1 || url.indexOf('.ssa') > -1) {
						if(rows[i].indexOf('Dialogue:') > -1) {
							t1 = TimeSub(rows[i].substr((url.indexOf('.ssa') > -1 ? rows[i].indexOf('=0') + 3 : 12), 12)) * 1 + url_shift;
							t2 = TimeSub(rows[i].substr((url.indexOf('.ssa') > -1 ? rows[i].indexOf('=0') + 14 : 23), 10)) * 1 + url_shift;
							var p = '';
							if(rows[i].indexOf('0,,') > 0) {
								p = rows[i].substr(rows[i].indexOf('0,,') + 3)
							} else {
								if(rows[i].indexOf('ffect,') > 0) {
									p = rows[i].substr(rows[i].indexOf('ffect,') + 6)
								}
							}
							if(sub[l][0][t1] != undefined) {
								sub[l][0][t1] += '\n'
							} else {
								sub[l][0][t1] = p
							}
							sub[l][0][t1] = sub[l][0][t1].replace(/{.*?}/, '');
							sub[l][0][t1] = sub[l][0][t1].replace(/\\\\N/, '<br>');
							sub[l][0][t1] = sub[l][0][t1].replace(/\\N/, '<br>');
							for(var j = t1; j < t2; j++) {
								sub[l][1][j] = t1
							}
						}
					}
				}
				parsed[url] = true;
				if(o.subs[y] != 'all') {
					Parsed()
				}
			} else {
				if(x != '') {
					if(x.indexOf('[') == 0) {
						Start(x)
					} else {
						SubtitleError("error")
					}
				} else {
					Remove();
					o.controls.refresh()
				}
			}
		}

		function Parsed() {
			o.controls.SubtitleChanged();
			o.actions.RenewSubtitle();
			o.controls.refresh()
		}

		function TimeSub(srt) {
			var tmp = srt.split(':');
			var out = 0;
			tmp.length == 2 ? tmp.unshift("00") : '';
			tmp[0] != '00' ? out += tmp[0] * 3600 : '';
			tmp[1] != '00' ? out += tmp[1] * 60 : '';
			out += tmp[2].substr(0, 2) * 1;
			out = out * 10 + tmp[2].substr(3, 1) * 1;
			return out
		};

		function SetSubtitle(x) {
			if(exist(o.current_subtitle)) {
				if(o.current_subtitle != x) {
					if(x == -1 || (v.sub_off == 1 && x == ioff)) {
						SubtitleOff()
					} else {
						v.sub_shift = 0;
						o.current_subtitle = x;
						o.subtitle_on = true;
						v.subtitle_start = 1;
						SetSubtitle2(x);
						js("subtitle", o.files_subtitle[x]);
						o.controls.SubtitleChanged()
					}
				} else {
					if(v.sub_off != 1) {
						SubtitleOff()
					}
				}
			}
		}

		function SubRem() {
			if(exist(o.files_subtitle[o.current_subtitle])) {
				if(o.storage && v.sub_store == 1) {
					localStorage.setItem("pljssubtitle", o.files_subtitle[o.current_subtitle])
				} else {
					o.remember_sub = o.files_subtitle[o.current_subtitle]
				}
			}
		}

		function SetSubtitle2(x) {
			if(exist(o.subs[x])) {
				log("Subtitle", x);
				o.current_subtitle = x;
				SubRem();
				if(o.file_type == "hls" && o.hls_subs == true) {
					o.media.hlsDashSub(x, "hls")
				} else {
					if(o.file_type == "dash" && o.dash_subs == true) {
						o.media.hlsDashSub(x, "dash")
					} else {
						if(o.subs[x] == "all") {
							SubtitleLoadAll(o.current_subtitle)
						} else {
							SubtitleLoad(o.current_subtitle)
						}
					}
				}
			}
		};
		this.SubUpload = function() {
			if(o.subupld) {
				var x = o.subupld.files;
				if(x[0]) {
					var y = new FileReader();
					y.onload = function(e) {
						var z = e.target.result;
						upld.push(z);
						o.current_subtitle = -1;
						var z = x[0].name;
						if(z.length > 40) {
							z = x[0].name.substr(0, 15) + '...' + x[0].name.substr(-15)
						}
						if(v.sub_off == 1 && v.sub_off0 == 1) {
							o.subs.push('upld' + (upld.length - 1));
							o.files_subtitle.push(z + '');
							SetSubtitle(o.subs.length - 1)
						} else {
							o.subs.unshift('upld' + (upld.length - 1));
							o.files_subtitle.unshift(z + '');
							v.sub_off == 1 ? ioff++ : '';
							SetSubtitle(0)
						}
						o.subupld.value = ""
					};
					y.readAsText(x[0])
				} else {
					o.subupld.click()
				}
			}
		};
		this.SetSubtitle = function(x) {
			SetSubtitle(x)
		};
		this.ioff = function() {
			return ioff
		};
		this.setioff = function(x) {
			ioff = x
		};
		this.show = function(x) {
			Show(x)
		};
		this.style = function() {
			Style()
		};
		this.remove = function() {
			Remove()
		};

		function SubtitleOff() {
			js("subtitle", "off");
			o.current_subtitle = v.sub_off == 1 ? ioff : -1;
			v.subtitle_start = 0;
			o.subtitle_on = false;
			o.controls.SubtitleChanged();
			SubRem();
			o.hls_subs || o.dash_subs ? SetSubtitle2(o.current_subtitle) : '';
			exist(o.subtitle) ? o.frame.removeChild(o.subtitle) : '';
			o.subtitle = null
		}

		function Show(time) {
			if(o.nativecontrols) {
				return
			}
			var t = parseInt(time * 10);
			if(v.sub_shift) {
				time = time - v.sub_shift * 1
			}
			if(o.subtitle_on && exist(o.subs)) {
				if(sub) {
					var x = o.current_subtitle;
					var t = parseInt(time * 10);
					if(v.subpausehide == 1 && !o.play) {
						return
					}
					if(o.subs[x] == "all") {
						if(!alldd) {
							for(var i = 0; i < o.subs.length; i++) {
								setTimeout(SubtitleLoad, i * 500, i)
							}
							if(!sub[x]) {
								sub[x] = Object();
								sub[x][0] = Array();
								sub[x][1] = Array()
							}
							alldd = true
						} else {
							if(sub[x][1][t]) {} else {
								for(var i = 0; i < o.subs.length; i++) {
									if(sub[i]) {
										if(exist(sub[i][1])) {
											if(exist(sub[i][1][t])) {
												if(!sub[x][0][t]) {
													sub[x][0][t] = ''
												}
												sub[x][0][t] += (sub[x][0][t] != '' ? '<br>[sub2]' : '') + sub[i][0][sub[i][1][t]] + (sub[x][0][t] != '' ? '[/sub2]' : '')
											}
										}
									}
								}
								if(exist(sub[x][0])) {
									if(exist(sub[x][0][t])) {
										sub[x][1][t] = t
									}
								}
							}
						}
					}
					if(exist(sub[x])) {
						if(exist(sub[x][1])) {
							if(exist(sub[x][1][t])) {
								var y = '';
								y = sub[x][0][sub[x][1][t]];
								if(!exist(o.subtitle)) {
									o.subtitle = createElement('div');
									attr(o.subtitle, {
										id: 'pjs_' + v.id + '_' + 'subtitle'
									});
									o.frame.appendChild(o.subtitle);
									Style();
									js("subtitles", o.files_subtitle[x])
								}
								if(empty) {
									show2(o.subtitle)
								}
								SubtitleBottom();
								if(v.sub_split2words == 1) {
									y = PluginSubword(y)
								}
								if(v.sub_all == 1) {
									y = y.replace(/\[sub2\]/gm, '<span style="color:' + CheckColor(v.sub_color2) + '">');
									y = y.replace(/\[\/sub2\]/gm, '</span>')
								}
								if(y.indexOf('<c.') > -1) {
									y = y.replace(/\<c./gm, '<span style=color:');
									y = y.replace(/\<\/c\>/gm, '</span>')
								}
								if(v.apiprm) {
									if(v.apiprm.sub == 1 && lastsub != y) {
										js("sub", y);
										lastsub = y
									}
								}
								o.subtitle.innerHTML = '<span style="' + (v.sub_bg == 1 ? 'background-color:' + hex2rgb(v.sub_bgcolor, v.sub_bga) + ';' : '') + '-webkit-box-decoration-break: clone;color:' + CheckColor(v.sub_color) + ';padding:' + v.sub_bgpadding + 'px ' + v.sub_bgpadding * 2 + 'px;border-radius:' + v.sub_bgo + 'px;margin:0 0;line-height:' + (v.sub_lineheight ? v.sub_lineheight : 1.8) + ';font-weight:' + v.sub_weight + '">' + trim(y) + '</span>';
								if(v.sub_big_fullscreen == 1) {
									if(o.fullscreen) {
										css(o.subtitle, {
											"font-size": ((v.sub_size_fullscreen + ((parseInt(v.sub_sizeproc) - 100) * v.sub_size_fullscreen / 100)) + "px")
										})
									} else {
										css(o.subtitle, {
											"font-size": ((v.sub_size + ((parseInt(v.sub_sizeproc) - 100) * v.sub_size / 100)) + "px")
										})
									}
								}
								empty = false
							} else {
								if(!empty && exist(o.subtitle)) {
									o.subtitle.innerHTML = '';
									empty = true;
									hide2(o.subtitle)
								}
							}
						}
					}
				}
			}
		}

		function Style() {
			if(o.subtitle) {
				css(o.subtitle, {
					"position": "absolute",
					"width": "100%",
					"padding-left": "10%",
					"padding-right": "10%",
					"left": 0,
					"color": v.sub_color,
					"text-align": "center",
					"box-sizing": "border-box"
				});
				if(v.sub_fonted == 1 && exist(v.sub_font)) {
					v.sub_font != '' ? css(o.subtitle, {
						"font-family": v.sub_font
					}) : ''
				}
				if(v.sub_shadow == 1) {
					css(o.subtitle, {
						"text-shadow": "1px 1px 2px black"
					})
				} else {
					css(o.subtitle, {
						"text-shadow": "none"
					})
				}
				if(v.sub_drag == 1) {
					PluginMovable(o.subtitle, 'o.subdrag')
				} else {
					v.sub_split2words != 1 ? Pnt0(o.subtitle) : ''
				}
			}
		}

		function SubtitleBottom() {
			if(!o.subdrag) {
				if(o.controls.ToolbarHidden() || v.sub_bottom > v.toolbar.h) {
					css(o.subtitle, {
						"position": "absolute",
						"top": "auto",
						"left": 0,
						"bottom": (v.sub_bottom * 1)
					})
				} else {
					css(o.subtitle, {
						"position": "absolute",
						"top": "auto",
						"left": 0,
						"bottom": (v.sub_bottom * 1 + v.toolbar.h * 1)
					})
				}
			}
		}

		function Remove() {
			o.current_subtitle = -1;
			o.subtitle_on = false;
			o.thumbs_on = false;
			v.subtitle = null;
			v.thumbnails = null;
			o.sub = null;
			o.subs = null;
			alldd = false;
			parsed = [];
			sub = [];
			if(exist(o.controls)) {
				o.controls.SubtitleChanged()
			}
			o.files_subtitle = null;
			if(exist(o.subtitle)) {
				o.frame.removeChild(o.subtitle);
				o.subtitle = null
			}
			o.current_subtitle = null;
			o.subtitle_on = false
		}
	};
	var PluginHdIcon = function(control, bg, style) {
		var icon = createElement("div");
		var cu;
		control.appendChild(icon);
		css(icon, {
			"position": "absolute",
			"top": (-bg.offsetHeight / 2) - 1,
			"background-color": "#f00",
			"border-radius_": 1,
			"display": "none",
			"pointerEvents": "none"
		});
		if(style.hdicon2 == 1 && style.hdiconlist) {
			cu = style.hdiconlist.split(",");
			css(icon, {
				"font-size": 8,
				"color": "#fff",
				"padding": "2px 2px 0 2px",
				"line-height": "1"
			})
		} else {
			style.hdicon2 = 0;
			css(icon, {
				"height": 9,
				"width": 13,
				"background-image": "url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMTAwJSIgdmVyc2lvbj0iMS4xIiB2aWV3Qm94PSIwIDAgMTMgOSIgd2lkdGg9IjEwMCUiPjxwYXRoIGQ9Ik01LDcgTDYsNyBMNiw4IEw1LDggTDUsNyBaIE0xMCwzIEwxMCw0IEw4LDQgTDgsMyBMMTAsMyBaIE0zLDYgTDMsNSBMNSw1IEw1LDYgTDMsNiBaIE0yLDcgTDMsNyBMMyw4IEwyLDggTDIsNyBaIE03LDcgTDEwLDcgTDEwLDggTDcsOCBMNyw3IFogTTEwLDYgTDExLDYgTDExLDcgTDEwLDcgTDEwLDYgWiIgZmlsbD0iIzAwMCIgZmlsbC1vcGFjaXR5PSIwLjY0NzEiIGZpbGwtcnVsZT0iZXZlbm9kZCIgLz48cGF0aCBkPSJNNSw3IEw1LDYgTDUsNSBMMyw1IEwzLDYgTDMsNyBMMiw3IEwyLDIgTDMsMiBMMyw0IEw1LDQgTDUsMiBMNiwyIEw2LDcgTDUsNyBaIE0xMSw2IEwxMCw2IEwxMCw3IEw3LDcgTDcsMiBMMTAsMiBMMTAsMyBMMTEsMyBMMTEsNiBaIE0xMCw0IEwxMCwzIEw4LDMgTDgsNCBMOCw2IEwxMCw2IEwxMCw0IFoiIGZpbGw9IiNmZmYiIGZpbGwtcnVsZT0iZXZlbm9kZCIgLz48L3N2Zz4=)"
			})
		}
		this.toggle = function() {
			var y = 0;
			var x = o.media.getQuality();
			x = x.replace(Lang("auto") + ' ', '');
			if(x) {
				if(style.hdicon2 != 1) {
					if(x == 'HD' || x.indexOf(' HD') > 0 || x.indexOf('hd') == 0 || x.indexOf('Hd') == 0) {
						x = '720'
					}
				}
				if(x.indexOf(' ') > 0) {
					x = x.substr(0, x.indexOf(' '))
				}
				y = parseInt(x)
			}
			var t = '-1';
			var z;
			if(style.hdicon2 == 1) {
				t = '';
				for(var i = 0; i < cu.length; i++) {
					var cu2 = cu[i].split(":");
					if(cu2.length == 2) {
						if(trim(cu2[0]) == y) {
							t = trim(cu2[1])
						}
					}
				}
				if(t == '') {
					if(y > 700) {
						z = true;
						icon.innerHTML = "HD"
					}
				} else {
					z = true;
					icon.innerHTML = t
				}
			} else {
				if(y > 700) {
					z = true
				}
			}
			if(z) {
				show2(icon);
				if(bg.offsetWidth - icon.offsetWidth > 0) {
					css(icon, {
						"left": (bg.offsetWidth - icon.offsetWidth) / 2 - 2
					})
				}
			} else {
				hide2(icon)
			}
		}
	};
	var PluginBlock = function() {
		var ll = 'https://imasdk.googleapis.com/' + Math.random().toString(36).substring(7);
		var ll2 = ll + '';
		var mm = {
			method: 'HEAD',
			mode: 'no-cors'
		};
		if(v.preroll && v.default_adb != 1) {
			if(v.preroll.indexOf("//") > -1) {
				ll = v.preroll.substr(v.preroll.lastIndexOf("//"))
			}
			if(ll.indexOf("[") > 0) {
				ll = ll.substr(0, ll.indexOf("["))
			}
			if(ll != ll2) {
				mm = {
					method: 'GET'
				}
			}
		}
		if(exist(window['fetch']) && exist(window['Request'])) {
			var x = new Request(ll, mm);
			fetch(x).then(function(y) {
				if(typeof(y) != 'undefined') {} else {
					o.ab = true;
					o.controls ? o.controls.refresh() : ''
				}
			}).catch(function(e) {
				o.ab = true;
				o.controls ? o.controls.refresh() : ''
			})
		}
	};
	o.lang_ru = {
		"auto": "РђРІС‚Рѕ",
		"play": "РџСѓСЃРє",
		"pause": "РџР°СѓР·Р°",
		"stop": "РЎС‚РѕРї",
		"fullscreen": "Р’Рѕ РІРµСЃСЊ СЌРєСЂР°РЅ",
		"normalscreen": "Р’С‹Р№С‚Рё РёР· РїРѕР»РЅРѕСЌРєСЂР°РЅРЅРѕРіРѕ СЂРµР¶РёРјР°",
		"settings": "РќР°СЃС‚СЂРѕР№РєРё",
		"options": "РџР°СЂР°РјРµС‚СЂС‹",
		"volume": "Р“СЂРѕРјРєРѕСЃС‚СЊ",
		"mute": "Р’С‹РєР»СЋС‡РёС‚СЊ Р·РІСѓРє",
		"unmute": "Р’РєР»СЋС‡РёС‚СЊ Р·РІСѓРє",
		"live": "Р’ Р­Р¤РР Р•",
		"playlist": "РџР»РµР№Р»РёСЃС‚",
		"quality": "РљР°С‡РµСЃС‚РІРѕ",
		"download": "РЎРєР°С‡Р°С‚СЊ",
		"subtitle": "РЎСѓР±С‚РёС‚СЂС‹",
		"speed": "РЎРєРѕСЂРѕСЃС‚СЊ",
		"normal": "РћР±С‹С‡РЅР°СЏ",
		"error": "РѕС€РёР±РєР°",
		"unmute_video": "Р’РєР»СЋС‡РёС‚Рµ Р·РІСѓРє",
		"audiotrack": "РђСѓРґРёРѕ",
		"loading_error": "РѕС€РёР±РєР° Р·Р°РіСЂСѓР·РєРё",
		"160p": "РћС‡РµРЅСЊ РЅРёР·РєРѕРµ",
		"240p": "РќРёР·РєРѕРµ",
		"360p": "РЎСЂРµРґРЅРµРµ",
		"480p": "Р’С‹СЃРѕРєРѕРµ",
		"540p": "Р’С‹СЃРѕРєРѕРµ",
		"next": "РЎР»РµРґСѓСЋС‰РёР№",
		"prev": "РџСЂРµРґС‹РґСѓС‰РёР№",
		"share": "РџРѕРґРµР»РёС‚СЊСЃСЏ",
		"copied": "РЎРєРѕРїРёСЂРѕРІР°РЅРѕ РІ Р±СѓС„РµСЂ РѕР±РјРµРЅР°",
		"ads": "Р РµРєР»Р°РјР°",
		"skip": "РџСЂРѕРїСѓСЃС‚РёС‚СЊ",
		"skip_after_": "РџСЂРѕРїСѓСЃС‚РёС‚СЊ С‡РµСЂРµР· ",
		"adsinvitation": "РџРµСЂРµР№С‚Рё РЅР° СЃР°Р№С‚ СЂРµРєР»Р°РјРѕРґР°С‚РµР»СЏ",
		"sub_sizeproc": "Р Р°Р·РјРµСЂ С‚РµРєСЃС‚Р°",
		"sub_shift": "РЎРґРІРёРі РїРѕ РІСЂРµРјРµРЅРё",
		"sub_color": "Р¦РІРµС‚ С‚РµРєСЃС‚Р°",
		"sub_color2": "Р¦РІРµС‚ С‚РµРєСЃС‚Р° 2",
		"sub_bgcolor": "Р¦РІРµС‚ С„РѕРЅР°",
		"sub_bga": "РџСЂРѕР·СЂР°С‡РЅРѕСЃС‚СЊ С„РѕРЅР°",
		"sub_shadow": "РўРµРЅСЊ",
		"sub_weight": "РўРѕР»С‰РёРЅР° С‚РµРєСЃС‚Р°",
		"sub_bottom": "РћС‚СЃС‚СѓРї СЃРЅРёР·Сѓ",
		"sub_reset": "РЎР±СЂРѕСЃРёС‚СЊ",
		"upload": "Р—Р°РіСЂСѓР·РёС‚СЊ",
		"sleeptimer": "РЎРѕРЅ",
		"offsettimer": "РџСЂРѕРїСѓСЃРє",
		"hour": "Р§Р°СЃ",
		"minute": "РњРёРЅСѓС‚Р°",
		"second": "РЎРµРєСѓРЅРґР°",
		"1val": "Р”Р°",
		"0val": "РќРµС‚",
		"of": "РёР·",
		"pass": "РџР°СЂРѕР»СЊ",
		"casterror": "РћС€РёР±РєР° РІРѕСЃРїСЂРѕРёР·РІРµРґРµРЅРёСЏ РЅР° СѓСЃС‚СЂРѕР№СЃС‚РІРµ",
		"castdevice": "РРіСЂР°РµС‚ РЅР° СѓСЃС‚СЂРѕР№СЃС‚РІРµ",
		"channel": "РљР°РЅР°Р»",
		"scale": "РњР°СЃС€С‚Р°Р±",
		"on": "Р’РєР».",
		"off": "Р’С‹РєР».",
		"together": "Р’СЃРµ СЃСЂР°Р·Сѓ",
		"kbps": "РєР±РёС‚/СЃ",
		"embed": "РљРѕРґ",
		"url": "РЎСЃС‹Р»РєР°",
		"color": "Р¦РІРµС‚",
		"contrast": "РљРѕРЅС‚СЂР°СЃС‚",
		"brightness": "РЇСЂРєРѕСЃС‚СЊ",
		"saturate": "РќР°СЃС‹С‰РµРЅРЅРѕСЃС‚СЊ",
		"sepia": "РЎРµРїРёСЏ"
	};
	var VastOverlay = function(vast) {
		var y = [];
		var box;
		var img;
		var start_timeout = true;
		var time_interval;
		var close_timeout;
		var js_events = [];
		var uix;
		var time = 0;
		var duration = 0;
		if(!exist(v.overlay_margin)) {
			v.overlay_margin = 15
		}
		if(!exist(v.overlay_position)) {
			v.overlay_position = "bottom-center"
		}
		if(!exist(v.overlay_x)) {
			v.overlay_x = 1
		}
		if(!exist(v.overlay_x_size)) {
			v.overlay_x_size = 10
		}
		if(!exist(v.overlay_x_opacity)) {
			v.overlay_x_opacity = 0.7
		}
		if(!exist(v.overlay_x_color)) {
			v.overlay_x_color = "#ffffff"
		}
		if(!exist(v.overlay_x_bgcolor)) {
			v.overlay_x_bgcolor = "#000000"
		}
		if(vast.file) {
			box = document.createElement('div');
			o.frame.appendChild(box);
			img = createElement("img");
			css(box, {
				position: "absolute",
				top: -2000
			});
			y.loading = 1;
			img.addEventListener("load", Loaded);
			img.addEventListener("error", NotLoaded);
			img.src = vast.file;
			box.appendChild(img)
		}

		function NotLoaded(e) {
			Event("Error", 401);
			Remove()
		}

		function Loaded(e) {
			e.target.removeEventListener("load", Loaded);
			y.src_w = e.target.offsetWidth;
			y.src_h = e.target.offsetHeight;
			if(exist(vast.overlay.width) && exist(vast.overlay.height) && v.overlay_image_size == 1) {
				y.src_w = vast.overlay.width;
				y.src_h = vast.overlay.height
			}
			y.w = y.src_w * 1;
			y.h = y.src_h * 1;
			y.src_aspect = y.src_w / y.src_h;
			y.loading = false;
			if(vast.overlay.scalable != "false") {
				Size()
			}
			Position();
			if(exist(vast.click)) {
				css(box, {
					"cursor": "pointer"
				});
				box.addEventListener("click", onClick)
			}
			if(v.overlay_x == 1) {
				uix = createElement("div");
				css(uix, {
					"position": "absolute",
					"top": 0,
					"right": 0,
					"width": v.overlay_x_size * 2,
					"height": v.overlay_x_size * 2,
					"padding-top": Math.floor(v.overlay_x_size < 15 ? v.overlay_x_size / 3 : v.overlay_x_size / 2),
					"transition": "opacity 0.2s linear",
					"cursor": "pointer",
					"background-color": v.overlay_x_bgcolor,
					"box-sizing": "border-box",
					"zIndex": 1,
					"opacity": v.overlay_x_opacity
				});
				uix.innerHTML = "<center><svg width='" + v.overlay_x_size + "px' height='" + v.overlay_x_size + "px' viewBox='-1 -1 20 20' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'><g stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' transform='translate(-1.000000, -1.000000)'><path d='M11.928473,10 L19.3733274,2.55514561 L17.4448544,0.626672571 L10,8.07152696 L2.55514561,0.626672571 L0.626672571,2.55514561 L8.07152696,10 L0.626672571,17.4448544 L2.55514561,19.3733274 L10,11.928473 L17.4448544,19.3733274 L19.3733274,17.4448544 L11.928473,10 Z' id='Combined-Shape' fill='" + v.overlay_x_color + "' fill-rule='nonzero'></path></g></svg></center>";
				box.appendChild(uix);
				uix.addEventListener("click", onClose);
				uix.addEventListener("mouseover", onCloseOver);
				uix.addEventListener("mouseout", onCloseOut);
				if(vast.extensions.skipTime > 0) {
					hide2(uix);
					close_timeout = setTimeout(CloseTimeout, vast.extensions.skipTime * 1000)
				}
			}
			if(y.w > 0) {
				Event("Impression", true);
				if(vast.duration > 0) {
					duration = vast.duration;
					time_interval = setInterval(onTime, 100)
				}
			} else {
				Event("Error")
			}
			setTimeout(startTimeout, 500)
		}

		function Size() {
			css(img, {
				width: y.w,
				height: y.h
			});
			if(y.src_w > o.screen_w - v.overlay_margin * 2) {
				y.w = o.screen_w - v.overlay_margin * 2;
				css(img, {
					width: y.w,
					height: y.w / y.src_aspect
				})
			}
		}

		function Position() {
			css(box, {
				top: "auto"
			});
			if(v.overlay_position.indexOf("bottom") > -1) {
				css(box, {
					bottom: v.toolbar.h + v.overlay_margin
				})
			}
			if(v.overlay_position.indexOf("top") > -1) {
				css(box, {
					top: v.overlay_margin
				})
			}
			if(v.overlay_position.indexOf("left") > -1) {
				css(box, {
					left: v.overlay_margin
				})
			}
			if(v.overlay_position.indexOf("right") > -1) {
				css(box, {
					right: v.overlay_margin
				})
			}
			if(v.overlay_position.indexOf("center") > -1) {
				css(box, {
					left: "50%",
					"margin-left": -y.w / 2
				})
			}
		}

		function startTimeout() {
			start_timeout = false
		}

		function onClick(e) {
			if(!start_timeout) {
				var d = new Date();
				o.clicktime = d.getTime();
				Event("NonLinearClickTracking");
				if(exist(vast.click)) {
					if(vast.click != '') {
						js2("vast_clickurl", vast.click);
						v.vast_openclick == 1 ? window.open(vast.click, '_blank') : ''
					}
					if(v.vast_pauseonclick == 1) {
						o.actions.Pause()
					}
				}
				if(v.overlay_keep == 1) {} else {
					Remove()
				}
			}
		}

		function onTime() {
			time += 0.1;
			if(exist(vast.events["firstQuartile"])) {
				if(time >= duration / 4) {
					Event("firstQuartile", true)
				}
			}
			if(exist(vast.events["midpoint"])) {
				if(time >= duration / 2) {
					Event("midpoint", true)
				}
			}
			if(exist(vast.events["thirdQuartile"])) {
				if(time >= (duration / 4) * 3) {
					Event("thirdQuartile", true)
				}
			}
			if(time >= duration) {
				Event("complete", true);
				Remove()
			}
			if(v.overlay_position.indexOf("bottom") > -1) {
				if(y.toolbar != o.toolbarhidden) {
					if(o.toolbarhidden) {
						css(box, {
							bottom: v.overlay_margin
						})
					} else {
						css(box, {
							bottom: v.toolbar.h + v.overlay_margin
						})
					}
				}
				y.toolbar = o.toolbarhidden
			}
		}

		function onClose(e) {
			Event("close", true);
			e.cancelBubble = true;
			Remove()
		}

		function onCloseOver() {
			uix.style.opacity = 1
		}

		function onCloseOut() {
			uix.style.opacity = v.overlay_x_opacity
		}

		function CloseTimeout() {
			show2(uix);
			clearTimeout(close_timeout)
		}

		function Remove() {
			if(uix) {
				box.removeChild(uix);
				uix.removeEventListener("click", onClose);
				uix.removeEventListener("mouseover", onCloseOver);
				uix.removeEventListener("mouseout", onCloseOut)
			}
			clearInterval(time_interval);
			clearTimeout(close_timeout);
			box.removeEventListener("click", onClick);
			o.frame.removeChild(box)
		}

		function Event(x, del, code, justcode) {
			if(exist(vast.prt) && v.eventstrackervast == 0) {} else {
				if(del) {
					if(!exist(js_events[x])) {
						js3("vast_" + x, VastInfo())
					}
					js_events[x] = true
				} else {
					code > 0 ? js3(("vast_" + x), code) : js3("vast_" + x, VastInfo())
				}
			}
			if(exist(vast.events)) {
				if(exist(vast.events[x])) {
					log("VAST Overlay Event " + x);
					for(var i = 0; i < vast.events[x].length; i++) {
						var z = vast.events[x][i];
						var stop = false;
						if(exist(z)) {
							if(code > 0) {
								if(z.indexOf("[ERRORCODE]") > 0) {
									z = z.replace("[ERRORCODE]", code)
								} else {
									justcode == 1 ? stop = true : ''
								}
							}
							if(z.indexOf("(visibility)") > 0) {
								if(exist(o.visibility)) {
									z = z.replace("(visibility)", o.visibility)
								}
							}
							z = z.replace("(adblock)", (o.ab ? 1 : 0));
							if(z.indexOf(".pjstat") > 0) {
								var m = 0;
								z = z + "&r=1&m=" + (o.system.tv ? 2 : (o.system.mobile ? 1 : 0)) + ("&h=" + (exist(v.parent_domain) ? v.parent_domain : o.d))
							}
							if(typeof v.vast_replace == "object") {
								for(var y in v.vast_replace) {
									if(v.vast_replace.hasOwnProperty(y)) {
										z = z.replace(y, v.vast_replace[y])
									}
								}
							}
						} else {
							stop = true
						}
						if(!stop) {
							gif(z)
						}
					}
					if(del) {
						vast.events["old_" + x] = vast.events[x];
						vast.events[x] = null
					}
				}
			}
			if(x == "click" && v.vast_addclick == 1) {
				Event("addClick")
			}
		};

		function gif(x) {
			var gif = document.createElement("img");
			gif.setAttribute('src', x);
			gif.setAttribute('height', '1px');
			gif.setAttribute('width', '1px')
		}

		function js2(x) {
			if(vast.adsystem != "intro" && vast.adsystem != "outro") {
				js(x)
			}
		}

		function js3(x, y) {
			if((exist(vast.prt) && v.eventstrackervast == 0) || vast.adsystem == "intro" || vast.adsystem == "outro") {} else {
				js(x, y)
			}
		}
	};
	var Motion = function(x) {
		var _ease;
		var _timer;
		var _type;
		var _from;
		var _to;
		var _steps;
		var _step = 0;
		var _speed;
		var _stop = false;
		var _timeout;
		if(x.me != undefined && x.mc != undefined && x.type != undefined && x.to != undefined) {
			if(x.time == null) {
				if(x.type.indexOf("alpha") > -1) {
					x.to == 0 ? x.time = 0.5 : x.time = 0.2
				} else {
					x.time = 0.20
				}
			}
			_ease = Ease(x.ease);
			if(x.type.indexOf("scale") == -1) {
				if(exist(o.motions[x.me])) {
					o.motions[x.me].TheEnd()
				}
				o.motions[x.me] = this
			}
			if(x.show == 1) {
				x.mc.set("display", true)
			}
			_type = x.type.split('|');
			_to = String(x.to).split('|');
			_from = new Array();
			for(var i = 0; i < _type.length; i++) {
				if(!_to[i]) {
					_to[i] = _to[0]
				}
				if(_type[i] == "alpha") {
					_from[i] = x.mc.g("opacity")
				}
				if(_type[i] == "alpha_div") {
					_from[i] = x.mc.style.opacity
				}
				if(_type[i] == "y") {
					_from[i] = x.mc.g("y")
				}
				if(_type[i] == "x") {
					_from[i] = x.mc.g("x")
				}
				if(_type[i] == "left") {
					_from[i] = parseInt(x.mc.style.left)
				}
				if(_type[i] == "top") {
					_from[i] = parseInt(x.mc.style.top)
				}
				if(_type[i] == "scale") {
					_from[i] = x.mc.g("scaleX")
				}
				if(_type[i] == "scroll") {
					_from[i] = x.mc.scrollTop
				}
				if(_type[i] == "scrollleft") {
					_from[i] = x.mc.scrollLeft
				}
				if(_type[i] == "scaleY") {
					_from[i] = x.mc.g("scaleY")
				}
				if(_type[i] == "scaleX") {
					_from[i] = x.mc.g("scaleX")
				}
				if(_type[i] == "width") {
					_from[i] = x.mc.g("width")
				}
				if(_type[i] == "width_div") {
					_from[i] = x.mc.offsetWidth;
					_to[i] = Math.floor(_to[i]);
					x.me == "line_play" ? log("width", x.me, _from[i], _to[i], x.mc.offsetWidth) : ''
				}
				if(_type[i] == "height") {
					_from[i] = x.mc.g("height")
				}
				if(_type[i] == "height_div") {
					_from[i] = x.mc.offsetHeight
				}
				_to[i] = Number(_to[i]);
				_from[i] = Number(_from[i])
			}
			_speed = x.time * 1000 / _ease.length;
			_steps = _ease.length;
			if(_type.length == 1 && _from[0] == _to[0]) {
				End()
			} else {
				setTimeout(onStep, Math.round(_speed))
			}
		}

		function onStep() {
			for(var i = 0; i < _type.length; i++) {
				var tmp = _from[i] + (_to[i] - _from[i]) * (_ease[_step] ? _ease[_step] : 0);
				Alpha(_type[i], tmp);
				if(_type[i] == "y") {
					x.mc.set("top", tmp)
				}
				if(_type[i] == "x") {
					x.mc.set("left", tmp)
				}
				if(_type[i] == "left") {
					x.mc.style.left = tmp + "px"
				}
				if(_type[i] == "top") {
					x.mc.style.top = tmp + "px"
				}
				if(_type[i] == "scale") {
					x.mc.set("scale", tmp)
				}
				if(_type[i] == "scaleY") {
					x.mc.set("scaleY", tmp)
				}
				if(_type[i] == "scaleX") {
					x.mc.set("scaleX", tmp)
				}
				if(_type[i] == "scroll") {
					x.mc.scrollTop = tmp
				}
				if(_type[i] == "scrollleft") {
					x.mc.scrollLeft = tmp
				}
				if(_type[i] == "width") {
					x.mc.set("width", tmp)
				}
				if(_type[i] == "width_div") {
					css(x.mc, {
						"width": tmp
					})
				}
				if(_type[i] == "height") {
					x.mc.set("height", tmp)
				}
				if(_type[i] == "height_div") {
					css(x.mc, {
						"height": tmp
					})
				}
			}
			_step++;
			if(!_stop) {
				if(_step == _steps) {
					End()
				} else {
					_timeout = setTimeout(onStep, Math.round(_speed))
				}
			}
		}

		function End() {
			_stop = true;
			if(x.hide) {
				if(_type[0] == "alpha_div" || _type[0] == "left") {
					hide(x.mc)
				} else {
					x.mc.set("display", false)
				}
			}
			if(x.type.indexOf("scale") == -1) {
				o.motions[x.me] = null;
				delete o.motions[x.me]
			}
			for(var i = 0; i < _type.length; i++) {
				Alpha(_type[i], _to[i])
			}
			clearTimeout(_timeout)
		};

		function Alpha(y, z) {
			if(y == "alpha") {
				x.mc.set("opacity", z)
			}
			if(y == "alpha_div") {
				x.mc.style.opacity = z
			}
		}
		this.TheEnd = function() {
			End()
		};
		this.TheEnd2 = function() {
			_step = _steps - 1;
			onStep();
			End()
		};
		this.XY = function(x0, x1, y0, y1) {
			var e = false;
			for(var i = 0; i < _type.length; i++) {
				if(_type[i] == 'x' && x0 != x1) {
					e = true
				}
				if(_type[i] == 'y' && y0 != y1) {
					e = true
				}
			}
			e ? End() : ''
		};

		function Ease(str) {
			switch(str) {
				case "elastic":
					return [0, 0.432, 0.857, 1.275, 1.372, 1.296, 1.102, 0.957, 0.883, 0.87, 0.914, 0.992, 1.029, 1.041, 1.036, 1.019, 0.996, 0.984, 0.981, 0.988, 1.001, 1.006, 1.007, 1.006, 1.003, 0.999, 0.998, 0.998, 0.998, 0.998, 1];
					break;
				case "cubic":
					return [0, 0.096, 0.185, 0.267, 0.344, 0.416, 0.483, 0.547, 0.606, 0.659, 0.705, 0.747, 0.785, 0.818, 0.848, 0.874, 0.897, 0.918, 0.935, 0.95, 0.962, 0.971, 0.979, 0.985, 0.99, 0.994, 0.997, 0.999, 1];
					break;
				default:
					return [0, 0.175, 0.32, 0.44, 0.52, 0.6, 0.67, 0.73, 0.775, 0.82, 0.85, 0.885, 0.915, 0.935, 0.95, 0.97, 0.983, 0.993, 1];
					break
			}
		}
	};
	var System = function() {
		var N = navigator.appName,
			ua = navigator.userAgent,
			tem;
		var M = ua.match(/(opera|chrome|safari|firefox|msie)\/?\s*(\.?\d+(\.\d+)*)/i);
		var M = ua.match(/(opera|chrome|safari|firefox|msie|trident|edge)\/?\s*(\.?\d+(\.\d+)*)/i);
		if(M && (tem = ua.match(/version\/([\.\d]+)/i)) != null) M[2] = tem[1];
		var mtp = navigator.maxTouchPoints;
		this.browser = M ? M[1] : N;
		this.version = M ? M[2] : navigator.appVersion;
		this.touch = navigator.maxTouchPoints > 1;
		this.opera = this.browser == "Opera";
		this.ie9 = this.browser == "MSIE 9.0";
		this.ie = this.browser == "MSIE" || this.browser == "Trident" || this.browser == "Edge";
		this.edge = ua.search(/(edge)\/?\s*/i) > -1;
		this.firefox = this.browser == "Firefox";
		this.safari = this.browser == "Safari";
		this.chrome = window.chrome;
		this.win = ua.search("Windows NT") > -1;
		this.ios = (ua.search(/(iphone|ipad|ipod)\/?\s*/i) > -1) || (navigator.platform === 'MacIntel' && mtp > 1);
		this.tv = v.notv != 1 && ua.search(/(TV|tvOS|webOS|armv|BRAVIA|Roku|Tizen|Philips)\/?\s*/i) > -1;
		this.lg = v.notv != 1 && ua.search(/(LG)\/?\s*/i) > -1;
		this.iphone = ua.search(/(iphone)\/?\s*/i) > -1;
		this.ipad = this.ios && !this.iphone;
		this.webkit = 'WebkitAppearance' in document.documentElement.style;
		if(ua.search(/(android)\/?\s*/i) > -1) {
			mtp > 0 ? this.android = true : this.tv = true;
			if(matchMedia('(pointer:fine)').matches) {
				this.tv = true
			}
		}
		this.mobile = (this.ios || this.android || (ua.search(/(blackberry|iemobile|opera mini)\/?\s*/i) > -1)) && !this.tv;
		this.mutedautoplay = this.safari || this.chrome;
		this.fullscreen = false;
		if(this.ios) {
			this.iosv = parseFloat(ua.substr(ua.indexOf('OS ') + 3, 4).replace('_', '.'));
			if(this.ipad && (!'ontouchstart' in window || mtp < 2)) {
				this.mobile = this.ios = false;
				this.tv = true
			}
		}
		this.desktop = !this.mobile;
		this.mobiletv = this.mobile || this.tv;
		this.wkdt = this.webkit && this.desktop;
		if(o.frame.requestFullScreen || o.frame.requestFullscreen || o.frame.mozRequestFullScreen || o.frame.webkitRequestFullScreen || o.frame.msRequestFullscreen) {
			this.fullscreen = true
		}
	};

	function UpdateObject(obj, obj2) {
		for(var s in obj2) {
			if(typeof(obj2[s]) == 'object') {
				if(s == "events" || s == "file") {
					obj[s] = obj2[s]
				} else {
					for(var s2 in obj2[s]) {
						if(typeof(obj[s]) != 'object') {
							obj[s] = {}
						}
						if(typeof(obj2[s][s2]) == 'object') {
							for(var s3 in obj2[s][s2]) {
								if(typeof(obj[s][s2]) != 'object') {
									obj[s][s2] = {}
								}
								if(typeof(obj2[s][s2][s3]) == 'object') {
									for(var s4 in obj2[s][s2][s3]) {
										if(typeof(obj[s][s2][s3]) != 'object') {
											obj[s][s2][s3] = {}
										}
										obj[s][s2][s3][s4] = obj2[s][s2][s3][s4];
										if(s3 == 'padding' || s3 == 'margin') {
											obj[s][s2][s3][s4] = parseInt(obj[s][s2][s3][s4])
										}
									}
								} else {
									obj[s][s2][s3] = obj2[s][s2][s3];
									if(s2 == 'padding' || s2 == 'margin') {
										obj[s][s2][s3] = parseInt(obj[s][s2][s3])
									}
								}
							}
						} else {
							obj[s][s2] = obj2[s][s2];
							if(s == 'padding' || s == 'margin') {
								obj[s][s2] = parseInt(obj[s][s2])
							}
						}
					}
				}
			} else {
				if(s.indexOf("roll") > 0 && trim(obj2[s]) === "") {} else {
					obj[s] = SettingsParser(s, obj2[s])
				}
			}
		}
		return obj
	};
	var SettingsParser = function(key, value) {
		if(typeof(value) == 'string') {
			value = trim(value);
			if(key.indexOf("color") > -1 && value != -1) {
				value = CheckColor(value)
			}
		}
		return value
	};

	function StorageSupport() {
		try {
			var storage = window['localStorage'],
				x = '__storage_test__';
			storage.setItem(x, x);
			storage.removeItem(x);
			return true
		} catch(e) {
			return false
		}
	};

	function killMotion(motion_id) {
		if(motion_id) {
			if(exist(o.motions[motion_id])) {
				o.motions[motion_id].TheEnd()
			}
		}
	};
	var Lang = function(x) {
		var y = x;
		if(y) {
			y = x.charAt(0).toUpperCase() + x.slice(1);
			if(y.indexOf("_") > -1) {
				y = y.replace(/_/ig, " ")
			}
		}
		var en = {
			"of": "of",
			"kbps": "kbps",
			"castdevice": "Playback on device",
			"casterror": "Playback error on device",
			"together": "All at once",
			"pass": "Password",
			"0val": "No",
			"sleeptimer": "Sleep",
			"offsettimer": "Skip",
			"1val": "Yes",
			"sub_bottom": "Bottom margin",
			"sub_weight": "Font weight",
			"sub_shadow": "Shadow",
			"sub_bga": "Background opacity",
			"sub_bgcolor": "Background color",
			"sub_sizeproc": "Text size",
			"sub_color": "Text color",
			"sub_color2": "Text color 2",
			"sub_shift": "Time shift",
			"sub_reset": "Reset",
			"prev": "Previous",
			"copied": "Copied to clipboard",
			"160p": "Tiny",
			"240p": "Small",
			"360p": "Medium",
			"480p": "High",
			"540p": "High",
			"720p": "HD",
			"1080p": "Full HD",
			"1296p": "Super HD",
			"1440p": "Quad HD",
			"2160p": "Ultra HD 4K",
			"ads": "Ad",
			"adsinvitation": "Go to the advertiser's website",
			"audiotrack": "Audio",
			"live": "LIVE",
			"fullscreen": "Enter fullscreen",
			"normalscreen": "Exit fullscreen"
		};
		if(exist(en[x])) {
			y = en[x]
		}
		if(exist(o['lang_' + v.lang])) {
			if(exist(o['lang_' + v.lang][x])) {
				y = o['lang_' + v.lang][x]
			}
		}
		if(v.rename) {
			if(v.rename[x]) {
				y = v.rename[x]
			}
		}
		return y
	};
	var gaTracker = function(x, y, z) {
		if(!exist(o.gatracked[y]) && v.playerjscom != 1) {
			var t = o.titlestore ? o.titlestore : (v.title ? v.title : '');
			exist(v.label) ? t = v.label : '';
			if(v.yamtr_event[x] == 1 && v.yamtr == 1 && exist(v.yamtrid)) {
				if(x == "init") {
					setInterval(yaHit, 300000)
				}
				if(exist(window["yaCounter" + v.yamtrid])) {
					window["yaCounter" + v.yamtrid].reachGoal('playerjs_' + x, {
						title: t
					});
					log("Yandex", 'playerjs_' + x)
				} else {
					log("Yandex Metric error")
				}
			}
			if(v.ga_event[x] == 1) {
				if(v.ga == 1) {
					var gao;
					if(v.ga4 == 1) {
						if(window.gtag) {
							gao = {
								'label': t
							};
							if(v.galabels) {
								if(typeof(v.galabels) == "object") {
									for(var g in v.galabels) {
										if(v.galabels.hasOwnProperty(g)) {
											gao[g] = v.galabels[g]
										}
									}
								}
							}
							gtag('event', 'playerjs_' + x, gao)
						}
					} else {
						if(window.ga) {
							gao = {
								eventCategory: 'Player',
								eventAction: y
							};
							if(t != '') {
								gao.eventLabel = t
							}
							if(v.gainact == 1 && !o.clicktime) {
								gao.nonInteraction = 1
							}
							ga('user.send', 'event', gao)
						}
					}
				}
			}
		}
		z ? o.gatracked[y] = true : ''
	};

	function yaHit() {
		if(exist(window["yaCounter" + v.yamtrid])) {
			window["yaCounter" + v.yamtrid].reachGoal('playerjs_hit')
		}
	};
	var YoutubeID = function(url) {
		var x = '';
		url = url.replace("v=", "{=");
		if(url.indexOf('youtu.be/') > -1) {
			x = url.substr(url.indexOf(".be/") + 4);
			x.replace("/", "")
		} else {
			x = url.split(/(youtu.be\/|v\/|embed\/|watch\?|youtube.capiom\/user\/[^#]*#([^\/]*?\/)*)\??{?=?([^#\&\?]*)/)[3]
		}
		if(x != '') {
			if(x.indexOf("?t=") > 0) {
				v.start = x.substr(x.indexOf("?t=") + 3);
				var h = 0;
				var m = 0;
				var s = 0;
				if(v.start.indexOf("h") > 0) {
					h = v.start.substr(0, v.start.indexOf("h"));
					v.start = v.start.substr(v.start.indexOf("h") + 1)
				}
				if(v.start.indexOf("m") > 0) {
					m = v.start.substr(0, v.start.indexOf("m"));
					v.start = v.start.substr(v.start.indexOf("m") + 1)
				}
				if(v.start.indexOf("s") > 0) {
					s = v.start.substr(0, v.start.indexOf("s"));
					v.start = v.start.substr(v.start.indexOf("s") + 1)
				}
				if(h > 0 || m > 0 || s > 0) {
					v.start = h * 3600 + m * 60 + s * 1
				}
				x = x.substr(0, x.indexOf("?t="))
			}
		}
		return x
	};
	var js = function(x, y, li, ev) {
		if(x == "init") {
			o.init = true
		}
		if(ev == 1) {
			for(var yi in y) {
				if(y.hasOwnProperty(yi)) {
					if(typeof(y[yi]) == "object") {
						y[yi] = ''
					}
				}
			}
		}
		if(v.eventstracker == 1 && o.init) {
			if(v.eventlisteners == 1 || li == 1) {
				JsEvent(x, y)
			} else {
				if(y != undefined) {
					if(typeof(y) == 'object') {
						try {
							y = JSON.stringify(y)
						} catch(e) {}
					} else {
						if(typeof(y) == 'string') {
							y = y.replace(/'/ig, 'вЂІ')
						}
					}
				}
				if(typeof(v.events) == 'string') {
					if(v.events.indexOf("{") == 0) {
						try {
							v.events = v.events.replace(/\'/ig, '"');
							v.events = JSON.parse(v.events)
						} catch(e) {
							console.log(e)
						}
					}
				}
				if(typeof(v.events) == 'object') {
					if(exist(v.events[x]) || exist(v.events['other'])) {
						var z = x;
						if(!exist(v.events[x]) && exist(v.events['other'])) {
							z = 'other'
						}
						if(x.indexOf("vast_") == 0) {
							if(exist(v.events['vast'])) {
								z = 'vast'
							}
						}
						try {
							if(y !== undefined) {
								eval(v.events[z] + "('" + x + "','" + v.id + "','" + y + "')")
							} else {
								eval(v.events[z] + "('" + x + "','" + v.id + "')")
							}
						} catch(e) {
							log("events", e, x)
						}
					}
				} else {
					if(v.events == '') {
						v.events = "PlayerjsEvents"
					}
					try {
						if(y !== undefined) {
							eval(v.events + "('" + x + "','" + v.id + "','" + y + "')")
						} else {
							eval(v.events + "('" + x + "','" + v.id + "')")
						}
					} catch(e) {
						log("events", e, x, y)
					}
				}
			}
		}
		if(o.init && v.pjsframe == 1) {
			if(o.pjsfrm) {
				try {
					o.pjsfrm.contentWindow.postMessage({
						event: x,
						info: y
					}, "*")
				} catch(e) {}
			}
		}
		if(v.postmessage == 1 && li !== 1) {
			var zv = {
				event: x,
				time: o.media ? (x == "seek" ? o.seeked_time : o.media.time()) : 0
			};
			if(y != undefined) {
				zv["data"] = y
			}
			if(x == "duration" || x == "time") {
				zv["duration"] = o.media.duration()
			}
			if(x == "volume" || x == "unmute") {
				zv["volume"] = v.volume
			}
			if(x == "new") {
				zv["id"] = apiProcessor("playlist_id")
			}
			window.parent.postMessage(zv, '*');
			var z = x;
			x == "init" || x == "start" || x == "end" ? z = x + "ed" : '';
			x == "play" ? z = "resumed" : '';
			x == "pause" ? z = "paused" : '';
			x == "mute" ? z = "muted" : '';
			x == "unmute" ? z = "unmuted" : '';
			x == "seek" ? z = "rewound" : '';
			x == "vast_Impression" ? z = "adShown" : '';
			zv["event"] = z;
			if(z != '' && z != x) {
				zv = JSON.parse(JSON.stringify(zv));
				window.parent.postMessage(zv, '*')
			}
		}
	};
	var JsEvent = function(x, y) {
		var ev = document.createEvent('Events');
		if(y !== undefined) {
			ev.info = y
		}
		ev.initEvent(x, true, true);
		o.container.dispatchEvent(ev)
	};
	this.event = function(x, y) {
		o.events[x] = y
	};
	this.api = function(x, y, but) {
		return apiProcessor(x, y, but)
	};

	function apiProcessor(x, y, but) {
		if(exist(o.actions) && typeof(x) == 'string') {
			if(o.destroyed == 1) {
				return
			}
			if(but) {
				if(typeof(but) == 'string') {
					if(but.indexOf("id:") == 0) {
						but = o.controls.butByS(but.substr(3), "dom");
						if(but) {
							if(x == "button" && y == "toogle") {
								but.Click()
							}
						}
					}
				}
			}
			if(x == "play" || x == "file") {
				if(exist(y)) {
					var noads = false;
					if(typeof(y) == 'string') {
						y = y.replace(/(\r\n|\n|\r)/gm, "");
						var seekto = -1;
						if(y.indexOf("[seek:") > -1 && y.lastIndexOf("]") == y.length - 1) {
							seekto = y.substr(y.indexOf("[seek:") + 6, y.length - 1);
							seekto = parseInt(seekto.substr(0, seekto.length - 1));
							y = y.substr(0, y.indexOf("[seek:"));
							if(y == '') {
								o.actions.Seek(seekto);
								o.actions.Play();
								return
							} else {
								o.seekto = seekto
							}
						}
						if(y.indexOf("[skipads]") > -1) {
							noads = true;
							y = y.replace('[skipads]', '')
						}
						if(y.indexOf("#" + v.enc2) == 0) {
							y = o[o.fd[0]](y)
						}
						if(y.indexOf("#" + v.enc3) == 0 && y.indexOf(v.file3_separator) > 0) {
							y = o[o.fd[1]](y)
						}
						if(y.indexOf("#0") == 0) {
							y = fd0(y)
						}
						if(v.fplace == 1) {
							y = fplace(y)
						}
						if(y.indexOf(".txt") == y.length - 4) {
							var xhr = XHR(y);
							xhr.onload = function() {
								if(this.readyState == 4 && this.status == 200) {
									try {
										apiProcessor('play', JSON.parse(this.responseText))
									} catch(e) {}
								}
							};
							xhr.send();
							return
						}
						if(y.indexOf("id:") == 0 && exist(o.playlist_dic)) {
							var z = FindIdPl(y);
							if(exist(o.playlist_dic[z])) {
								o.controls.PlaylistPlayId(z);
								seekto > -1 ? o.seekto = seekto : '';
								return true
							} else {
								return false
							}
						}
						if(y.indexOf("youtubeid:") == 0) {
							var z = y.substr(10);
							if(o.file_type == "youtube") {
								o.media.playByYoutubeId(z);
								return true
							} else {
								y = '//youtu.be/' + z
							}
						}
					}
					if(x == "play") {
						o.controls.PreNewPl();
						o.actions.NewFile(y, undefined, undefined, (noads ? 1 : 0))
					}
					if(x == "file") {
						o.newfile = true;
						v.autoplay = 0;
						o.actions.NewFile(y, 1, undefined, (noads ? 1 : 0));
						o.controls.Duration(0, 0);
						o.start = false
					}
				} else {
					if(x == "play") {
						o.actions.Play()
					}
					if(x == "file") {
						typeof Papi41 == 'function' ? Papi41() : ''
					}
				}
			}
			if(x == "preload") {
				if(exist(y)) {
					o.newfile = true;
					o.actions.NewFile(y, 1, 1)
				} else {
					o.media.Preload()
				}
			}
			if(x == "pause") {
				if(o.play) {
					o.actions.Pause();
					o.actions.RenewSubtitle()
				}
			}
			if(x == "channel" && exist(y)) {
				o.start && o.channels ? o.channels.SetChannel(y) : ''
			}
			if(x.indexOf("vpaid_") == 0) {
				if(o.vast) {
					o.vast.VpaidSet(x.substr(6), y)
				}
			}
			if(x == "alert") {
				o.alert.close();
				o.alert = new Alert();
				if(v.alert404 == 1) {
					o.alert.txt(v.alert404text)
				} else {
					o.alert.txt("Test message")
				}
				if(v.alert404v == 1 && exist(v.alert404video)) {
					o.err404v = new PluginErrorVideo()
				}
			}
			if(x == "waiting") {
				!o.start ? o.controls.startcss() : '';
				o.controls.Waiting();
				o.controls.HideElement("control_start")
			}
			if(x == "toggle") {
				o.play ? o.actions.Pause() : o.actions.Play()
			}
			if(x == "stop") {
				v.preload = 0;
				v.autoplay = 0;
				o.media.Recover();
				o.actions.Stop()
			}
			if(x == "reload") {
				o.time = o.media.time();
				o.actions.Reload()
			}
			if(x == "download") {
				if(v.apiprm) {
					if(v.apiprm.on == 1 && v.apiprm.dwn == 1) {
						o.actions.Download()
					}
				}
			}
			if(x == "effect" && exist(y)) {
				if(o.effects) {
					o.effects.api(y)
				}
			}
			if(x == "share") {
				o.controls.showShare()
			}
			if(x == "startvast" && exist(y)) {
				if(v.vast == 1) {
					if(y.indexOf('js:') == 0) {
						v.midroll = y;
						v.midrolls = true;
						o.actions.advertising("midroll")
					} else {
						if(o.p != '') {
							var sv = JSON.parse(decode(o.p));
							for(var l in sv) {
								if(sv.hasOwnProperty(l)) {
									if(exist(sv[l].id)) {
										if(y == sv[l].id) {
											v.midroll = 'prt' + (exist(sv[l]['cpm']) ? 'cpm' + sv[l]['cpm'] : '') + y + '_' + sv[l].preroll;
											v.midrolls = true;
											o.actions.advertising("midroll")
										}
									}
								}
							}
						}
					}
				}
			}
			if(x == "vastbreak") {
				typeof VastBreak == "function" ? VastBreak() : ''
			}
			if(x == "cuid" && y) {
				v.cuid = y;
				o.continue ? o.continue.updateCuid() : ''
			}
			if(x == "mute") {
				o.actions.Mute()
			}
			if(x == "speed") {
				if(exist(y)) {
					o.actions.SetSpeed(y)
				} else {
					return o.files_speed[o.current_speed]
				}
			}
			if(x == "played") {
				if(v.apiprm && o.pld) {
					if(v.apiprm.pld == 1) {
						return Math.round((o.pld.filter(Boolean).length - 1) / Math.round(o.media.duration()) * 100)
					}
				}
			}
			if(x == "speeds") {
				return o.files_speed
			}
			if(x == "unmute") {
				o.actions.Unmute()
			}
			if(x == "thumbnails") {
				if(exist(y)) {
					v[x] = y;
					o.actions.Thumbs()
				}
			}
			if(x == "qualities") {
				return o.files_quality
			}
			if(x == "adblock") {
				return o.ab ? true : false
			}
			if(x == "live") {
				return o.media ? o.media.isLive() : false
			}
			if(x == "subtitles") {
				return v.sub_off == 1 ? o.files_subtitle.slice(0, -1) : o.files_subtitle
			}
			if(x.indexOf("subtitle:") == 0 && y) {
				v[x.replace('title:', '_')] = y;
				o.actions.RenewSubtitle()
			}
			if(x == "plduration") {
				return o.pldur
			}
			if(x == "audiotracks") {
				return o.files_audiotrack
			}
			if(x == "volume" || x == "setVolume") {
				if(exist(y)) {
					if(typeof y == "string") {
						if(y.indexOf("+") == 0) {
							y = v.volume + parseFloat(y.substr(1))
						} else {
							if(y.indexOf("-") == 0) {
								y = v.volume - parseFloat(y.substr(1))
							}
						}
					}
					if(y >= 0 && y <= 1) {
						o.actions.Volume(y)
					}
				}
				return o.muted ? 0 : v.volume
			}
			if(x == "muted") {
				return exist(o.muted) ? o.muted : false
			}
			if(x == "moveplaylist") {
				o.controls ? o.controls.PlaylistMove(y) : ''
			}
			if(x == "design") {
				y < 2 ? y = '' : '';
				if(exist2(o['u' + y])) {
					var x2 = JSON.parse(decode(o['u' + y]));
					var v2 = [];
					for(var l in v) {
						if(v.hasOwnProperty(l)) {
							if(l.indexOf("control_") == 0) {
								v[l] = null
							}
						}
					}
					if(typeof x2 == "object") {
						for(var k in x2) {
							if(x2.hasOwnProperty(k)) {
								if(k.indexOf("control_") == 0) {
									v[k] = x2[k]
								}
								if(k == "toolbar") {
									v2[k] = x2[k]
								}
							}
						}
					}
					v = UpdateObject(v, v2);
					var show_settings = false;
					if(o.controls.SettingsVisible()) {
						o.controls.Settings();
						show_settings = true
					}
					var show_playlist = false;
					if(o.controls.PlaylistVisible()) {
						o.controls.Playlist();
						show_playlist = true
					}
					o.controls.Remove();
					o.controls = null;
					o.controls = new Controls();
					if(o.media.status() == "playing") {
						o.controls.Play()
					}
					o.controls.Volume(v.volume);
					if(exist(v.title)) {
						Title(v.title)
					}
					if(show_settings) {
						o.controls.Settings()
					}
					if(show_playlist) {
						o.controls.Playlist()
					}
					if(o.fullscreen) {
						o.controls.Fullscreen()
					}
					if(key != 'control_duration') {
						o.controls.Duration(o.media.time(), o.media.duration())
					}
					MainResize()
				}
			}
			if(x == "vars") {
				return v.vars
			}
			if(x == "resize") {
				o.controls.resize(true)
			}
			if(x == "resize2") {
				MainResize()
			}
			if(x == "seek") {
				if(exist(y)) {
					if(typeof y == "string") {
						if(y.indexOf("%") > -1) {
							y = parseInt(y.substr(0, y.indexOf("%")));
							y = o.media.duration() * y / 100
						} else {
							var omt = o.media.time();
							if(o.continue && !o.start) {
								if(!o.continue.seeked) {
									var f = o.continue.flag();
									if(f.t && f.d) {
										omt = f.t;
										o.continue.seeked = true
									}
								}
							}
							if(y.indexOf("+") == 0) {
								y = omt + parseFloat(y.substr(1))
							} else {
								if(y.indexOf("-") == 0) {
									y = omt - parseFloat(y.substr(1))
								}
							}
						}
					}
					y = y * 1;
					y < 0 ? y = 0 : '';
					if(o.media.duration() > 0) {
						y > o.media.duration() ? y = 0 : ''
					}
					if(!exist(o.vast) && !exist(o.vastloader) && o.media.duration() > 0) {
						o.seekto = undefined;
						o.actions.Seek(y, true);
						o.actions.Playing()
					} else {
						o.seekto = y
					}
				}
			}
			if(x == "fullscreen") {
				!o.fullscreen ? o.actions.Fullscreen() : ''
			}
			if(x == "exitfullscreen") {
				o.fullscreen ? o.actions.Normalscreen() : ''
			}
			if(x == "isfullscreen") {
				return o.fullscreen
			}
			if(x == "size") {
				return o.screen_w + '/' + o.screen_h
			}
			if(x == "fix") {
				if(exist(o.minify)) {
					o.minify.Do()
				}
			}
			if(x == "unfixing" || x == "unfix") {
				if(exist(o.minify)) {
					o.minify.Un()
				}
			}
			if(x == "time" || x == "time2") {
				var _t = o.media ? o.media.time() : 0;
				if(o.continue && v.timestore == 1 && !o.start && _t == 0) {
					var f = o.continue.flag();
					if(f.t) {
						_t = f.t
					}
				}
				return x == "time2" ? timeFormat(_t) : _t
			}
			if(x == "timeplay") {
				if(o.butplstart) {
					apiProcessor("play", "id:" + o.butplstart)
				}
				if(o.butseekto) {
					apiProcessor("seek", o.butseekto);
					apiProcessor("play")
				}
			}
			if(x == "duration") {
				return o.media ? o.media.duration() : 0
			}
			if(x == "buffered") {
				return o.media ? o.media.loaded() : 0
			}
			if(x == "points") {
				if(y) {
					v.points = y;
					o.controls.RenewPoints()
				}
			}
			if(x == "quality") {
				if(exist(y)) {
					if(but) {
						v.hd = Switcher(v.hd, y, but);
						if(o.files_quality.length == 2) {
							o.actions.SetQuality(v.hd)
						}
					} else {
						o.actions.SetQuality(y)
					}
				} else {
					return o.media ? NoSpan(o.media.getQuality()) : 0
				}
			}
			if(x == "audiotrack") {
				if(exist(y)) {
					if(but) {
						v.ahd = Switcher(v.ahd, y, but);
						if(o.files_audiotrack.length == 2) {
							o.actions.SetAudioTrack(v.ahd)
						}
					} else {
						o.actions.SetAudioTrack(y)
					}
				} else {
					return o.media ? o.media.getAudioTrack() : 0
				}
			}
			if(x == "isyoutube") {
				return o.file_type == "youtube"
			}
			if(x == "restart") {
				if(o.current_audiotrack > 0) {
					o.restart_audio = o.current_audiotrack
				}
				o.actions.NewFile(o.files[o.current_file])
			}
			if(x == "playing") {
				return o.play
			}
			if(x == "started") {
				return o.start
			}
			if(x == "system") {
				return o.system[y]
			}
			if(x == "youtubeready") {
				o.destroyed != 1 ? o.media.onYoutubeReady() : ''
			}
			if(x == "id") {
				return v.id
			}
			if(x == "log") {
				v.log = y
			}
			if(x == "eventstracker") {
				v.eventstracker = y
			}
			if(x == "pip") {
				o.media.PipToggle()
			}
			if(x == "switchpip") {
				o.media.PipSwitch();
				if(but) {
					o.piped = Switcher(o.piped, y, but)
				}
			}
			if(x == "airplay") {
				o.media.Airplay()
			}
			if(x == "pipwebkit") {
				o.media.PipWebkit()
			}
			if(x == "options" && v.playerjscom != 1) {
				console.log(options)
			}
			if(x == "castinit" && o.chromecast) {
				o.chromecast.init()
			}
			if(x == "subtitle") {
				if(exist(y)) {
					if(y == '0/1') {
						if(o.subtitle_on) {
							o.submm = o.current_subtitle;
							y = -1
						} else {
							y = o.submm ? o.submm : 0
						}
					}
					v.subtitle = y;
					if(y.toString().length < 3 && o.sbt) {
						o.sbt.SetSubtitle(y * 1)
					} else {
						o.actions.Subtitle(y)
					}
				} else {
					return o.files_subtitle ? o.files_subtitle[o.current_subtitle] : ''
				}
			}
			if(x == "quiz") {
				if(exist(o.quiz)) {
					if(exist(y)) {
						o.quiz.api(y)
					} else {
						return o.quiz.Active()
					}
				}
			}
			if(x == "geo") {
				if(o.geobj) {
					return o.geobj
				} else {
					return false
				}
			}
			if(x == "ratio") {
				return o.media.ratio()
			}
			if(x == "box") {
				var box = createElement("div");
				box.id = y;
				box.style.zIndex = 10000;
				o.frame.appendChild(box)
			}
			if(x == "screenshot") {
				if(o.tagvideo) {
					var canvas = createElement("canvas");
					var size = o.media.size();
					canvas.width = size.width > 0 ? size.width : o.normal_w;
					canvas.height = size.height > 0 ? size.height : o.normal_h;
					css(canvas, {
						"position": "absolute",
						"top": -canvas.height,
						"left": -canvas.width,
						"display": "none"
					});
					document.body.appendChild(canvas);
					var ctx = canvas.getContext('2d');
					ctx.drawImage(o.media.tag(), 0, 0, canvas.width, canvas.height);
					var quality = 2;
					var canvas2 = document.createElement("canvas");
					canvas2.width = canvas.width * quality;
					canvas2.height = canvas.height * quality;
					var ctx2 = canvas2.getContext("2d");
					ctx2.drawImage(o.media.tag(), 0, 0, canvas.width * quality, canvas.height * quality);
					if(v.sscopyright == 1 && exist(v.sstext)) {
						!exist(v.ssfontsize) ? v.ssfontsize = 20 : '';
						!exist(v.ssfontcolor) ? v.ssfontcolor = "ffffff" : '';
						ctx2.font = v.ssfontsize + "px Courier, Arial";
						ctx2.fillStyle = CheckColor(v.ssfontcolor);
						ctx2.fillText((v.sstext == "domain" ? o.domain : v.sstext), v.ssfontsize, canvas.height * quality - v.ssfontsize - 5)
					}
					ctx.drawImage(canvas2, 0, 0, canvas.width, canvas.height);
					var img;
					try {
						img = canvas.toDataURL("image/jpeg")
					} catch(e) {
						console.log(e.message);
						return false
					}
					return img
				} else {
					return false
				}
			}
			if(x == "dash") {
				return o.file_type == x ? o.media.getDASH() : undefined
			}
			if(x == "hls") {
				return o.file_type == x ? o.media.getHLS() : undefined
			}
			if(x == "poster") {
				if(!o.play || v.posterhide === 0) {
					o.media.Poster(y);
					return true
				} else {
					return false
				}
			}
			if(x == "stretch") {
				if(exist(y)) {
					y == '1/0' ? y = 1 - existv(v.covervideo, 0) : '';
					v.covervideo = y;
					o.media.normalscale()
				} else {
					return existv(v.covervideo, 0)
				}
			}
			if(x == "scale") {
				if(exist(y)) {
					if(y == 0) {
						o.media.normalscale()
					} else {
						o.media.scale(y)
					}
				} else {
					return [o.mediascale.x, o.mediascale.y, o.mediacontainer.style.left, o.mediacontainer.style.top]
				}
			}
			if(x == "title") {
				if(exist(y)) {
					exist(y) ? v.title = y : '';
					o.actions.Title('title');
					return true
				} else {
					return v.title
				}
			}
			if(x == "invert") {
				o.actions.InvertPlaylist()
			}
			if(x == "push") {
				if(y) {
					!o.playlist_source ? o.playlist_source = [] : '';
					if(typeof(y) == 'object') {
						y = o.playlist_source.concat(y);
						x = "playlist"
					}
				}
			}
			if(x == "playlist") {
				if(y) {
					if(typeof(y) == 'object') {
						try {
							o.actions.UpdatePlaylist(y);
							return true
						} catch(e) {
							return false
						}
					} else {
						if(y.indexOf(".txt") == y.length - 4 || y.indexOf(".txt?") > 0) {
							var xhr = XHR(y);
							xhr.onload = function() {
								if(this.readyState == 4 && this.status == 200) {
									try {
										apiProcessor('playlist', JSON.parse(this.responseText))
									} catch(e) {}
								}
							};
							xhr.send();
							return true
						} else {
							if(y == '') {
								o.actions.UpdatePlaylist([])
							} else {
								if(y == 'played' && o.pldur > 0) {
									var tmp = Math.round(((o.pldur2 + (!o.controls.PlaylistG("played") ? o.media.time() : 0)) / o.pldur) * 100);
									if(tmp < o.pldur3 || tmp > 100) {
										return o.pldur3
									} else {
										o.pldur3 = tmp;
										return tmp
									}
								}
							}
						}
					}
				}
			}
			if(x == "next") {
				o.controls ? o.controls.PlaylistNext() : ''
			}
			if(x == "prev") {
				o.controls ? o.controls.PlaylistPrev() : ''
			}
			if(x == "cut") {
				o.controls ? o.controls.Cut(y) : ''
			}
			if(x == "cut?") {
				return o.cutted ? [o.cut1, o.cut2] : 0
			}
			if(x == "flip") {
				o.media ? o.media.flip() : ''
			}
			if(x == "find") {
				if(exist(y) && exist(o.playlist_dic)) {
					!o.play ? v.autoplay = 0 : '';
					for(var j in o.playlist_dic) {
						if(o.playlist_dic.hasOwnProperty(j)) {
							if(o.playlist_dic[j].pjs_id == y) {
								y = j
							}
						}
					}
					if(exist(o.playlist_dic[y])) {
						o.controls.PlaylistOpenId(y);
						return true
					} else {
						return false
					}
				}
			}
			if(x == "playlist_folders") {
				var tmp = [];
				if(exist(o.playlist_dic)) {
					for(var j in o.playlist_dic) {
						if(o.playlist_dic[j].folder && o.playlist_dic[j].pjs_parent_i == -1) {
							tmp.push({
								title: o.playlist_dic[j].title,
								id: o.playlist_dic[j].id
							})
						}
					}
				}
				return tmp
			}
			if(x == "playlist_id") {
				if(o.plid) {
					return o.playlist_dic[o.plid].pjs_id ? o.playlist_dic[o.plid].pjs_id : o.plid
				}
			}
			if(x == "playlist_length") {
				if(o.playlist_dic) {
					return Object.keys(o.playlist_dic).length
				} else {
					return -1
				}
			}
			if(x == "playlist_title") {
				if(exist(o.playlist_title)) {
					return o.playlist_title
				}
			}
			if(x == "showplaylist") {
				o.controls.PlaylistShow(y)
			}
			if(x == "showvlt") {
				o.media.VstLdTxt()
			}
			if(x == "toolbar") {
				o.controls.ShowForce()
			}
			if(x == "vastnow") {
				if(o.vast) {
					return true
				} else {
					return false
				}
			}
			if(x == "vastinfo") {
				if(o.vast) {
					return VastInfo()
				} else {
					return false
				}
			}
			if(x == "vastpause") {
				if(o.vast) {
					return o.vast.pause()
				} else {
					return false
				}
			}
			if(x == "vastresume") {
				if(o.vast) {
					return o.vast.resume()
				} else {
					return false
				}
			}
			if(x == "vaststart") {
				if(o.vast) {
					o.vast.startAd()
				} else {
					return false
				}
			}
			if(x == "vastmute") {
				if(o.vast) {
					o.vast.mute()
				} else {
					return false
				}
			}
			if(x == "captions") {
				v.captions = Switcher(v.captions, y, but);
				o.media.captions()
			}
			if(x == "loop") {
				if(exist(but)) {
					v.loop = Switcher(v.loop, y, but)
				} else {
					if(exist(y)) {
						y == '0/1' ? y = 1 - v.loop : '';
						v.loop = y
					} else {
						return v.loop
					}
				}
			}
			if(x == "shuffle") {
				if(exist(but)) {
					v.shuffle = Switcher(v.shuffle, y, but)
				} else {
					if(exist(y)) {
						v.shuffle = y
					} else {
						return v.shuffle
					}
				}
			}
			if(x == "autonext" || x == "playlistloop") {
				var z = "autoplaylist";
				x == "playlistloop" ? z = "playlistrewind" : "";
				if(exist(but)) {
					v.playlist[z] = Switcher(v.playlist[z], y, but)
				} else {
					if(exist(y)) {
						y == '0/1' ? y = 1 - v.playlist[z] : '';
						v.playlist[z] = y
					}
				}
				return v.playlist[z]
			}
			if(x == "hd") {
				if(o.files_quality.length == 2) {
					v.hd = o.files_quality[o.current_quality];
					v.hd = Switcher(v.hd, y, but);
					if(o.files_quality[0] == v.hd) {
						o.actions.SetQuality(0)
					} else {
						o.actions.SetQuality(1)
					}
				}
			}
			if(x == "v" && y) {
				if(y.indexOf('file') == 0 || y.indexOf('bk') == 0) {
					return
				}
				return v[y]
			}
			if(x.indexOf("update:") == 0) {
				var xx = x.substr(7);
				if(typeof(y) == 'object' && typeof(v[xx]) == 'object') {
					for(var yy in y) {
						if(y.hasOwnProperty(yy)) {
							v[xx][yy] = y[yy]
						}
					}
				} else {
					if(x.indexOf('rc_') == -1) {
						v[xx] = y
					}
				}
				return true
			}
			if(x.indexOf("text:") == 0) {
				o.controls.customText(x.substr(5), y)
			}
			if(v.clrs == 1 && x.indexOf("color") == 0 && y) {
				pushCSS('pjsdiv, pjsdiv > *{--pjs' + x + ':' + CheckColor(y) + '}')
			}
			if(x == "currentfile") {
				return o.media ? o.media.currentFile() : ''
			}
			if(x == "vrsn") {
				return o.version + ' ' + o.playerid
			}
			if(x == "playerid") {
				return o.playerid
			}
			if(x == "hlserror") {
				return o.hlserror
			}
			if(x == "dasherror") {
				return o.dasherror
			}
			if(x == "visibility") {
				return o.visibility
			}
			if(x == "vastids") {
				return o.vast ? o.vast_adid : undefined
			}
			if(x == "destroy") {
				o.actions.StopMedia();
				v.hotkey.on = 0;
				if(v.stopotherplayers == 1) {
					for(var i = 0; i < pljssglobal.length; i++) {
						if(pljssglobal[i]) {
							if(pljssglobal[i].api("id") == v.id) {
								pljssglobal[i] = null
							}
						}
					}
				}
				for(var w in window) {
					if(window[w] == o.this) {
						window[w] = null
					}
				}
				if(pljssglobalid == v.id) {
					pljssglobalid = ''
				}
				o.destroyed = 1;
				o.container.innerHTML = '';
				o.this = null
			}
		} else {
			return false
		}
	};

	function Switcher(x, y, but) {
		var z = trim(y) + '';
		if(y.indexOf("/") > 0) {
			var y2 = y.split("/");
			if(y2.length == 2) {
				if(x == trim(y2[0])) {
					z = trim(y2[1]);
					if(but) {
						but.CustomSwitch(1)
					}
				} else {
					z = trim(y2[0]);
					if(but) {
						but.CustomSwitch(0)
					}
				}
			}
		}
		return z
	}

	function XHR(x) {
		var xhr = new XMLHttpRequest();
		xhr.open('GET', x, true);
		return xhr
	}

	function FindIdPl(y) {
		var z = y.substr(3);
		if(o.playlist_dic) {
			for(var j in o.playlist_dic) {
				if(o.playlist_dic.hasOwnProperty(j)) {
					if(o.playlist_dic[j].pjs_id == z) {
						z = j
					}
				}
			}
		}
		return z
	}

	function VastInfo() {
		var x;
		if(o.vast) {
			if(o.vast.active()) {
				x = o.vast
			}
		}
		if(!x && o.vastloader) {
			x = o.vastloader
		}
		if(x) {
			var y = {
				is: o.vasttype,
				system: x.info("adsystem"),
				version: x.info("version"),
				vpaid: x.info("isVpaid"),
				url: o.current_vast_url + (x.info("wrapper") ? x.info("wrapper0") + x.info("wrapper") : ''),
				type: x.info("filetype"),
				file: x.info("file"),
				time: (o.media ? o.media.time() : ''),
				volume: x.getVolume(),
				id: o.vast_adid
			};
			if(o.vasttype == "midroll") {
				y.midroll_time = o.midrollcrtm
			}
			return y
		}
	}

	function MediaSess() {
		if('mediaSession' in navigator) {
			navigator.mediaSession.metadata = new MediaMetadata({
				title: existv(o.titlestore, v.title),
				artwork: [{
					src: existv(v.poster, '')
				}]
			});
			if(!o.mss) {
				navigator.mediaSession.setActionHandler('play', function() {
					apiProcessor("play")
				});
				navigator.mediaSession.setActionHandler('pause', function() {
					apiProcessor("pause")
				});
				if(o.controls.PlaylistExist()) {
					navigator.mediaSession.setActionHandler('previoustrack', function() {
						apiProcessor("prev")
					});
					navigator.mediaSession.setActionHandler('nexttrack', function() {
						apiProcessor("next")
					})
				}
				o.mss = true
			}
		}
	}
	var createElement = function(x) {
		var y = x;
		x == 'div' || x == 'div2' ? y = 'pjsdiv' : '';
		var z = document.createElement(y);
		if(x == 'div2') {
			css(z, {
				"cursor": "pointer",
				"display": "block"
			})
		}
		return z
	};
	var log = function(a, b, c, d, e, f, g) {
		if(v.log == 1 || v.logout == 1) {
			var x = a + (b != undefined ? " " + b : "") + (c != undefined ? " " + c : "") + (d != undefined ? " " + d : "") + (e != undefined ? " " + e : "") + (f != undefined ? " " + f : "") + (g != undefined ? " " + g : "");
			console.log("Playerjs" + (v.pjsframed == 1 ? "2" : "") + ": " + x);
			if(v.logout == 1 && exist(document.getElementById("pjslog"))) {
				document.getElementById("pjslog").innerHTML += x + '<br/>'
			}
		}
	};
	var CustomFonts = function() {
		if(v.fonts == 1 && exist(v.fontnames) && v.fontnames != '') {
			var x = document.createElement('link');
			x.rel = 'stylesheet';
			x.href = 'https://fonts.googleapis.com/css?family=' + v.fontnames.replace(/,/ig, "|").replace(/ /ig, "+");
			document.head.appendChild(x)
		}
	};
	var SvgColor = function(div, clr) {
		var x = ["path", "polygon", "polyline", "rect", "ellipse", "circle"];
		for(var y = 0; y < x.length; y++) {
			var z = div.querySelectorAll("svg " + x[y]);
			if(z.length > 0) {
				for(var y2 = 0; y2 < z.length; y2++) {
					z[y2].style.fill = clr
				}
			}
		}
	};
	var Time = function(time) {
		time < 0 ? time = 0 : '';
		var full_minutes = o.media.duration >= 600 ? true : false;
		var full_hours = o.media.duration >= 3600 ? true : false;
		var minutes = Math.floor(time / 60);
		var seconds = Math.floor(time - minutes * 60);
		var hours = Math.floor(minutes / 60);
		var days = Math.floor(hours / 24);
		minutes = minutes - hours * 60;
		if(days > 0) {
			hours = hours - days * 24
		}
		if(v.dvrtime == 1 && o.media.isLive()) {
			var d = new Date();
			return String(new Date(d.getTime() + time * 1000).toLocaleTimeString())
		} else {
			return String((days > 0 ? days + ':' : '') + (hours > 0 || full_hours ? hours + ':' : '') + ((hours > 0 || full_minutes) && minutes < 10 ? '0' : '') + minutes + ':' + (seconds < 10 ? '0' : '') + seconds)
		}
	};
	var timeFormat = function(x) {
		var seconds = Math.floor(x);
		var minutes = Math.floor(seconds / 60);
		var hours = Math.floor(minutes / 60);
		minutes = Math.floor(minutes % 60);
		seconds = Math.floor(seconds % 60);
		hours > 0 && minutes < 10 ? minutes = "0" + minutes : "";
		seconds = seconds >= 0 ? ((seconds >= 10) ? seconds : "0" + seconds) : "00";
		var out = (hours > 0 ? hours + ":" : "") + (minutes >= 0 ? minutes : "0") + ":" + seconds;
		if(v.dvrtime == 1 && o.media.isLive()) {
			var d = new Date();
			return String(new Date(d.getTime() + x * 1000).toLocaleTimeString())
		} else {
			return out
		}
	};
	var Href = function() {
		return encodeURIComponent((window.location != window.parent.location) ? document.referrer : document.location.href)
	};
	var NoSpan = function(x) {
		if(x) {
			x = x.toString();
			var spn = x.indexOf(" <span style='opacity");
			if(spn > -1) {
				x = x.substr(0, spn)
			}
		}
		return x
	};
	var Script = function(x, y, z) {
		var t;
		if(!Scripted(x) && y) {
			t = document.createElement('script');
			y == "same" ? y = x : '';
			t.src = y.indexOf('//') == -1 ? '//' + y : y;
			t.async = 1;
			if(z) {
				t.name = z
			}
			var s = document.getElementsByTagName('script')[0];
			s.parentNode.insertBefore(t, s)
		}
		return t
	};
	var Scripted = function(y) {
		var x = false;
		var scripts = document.getElementsByTagName('script');
		for(var i = 0; i < scripts.length; i++) {
			if(scripts[i].src.indexOf(y) > -1) {
				x = true
			}
		}
		return x
	};
	var hex2rgb = function(x, y) {
		if(x) {
			if(x.indexOf('color') > -1 || x.indexOf('var') > -1) {
				return CheckColor(x)
			} else {
				x = x.replace('#', '');
				var r = parseInt(x.length == 3 ? x.slice(0, 1).repeat(2) : x.slice(0, 2), 16);
				var g = parseInt(x.length == 3 ? x.slice(1, 2).repeat(2) : x.slice(2, 4), 16);
				var b = parseInt(x.length == 3 ? x.slice(2, 3).repeat(2) : x.slice(4, 6), 16);
				if(exist(y)) {
					return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + y + ')'
				} else {
					return 'rgb(' + r + ', ' + g + ', ' + b + ')'
				}
			}
		}
	};
	var css = function(e, o) {
		if(exist(e)) {
			for(var key in o) {
				if(o.hasOwnProperty(key)) {
					if(o[key] != 'NaNpx' && o[key] != undefined) {
						if(typeof o[key] == 'number' && key != 'opacity' && key != 'zIndex') {
							o[key] += 'px'
						}
						if(key.indexOf("olor") > -1 && key.indexOf("scheme") == -1) {
							o[key] = CheckColor(o[key])
						}
						if(key == "transform") {
							e.style['-ms-' + key] = o[key];
							e.style['-moz-' + key] = o[key];
							e.style['-webkit-' + key] = o[key];
							e.style['-o-' + key] = o[key]
						}
						if(key == "fontFamily") {
							if(o[key].indexOf(" ") > -1) {
								o[key] = '"' + o[key] + '"'
							}
						}
						if(key == "box-sizing") {
							e.style.setProperty(key, o[key], 'important')
						} else {
							e.style[key] = o[key]
						}
					}
				}
			}
		}
	};
	var Bglines = function(x, clr, b1, b2) {
		clr = CheckColor(clr);
		var y = existv(b1, 1) * 1;
		var z = existv(b2, 1) * 1;
		css(x, {
			"background": "repeating-linear-gradient(-45deg," + clr + "," + clr + " " + y + "px,rgba(0,0,0,0)," + y + "px,rgba(0,0,0,0) " + (y + z) + "px)"
		})
	};
	var CheckColor = function(c) {
		if(c) {
			c.indexOf("color") == 0 ? c = 'var(--pjs' + c + ')' : '';
			return c.substr(0, 1) != '#' && c.indexOf("var") == -1 && c.indexOf("rgb") == -1 ? c = "#" + c : c
		}
	};
	var controlCSS = function(x, color, y) {
		!color ? color = '#fff' : '';
		color = CheckColor(color);
		var r = random(100000, 1000000);
		x = x.replace(/\(rand\)/g, r);
		x = x.replace(/\(color\)/g, color);
		x = x.replace(/\(scl\)/g, 1 + (v.control_buffer.scale - 1) / 2);
		var _html = x.substr(0, x.indexOf('|||'));
		var _css = x.substr(x.indexOf('|||') + 3);
		var _css2 = '';
		if(o.system.webkit) {
			_css2 = _css.replace(/animation:/g, "-webkit-animation:");
			_css2 = _css2.replace(/animation-/g, "-webkit-animation-");
			_css2 = _css2.replace(/@keyframes/g, "@-webkit-keyframes");
			_css2 = _css2.replace(/transform/g, "-webkit-transform")
		}
		y ? y.innerHTML = _html : '';
		pushCSS(_css2 + _css)
	};
	var indOf = function(x, y) {
		var z;
		if(x) {
			for(var i = 0; i < x.length; i++) {
				if(x[i]) {
					if(String(x[i]).indexOf(y) > -1) {
						z = true
					}
				}
			}
		}
		return z
	};
	var pushCSS = function(x) {
		if(o.css) {
			if(o.css.styleSheet) {
				o.css.styleSheet.cssText = x
			} else {
				o.css.appendChild(document.createTextNode(x))
			}
		}
	};
	var Pos0 = function(x) {
		css(x, {
			"position": "absolute",
			"top": 0,
			"left": 0,
			"width": "100%",
			"height": "100%"
		})
	};
	var Pnt0 = function(x) {
		css(x, {
			"pointerEvents": "none"
		})
	};
	var xhr = function(y, z) {
		var x = new XMLHttpRequest();
		x.open('GET', y, true);
		x.onload = z;
		x.send()
	};
	var FindPjsDiv = function(x) {
		if(x) {
			for(var i = 0; i < 5; i++) {
				if(x.nodeName == "PJSDIV") {
					break
				} else {
					if(x.parentElement) {
						x = x.parentElement
					}
				}
			}
		}
		return x
	};
	var gif = function(z) {
		var gif = document.createElement("img");
		if(o.gifed.indexOf(z) > -1) {
			o.gifed.push(z);
			if(z.indexOf("?") > 0) {
				z = z + '&' + Math.random()
			} else {
				z = z + '?' + Math.random()
			}
		} else {
			o.gifed.push(z)
		}
		gif.setAttribute('src', z);
		gif.setAttribute('height', '1px');
		gif.setAttribute('width', '1px')
	};
	var attr = function(e, o) {
		for(var key in o) {
			if(o.hasOwnProperty(key)) {
				e.setAttribute(key, o[key])
			}
		}
	};
	var destroy = function(e) {
		if(e) {
			try {
				e.parentNode.removeChild(e);
				e = null
			} catch(e) {}
		}
	};
	var random = function(min, max) {
		return Math.floor(arguments.length > 1 ? (max - min + 1) * Math.random() + min : (min + 1) * Math.random())
	};
	var randomstr = function() {
		return Math.random().toString(36).substring(2, 12)
	};
	var removebykey = function(x, y) {
		x = Object.keys(x).reduce(function(obj, key) {
			if(key != y) {
				obj[key] = x[key]
			}
			return obj
		}, {});
		return x
	};
	var trim = function(x) {
		if(typeof x == "string") {
			return x.replace(/^\s+|\s+$/gm, '')
		} else {
			return x
		}
	};
	var cut = function(x, y, z) {
		var r = false;
		if(x) {
			if(x.indexOf(y) > -1) {
				var r = x.substr(x.indexOf(y) + y.length);
				if(z) {
					if(r.indexOf(z) > -1) {
						r = r.substr(0, r.indexOf(z))
					}
				}
			}
		}
		return r
	};
	var encode = function(x, n) {
		if(n == 0) {
			return "#0" + salt.e(x)
		}
		if(n == -1) {
			return salt.e(x)
		}
		if(n == 1) {
			return "#1" + pepper(salt.e(x), 1)
		}
	};
	var str2obj = function(x) {
		if(v[x] != "") {
			if(typeof v[x] != "string") {
				o[x + 'o'] = v[x]
			} else {
				if(v[x].indexOf("[{") == 0) {
					try {
						v[x] = v[x].replace(/pjs'qt/ig, '"');
						o[x + 'o'] = eval(v[x])
					} catch(e) {}
				}
			}
		}
	};
	var dechar = function(x) {
		return String.fromCharCode(x)
	};
	var decode = function(x) {
		if(x.substr(0, 2) == "#1") {
			return salt.d(pepper(x.substr(2), -1))
		} else if(x.substr(0, 2) == "#0") {
			return salt.d(x.substr(2))
		} else {
			return x
		}
	};
	var checkBase64 = function(x) {
		if(x) {
			if(x.indexOf('http') == -1 && x.indexOf('.') == -1 && x.length > 100 && x.indexOf('data:') == -1) {
				x = 'data:image/png;base64,' + x
			}
		}
		return x
	};
	var hide = function(x) {
		x ? x.style.visibility = "hidden" : ''
	};
	var show = function(x) {
		x ? x.style.visibility = "visible" : ''
	};
	var hide2 = function(x) {
		x ? x.style.display = "none" : ''
	};
	var show2 = function(x) {
		x ? x.style.display = "block" : ''
	};
	var isVisible = function(x) {
		return x ? x.style.visibility != "hidden" && x.style.display != "none" : false
	};
	var int = function(s) {
		if(typeof s == "string") {
			if(s.indexOf("px") > 0) {
				s = s.substr(0, s.indexOf("px"))
			}
		}
		return parseInt(s)
	};
	var hidden = function(x) {
		return x.style.display == "none"
	};
	var MarginPadding = function(o, x, y) {
		o[x + 'top'] = 0;
		o[x + 'right'] = 0;
		o[x + 'bottom'] = 0;
		o[x + 'left'] = 0;
		if(exist(o[y])) {
			var z = o[y].split(" ");
			if(z.length == 4) {
				o[x + 'top'] = z[0] ? parseFloat(z[0]) : 0;
				o[x + 'right'] = z[1] ? parseFloat(z[1]) : 0;
				o[x + 'bottom'] = z[2] ? parseFloat(z[2]) : 0;
				o[x + 'left'] = z[3] ? parseFloat(z[3]) : 0
			}
		}
		return o
	};
	var MarPad = function(x) {
		if(x) {
			x = x.replace(/ /ig, 'px ')
		}
		return x + 'px'
	};
	var StringVar = function(x, y) {
		return v[x] && v[x] != '' ? v[x] : y
	};
	var abc = String.fromCharCode(65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122);
	var salt = {
		_keyStr: abc + "0123456789+/=",
		e: function(e) {
			var t = "";
			var n, r, i, s, o, u, a;
			var f = 0;
			e = salt._ue(e);
			while(f < e.length) {
				n = e.charCodeAt(f++);
				r = e.charCodeAt(f++);
				i = e.charCodeAt(f++);
				s = n >> 2;
				o = (n & 3) << 4 | r >> 4;
				u = (r & 15) << 2 | i >> 6;
				a = i & 63;
				if(isNaN(r)) {
					u = a = 64
				} else if(isNaN(i)) {
					a = 64
				}
				t = t + this._keyStr.charAt(s) + this._keyStr.charAt(o) + this._keyStr.charAt(u) + this._keyStr.charAt(a)
			}
			return t
		},
		d: function(e) {
			var t = "";
			var n, r, i;
			var s, o, u, a;
			var f = 0;
			e = e.replace(/[^A-Za-z0-9\+\/\=]/g, "");
			while(f < e.length) {
				s = this._keyStr.indexOf(e.charAt(f++));
				o = this._keyStr.indexOf(e.charAt(f++));
				u = this._keyStr.indexOf(e.charAt(f++));
				a = this._keyStr.indexOf(e.charAt(f++));
				n = s << 2 | o >> 4;
				r = (o & 15) << 4 | u >> 2;
				i = (u & 3) << 6 | a;
				t = t + dechar(n);
				if(u != 64) {
					t = t + dechar(r)
				}
				if(a != 64) {
					t = t + dechar(i)
				}
			}
			t = salt._ud(t);
			return t
		},
		_ue: function(e) {
			e = e.replace(/\r\n/g, "\n");
			var t = "";
			for(var n = 0; n < e.length; n++) {
				var r = e.charCodeAt(n);
				if(r < 128) {
					t += dechar(r)
				} else if(r > 127 && r < 2048) {
					t += dechar(r >> 6 | 192);
					t += dechar(r & 63 | 128)
				} else {
					t += dechar(r >> 12 | 224);
					t += dechar(r >> 6 & 63 | 128);
					t += dechar(r & 63 | 128)
				}
			}
			return t
		},
		_ud: function(e) {
			var t = "";
			var n = 0;
			var r = 0;
			var c1 = 0;
			var c2 = 0;
			while(n < e.length) {
				r = e.charCodeAt(n);
				if(r < 128) {
					t += dechar(r);
					n++
				} else if(r > 191 && r < 224) {
					c2 = e.charCodeAt(n + 1);
					t += dechar((r & 31) << 6 | c2 & 63);
					n += 2
				} else {
					c2 = e.charCodeAt(n + 1);
					c3 = e.charCodeAt(n + 2);
					t += dechar((r & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
					n += 3
				}
			}
			return t
		}
	};
	var pepper = function(s, n) {
		s = s.replace(/\+/g, "#");
		s = s.replace(/#/g, "+");
		var a = sugar(o.y) * n;
		if(n < 0) a += abc.length / 2;
		var r = abc.substr(a * 2) + abc.substr(0, a * 2);
		return s.replace(/[A-Za-z]/g, function(c) {
			return r.charAt(abc.indexOf(c))
		})
	};
	var sugar = function(x) {
		x = x.split(dechar(61));
		var result = '';
		var c1 = dechar(120);
		var chr;
		for(var i in x) {
			if(x.hasOwnProperty(i)) {
				var encoded = '';
				for(var j in x[i]) {
					if(x[i].hasOwnProperty(j)) {
						encoded += (x[i][j] == c1) ? dechar(49) : dechar(48)
					}
				}
				chr = parseInt(encoded, 2);
				result += dechar(chr.toString(10))
			}
		}
		return result.substr(0, result.length - 1)
	};
	var exist = function(x) {
		return x != null && typeof(x) != 'undefined' && x != 'undefined'
	};
	var existv = function(x, y) {
		return exist(x) ? x : y
	};
	var exist2 = function(x) {
		return exist(x) && x != -1 && x != ''
	};
	var copyObject = function(x) {
		if(typeof x == "object") {
			x = JSON.parse(JSON.stringify(x))
		}
		return x
	};
	var findLeft = function(el) {
		var x = el.getBoundingClientRect().left + (window.scrollX ? window.scrollX : window.pageXOffset);
		return x
	};
	var checkFont = function(x) {
		v.globalfont == 1 && exist2(v.globalfontname) ? x = v.globalfontname : '';
		return x
	};
	var findTop = function(el) {
		const rect = el.getBoundingClientRect();
		return rect.top + window.scrollY
	};
	var redirect = function(x, y) {
		if(x != '') {
			if(v.redirectblank == 1) {
				window.open(x)
			} else {
				if(v.redirectparent == 1) {
					window.parent.location.href = x
				} else {
					window.location.href = x
				}
			}
			x = ''
		}
	};
	var reRightMenu = function() {
		if(v.rightmenu == 1) {
			o.rightmenu ? o.frame.removeChild(o.rightmenu) : '';
			o.rightmenu = null
		}
	};
	var Actions = function() {
		var _fullscreen_end = false;
		if(o.system.tv) {
			log("tv")
		}
		this.Title = function(x) {
			o.controls ? o.controls.title(x) : ''
		};
		this.File = function(x) {
			if(x) {
				if(typeof(x) == 'string') {
					x = x.replace(/(\r\n|\n|\r)/gm, "");
					if(x.indexOf("[{") == 0) {
						try {
							x = x.replace(/pjs'qt/ig, '"');
							x = JSON.parse(x)
						} catch(e) {
							x = "incorrect JSON"
						}
					}
				}
				if(typeof(x) == 'object') {
					o.playlist_dic = [];
					o.playlist_source = copyObject(x);
					o.playlist = IndexPlaylist(x);
					if(o.playlist.length > 0) {
						if(v.playlist.openlast == 1 && !v.plstart) {
							var keys = Object.keys(o.playlist_dic);
							var last = keys.slice(-1)[0];
							last ? v.plstart = last : ''
						}
						var y = FindFileInPlaylist();
						if(y) {
							x = y.file;
							o.titlestore = y.title;
							o.controls ? o.controls.titlepl(y.title) : '';
							if(exist(y.poster)) {
								if(o.media) {
									o.media.Poster(y.poster)
								} else {
									v.poster = y.poster
								}
							}
							if(exist(y.sub)) {
								y.subtitle = y.sub
							}
							if(exist(y.start)) {
								v.start = o.seekto = y.start
							}
							SettingsTimers("offset");
							if(exist(y.id)) {
								o.plid = y.id
							}
							var sx = ["subtitle", "vars", "embed", "url", "url2", "url3", "heartbeat", "thumbnails", "label", "download", "points", "remove", "end", "delete", "title2", "skip", "customtext", "volume"];
							if(exist(v.control_title)) {
								if(v.control_title.showfrom1file == 1 && v.control_title.showtitleplaylist == 1) {
									sx.push("title");
									sx.push("t1");
									sx.push("t2");
									sx.push("t3");
									sx.push("t4");
									sx.push("t5")
								}
							}
							for(var i = 0; i < sx.length; i++) {
								if(exist(y[sx[i]])) {
									v[sx[i]] = y[sx[i]]
								}
							}
							Ctxt(y);
							if(sx.indexOf('title') > 0) {
								if(v.control_title.templated == 1) {
									o.title_template = v.control_title.template;
									o.actions.TitleTemplate(y)
								}
								o.actions.Title('title')
							}
							if(exist(y.volume)) {
								setTimeout(function() {
									o.actions.Volume(y.volume)
								}, 200)
							}
							if(o.controls) {
								o.controls.UpdatePlaylist(o.playlist);
								if(v.customtext) {
									o.controls.customTextPl()
								}
							}
							if(o.droplist) {
								o.droplist.Update()
							}
						} else {}
					}
				}
				if(typeof(x) == 'string') {
					x = fjs(x);
					if(x.indexOf("#" + v.enc2) == 0) {
						x = o[o.fd[0]](x)
					}
					if(x) {
						if(x.indexOf("#" + v.enc3) == 0 && x.indexOf(v.file3_separator) > 0) {
							x = o[o.fd[1]](x)
						}
						if(x.indexOf("#0") == 0) {
							x = fd0(x)
						}
						x = fjs(x)
					}
					if(v.fplace == 1) {
						x = fplace(x)
					}
					if(x == '') {
						log("empty file");
						o.media_error = true;
						js("error", "empty")
					}
					o.files_quality = [];
					o.files_quality_ag = [];
					o.files_audiotrack = [];
					o.current_file = 0;
					o.current_quality = 0;
					o.current_audiotrack = 0;
					v.file_separator == '' ? v.file_separator = ',' : '';
					if((x.indexOf(v.qbr1) > -1 && x.indexOf(v.qbr2) > -1) || exist(v.qualities)) {
						o.files = x.split(v.file_separator)
					} else {
						o.files = [x]
					}
					o.audiotracks = [];
					if(exist(v.qualities)) {
						var qualities = v.qualities.split(v.file_separator)
					}
					if(o.files.length > 0) {
						var q = -1;
						for(var i = 0; i < o.files.length; i++) {
							o.files[i] = trim(o.files[i]);
							if(o.files[i] != '') {
								if(o.files[i].indexOf(v.qbr1) == 0 && o.files[i].indexOf(v.qbr2) > 1) {
									o.files_quality[i] = o.files[i].substr(o.files[i].indexOf(v.qbr1) + v.qbr1.length, o.files[i].indexOf(v.qbr2) - v.qbr2.length);
									o.files[i] = o.files[i].substr(o.files[i].indexOf(v.qbr2) + v.qbr2.length)
								} else {
									if(exist(v.qualities)) {
										o.files_quality[i] = exist(qualities[i]) ? qualities[i] : ''
									} else {
										o.files_quality[i] = i + 1
									}
								}
								var is = 0;
								if(exist(v.default_quality) && q == -1) {
									if(String(v.default_quality).indexOf("num:") == 0) {
										if(v.default_quality.substr(4) * 1 == i) {
											is = 1
										}
									}
									if(v.default_quality == o.files_quality[i]) {
										is = 1
									}
									if(v.default_quality == "max" && i == o.files.length - 1) {
										is = 1
									}
								}
								if(exist(o.default_quality)) {
									if(o.default_quality == o.files_quality[i]) {
										is = 1;
										q = i
									}
								}
								if(is == 1) {
									o.current_file = i;
									o.current_quality = i
								}
								o.files[i] = Prefile(o.files[i])
							}
						}
					} else {
						o.files[0] = Prefile(o.files[0])
					}
					return o.files[o.current_file]
				}
			} else {
				return x
			}
		};

		function Prefile(x) {
			if(exist(v.prefile) && x.indexOf("//") == -1) {
				x = v.prefile + x
			}
			return x
		};
		this.InvertPlaylist = function() {
			if(o.playlist) {
				var x = o.playlist.reverse();
				for(var i = 0; i < x.length; i++) {
					x[i].pjs_i = i
				}
				o.playlist = x;
				o.controls.UpdatePlaylist(o.playlist)
			}
		};

		function Ctxt(y) {
			var utx;
			for(var i = 1; i < 6; i++) {
				var t = "text" + i;
				if(exist(y[t])) {
					v[t] = y[t];
					utx = true
				}
			}
			if(utx && o.controls) {
				o.controls.upTexts()
			}
		}
		this.Ctxt = function(x) {
			Ctxt(x)
		};
		this.UpdatePlaylist = function(x) {
			if(typeof(x) == 'object') {
				o.playlist_dic = [];
				o.playlist_source = copyObject(x);
				o.playlist = IndexPlaylist(x);
				if(o.controls) {
					o.controls.UpdatePlaylist(o.playlist)
				}
			}
		};
		this.NewFile = function(x, y, z, no) {
			!exist(y) ? o.autoplay = true : '';
			!exist(z) ? v.preload = 0 : '';
			v.duration = undefined;
			v.end = undefined;
			v.delete = undefined;
			o.media_error != 2 ? o.media_error = false : '';
			o.metadata = false;
			o.pipwebkit = false;
			o.reloadTimer = 0;
			o.gatracked = [];
			o.checknative = false;
			o.gained = false;
			o.dvr = false;
			o.bitrate = undefined;
			o.quartile = [false, false, false];
			o.sess = randomstr();
			o.sesstime = 0;
			o.or0 = 0;
			o.pld ? o.pld = [] : '';
			o.file_type != 'pjs' && o.sbt ? o.sbt.remove() : '';
			o.trcka ? o.trcka = [] : '';
			if(o.err404v) {
				o.err404v.remove()
			}
			if(o.media.status() == "playing") {
				this.Stop()
			}
			if(o.cut && o.cutted) {
				o.controls.Cut()
			}
			if(exist(o.share)) {
				o.share.Remove()
			}
			if(exist(o.reloadto)) {
				clearTimeout(o.reloadto)
			}
			js("new");
			if(v.vast == 1 && no != 1) {
				o.actions.VastRecover();
				o.actions.VastRecover('midroll')
			}
			x = this.File(x);
			if(y == 1) {
				o.file_type = ''
			}
			o.media.File(x);
			if((o.system.mobile || o.system.safari) && !exist(y)) {
				o.actions.Play()
			}
			if(exist(o.custom_aspect)) {
				o.mediascale = {
					x: 1,
					y: 1,
					x0: 1,
					y0: 1
				};
				o.media.normalscale()
			}
			gaTracker("play", "Play");
			o.media.NativeControls();
			o.controls.QualityChangedNoHand();
			o.controls.AudioTrackChangedNoHand();
			o.controls.refresh();
			o.mediatags ? o.mediatags.read() : ''
		};
		this.TitleTemplate = function(x) {
			var y = false;
			if(x && o.title_template) {
				v.title = o.title_template;
				for(var i = 1; i < 6; i++) {
					if(exist(x['t' + i])) {
						v.title = v.title.replace("{" + i + "}", x['t' + i]);
						y = true
					}
				}
			}
			return y
		};
		this.MediaReady = function() {
			if(v.autoplay == 1 && !v.autoplayed || o.autoplay) {
				if(v.observer == 1) {
					setTimeout(function() {
						o.actions.Play()
					}, 500)
				} else {
					this.Play()
				}
				v.autoplayed = 1;
				o.autoplay = false
			}
			Thumbs()
		};
		this.Thumbs = function() {
			Thumbs()
		};

		function Thumbs() {
			if(v.thumbs == 1) {
				if(typeof PluginThumbs !== "undefined") {
					o.th = new PluginThumbs()
				}
			}
		}
		this.NativeControls = function() {
			var x = false;
			if(o.system.mobile) {
				x = true;
				if(v.nativenotiphone == 1 && o.system.iphone) {
					x = false
				}
				if(v.nativenotipad == 1 && o.system.ipad) {
					x = false
				}
				if(v.nativenotios == 1 && o.system.ios) {
					x = false
				}
				if(v.nativenotandroid == 1 && o.system.android) {
					x = false
				}
			}
			if(v.nativeontv == 1 && o.system.tv) {
				x = true
			}
			return x
		};
		this.Metadata = function() {
			o.media.Volume(v.volume);
			if(o.muted) {
				o.media.Mute()
			}
			o.metadata = true;
			o.controls ? o.controls.refresh() : '';
			if(!o.play && !o.start) {
				v.effects == 1 ? o.effects.api("pause") : ''
			}
			if(o.casting && o.tagvideo) {
				o.chromecast.Exit();
				o.chromecast.Go()
			}
			if(v.vast == 1) {
				if(v.nomidroll != 1 && v.midrolls == 1) {
					!exist(o.vast) ? MidrollOverlay("midroll", "metadata") : ''
				}
			}
		};
		this.onPlayTag = function() {
			!o.onplay ? onPlay(true) : ''
		};

		function onPlay(x) {
			o.onplay = true;
			if(o.controls) {
				if(o.controls.SettingsVisible()) {
					o.controls.Settings()
				}
			}
			if(o.droplist) {
				o.droplist.Close()
			}!x ? o.media.Play() : '';
			if(!o.checknative) {
				setTimeout(function() {
					o.media.NativeControls()
				}, 500)
			}!o.play ? o.controls.Play() : '';
			v.effects == 1 ? o.effects.api("play") : '';
			v.vast == 1 ? o.actions.VastRecover('pauseroll') : '';
			if(o.system.mobile) {
				o.controls.HideInterval()
			}
			if(exist(o.share)) {
				o.share.isOpen() ? o.share.Hide() : ''
			}
			if(v.heartbeats == 1 && exist(v.heartbeat) && o.dt) {
				if(v.heartbeat != '' && !exist(o.heartbeatInterval)) {
					o.heartbeatInterval = setInterval(Heartbeat, v.heartbeatinterval * 1000);
					Heartbeat()
				}
			}
		}
		this.Play = function(noads) {
			if(!o.play && o.media) {
				o.actplay = true;
				o.ended = false;
				clearTimeout(o.plapto);
				var stop = false;
				if(o.file_type == "youtube") {
					if(!o.media.YoutubeReady() && v.autoplay != 1 && v.preload == 1) {
						stop = true;
						if(window['YT']) {
							v.autoplay = 1;
							o.autoplay = true;
							o.media.onYoutubeReady()
						}
					}
				}
				if(v.pass == 1 && v.passontime == 0) {
					o.actions.Password();
					stop = true
				}
				if(o.media_error || stop) {
					if(o.media_error) {
						Advertising("preroll") ? datetime(2) : ''
					}
				} else {
					o.newfile = false;
					StopOtherPlayer(!o.start);
					o.alert.close();
					if(!o.start) {
						js("start");
						o.start = true;
						if(v.toolbar.hideuntilstarted == 1) {
							setTimeout(function() {
								o.controls.resizetext()
							}, 100)
						}
						if(v.toolbar.hideleavetimeout > 0 && v.autoplay == 1) {
							o.starttimeout = true;
							setTimeout(StartTimeout, v.toolbar.hideleavetimeout * 1000)
						}
						if(v.water == 1 && v.wid) {
							PluginWater()
						}
						for(var i = 0; i < o.vsts.length; i++) {
							if(v['vast_nofirst' + o.vsts[i]] == 1) {
								localStorage.setItem("pljsfirst" + o.vsts[i], Date.now())
							}
						}
						if(v.pjsstat == 1 && v.pjsstatid) {
							PluginStat("start")
						}
						if(o.sbt) {
							o.sbt.start()
						}
						js("new");
						o.ctxtnk ? o.controls.upText(o.ctxtnk) : '';
						o.controls.startcss();
						o.controls.refresh();
						gaTracker("play", "Play");
						o.system.mobile ? MediaSess() : '';
						o.ab ? gaTracker("adblock", "AdBlock", 1) : ''
					} else {
						gaTracker("resume", "Resume")
					}
					if(v.fullonplay == 1 && !o.fullscreen) {
						var dd = new Date();
						var tt = dd.getTime();
						if(tt - o.clicktime < 300) {
							if(!o.system.ios && (v.fullonplaymobile != 1 || o.system.mobile)) {
								this.Fullscreen()
							}
						}
					}
					if(o.subtitle_on) {
						if(v.subpausehide == 1) {
							show2(o.subtitle)
						}
					}
					if(o.err404v) {
						o.err404v.remove()
					}
					if(noads != 1 && Advertising("preroll") || Advertising("intro")) {
						datetime(2)
					} else {
						if(v.redirect == 1 && exist(v.redirectonplay) && !exist(options.redirect)) {
							redirect(v.redirectonplay);
							stop = true
						}
						if(!stop) {
							log("Play");
							o.media.duration() > 0 ? o.controls.Duration(o.media.time(), o.media.duration()) : '';
							if(!o.start2) {
								o.start2 = true;
								if(v.toolbar.hideleavetimeout > 0 && v.autoplay == 1) {
									o.starttimeout = true;
									setTimeout(StartTimeout, v.toolbar.hideleavetimeout * 1000)
								}
							}
							var playroll = false;
							if(o.media.time() > 1 && v.pauserollonplay == 1 && noads != 1 && !isVastBgLoad() && !exist(o.vast) && !exist(o.vastloader)) {
								playroll = Advertising("pauseroll")
							}
							if(playroll) {
								isVastBgLoad() ? onPlay(false) : ''
							} else {
								onPlay(false)
							}
						}
					}
				}
			} else {
				o.media ? o.media.Play() : ''
			}
		};

		function StartTimeout() {
			o.starttimeout = false;
			o.controls.refresh()
		}
		this.Pause = function() {
			if(o.play) {
				o.actplay = false;
				log("Pause");
				o.media.Pause();
				o.controls.Pause();
				js("pause");
				v.posteronpause == 1 ? ShowPoster() : '';
				v.posterhidepause == 1 ? HidePoster2() : '';
				v.effects == 1 ? o.effects.api("pause") : '';
				if(o.subtitle_on) {
					if(v.subpausehide == 1) {
						hide2(o.subtitle)
					}
				}
				if(!exist(o.vast) && !exist(o.vastloader) && v.pauserollonplay == 0) {
					Advertising("pauseroll")
				}
				o.onplay = false
			}
		};
		this.Mute = function() {
			o.media.Mute();
			o.controls.Mute();
			o.muted = true;
			js("mute")
		};
		this.Unmute = function() {
			o.media.Unmute();
			o.muted = false;
			o.controls.Unmute();
			o.media.Volume(v.volume);
			js("unmute")
		};
		this.Volume = function(x, y) {
			if(o.controls) {
				x < 0.01 ? x = 0 : '';
				x > 1 ? x = 1 : '';
				if(x <= 0) {
					this.Mute();
					v.volume = 0;
					x = 0
				} else {
					if(o.muted) {
						this.Unmute()
					}
					v.volume = x
				}
				js("volume", x);
				o.controls.Volume(x, y);
				o.media.Volume(x)
			}
		};
		this.Waiting = function() {
			o.controls.Waiting()
		};
		this.StopWaiting = function() {
			o.controls ? o.controls.StopWaiting() : ''
		};
		this.Progress = function() {
			this.StopWaiting()
		};
		this.Seeked = function() {
			o.actions.UpdatePlay();
			this.StopWaiting()
		};
		this.Duration = function(time, duration) {
			if(o.continue && !o.start) {
				var f = o.continue.flag();
				if(f.t && f.d) {
					time = f.t
				}
			}
			o.controls ? o.controls.Duration(time, duration) : ''
		};
		this.LoadedData = function(time, duration) {
			if(exist(o.seekto) && o.file_type != "youtube" && !o.media.isLive()) {
				o.actions.Seek(o.seekto, false);
				o.seekto = undefined
			}
		};
		this.ScreenClick = function() {
			var d = new Date();
			o.clicktime = d.getTime();
			var x = false;
			if(o.controls.SettingsVisible() && v.settings.always != 1) {
				o.controls.SettingsClose();
				x = true
			}
			if(o.droplist) {
				if(o.droplist.Visible()) {
					o.droplist.Close();
					x = true
				}
			}
			if(v.playlist.always == 0) {
				if(o.controls.PlaylistVisible() && v.playlist.autohide == 1) {
					o.controls.Playlist();
					x = true
				}
			}
			if(v.redirect == 1 && exist(v.redirectonclick) && !exist(options.redirect)) {
				redirect(v.redirectonclick);
				x = true
			}
			if(o.muted && v.unmuteonclick == 1) {
				o.actions.Unmute();
				v.unmuteonclick = 0;
				x = true
			}
			if(!x) {
				if(v.hotkey.on == 1 && v.hotkey.icons == 1 && v.hotkey.playiconbut == 1) {
					PluginHotIcon('play', (o.play ? 0 : 1))
				}
				this.Toggle()
			}
		};
		this.ControlsBgClick = function() {
			if(o.controls.SettingsVisible()) {
				o.controls.Settings()
			}
		};
		this.Toggle = function() {
			if(o.media.status() == "playing") {
				v.scrnstp == 1 ? this.StopMedia() : this.Pause()
			} else {
				this.Play()
			}
			Sub()
		};
		this.Seek = function(sec, hand) {
			if(sec < o.media.duration()) {
				if(v.control_line.dontseekforward == 1) {
					if(sec > o.media.time()) {
						return
					}
				}
				if(v.delete > 0) {
					sec < v.delete ? sec = v.delete : ''
				}
				o.seeked_time = sec;
				o.media.Seek(sec);
				if(hand) {
					o.controls.Seek(sec, o.media.duration())
				}
				o.seeking = true;
				o.seeking_time = o.media.time();
				Sub(o.seeking_time)
			}
		};
		this.Open = function(url, target, endfull) {
			if(o.media.status() == "playing" && o.mode != 'audio') {
				Pause();
				if(o.fullscreen && endfull) {
					o.actions.Normalscreen()
				}
			}
			window.open(url, target)
		};
		this.Download = function() {
			if(v.vast == 1 && !o.start) {
				if(Advertising("preroll")) {
					o.vstdwn = true;
					return
				}
			}
			var x = o.media.currentFile();
			if(exist(v.download)) {
				x = v.download
			}
			if(x != '') {
				js("download");
				var win = window.open(x, (v.downself == 1 ? '_self' : '_blank'));
				win.focus()
			}
		};
		this.UpdatePlay = function(x) {
			var time = o.media.time();
			var duration = o.media.duration();
			o.controls.Played(time, duration, x)
		};
		this.Playing = function() {
			var time = o.media.time();
			var duration = o.media.duration();
			var delta = duration > 0 ? time / duration : 0;
			if(!o.seeking) {
				o.controls ? o.controls.Played((o.seekto > 0 ? o.seekto : time), duration) : ''
			} else {
				time != o.seeking_time && o.seeking_time != -9 ? o.seeking = false : ''
			}
			if((v.ga == 1 || v.yamtr == 1) && duration > 0) {
				gaTrackPlay("play25", "Play 25%", delta, 0.25);
				gaTrackPlay("play50", "Play 50%", delta, 0.50);
				gaTrackPlay("play75", "Play 75%", delta, 0.75)
			}
			for(var i = 0; i < 3; i++) {
				if(!o.quartile[i]) {
					if(delta >= i * 0.25 + 0.25) {
						Quartile(i)
					}
				}
			}
			v.reloadlog == 1 ? log(1, time, duration) : '';
			if(v.reload == 1 || v.fileorto > 0) {
				if(o.play) {
					var z = false;
					var rld = false;
					if(v.reloadlive == 1 && v.reload == 1) {
						if(!o.media.isLive()) {
							z = true
						}
					}
					if(time > 0) {
						if(time == o.time && !z) {
							rld = true
						} else {
							o.reloadTimer = 0
						}
						o.time = time
					} else {
						if(v.reloadstart == 1) {
							var ld = o.media.loaded();
							v.reloadlog == 1 ? log(2, ld, o.timeld) : '';
							if(!z) {
								if(ld == o.timeld) {
									rld = true
								} else {
									o.reloadTimer = 0
								}
							}
							o.timeld = ld
						}
					}
					if(rld) {
						o.reloadTimer++;
						if(v.reload == 1) {
							v.reloadlog == 1 ? log(3, o.reloadTimer) : '';
							if(o.reloadTimer == v.reloadtimeout * (1000 / o.timerTime)) {
								o.actions.Reload()
							}
						} else if(v.fileorto > 0 && o.media.urlsl() > 1) {
							if(o.reloadTimer == v.fileorto * (1000 / o.timerTime)) {
								o.media.onError('OR timeout')
							}
						}
					}
				}
			}
			if(v.apiprm) {
				if(v.apiprm.pld == 1 && duration > 0) {
					!o.pld ? o.pld = [] : '';
					o.pld[Math.round(time)] = 1
				}
			}
			if(v.vast == 1) {
				if(v.nomidroll != 1 && v.midrolls == 1) {
					!exist(o.vast) ? MidrollOverlay("midroll", time, duration) : ''
				}
				if(v.nooverlay != 1 && v.overlays == 1) {
					!exist(o.vast) ? MidrollOverlay("overlay", time, duration) : ''
				}
			}
			if(v.intros == 1 && v.introstart > 0) {
				if(time >= v.introstart) {
					if(!exist(o.vast)) {
						if(Advertising("intro")) {
							o.media.Pause();
							o.controls.Pause()
						}
						v.introstart = 0
					}
				}
			}
			SettingsTimers("play");
			if(v.pass == 1 && v.passontime > -1) {
				PasswordTime(time, duration)
			}
			if(o.subtitle_on) {
				Sub(time)
			}
			if(o.storage && v.timestore == 1) {
				if(o.continue) {
					!o.seekto ? o.continue.write(time, duration) : ''
				}
			}
			if(o.cutted) {
				o.cut ? o.cut.play(time) : ''
			}
			if(exist(v.end)) {
				var ed = v.end;
				if(indOf([v.end], '-')) {
					ed = duration
				}
				if(ed > 0 && time > ed) {
					if(o.file_type == "youtube") {
						o.media.Pause();
						o.media.Seek(v.start > 0 ? v.start : 0)
					} else {
						o.media.Recover();
						o.actions.Stop()
					}
					v.start > 0 ? o.seekto = v.start : '';
					o.actions.Ended()
				}
			}
			if(exist(v.remove)) {
				var r1 = v.remove.split(",");
				for(var i = 0; i < r1.length; i++) {
					var r2 = r1[i].split("-");
					if(r2.length == 2) {
						if(time > r2[0] && time < r2[1]) {
							o.media.Seek(r2[1] * 1 + (o.system.safari ? 1 : 0))
						}
					}
				}
			}
			if(v.tracking == 1) {
				if(typeof PluginTrack !== "undefined") {
					PluginTrack(time, delta)
				}
			}
		};

		function Quartile(x) {
			o.quartile[x] = true;
			if(v.timestore == 1 && v.playedstore == 1 && v.playedquartile == x) {
				if(o.storage && o.plid) {
					o.continue ? o.continue.writePl(o.plid) : ''
				}
			}
		}

		function gaTrackPlay(x, y, t, p) {
			if(!exist(o.gatracked[y])) {
				if(t > p) {
					gaTracker(x, y, 1)
				}
			}
		};
		this.Reload = function() {
			o.reloadTimer = 0;
			exist(o.reloadto) ? clearTimeout(o.reloadto) : '';
			if(v.reloadjustevent == 1) {
				js("reload")
			} else {
				o.seekto > 0 || o.media.isLive() ? '' : o.seekto = o.media.time() + (v.reloadplus > 0 ? 1 : 0);
				var openpl = o.controls.PlaylistVisible();
				js("reload");
				o.media.reload();
				openpl && v.playlist.autohide == 1 ? o.controls.PlaylistShow() : ''
			}
		};
		this.Stopped = function() {
			o.controls.Played(0, 0);
			o.controls.Loaded(0, 0);
			o.actions.Duration(0, 0);
			o.controls.StopWaiting()
		};
		this.Loading = function() {
			if(o.media) {
				var time = o.media.loaded();
				if(v.pjsiframed == 1) {
					js("loaded", time)
				}
				var duration = o.media.duration();
				o.controls ? o.controls.Loaded(time, duration) : ''
			}
		};
		this.Ended = function() {
			js("fileend");
			o.ended = true;
			if(v.loop == 1) {
				if(o.file_type == "youtube") {
					this.Stop()
				}
				v.vast == 1 ? o.actions.VastRecover('preroll') : '';
				if(v.start > 0) {
					o.actions.Seek(v.start)
				}
				this.Play()
			} else {
				if(o.media.isLive() || o.file_type == "youtube") {
					this.Stop()
				} else {
					if(v.finishrewind == 1) {
						o.actions.Seek((v.start > 0 ? v.start : 0), true);
						if(o.system.ie) {
							o.media.Pause()
						}
					}
				}
				o.controls.onEnded();
				v.intros == 1 ? v.outros = 1 : '';
				if(Advertising("postroll") || Advertising("outro")) {} else {
					End()
				}
			}
		};
		this.Fullscreen = function() {
			var stop = false;
			var error = false;
			o.fs_error = false;
			o.fullscreen_process = true;
			setTimeout(function() {
				o.fullscreen_process = false
			}, 3000);
			for(var x in o.motions) {
				if(o.motions.hasOwnProperty(x)) {
					if(exist(o.motions[x])) {
						try {
							o.motions[x].TheEnd2()
						} catch(e) {}
					}
				}
			}
			try {
				o.fullscreen_start = true;
				if(((o.system.ios && v.nativefullios == 1) || (o.system.android && v.nativefulldroid == 1)) && o.tagvideo && !o.nativecontrols) {
					var x = o.media.tag();
					if(x) {
						if(x.webkitSupportsFullscreen) {
							NativeEnterFs();
							stop = true
						}
					}
				}
				if(!stop) {
					var fspr;
					var y = o.frame;
					if((o.file_type == "dm" || o.file_type == "vimeo") && o.system.iphone && v.nativefullios == 1) {
						o.media.iosfull();
						return
					}
					if(y.requestFullscreen) {
						o.realfullscreen = true;
						fspr = y.requestFullscreen({
							navigationUI: "hide"
						});
						if(fspr !== undefined) {
							fspr.then(function() {}).catch(function(error) {})
						}
					} else if(y.requestFullScreen) {
						y.requestFullScreen({
							navigationUI: "hide"
						});
						o.realfullscreen = true
					} else if(o.frame.mozRequestFullScreen) {
						y.mozRequestFullScreen({
							navigationUI: "hide"
						});
						o.realfullscreen = true
					} else if(y.webkitRequestFullScreen) {
						y.webkitRequestFullScreen({
							navigationUI: "hide"
						});
						o.realfullscreen = true
					} else if(y.msRequestFullscreen) {
						y.msRequestFullscreen();
						o.realfullscreen = true
					}
				}
			} catch(e) {
				error = true;
				log(e)
			}
			if(!o.realfullscreen && !stop) {
				if(o.system.webkit && o.iniframe) {
					NativeEnterFs()
				} else {
					this.FullscreenUI()
				}
			}
			if(!error) {
				setTimeout(PostFullscreen, 200)
			}
		};

		function NativeEnterFs() {
			var x = o.media.tag();
			if(x) {
				o.nativefull = true;
				o.media.nativeSubtitle();
				x.webkitEnterFullScreen();
				x.addEventListener("webkitendfullscreen", iosExitFullscreen)
			}
		}

		function NativeExitFs() {
			var x = o.media.tag();
			if(x) {
				x.webkitExitFullscreen()
			}
		};
		this.NativeEnterFs = function() {
			NativeEnterFs()
		};
		this.NativeExitFs = function() {
			NativeExitFs()
		};

		function PostFullscreen() {
			if(o.fs_error != true) {
				if(o.ispipkit) {
					o.media.PipWebkit()
				}
				if(v.hotkey.volumewheelfull == 1) {
					VolumeWheelX(true);
					o.volumewheel = true
				}
				v.effects == 1 ? o.effects.api("full") : '';
				js("fullscreen");
				gaTracker("full", "Fullscreen", 1)
			}
		};
		var volumewheelin;
		var lastwheel = {
			x: 0,
			y: 0
		};

		function VolumeWheel(e) {
			if(o.droplist) {
				if(o.droplist.OpenScroll()) {
					return
				}
			}
			if(e.wheelDelta != 0) {
				e.deltaX != 0 ? lastwheel.x++ : lastwheel.x--;
				e.deltaY != 0 ? lastwheel.y++ : lastwheel.y--;
				if((v.hotkey.whlskfll == 1 || v.hotkey.scrollwheelfull == 1) && o.fullscreen && lastwheel.y > lastwheel.x) {
					clearInterval(volumewheelin);
					volumewheelin = setInterval(function() {
						lastwheel = {
							x: 0,
							y: 0
						};
						clearInterval(volumewheelin)
					}, 1000)
				} else {
					o.hidden_volume_over = true;
					clearInterval(volumewheelin);
					volumewheelin = setInterval(function() {
						o.hidden_volume_over = false;
						o.controls.resize();
						lastwheel = {
							x: 0,
							y: 0
						};
						clearInterval(volumewheelin)
					}, 2000);
					o.controls.resize()
				}
				if(lastwheel.x > lastwheel.y) {
					if(e.deltaX > 0) {
						o.actions.Volume(parseFloat(v.volume) - v.hotkey.wheelstep / 10, "no")
					} else {
						o.actions.Volume(parseFloat(v.volume) + v.hotkey.wheelstep / 10, "no")
					}
				} else {
					var st = (o.system.win ? -v.hotkey.wheelstep / 10 : v.hotkey.wheelstep / 10);
					if(v.hotkey.scrollwheelfull == 1 && o.fullscreen) {
						o.media.scale((e.deltaY > 0 ? st : -st))
					} else if(v.hotkey.whlskfll == 1 && o.fullscreen) {
						apiProcessor("seek", (e.deltaY > 0 ? "+" + st * 10 : "-" + st * 10))
					} else {
						o.actions.Volume(parseFloat(v.volume) + (e.deltaY > 0 ? st : -st), "no");
						o.controls.volumescroll()
					}
				}
			}
		}

		function iosExitFullscreen() {
			if(o.system.ios) {
				o.media.removeNativeSubtitle();
				js("exitfullscreen")
			}
			o.nativefull = false
		}
		this.FullscreenUI = function() {
			if(o.fullscreen_start) {
				o.fullscreen = true;
				o.controls.Fullscreen();
				if(!o.realfullscreen) {
					if(exist(o.parentIframe)) {
						try {
							css(o.parentIframe, {
								'width': '100%',
								'height': '100%',
								'position': 'fixed',
								'left': 0,
								'top': 0,
								'zIndex': "100000"
							})
						} catch(err) {}
					}
					css(o.frame, {
						'width': '100%',
						'height': '100%',
						'position': 'fixed',
						'left': 0,
						'top': 0,
						'zIndex': "100000"
					});
					o.screen_w = o.frame.offsetWidth;
					o.screen_h = o.frame.offsetHeight;
					try {
						document.body.style.overflow = 'hidden';
						if(!exist(o.playlist)) {
							document.ontouchmove = function(e) {
								e.preventDefault()
							}
						}
					} catch(err) {}
				}
				if(v.fullblack == 1) {
					css(o.frame, {
						'backgroundColor': '#000000'
					})
				}
				if(v.fzoom == 1 && o.system.webkit == 1) {
					var sw = window.screen.width;
					var fz = 1;
					for(var i = 1; i < 6; i++) {
						if(sw > 1000 * i) {
							fz = existv(v['fzoom' + (1000 * i)], i)
						}
					}
					if(fz > 1) {
						o.frame.style.zoom = fz;
						o.fzoom = fz
					}
				}
				if(o.droplist) {
					o.droplist.Close()
				}
				Sub();
				o.fullscreen_start = false
			}
		};
		this.Normalscreen = function() {
			_fullscreen_end = true;
			if(document.cancelFullScreen) {
				document.cancelFullScreen()
			} else if(document.exitFullscreen) {
				document.exitFullscreen()
			} else if(document.cancelFullscreen) {
				document.cancelFullscreen()
			} else if(document.mozCancelFullScreen) {
				document.mozCancelFullScreen()
			} else if(document.webkitCancelFullScreen) {
				document.webkitCancelFullScreen()
			} else if(document.msExitFullscreen) {
				document.msExitFullscreen()
			}
			if(!o.realfullscreen) {
				this.NormalscreenUI(false)
			}
		};
		this.changeAspect = function(x, y) {
			NewAspect(x, y)
		};

		function NewAspect(x, frmvst) {
			if(exist(o.vast) && !frmvst) {
				o.resizeonplay = x
			} else {
				var stop = false;
				var coh = o.container_w / x;
				var cow = 0;
				var nhs = {
					'height': coh
				};
				if(v.chngwd == 1) {
					if(coh > o.container_h) {
						coh = o.container_h;
						cow = o.container_w / x;
						o.container_w = nhs['width'] = cow
					}
				}
				if(exist(o.parentIframe) && v.notframe != 1) {
					try {
						css(o.parentIframe, nhs)
					} catch(err) {
						stop = true;
						log("iframe crossdomain issue")
					}
				}
				if(!stop) {
					o.aspect = x;
					o.container_h = coh;
					if(o.aspect > 0) {
						css(o.container, nhs)
					}
					if(cow > 0) {
						js("width", cow)
					}
					js("height", coh)
				}
				if(o.vast && !o.fullscreen) {
					o.screen_h = coh;
					if(cow > 0) {
						o.screen_w = cow
					}
					o.vast.Resize()
				}
			}
		};
		this.NormalscreenUI = function(x) {
			if(_fullscreen_end || x) {
				o.fullscreen = false;
				o.nativefull = false;
				if(!o.realfullscreen) {
					if(exist(o.parentIframe)) {
						try {
							css(o.parentIframe, {
								'position': 'static',
								'left': 0,
								'top': 0,
								'zIndex': 'unset'
							});
							css(o.parentIframe, o.parentIframe_style);
							css(o.parentIframe, {
								'width': o.normal_w,
								'height': o.normal_h
							})
						} catch(err) {}
					}
					css(o.frame, {
						'width': o.normal_w,
						'height': o.normal_h,
						'position': 'absolute',
						'left': 0,
						'top': 0,
						'zIndex': 'unset'
					});
					try {
						document.body.style.overflow = 'auto';
						document.ontouchmove = function(e) {
							return true
						}
					} catch(err) {}
				}
				o.controls.Normalscreen();
				if(v.fullblack == 1) {
					css(o.frame, {
						'backgroundColor': v.screencolor
					});
					if(v.transparent == 1) {
						o.frame.style.backgroundColor = 'transparent'
					} else {
						css(o.frame, {
							'backgroundColor': v.screencolor
						})
					}
				}
				if(o.fzoom > 1) {
					o.frame.style.zoom = 1;
					o.fzoom = 1
				}
				if(v.hotkey.volumewheelfull == 1) {
					VolumeWheelX(false);
					o.volumewheel = false
				}
				if(o.droplist) {
					o.droplist.Close()
				}
				Sub();
				o.subdrag ? o.subdrag = false : '';
				o.controls.PlaylistHere();
				_fullscreen_end = false;
				js("exitfullscreen");
				o.realfullscreen = false;
				o.fullscreen_process = false
			}
		};
		this.volumewheel = function(x) {
			VolumeWheelX(x)
		};

		function VolumeWheelX(x) {
			lastwheel = {
				x: 0,
				y: 0
			};
			if(x) {
				window.addEventListener("wheel", VolumeWheel)
			} else {
				clearInterval(volumewheelin);
				window.removeEventListener("wheel", VolumeWheel)
			}
		}
		this.Stop = function() {
			v.preload = 0;
			o.controls.Pause();
			o.actions.Stopped();
			o.media.Volume(v.volume);
			if(o.controls.SettingsVisible()) {
				o.controls.Settings()
			}
			if(o.muted) {
				this.Mute()
			}
			if(exist(o.heartbeatInterval)) {
				clearInterval(o.heartbeatInterval);
				o.heartbeatInterval = null
			}
			Sub(0);
			log("stop");
			js("stop")
		};
		this.StopMedia = function() {
			v.preload = 0;
			v.autoplay = 0;
			o.media.Recover();
			o.actions.Stop()
		};
		this.SetQuality = function(x) {
			if(exist(o.current_quality)) {
				if(o.current_quality != x) {
					o.current_quality = x;
					if(v.qualitystore == 1) {
						o.default_quality = o.files_quality[x];
						if(o.storage) {
							localStorage.setItem("pljsquality", o.default_quality)
						}
					}
					o.media.SetQuality(x);
					js("quality", o.files_quality[x]);
					o.controls.QualityChanged(x)
				}
			}
		};
		this.AirplayChanged = function() {
			o.controls ? o.controls.AirplayChanged() : ''
		};
		this.SetAudioTrack = function(x) {
			if(exist(o.current_audiotrack)) {
				if(o.current_audiotrack != x) {
					o.current_audiotrack = x;
					if(v.trackstore == 1) {
						o.default_audio = v.default_audio = o.files_audiotrack[x];
						if(o.storage) {
							localStorage.setItem("pljstrack", o.default_audio)
						}
					}
					o.media.SetAudioTrack(x);
					js("audiotrack", x);
					o.controls.SettingChanged("audiotrack")
				}
			}
		};
		this.SetSpeed = function(x, z) {
			x == '0.0' ? x = 0.1 : '';
			var y = x;
			String(y).indexOf('.') > 0 ? z = 1 : '';
			y = y * 1;
			if(!z) {
				y = x == o.speed1 ? 1 : o.files_speed[x];
				o.current_speed = x
			}
			if(o.line_speed || z) {
				o.custom_speed = y;
				for(var i = 0; i < o.files_speed.length; i++) {
					if(y <= o.files_speed[i] * 1) {
						o.current_speed = i;
						break
					}
				}
			}
			if(o.storage && v.speedstore == 1) {
				localStorage.setItem("pljsspeed", y)
			}
			js("speed", y);
			o.media.SetSpeed(y);
			o.controls.SettingChanged("speed")
		};

		function Sub(x) {
			o.sbt ? o.sbt.show(exist(x) ? x : o.media.time()) : ''
		};
		this.RenewSubtitle = function() {
			if(o.sbt) {
				Sub();
				o.sbt.style()
			}
		};
		this.Subtitle = function(x) {
			if(typeof(PluginSub) == 'function') {
				!o.sbt ? o.sbt = new PluginSub() : '';
				o.sbt.check(x)
			}
		};
		var vast_and;
		var vast_or;
		var vast_type;
		var vasturl;

		function Advertising(x) {
			if(v["vast_" + x + "timebreak"] > 0 && o.storage) {
				var tb = localStorage.getItem("pljs" + x + "_" + o.d);
				if(tb) {
					var ct = new Date();
					o.clicktime = ct.getTime();
					var ct2 = (ct.getTime() - tb) / 3600000;
					if(ct2 < v["vast_" + x + "timebreak"]) {
						return false
					}
				}
			}
			if(v["vast_" + x + "timelimit"] > 0) {
				if(o.media.duration() > 0) {
					if(o.media.duration() < v["vast_" + x + "timelimit"] * 60) {
						if(v["vast_" + x + "timelimited"] > 0) {
							v["vast_" + x + "_" + "andlimit"] = v["vast_" + x + "timelimited"]
						} else {
							return false
						}
					}
				}
			}
			if(o.compilations.indexOf("VAST") != -1 && v.vast == 1 && !o.noads && v[x + 's'] == 1) {
				if(typeof VastVideo == "undefined") {
					return false
				}
				if(x == "intro" || x == "outro") {
					if(typeof PluginIntro !== "undefined") {
						vasturl = [];
						return PluginIntro(x)
					}
				}
				if(exist(o.vast) || exist(o.vastloader)) {
					if(!isVisible(o.vastcontainer) || isVastBgLoad(o.vasttype)) {
						log('ad bg');
						return false
					} else {
						log('ad now');
						return true
					}
				} else {
					if(exist(v[x])) {
						if(v[x].toString().indexOf(".") > -1 || v[x].toString().indexOf(":") > -1 || v[x].toString().indexOf("[yandex]") > -1) {
							js("vast_init", x);
							if(!isVastBgLoad(x) && x != "overlay") {
								setTimeout(function() {
									o.play || (o.vastloader == null && o.vast == null) ? '' : o.actions.Waiting()
								}, 10);
								Curtain()
							}
							vast_and = 0;
							vast_or = 0;
							vast_type = x;
							vasturl = v[x].split(" and ");
							o.vast_loaders = [];
							o.adsinchain = vasturl.length;
							VastAndLimit();
							o.adscounter = 1;
							o.adsfirst = true;
							for(var i = 0; i < vasturl.length; i++) {
								vasturl[i] = vasturl[i].split(" or ")
							}
							v[x.concat("_", "recover")] = v[x];
							v[x] = null;
							o.vasttype = x;
							if(x != 'overlay') {
								o.vast = new VastVideo()
							}
							o.vastloader = new VastLoader();
							for(var i = 0; i < vasturl.length; i++) {
								for(var j = 0; j < vasturl[i].length; j++) {
									var _url = trim(vasturl[i][j]);
									if(_url.indexOf("[50%]") > 0) {
										var tmp = random(1, 2);
										vasturl[i][j] = vasturl[i][j].replace("[50%]", "");
										if(tmp == 2) {
											vasturl[i][j] = ''
										}
									}
								}
							}
							if(v.vast_preload == 1) {
								for(var i = 0; i < vasturl.length; i++) {
									var n = i == 0 ? 1 : 0;
									if(vasturl[i].length > n) {
										for(var j = n; j < vasturl[i].length; j++) {
											var _url = trim(vasturl[i][j]);
											if(o.system.ie9) {
												VastAddPreload(_url)
											} else {
												setTimeout(VastAddPreload, i * 100, _url)
											}
										}
									}
								}
							}
							if(vasturl[0][0] == '') {
								VastNext()
							} else {
								o.vastloader.Load(trim(vasturl[0][0]), x)
							}
							return true
						} else {
							return false
						}
					} else {
						return false
					}
				}
			} else {
				return false
			}
		};
		this.advertising = function(x) {
			Advertising(x)
		};

		function MidrollOverlay(w, x, d) {
			if(exist(o[w + 'o']) && v[w + 's'] == 1) {
				var y;
				for(var i in o[w + 'o']) {
					if(o[w + 'o'].hasOwnProperty(i)) {
						if(!exist(o[w + 'o'][i].worked) && exist(o[w + 'o'][i].time) && exist(o[w + 'o'][i].vast)) {
							var z = o[w + 'o'][i].time.toString();
							var ok = false;
							if(z) {
								if(x == "metadata") {
									if(z == x) {
										ok = true
									}
								} else {
									if(z.indexOf("%") > 0) {
										if(d > 0) {
											z = parseInt(z.substr(0, z.indexOf("%"))) * d / 100
										} else {
											z = -1
										}
									} else {
										z = parseInt(z)
									}
									if(x >= z) {
										if(v['vast_' + w + 'rest'] > 0 && z > -1) {
											if(x - z >= v['vast_' + w + 'rest']) {
												z = -1
											}
										}
										if(z > -1) {
											ok = true
										}
									}
								}
								if(o[w + 'o'][i].minduration && o.media.duration() > 0) {
									if(o.media.duration() < o[w + 'o'][i].minduration * 1) {
										o[w + 'o'][i].worked = true;
										ok = false
									}
								}
								if(ok) {
									y = o[w + 'o'][i].vast;
									v[w] = o[w + 'o'][i].vast;
									o[w + 'crtm'] = o[w + 'o'][i].time;
									o[w + 'skipimprsd'] = o[w + 'o'][i].skipimpessed;
									if(Advertising(w)) {
										o[w + 'o'][i].worked = true;
										break
									}
								}
							}
						}
					}
				}
			}
		};

		function VastBgLoad() {
			if(isVastBgLoad()) {
				if(o.vast_impressions == 0 || v['vast_' + o.vasttype + 'bgload2'] == 1) {
					css(o.vastcontainer, {
						"opacity": 0,
						"visibility": "hidden",
						"top": 2000
					});
					log(o.vasttype + " hide");
					o.vasttype == 'midroll' ? o.media.Play() : ''
				}
			}
		}

		function isVastBgLoad(z) {
			var y = false;
			var x = ['midroll', 'pauseroll'];
			for(var i = 0; i < x.length; i++) {
				if(o.vasttype == x[i] || z == x[i]) {
					if(v['vast_' + x[i] + 'bgload'] == 1) {
						y = true
					}
				}
			}
			return y
		};
		this.isVastBgLoad = function(x) {
			return isVastBgLoad(x)
		};
		this.VastImpression = function(x) {
			x ? '' : VastVisible();
			o.vasttype == "midroll" ? o.midrollimprsd.push(o.current_vast_url) : ''
		};
		this.VpaidStarted = function() {
			VastVisible()
		};
		this.VastShow = function() {
			VastVisible()
		};

		function VastVisible() {
			if(isVastBgLoad()) {
				if(o.play) {
					o.media.Pause();
					o.controls.Pause()
				}
				log(o.vasttype + " show");
				css(o.vastcontainer, {
					"opacity": 1,
					"visibility": "visible",
					"top": 0
				});
				o.vastfrombg = 1
			}
			if(o.nativefull && !o.realfullscreen) {
				NativeExitFs()
			} else {
				if(v["vast_" + o.vasttype + "normal"] == 1 && o.fullscreen) {
					o.actions.Normalscreen()
				}
			}
		};
		this.VastReady = function(x) {
			o.vastloader = null;
			o.vastfrombg = 0;
			log("VAST ready", o.vasttype);
			js("vast_ready", o.vasttype);
			if(x.type == "overlay") {
				var ovr = new VastOverlay(x);
				o.overlays.push(ovr)
			} else {
				if(exist(o.vast)) {
					if(v.preload == 0 && v.vastbgpreload == 1 && o.media.time() == 0 && o.media.duration() == 0) {
						v.preload = 1;
						o.media.Preload()
					}
					if((!o.vast.tagLive() || x.isVpaid) && o.vastgo > 0) {
						log("VAST renew");
						o.vast.Remove();
						o.vast = null;
						o.vast = new VastVideo()
					}
					if(isVastBgLoad()) {
						VastBgLoad()
					} else {
						if(o.play) {
							o.media.Pause();
							o.controls.Pause()
						}
					}
					o.vastgo++;
					if(o.adsfirst && v.vast_longtimeout > 0) {
						clearTimeout(o.vast_longtimeout);
						o.vast_longtimeout = setTimeout(VastLongTimeout, v.vast_longtimeout * 1000 * 60);
						if(exist(v.vast_longtimemsg)) {
							if(v.vast_longtimemsg != '') {
								o.vast_longtomsg ? o.vast_longtomsg.remove() : '';
								o.vast_longtomsg = new PluginVastTimeMsg()
							}
						}
					}
					o.adsfirst = false;
					if(v.vast_prestarttimeout > 0) {
						log("VAST startdelay");
						js("vast_startdelay");
						setTimeout(VastGo, v.vast_prestarttimeout * 1000, x)
					} else {
						VastGo(x)
					}
				} else {
					log("VAST alarm")
				}
			}
		};

		function VastGo(x) {
			o.vast.Go(x)
		}

		function VastLongTimeout() {
			if(exist(o.vast)) {
				if(o.vast.active() && o.vast_impressions == 0) {
					o.vast.RemoveForNextAd();
					log("VAST timeout " + v.vast_longtimeout);
					vasturl = [];
					VastRemoveAndPlay()
				}
			}
		}
		this.VastError = function() {
			js('vast_error', o.vasttype);
			log("VAST error");
			VastCheckNext()
		};
		this.VastNext = function() {
			VastCheckNext()
		};

		function VastCheckNext() {
			var n = VastAndLimit();
			log("VAST next " + !n);
			!n ? VastNext() : VastRemoveAndPlay()
		};
		this.VastRemoveUrl = function(x) {
			if(v[o.vasttype + "_recover"]) {
				for(var i = 0; i < 3; i++) {
					v[o.vasttype + "_recover"] = v[o.vasttype + "_recover"].replace(x + (i == 0 ? ' and ' : (i == 1 ? ' or ' : '')), '')
				}
			}
		};

		function VastAndLimit() {
			var x = false;
			if(o.vasttype) {
				var val = v['vast_' + o.vasttype + '_' + 'andlimit'];
				var va2l = v['vast_' + o.vasttype + '_' + 'and2limit'];
				if(va2l || val) {
					if(va2l > 0 && o.vast_starts > 0) {
						o.adsinchain = va2l;
						if(o.vast_impressions >= va2l) {
							x = true
						}
					} else {
						if(val > 0) {
							o.adsinchain = val;
							if(o.vast_impressions >= val) {
								x = true
							}
						}
					}
				}
			}
			return x
		}

		function VastNext() {
			if(vasturl.length > 0 && vasturl[vast_and]) {
				if(vast_or < vasturl[vast_and].length - 1) {
					log("VAST Next");
					o.vast ? o.vast.RemoveForNextAd() : '';
					VastBgLoad();
					vast_or++;
					var _url = trim(vasturl[vast_and][vast_or]);
					var _preloaded = VastPreloaded(_url);
					if(_preloaded == 'skip') {
						o.vastloader = new VastLoader();
						o.vastloader.Load(_url, o.vasttype)
					}
					if(_preloaded == 'error') {
						VastNext()
					}
				} else {
					VastRemoveAndPlay()
				}
			} else {
				VastRemoveAndPlay()
			}
		}

		function VastPreloaded(_url) {
			var x = 'skip';
			if(v.vast_preload == 1 && o.vast_loaders) {
				var find = false;
				var n = 0;
				for(var i = 0; i < o.vast_loaders.length; i++) {
					if(o.vast_loaders[i].done == 0) {
						if(o.vast_loaders[i].ldr.preloaded(_url)) {
							o.vast_loaders[i].done = 1;
							var y = o.vast_loaders[i].ldr.Status();
							if(y == 'ready') {
								o.vastloader = o.vast_loaders[i].ldr;
								log("VAST preloaded");
								o.vast_loaders[i].ldr.Ready();
								x = y
							} else {
								if(y == '') {
									x = 'ok';
									log("VAST preloading");
									o.vastloader = o.vast_loaders[i].ldr;
									o.vast_loaders[i].ldr.disablePreload()
								}
								if(y == 'error') {
									x = 'error'
								}
							}
							find = true
						}
						if(find && o.vast_loaders[i].load == 0) {
							n++;
							if(n < 6) {
								VastPreloadLoad(o.vast_loaders[i])
							} else {
								break
							}
						}
					}
				}
			}
			return x
		}
		this.VastInsertAnd = function(x, y) {
			if(x != '') {
				var z = vast_and;
				var moveOr2end = false;
				if(y) {
					for(var j = 0; j < vasturl.length; j++) {
						vasturl[j] == y ? z = j : ''
					}
				}
				if(vasturl.length == 1) {
					if(vasturl[0].length > 1 && vast_or < vasturl[0].length - 1 && vasturl[vast_or]) {
						var last_ors = vasturl[vast_or].slice(1, 99);
						vasturl[0].splice(vast_or + 1, 99);
						moveOr2end = true
					}
				}
				if(typeof(x) == "object") {
					for(var i = 0; i < x.length; i++) {
						vasturl.splice(z + i + 1, 0, [x[i]]);
						if(o.system.ie9) {
							VastAddPreload(x[i])
						} else {
							setTimeout(VastAddPreload, i * 100, x[i])
						}
					}
				} else {
					if(typeof(x) == "string") {
						vasturl.push([x]);
						VastAddPreload(x)
					}
				}
				if(moveOr2end) {
					vasturl[vasturl.length - 1] = vasturl[vasturl.length - 1].concat(last_ors)
				}
			}
		};
		this.VastInsertOr = function(x, y) {
			if(x != '') {
				var z = vast_and;
				if(y) {
					for(var j = 0; j < vasturl.length; j++) {
						vasturl[j] == y ? z = j : ''
					}
				}
				if(vasturl[z]) {
					if(typeof(x) == "object") {
						for(var i = 0; i < x.length; i++) {
							vasturl[z].push(x[i])
						}
					} else {
						if(typeof(x) == "string") {
							vasturl[z].push(x)
						}
					}
				}
			}
		};
		this.VastRemoveAndPlay = function(x) {
			VastRemoveAndPlay(x)
		};

		function VastAddPreload(x) {
			if(v.vast_preload == 1 && o.vast_loaders) {
				var i = 0;
				for(var i = 0; i < vasturl.length; i++) {
					if(vasturl[i] == x) {
						if(vast_and >= i) {
							return
						} else {}
					}
				}
				if(vasturl.length == 1 && vasturl[0].length > 1) {} else {
					var n = 0;
					for(i = 0; i < o.vast_loaders.length; i++) {
						o.vast_loaders[i].done == 0 ? n++ : ''
					}
					o.vast_loaders.push({
						load: 0,
						done: 0,
						x: trim(x),
						t: o.vasttype,
						ldr: new VastLoader(true)
					});
					n < 5 ? VastPreloadLoad(o.vast_loaders[o.vast_loaders.length - 1]) : ''
				}
			}
		}

		function VastPreloadLoad(x) {
			if(x) {
				x.load = 1;
				x.ldr.Load(x.x, x.t)
			}
		}

		function VastRemoveAndPlay(dontplay) {
			var stop = VastAndLimit();
			log("VAST remove (" + o.vast_impressions + ")");
			if(vasturl.length > 0 && vast_and == vasturl.length - 1) {
				if(vasturl[0][0].indexOf("js:") == 0) {
					vast_and = -1;
					vasturl = [
						[vasturl[0][0]]
					]
				}
			}
			if(o.vast_stop == 2) {
				stop = true
			}
			if(vasturl.length > vast_and + 1 && !stop) {
				o.vast.RemoveForNextAd();
				VastBgLoad();
				vast_and++;
				o.adscounter++;
				vast_or = 0;
				var _url = trim(vasturl[vast_and][0]);
				var _preloaded = VastPreloaded(_url);
				if(_preloaded == 'skip') {
					o.vastloader = new VastLoader();
					o.vastloader.Load(_url, vast_type)
				}
				if(_preloaded == 'error') {
					VastRemoveAndPlay(dontplay)
				}
			} else {
				RemoveCurtain();
				o.controls.StopWaiting();
				if(exist(o.vast)) {
					o.vast.Remove();
					o.vast = null
				}
				o.vastloader = null;
				vasturl = [];
				vast_or = 0;
				vast_and = 0;
				o.vastfrombg = 0;
				o.shwvstfnsh != 1 ? js("vast_finish", o.vasttype) : '';
				o.shwvstfnsh = 0;
				if(v.vast_ima == 1) {
					if(o.ima) {
						try {
							o.ima.Destroy()
						} catch(e) {
							log(o.ima, e)
						}
						o.ima = undefined
					}
				}
				vast_type = '';
				o.vast_impressions = 0;
				o.vpaid_starts = 0;
				clearTimeout(o.vast_longtimeout);
				clearInterval(o.vldcntrInterval);
				o.vast_longtomsg ? o.vast_longtomsg.remove() : '';
				o.vast_loadtxt ? o.vast_loadtxt.hide() : '';
				o.vast_starts++;
				if(o.vasttype == "preroll" || (o.vasttype == "pauseroll" && v.pauserollonplay == 1 && o.actplay) || o.vasttype == "midroll") {
					if(v.file != '?') {
						o.media.AfterVast();
						var re;
						if(o.vstdwn) {
							o.actions.Download();
							o.vstdwn = false;
							re = true
						}
						if(o.file_type == "youtube" && !o.vastclick && o.system.ios) {
							re = true;
							o.vasttype == "preroll" ? o.media.reYT() : ''
						}
						if(re || dontplay == 'dontplay' || v.vast_dontplay == 1) {} else {
							o.actions.Play(1)
						}
					}
				}
				if(o.resizeonplay > 0) {
					NewAspect(o.resizeonplay);
					o.resizeonplay = 0
				}
				if(o.vasttype == "postroll") {
					End()
				}
				o.vastclick = false;
				o.vasttype = null
			}
		};
		this.EmptyVastUrl = function() {
			vasturl = [
				['']
			]
		};
		this.VastRecover = function(y) {
			var x = ['preroll', 'pauseroll', 'postroll', 'intro', 'outro'];
			var z;
			for(var i = 0; i < x.length; i++) {
				z = false;
				if(y) {
					y != x[i] ? z = true : ''
				}
				if(!z && exist(v[x[i].concat("_", "recover")])) {
					v['vast_' + x[i].concat("_", "limit")]--;
					if(v['vast_' + x[i].concat("_", "limit")] > 0) {
						v[x[i]] = v[x[i].concat("_", "recover")];
						v[x[i].concat("_", "recover")] = null
					}
				}
			}
			if(y == "preroll" || y == "midroll") {
				if(v.vast_midroll_limit > 1) {
					if(exist(o.midrollo) && v.midrolls == 1) {
						for(var i in o.midrollo) {
							o.midrollo[i].worked = undefined
						}
						v.vast_midroll_limit--
					}
				}
			}
		};
		this.Password = function() {
			Curtain();
			if(exist(o.pass)) {
				o.pass.Remove();
				o.pass = null
			}
			o.pass = new Pass()
		};
		this.RemovePassword = function() {
			RemoveCurtain();
			o.pass.Remove();
			o.pass = null
		};
		this.Curtain = function() {
			Curtain()
		};
		this.RemoveCurtain = function() {
			RemoveCurtain()
		};

		function Curtain() {
			if(o.curtain) {} else {
				o.curtain = createElement("div");
				o.frame.appendChild(o.curtain);
				Pos0(o.curtain);
				css(o.curtain, {
					"background": "#000000",
					"opacity": 0.1
				});
				o.curtain.style.zIndex = 1001
			}
		};

		function RemoveCurtain() {
			if(o.curtain) {
				o.frame.removeChild(o.curtain);
				o.curtain = null
			}
		};

		function ShowPoster() {
			if(exist(o.poster)) {
				if(v.poster != o.currentposter) {
					Poster(v.poster, o.poster, v.poster_scale)
				}
				show(o.poster);
				css(o.poster, {
					"opacity": v.poster_a
				});
				o.controls.refresh();
				o.pstrv ? o.pstrv.play() : ''
			}
		};
		this.HidePoster = function() {
			if(exist(o.poster)) {
				if(isVisible(o.poster)) {
					clearInterval(o.pstrsin);
					var t = o.media.time();
					if(t == 0 && v.posterhidestart == 1) {} else {
						if(v.posterhidetime > 0) {
							clearTimeout(o.pstr_to);
							o.pstr_to = setTimeout(HidePoster2, v.posterhidetime * 1000)
						} else {
							HidePoster2()
						}
					}
				}
			}
		};

		function HidePoster2() {
			clearTimeout(o.pstr_to);
			if(v.posteronpause == 1 && !o.play) {} else {
				css(o.poster, {
					"opacity": 0
				});
				setTimeout(HidePoster3, 500)
			}
		}

		function HidePoster3() {
			if(!o.play && v.posterhide == 1) {} else {
				hide(o.poster);
				o.pstrv ? o.pstrv.pause() : ''
			}
		}
		this.ShowPoster = function() {
			ShowPoster()
		};

		function StopOtherPlayer(x) {
			if(v.stopotherplayers == 1) {
				for(var i = 0; i < pljssglobal.length; i++) {
					if(pljssglobal[i]) {
						if(pljssglobal[i].api("id") != v.id) {
							pljssglobal[i].api('pause')
						}
					}
				}
			}
			pljssglobalid = v.id
		}

		function IndexPlaylist(x) {
			var y = Object.keys(x).length;
			o.pldur = 0;
			if(y > 0) {
				x = IndexPlaylistProcessor(x, y, '', -1)
			}
			return x
		}

		function IndexPlaylistProcessor(x, y, p, j) {
			var x2 = [];
			var stop;
			if(exist(x['playlist'])) {
				x = x['playlist'];
				y = x.length
			}
			var ii = 0;
			for(var i = 0; i < y; i++) {
				stop = false;
				if(exist(x[i]['id'])) {
					x[i]['pjs_id'] = x[i]['id']
				}
				x[i]['id'] = "x" + p + '-' + i + (exist(x[i]['id']) ? '-' + x[i]['id'] : '');
				j == -1 && i == 0 && !exist(x[i]['folder']) ? o.pl_first_id = x[i]['id'] : '';
				if(!exist(o.pl_first_id)) {
					j == 0 && !exist(x[i]['folder']) ? o.pl_first_id = x[i]['id'] : ''
				}
				x[i]['pjs_parent'] = p;
				x[i]['pjs_parent_i'] = j;
				x[i]['pjs_i'] = ii;
				if(exist(x[i]['duration'])) {
					o.pldur += x[i]['duration']
				}
				if(!exist(x[i]['folder'])) {
					if(exist(x[i]['file'])) {
						if(x[i]['file'] == '' && !exist(x[i]['redirect'])) {
							stop = true
						}
					} else {
						stop = true
					}
				}
				if(!stop) {
					o.playlist_dic[x[i]['id']] = x[i];
					ii += 1
				}
				if(exist(x[i]['folder'])) {
					var z = Object.keys(x[i]['folder']).length;
					if(z > 0) {
						x[i]['folder'] = IndexPlaylistProcessor(x[i]['folder'], z, x[i]['id'], i)
					}
				}
				if(!stop) {
					x2.push(x[i])
				}
			}
			return x2
		}

		function FindFileInPlaylist() {
			var x = [];
			if(exist(v.plstart)) {
				if(v.plstart.indexOf("x-") != 0) {
					for(var y in o.playlist_dic) {
						if(o.playlist_dic.hasOwnProperty(y)) {
							if(o.playlist_dic[y].pjs_id == v.plstart) {
								v.plstart = y
							}
						}
					}
				}
				if(exist(o.playlist_dic[v.plstart])) {
					v.playlist.norootplstart == 1 ? v.playlist.openplaylistroot = 0 : '';
					x = o.playlist_dic[v.plstart]
				} else {
					x = o.playlist[0];
					if(v.plstart == o.plcontinue) {
						o.seekto = undefined
					}
				}
			} else {
				x = o.playlist[0]
			}
			if(x) {
				for(var i = 0; i < 10; i++) {
					if(exist(x['folder'])) {
						x = x['folder'][0]
					} else {
						break
					}
				}
				v.plstart = x.id;
				if(v.plstart == o.plcontinue) {
					x.start = undefined
				}
			}
			return x
		}

		function End() {
			gaTracker("end", "End", 1);
			o.actions.VastRecover();
			if(o.storage && v.timestore == 1) {
				o.continue.write(0, o.media.duration())
			}
			if(o.controls.PlaylistExist()) {
				if(v.playlist.autoplaylist == 1 && o.controls.PlaylistNextExist()) {
					if(exist(v.playlist.apto)) {
						o.plapto = setTimeout(function() {
							o.controls.PlaylistNext()
						}, v.playlist.apto * 1000)
					} else {
						o.controls.PlaylistNext()
					}
				} else {
					End2()
				}
			} else {
				if(v.finishnormal == 1 && o.fullscreen) {
					o.actions.Normalscreen()
				}
				End3()
			}
		}
		this.ShuffleEnd = function() {
			End2()
		};

		function End2() {
			if(v.playlist.playlistrewind == 1 && !o.controls.PlaylistNextExist()) {
				o.controls.PlaylistRewind();
				return
			}
			if(v.playlist.openplaylistafter == 1) {
				!o.controls.PlaylistVisible() ? o.controls.Playlist() : ''
			}
			End3()
		}

		function End3() {
			ShowPoster();
			js("finish");
			if(v.redirect == 1 && v.redirectafter == 1 && exist2(v.after)) {
				redirect(v.after)
			}
			if(v.suggestions) {
				if(typeof PluginSug !== "undefined") {
					!o.sug ? o.sug = new PluginSug() : ''
				}
			}
		}

		function fjs(x) {
			if(x.indexOf('js:') == 0) {
				try {
					x = eval(x.substr(3))
				} catch(e) {
					console.log(e.message)
				}
			}
			return x ? x : ''
		}

		function Heartbeat() {
			var vts = Math.floor(Date.now() / 1000);
			var fts = (exist(v.livets) ? v.livets : 0) + parseInt(o.media.time());
			var type = 0;
			o.system.desktop ? type = 1 : '';
			o.system.ios ? type = 2 : '';
			o.system.android ? type = 3 : '';
			o.system.winmob ? type = 4 : '';
			o.system.tv ? type = 5 : '';
			var url = v.heartbeat.replace("[vts]", vts);
			url = url.replace("[fts]", fts);
			url = url.replace("[dvtp]", type);
			var gif = document.createElement("img");
			gif.setAttribute('src', url);
			gif.setAttribute('height', '1px');
			gif.setAttribute('width', '1px');
			o.frame.appendChild(gif)
		}
	};
	var Media = function(url) {
		var url;
		var urls;
		var urls_and;
		var current_url;
		var _status = "";
		var _lastime = 0;
		var _ended = false;
		var _stopped = false;
		var _tags;
		var media;
		var media2;
		o.mediascale = {
			x: 1,
			y: 1,
			x0: 1,
			y0: 1
		};
		var wait;
		var plurls;
		var current_plurl = 0;
		var rldcnt = 0;
		var hlsend_to;
		if(typeof(url) == 'string') {
			url = trim(url);
			if(url.indexOf("[{") == 0) {
				try {
					url = url.replace(/pjs'qt/ig, '"');
					url = JSON.parse(url);
					wait ? url = o.actions.File(url) : ''
				} catch(e) {
					console.log(e);
					url = "incorrect JSON"
				}
			}
			if(url.indexOf("#" + v.enc2) == 0) {
				url = o[o.fd[0]](url)
			}
			if(url) {
				if(url.indexOf("#" + v.enc3) == 0 && url.indexOf(v.file3_separator) > 0) {
					url = o[o.fd[1]](url)
				}
			}
			if(url) {
				if(url.indexOf("#0") == 0) {
					if(url.indexOf(o.pltxt) > 0) {
						url = fd0(url.replace(o.pltxt, '')) + o.pltxt
					} else {
						url = fd0(url)
					}
				}
			}
			if(v.fplace == 1) {
				url = fplace(url)
			}
			if(typeof(url) == 'string') {
				if(url.indexOf(".m3u") == url.length - 4 || url.indexOf(".txt") > 0) {
					plurls = url.split(" or ");
					PlaylistLoad()
				}
			}
		}
		o.mediacontainer = createElement("div");
		Pos0(o.mediacontainer);
		css(o.mediacontainer, {
			"transition": "transform 0.2s linear",
			"text-align": "center"
		});
		o.frame.appendChild(o.mediacontainer);
		if(v.hotkey.swiping == 1) {
			if(!o.mdswp) {
				PluginMovable(o.mediacontainer, 'o.swiping', v.hotkey.swipev != 1, v.hotkey.swipev == 1, Swiping);
				o.mdswp = true
			}
		}
		if(!wait) {
			Start()
		}

		function Swiping() {
			var p = o.mediacontainer.offsetLeft;
			var p2 = o.screen_w;
			if(v.hotkey.swipev == 1) {
				p = o.mediacontainer.offsetTop;
				p2 = o.screen_h
			}
			var x;
			if(p > p2 * existv(v.hotkey.swipep, 0.5)) {
				if(o.controls.PlaylistPrevExist()) {
					x = true;
					o.controls.PlaylistPrev()
				}
			} else {
				if(p < -p2 * existv(v.hotkey.swipep, 0.5)) {
					if(o.controls.PlaylistNextExist()) {
						x = true;
						o.controls.PlaylistNext()
					}
				}
			}
			if(x) {
				if(v.hotkey.swipev == 1) {
					css(o.mediacontainer, {
						"top": 0
					})
				} else {
					css(o.mediacontainer, {
						"left": 0
					})
				}
			} else {
				new Motion({
					mc: o.mediacontainer,
					type: (v.hotkey.swipev == 1 ? "top" : "left"),
					to: 0,
					time: 0.1,
					ease: "back",
					me: "mdswp"
				})
			}
		}

		function PlaylistLoad() {
            console.log("LLOL");
			url = plurls[current_plurl];
			if(url.indexOf(o.pltxt) > 0) {
                
				url = url.replace(o.pltxt, '');
				v.file = url
                console.log(url)
			}
			var xhr = XHR(url);
			xhr.onload = function() {
				if(this.readyState == 4 && this.status == 200) {
					Playlist(this);
					o.controls.NewPl()
				} else {
					PlaylistError(1)
				}
			};
			xhr.onerror = function(e) {
				PlaylistError(1)
			};
			xhr.send();
			wait = true
		}

		function PlaylistError(x) {
			if(current_plurl + 1 < plurls.length) {
				current_plurl++;
				PlaylistLoad();
				x = 0
			}
			if(x == 1) {
				onError("playlist not found or access denied")
			}
			if(x == 2) {
				onError("playlists JSON")
			}
		}

		function Playlist(x) {
			if(x.responseText) {
				var y = x.responseText;
				if(y.indexOf("#" + v.enc2) == 0) {
					y = o[o.fd[0]](y)
				}
				if(y.indexOf("#" + v.enc3) == 0 && y.indexOf(v.file3_separator) > 0) {
					y = o[o.fd[1]](y)
				}
				if(url.indexOf(".m3u") == url.length - 4) {
					var m3u = y.split(/(\r\n\t|\n|\r\t)/gm);
					url = [];
					var m3ui = 1;
					var m3ut = '';
					for(var i = 0; i < m3u.length; i++) {
						if(m3u[i].indexOf("#EXTINF") > -1) {
							if(m3u[i].indexOf(" - ") > -1) {
								var tmp = m3u[i].split(" - ");
								m3ut = tmp[tmp.length - 1]
							}
						}
						if(m3u[i].indexOf("http") > -1) {
							url.push({
								title: "" + (m3ut != '' ? m3ut : m3ui),
								file: m3u[i]
							});
							m3ui++;
							m3ut = ''
						}
					}
				} else {
					y = y.replace(/(\r\n\t|\n|\r\t)/gm, "");
					try {
						url = JSON.parse(y)
					} catch(e) {
						PlaylistError(2)
					}
				}
				if(o.controls) {
					if(v.playlist.openplaylistbefore == 1) {
						o.controls.PlaylistShow(2)
					}
				}
				Start();
				MainResize();
				setTimeout(function() {
					js("playlist")
				}, 1)
			}
		}

		function Start() {
			url = o.actions.File(url);
			url && url != '?' ? File(url) : ''
		}

		function onError(x, norld) {
			log("Error: " + x);
			var y = true;
			var yy = true;
			js("loaderror", x);
			if(norld != 1 && v.reload == 1 && v.reloadfirst == 1) {
				ErrorReload();
				return
			}
			if(urls) {
				if(urls.length > 0) {
					current_url++;
					y = current_url > urls.length - 1;
					if(y && urls.length > 1 && v.or0 > 0) {
						if(o.or0 < v.or0) {
							current_url = 0;
							y = false
						}
						o.or0++
					}
					if(y && v.tryotherquality == 1) {
						if(o.files.length > 1) {
							if(o.files_quality[o.current_quality].indexOf(Lang("loading_error")) == -1) {
								o.files_quality[o.current_quality] = o.files_quality[o.current_quality] + ' (' + Lang("loading_error") + ')'
							}
							if(o.current_quality > 0) {
								yy = false;
								o.actions.SetQuality(o.current_quality - 1);
								FileTo()
							} else {
								if(o.files_quality[o.current_quality + 1].indexOf(Lang("loading_error")) == -1) {
									yy = false;
									o.actions.SetQuality(o.current_quality + 1);
									FileTo()
								}
							}
						}
					}
					if(!y) {
						var z = false;
						o.seekto > 0 || !o.start || media.isLive() ? '' : o.seekto = Time();
						if(o.file_type != FileType(urls[current_url]) || o.file_type != 'native') {
							if(o.play) {
								o.actions.Stop();
								z = true
							}
						}
						if(v.filerorto > 0) {
							clearTimeout(o.errorto);
							o.errorto = setTimeout(ErrorOr, v.filerorto * 1000)
						} else {
							ErrorOr()
						}
					} else {
						if(v.reload == 1 && yy && v.reloadfirst != 1) {
							y = false;
							ErrorReload()
						}
					}
				}
			}
			if(y && yy && x) {
				ErrorMsg(x, true)
			}
		};

		function ErrorOr() {
			log("Alternative source", o.seekto);
			File('or');
			o.start && !o.vast ? media.Play() : '';
			FileTo()
		}

		function ErrorMsg(x, mr) {
			gaTracker("error", "Error", true);
			if(v.alerts == 1 && !o.media_error) {
				if(v.alert404 == 1) {
					o.alert.txt(v.alert404text)
				} else {
					o.alert.txt(x)
				}
				if(v.alert404v == 1 && exist(v.alert404video)) {
					o.err404v = new PluginErrorVideo();
					o.actions.HidePoster()
				}
			}
			mr ? o.media_error = true : '';
			if(o.play) {
				o.actions.StopWaiting();
				o.controls.Pause()
			}
			exist(o.poster) && !exist(o.err404v) ? o.actions.ShowPoster() : '';
			js("error", x)
		}

		function ErrorReload() {
			rldcnt++;
			log("Error Reload Timeout " + rldcnt);
			o.play ? o.rldplay = 1 : '';
			exist(o.reloadto) ? clearTimeout(o.reloadto) : '';
			o.reloadto = setTimeout(ReloadTimeout, v.reloadtimeout * 1000)
		}

		function ReloadTimeout() {
			var x = existv(v.reloadtimes, 10);
			if(o.play || o.rldplay == 1) {
				o.rldplay = 0;
				if(rldcnt < x) {
					o.actions.Reload()
				} else {
					if(v.reloadfirst == 1) {
						onError(media.errorMessage(), 1)
					} else {
						ErrorMsg('Reload Error ' + media.errorMessage())
					}
				}
			}
		}
		this.onError = function(x) {
			onError(x ? x : media.errorMessage())
		};
		this.onEnded = function(y) {
			log("Ended");
			_ended = true;
			clearTimeout(hlsend_to);
			var x = false;
			if(Duration() > 0 && !o.casting && !y) {
				var time = o.current_time;
				if(time + 10 < Duration()) {
					log('Break (recovery)');
					js("recovery");
					media.Play();
					media.Seek(time);
					x = true
				}
			}
			if(!x) {
				o.actions.Ended();
				js("end")
			}
		};
		this.onPlay = function() {
			if(v.posterhidepause == 1) {
				exist(o.poster) ? o.actions.ShowPoster() : ''
			}
			v.posterhide == 1 ? o.actions.HidePoster() : '';
			o.controls.Play();
			o.actions.onPlayTag();
			if(v.tags == 1 && exist(v.tagsurl)) {
				if(v.tagsurl.length > 5) {
					RadioTags();
					clearInterval(_tags);
					_tags = setInterval(RadioTags, v.tagsinterval * 1000)
				}
			}
			js("play")
		};
		this.NativeControls = function() {
			if(v.nativecontrolsmobile == 1 && o.tagvideo) {
				if(o.actions.NativeControls()) {
					o.nativecontrols = media.nativeControls();
					o.controls.refresh();
					NativeSubtitle()
				}
			}
			o.checknative = true
		};
		this.onPause = function() {
			o.actions.Pause()
		};
		this.onSeeking = function() {
			log("Seeking")
		};
		this.onSeeked = function() {
			log("Seeked");
			o.actions.Seeked();
			exist(o.seeking_time) ? js("seek", o.seeking_time) : ''
		};
		this.onMeta = function() {
			log("Metadata");
			rldcnt = 0;
			o.actions.Metadata();
			o.file_type == "hls" ? StartSpeed(1) : ''
            
		};
		this.onDuration = function() {
			if(media) {
				log("Duration", Duration());
				o.actions.Duration(Time(), Duration());
				js("duration", Duration());
				rldcnt = 0;
				clearTimeout(o.reloadto);
				if(exist(o.restart_audio)) {
					o.actions.SetAudioTrack(o.restart_audio);
					o.restart_audio = null
				}
			}
		};

		function Time() {
			var x = media.time();
			return x
		}

		function Duration() {
			var x = media.duration();
			return x
		}
		this.onVolume = function() {};
		this.onWaiting = function() {
			log("Waiting");
			o.actions.Waiting();
			js("waiting")
		};
		this.onTimeupdate = function() {
			if(_lastime != Time()) {
				if(!o.curtain) {
					o.actions.StopWaiting();
					if(_lastime == 0) {
						if(v.posterhide == 1 && v.posterhidestart == 1) {
							o.actions.HidePoster()
						}
					}
				}
			}
			_lastime = Time();
			var dur = Duration();
			js("time", _lastime);
			if(v.pip.on == 1) {
				if(typeof(PluginPip) == 'function') {
					if(!media2 && v.pip.custom != 1 && v.file2 && v.file2 != '' && _lastime > 0) {
						o.mediapip = new PluginPip();
						media2 = o.mediapip.create()
					}
				}
			}
			if(o.file_type == "hls" && o.system.safari && dur > 0) {
				if(o.play && _lastime > dur - 1) {
					clearTimeout(hlsend_to);
					hlsend_to = setTimeout(ChkHlsEnd, 2000)
				}
			}
		};

		function ChkHlsEnd() {
			if(!_ended) {
				o.actions.Pause();
				o.media.onEnded()
			}
		}
		this.onYoutubeReady = function() {
			if(o.file_type == "youtube") {
				media ? media.YoutubeReady() : ''
			}
		};
		this.playByYoutubeId = function(x) {
			o.actions.Stop();
			media.playId(x)
		};
		this.YoutubeReady = function() {
			if(o.file_type == "youtube" && media) {
				return media.ready()
			} else {
				return true
			}
		};
		this.getHLS = function() {
			return media.getHLS()
		};
		this.getDASH = function() {
			return media.getDASH()
		};
		this.SetQuality = function(x) {
			log("Quality", x);
			if((o.file_type == "native" || o.file_type == o.ws || (o.file_type == "hls" && (v.hlsquality == 0 || HlsLevelsLength() < 2)) || (o.file_type == "dash" && (v.dashquality == 0 || DashLevelsLength() < 2))) && exist(o.files[x])) {
				var time = this.time();
				o.seekto > 0 ? '' : o.seekto = time;
				o.actions.Seek(time, false);
				File(o.files[x], true);
				var y = true;
				if(v.settings) {
					if((v.settings.qualitypause == 1 && !o.play) || !o.start) {
						y = false
					}
				}
				if(y) {
					o.actions.Play()
				}
			}
			if(o.file_type == "hls" && v.hlsquality == 1 && HlsLevelsLength() > 1) {
				media.setHlsQuality(x)
			} else if(o.file_type == "dash" && v.dashquality == 1 && DashLevelsLength() > 1) {
				media.setDashQuality(x)
			} else if(o.file_type == "youtube" || o.file_type == "dm") {
				media.setQuality(x)
			}
		};
		this.renameQualities = function(x, y) {
			return RenameQualities(x, y)
		};
		this.renameTracks = function(x, y) {
			return RenameTracks(x, y)
		};

		function RenameQualities(x, y) {
			var r = x.height + 'p';
			if(x.height < 200) {
				r = '160p'
			} else if(x.height >= 200 && x.height <= 300) {
				r = '240p'
			} else if(x.height > 300 && x.height <= 400) {
				r = '360p'
			} else if(x.height > 400 && x.height <= 500) {
				r = '480p'
			} else if(x.height > 500 && x.height <= 600) {
				r = '540p'
			} else if(x.height > 600 && x.height <= 900) {
				r = '720p'
			} else if(x.height > 900 && x.height <= 1200) {
				r = '1080p'
			} else if(x.height > 1200 && x.height <= 1800) {
				r = '1440p'
			} else if(x.height > 1800) {
				r = '2160p'
			}
			if(x.width == 426 && x.height <= 240) {
				r = '240p'
			} else if(x.width == 640 && x.height <= 360) {
				r = '360p'
			} else if(x.width == 854 && x.height <= 480) {
				r = '480p'
			} else if(x.width == 1280 && x.height <= 720) {
				r = '720p'
			} else if(x.width == 1920 && x.height <= 1080) {
				r = '1080p'
			} else if(x.width == 2560 && x.height <= 1440) {
				r = '1440p'
			} else if(x.width == 3840 && x.height <= 2160) {
				r = '2160p'
			}
			if(v.settings.customqualities == 1 && exist(v.settings['name' + r])) {
				r = v.settings['name' + r]
			} else {
				if(y == 1) {
					r = Lang(r)
				}
				if(y == 2 && exist(x.bitrate)) {
					r = parseInt(x.bitrate / 1000) + ' ' + Lang('kbps')
				}
			}
			return r
		};

		function RenameTracks(x, y) {
			var r = x.toLowerCase();
			if(r == "eng" || r == "en") {
				x = "English"
			} else if(r == "rus" || r == "ru") {
				x = "Р СѓСЃСЃРєРёР№"
			}
			if(typeof(v.rename_audio) == "object") {
				if(exist(v.rename_audio[x])) {
					x = v.rename_audio[x]
				} else {
					x = existv(v.rename_audio[y.toString()], x)
				}
			}
			return x
		};

		function NativeSubtitle() {
			if(o.tagvideo && o.subs && !o.nativesub) {
				media.removeTracks();
				for(var i = 0; i < o.subs.length; i++) {
					if(o.subs[i] != 'all') {
						media.addTrack(o.subs[i], o.files_subtitle[i], (i == o.current_subtitle))
					}
				}
				o.nativesub = true
			}
		}
		this.SetSpeed = function(x) {
			log("Speed", x);
			media ? media.setSpeed(x) : '';
			if(v.pip.on == 1) {
				if(media2) {
					media2.setSpeed(x)
				}
			}
		};
		this.nativeSubtitle = function() {
			NativeSubtitle()
		};
		this.removeNativeSubtitle = function() {
			media.removeTracks()
		};
		this.SetAudioTrack = function(x) {
			log("Audiotrack", x);
			if(o.audiotracks.length > 0) {
				if(o.audiotracks[x]) {
					var time = this.time();
					o.seekto > 0 ? '' : o.seekto = time;
					o.actions.Seek(time, false);
					File(o.audiotracks[x], true);
					o.actions.Play()
				}
			} else {
				if(o.file_type == "hls" && v.hlsaudio == 1) {
					media.setHlsAudioTrack(x)
				} else if(o.file_type == "dash" && v.dashaudio == 1) {
					media.setDashAudioTrack(x)
				}
			}
		};
		this.getQuality = function() {
			var x = o.files_quality[o.current_quality];
			x == undefined ? x = '' : '';
			var y = autoQuality() && v.hlsautoquality == 1 && v.hlsquality == 1 && x != Lang("auto");
			return(y ? '' + Lang("auto") + ' ' : '') + x
		};
		this.getAudioTrack = function() {
			var x = o.files_audiotrack[o.current_audiotrack];
			x == undefined ? x = '' : '';
			return x
		};
		this.autoQuality = function() {
			return autoQuality()
		};

		function autoQuality() {
			var x = false;
			if(media) {
				if(o.file_type == "youtube") {
					x = media.auto()
				}
				if(o.file_type == "hls" && v.hlsquality == 1 && HlsLevelsLength() > 1 && v.hlsautoquality == 1) {
					x = media.auto()
				}
				if(o.file_type == "dash" && v.dashquality == 1 && DashLevelsLength() > 1) {
					x = media.auto()
				}
			}
			return x
		}

		function HlsLevelsLength() {
			if(o.file_type == "hls") {
				return media.HlsLevelsLength()
			} else {
				return 0
			}
		}

		function DashLevelsLength() {
			if(o.file_type == "dash") {
				return media.DashLevelsLength()
			} else {
				return 0
			}
		};
		this.ratio = function() {
			return o.tagvideo ? media.ratio() : o.aspect
		};
		this.resize = function(x) {
			if(media && (o.file_type == "youtube" || o.file_type == "vimeo" || exist(v.ratio))) {
				media.resize()
			}
			if(v.screenmarginbottom > 0) {
				css(o.mediacontainer, {
					"height": (o.fullscreen ? "100%" : o.normal_h - v.screenmarginbottom)
				})
			}
			if(o.media2 && v.pip.movable == 1) {
				o.mediapip.resize()
			}
			if(v.poster_float == 1) {
				FloatPosterScale()
			}
			if(o.v360) {
				o.v360.resize()
			}
		};
		this.size = function() {
			return media ? media.size() : {}
		};
		this.iosfull = function() {
			media.iosfull()
		};
		this.reload = function() {
			log('reload');
			o.reloadTimer = 0;
			o.start ? v.autoplay = 1 : '';
			o.actions.Waiting();
			if(url && v.rldnornd != 1) {
				if(url.indexOf('(random)') == -1) {
					url = url + (url.indexOf('?') == -1 ? '?' : '&') + 'rand=(random)'
				}
			}
			if(url) {
				if(o.tagvideo) {
					media.src(url);
					this.Play()
				} else {
					File(url)
				}
			}
		};
		if(!exist(o.poster)) {
			CreatePoster()
		}
		if(exist(v.poster)) {
			if(v.poster != '') {
				Poster(v.poster, o.poster, v.poster_scale);
				if(v.posterhidepause == 1 && !o.start) {
					hide(o.poster)
				}
			} else {
				v.poster = null
			}
		}

		function Status() {
			_status = media ? media.status() : ''
		}

		function ParseUrl(url) {
			urls = url.split(" or ");
			for(var i = 0; i < urls.length; i++) {
				if(urls[i].indexOf(" and ") > -1) {
					urls_and = urls[i].split(" and ");
					urls[i] = urls_and[random(0, urls_and.length - 1)]
				}
				if(exist(v.prefile) && urls[i].indexOf("//") == -1) {
					urls[i] = v.prefile + urls[i]
				}
			}
			current_url = 0
		}

		function Timer() {
			Status();
			if(_status == "playing" || o.casting) {
				o.actions.Playing()
			}
			if(_status != "") {
				o.actions.Loading()
			}
		}

		function CreatePoster() {
			if(o.poster) {
				o.frame.removeChild(o.poster)
			}
			o.poster = createElement("div");
			css(o.poster, {
				"pointer-events": "none",
				"opacity": v.poster_a,
				transition: "opacity 0.5s"
			});
			if(v.poster_float == 1) {
				PluginFloatPoster()
			} else {
				css(o.poster, {
					'position': 'absolute',
					'left': 0,
					'top': 0,
					'width': '100%',
					'height': '100%'
				})
			}
			o.frame.appendChild(o.poster)
		}

		function File(x, y, crt) {
			clearTimeout(hlsend_to);
			v.file2_separator == '' ? v.file2_separator = ';' : '';
			if(x.indexOf('{') > -1 && x.indexOf('}') > -1 && x.indexOf(v.file2_separator) > -1) {
				var z = x.split(v.file2_separator);
				o.audiotracks = [];
				for(var i = 0; i < z.length; i++) {
					o.files_audiotrack[i] = z[i].substr(z[i].indexOf("{") + 1, z[i].indexOf("}") - 1);
					o.audiotracks[i] = z[i].substr(z[i].indexOf("}") + 1);
					if(exist(v.default_audio)) {
						if(v.default_audio == o.files_audiotrack[i]) {
							o.current_audiotrack = i
						}
					}
				}
				x = o.audiotracks[o.current_audiotrack]
			}!exist(urls) ? urls = [] : '';
			o.fileTimeout ? clearTimeout(o.fileTimeout) : '';
			x && x != 'or' && x != 'x' ? ParseUrl(x) : '';
			var ft = o.file_type;
			if(urls.length > 0) {
				o.file_type = FileType(urls[current_url]);
				var create = false;
				if(crt) {
					create = true
				}
				url = urls[current_url];
				if(url) {
					url = url.replace(/\(random\)/g, Math.random())
				} else {
					url = urls[0]
				}
				if(!create && x != 'x' && media && o.file_type == ft && (ft == "native" || (ft == "vimeo" && !o.system.mobile) || (ft == "youtube" && o.start && !_stopped) || ft == "dm" || ft == "hls" || ft == "dash")) {
					media.src(url);
					log("src")
				} else {
					log("New");
					RemoveMedia();
					CreateMedia(url)
				}
				StartSpeed()
			}
			if(!y) {
				clearInterval(o.timerInterval);
				o.timerInterval = setInterval(Timer, o.timerTime);
				if(!exist(v.subtitle) && v.sub_upload == 1 && v.sub_upload0 == 1) {
					v.subtitle = ''
				}
				if(exist(v.subtitle)) {
					o.actions.Subtitle(v.subtitle)
				}
				if(v.hidevideo == 1) {
					if(v.nativecontrolsmobile == 1 && o.system.mobile) {} else {
						if(o.file_type == "youtube") {
							css(o.mediacontainer, {
								"top": -3000,
								"left": -3000
							})
						} else {
							hide2(o.mediacontainer)
						}
						v.toolbar.hide = 0
					}
				}
			}
		}

		function StartSpeed(x) {
			if(o.speed1 || x) {
				if(o.line_speed) {
					media.setSpeed(o.custom_speed)
				} else {
					if(o.current_speed != o.speed1) {
						media.setSpeed(o.files_speed[o.current_speed])
					}
				}
			}
		}

		function FileType(x) {
			var type = "native";
			if(x) {
				if(x.indexOf(".m3u8") > 0) {
					type = "hls"
				} else if(x.indexOf(".mpd") > 0) {
					type = "dash"
				} else if(x.indexOf("w") == 0 && x.indexOf("s") == 1) {
					type = o.ws
				} else if(x.indexOf('youtube.com/') > -1 || x.indexOf('youtu.be/') > -1) {
					if(typeof(MediaYoutube) == 'function') {
						type = "youtube";
						if(v.youtubeposter == 1) {
							var y = 'https://img.youtube.com/vi/' + YoutubeID(x) + '/';
							imageExists(y + 'maxresdefault.jpg', function(z) {
								z > 100 ? v.poster = y + 'maxresdefault.jpg' : v.poster = y + 'hqdefault.jpg';
								if(o.playlist_dic) {
									o.playlist_dic[o.plid]['poster'] = v.poster
								}
								v.autoplay == 1 || o.start ? '' : Poster(v.poster, o.poster, v.poster_scale)
							})
						}
					} else {
						log("No YouTube")
					}
				} else if(v.vimeo == 1 && x.indexOf('vimeo.com/') > -1) {
					type = "vimeo"
				} else if(v.dm == 1 && x.indexOf('dailymotion.com') > -1) {
					type = "dm"
				} else if(v.pjsframe == 1) {
					if(typeof(PjsFramed) == 'function') {
						PjsFramed(x) ? type = "pjs" : ''
					}
				}
			}
			o.tagvideo = type == "native" || type == "hls" || type == "dash" || type == o.ws;
			return type
		}

		function imageExists(url, callback) {
			var img = new Image();
			img.onload = function() {
				callback(this.height)
			};
			img.src = url
		}

		function CreateMedia(x) {
			o.file_type = FileType(x);
			if(o.tagvideo) {
				media = new MediaVideo(x, o.mediacontainer, false)
			}
			if(o.file_type == "youtube") {
				media = new MediaYoutube(x, o.mediacontainer)
			}
			if(v.vimeo == 1 && o.file_type == "vimeo") {
				media = new MediaVimeo(x, o.mediacontainer)
			}
			if(o.file_type == "pjs") {
				media = new MediaPjs(x)
			}
			if(o.file_type == "dm") {
				media = new MediaDaily(x, o.mediacontainer)
			}
			o.controls ? o.controls.UpdateSettings() : '';
			var t = 0;
			if(exist(v.duration)) {
				if(o.continue && v.timestore == 1 && !o.start) {
					t = o.continue.flag().t
				}
				setTimeout(function() {
					o.actions.Duration(t, v.duration)
				}, 100)
			}
		}

		function RemoveMedia() {
			if(media) {
				media.Remove();
				media = null;
				_status = "ended"
			}
			if(media2) {
				media2.Remove();
				media2 = null;
				media2 = undefined;
				o.mediapip.remove();
				o.media2 = null;
				o.mediapip = null
			}
		};
		this.Remove = function() {
			RemoveMedia()
		};
		this.RemoveAll = function() {
			urls = [];
			RemoveMedia()
		};
		this.File = function(x, y, z) {
			File(x, y, z)
		};
		this.Poster = function(x) {
			Poster(x, o.poster, v.poster_scale)
		};
		this.Play = function() {
			if(media) {
				_ended = false;
				_stopped = false;
				if(o.casting) {
					o.chromecast.Play()
				} else {
					media.Play();
					v.posterhide == 1 ? o.actions.HidePoster() : ''
				}
				if(exist(media2)) {
					media2.Play()
				}
				if(o.channels) {
					if(o.tagvideo) {
						if(o.clicktime > 0 && !o.channels.Created()) {
							o.channels.Update()
						}
					} else {
						o.files_channel = [];
						o.controls.SettingChanged("channel")
					}
				}
				if(o.tagvideo && v.volumegain > -1 && !o.gained && !o.system.ios) {
					if(o.clicktime > 0) {
						media.Gain()
					}
				}
				FileTo()
			} else {
				setTimeout(this.Play, 500)
			}
		};

		function FileTo() {
			if(v.fileto > 0 && urls.length > 1) {
				if(Duration() == 0 || v.filetod == 1) {
					clearTimeout(o.fileTimeout);
					o.fileTimeout = setTimeout(FileTimeout, v.fileto * 1000)
				}
			}
		}

		function FileTimeout() {
			if(o.play && (Duration() == 0 || v.filetod == 1) && Time() == 0) {
				if(media) {
					if(media.loaded() == 0 && current_url != urls.length - 1) {
						onError('File Timeout')
					}
				}
			}
		}
		this.PipSwitch = function(event) {
			if(o.media2) {
				if(v.pip.movable == 1) {
					if(o.moving[o.media2] > 2) {
						return
					}
				}
				if(event) {
					event.stopPropagation();
					window.event ? window.event.cancelBubble = true : ''
				}
				var tmp = media;
				media.ChangePip(true, o.media2);
				media2.ChangePip(false, o.mediacontainer);
				media = media2;
				media2 = tmp;
				media.Play();
				media2.Play();
				js("pip")
			}
		};
		this.reYT = function() {
			media.src(url)
		};
		this.ToolbarHide = function() {
			v.effects == 1 ? o.effects.api("hide") : '';
			o.toolbarhidden = true
		};
		this.ToolbarShow = function() {
			if(v.toolbar.resizeme) {
				v.toolbar.resizeme = false;
				if(o.controls) {
					o.controls.resizeFromText(1);
					o.controls.resizetext()
				}
			}
			o.toolbarhidden = false
		};
		this.PipToggle = function() {
			if(o.media2 && o.mediapip) {
				o.mediapip.toggle()
			}
		};
		this.Airplay = function() {
			if(o.tagvideo && o.airplay) {
				o.airplayed = true;
				media.airplay()
			}
		};
		this.PipWebkit = function() {
			if(o.tagvideo && o.pipwebkit) {
				media.pipwebkit()
			}
		};
		this.BeforeVast = function() {
			if(v.vast_poster == 1 && exist(v.vast_posterurl)) {
				if(exist(o.vast_poster)) {
					o.vast_poster.show()
				} else {
					if(typeof(PlgnVstPstr) == 'function') {
						o.vast_poster = new PlgnVstPstr()
					}
				}
			}
			VstLdTxt();
			if(media) {
				datetime(0);
				media.BeforeVast()
			}
		};
		this.AfterVast = function() {
			o.vast_poster ? o.vast_poster.hide() : '';
			media ? media.AfterVast() : ''
		};
		this.VstLdTxt = function(x) {
			VstLdTxt(x)
		};

		function VstLdTxt(x) {
			if(v.vast_loadtxtd == 1 && exist2(v.vast_loadtxt)) {
				if(exist(o.vast_loadtxt)) {
					o.vast_loadtxt.show(x)
				} else {
					if(typeof(PlgnVstLdtx) == 'function') {
						o.vast_loadtxt = new PlgnVstLdtx()
					}
				}
			}
		}
		this.Pause = function() {
			if(o.casting) {
				o.chromecast.Pause()
			} else {
				media ? media.Pause() : log("nomedia")
			}
			if(exist(o.media2)) {
				media2.Pause()
			}
		};
		this.Recover = function() {
			_stopped = true;
			o.actions.Seek(0, false);
			exist(o.poster) ? o.actions.ShowPoster() : '';
			File('x')
		};
		this.Toggle = function() {
			media ? media.Toggle() : ''
		};
		this.Seek = function(x) {
			if(media) {
				if(o.casting) {
					o.chromecast.Seek(x)
				} else {
					media.Seek(x);
					if(v.pip.on == 1) {
						if(media2) {
							media2.Seek(x)
						}
					}
				}
			}
		};
		this.Mute = function() {
			if(media) {
				media.Mute();
				o.casting ? o.chromecast.Mute() : '';
				log("mute")
			}
			if(v.pip.on == 1 && v.pip.nomute == 1) {
				if(media2) {
					media2.Mute()
				}
			}
		};
		this.Unmute = function() {
			if(media) {
				media.Unmute();
				o.casting ? o.chromecast.Unmute() : '';
				log("unmute")
			}
			if(v.pip.on == 1 && v.pip.nomute == 1) {
				if(media2) {
					media2.Unmute()
				}
			}
		};
		this.Volume = function(x) {
			media ? media.Volume(x) : '';
			if(v.pip.on == 1) {
				if(v.pip.nomute == 1 && media2) {
					media2.Volume(x)
				}
			}
			if(o.casting) {
				o.chromecast.Volume(x)
			}
		};
		this.isPlaying = function() {
			return media ? media.isPlaying() : false
		};
		this.isLive = function() {
			return media ? media.isLive() : false
		};
		this.status = function() {
			return _status
		};
		this.ended = function() {
			return _ended
		};
		this.time = function() {
			var x = 0;
			if(media) {
				x = Time();
				if(o.casting) {
					var y = o.chromecast.Time();
					y ? x = y : ''
				} else {
					if(Duration() > 0 && x != Duration()) {
						o.current_time = x + 0.0001
					}
				}
				return x
			} else {
				return 0
			}
		};
		this.duration = function() {
			var x = 0;
			if(media) {
				x = Duration();
				x == 0 && exist(v.duration) ? x = v.duration * 1 : '';
				if(o.casting) {
					var y = o.chromecast.Duration();
					y ? x = y : ''
				}
			}
			return x
		};
		this.loaded = function() {
			return media ? media.loaded() : 0
		};
		this.flip = function() {
			o.mediascale.flip = o.mediascale.flip ? false : true;
			css(o.mediacontainer, {
				"transform": (o.mediascale.flip ? "scaleX(-1)" : "scaleX(1)")
			})
		};
		this.createposter = function() {
			CreatePoster()
		};
		this.Preload = function() {
			if(o.tagvideo) {
				media.preload()
			}
		};
		this.menufltr = function(x, y) {
			if(x == 'scale') {
				if(y == 1) {
					Scale(v.settings.scale / 100)
				}
				if(y == 2) {
					Scale(-v.settings.scale / 100)
				}
				if(y == 3) {
					o.media.normalscale()
				}
			} else {
				if(o.tagvideo) {
					if(!o.fltrs[x]) {
						if(x == 'sepia') {
							o.fltrs[x] = 0
						} else {
							o.fltrs[x] = 1
						}
					}
					if(y == 1) {
						o.fltrs[x] += v.settings[x] / 100
					}
					if(y == 2) {
						o.fltrs[x] -= v.settings[x] / 100
					}
					if(y == 3) {
						if(x == 'sepia') {
							o.fltrs[x] = 0
						} else {
							o.fltrs[x] = 1
						}
					}!o.cftlr ? o.cftlr = [] : '';
					o.cftlr[x] = x + '(' + parseInt(o.fltrs[x] * 100) + '%) ';
					var cf = '';
					for(var i in o.cftlr) {
						cf += o.cftlr[i]
					}
					css(media.tag(), {
						'filter': cf
					});
					o.controls.MenuProc(x)
				}
			}
		};
		this.scale = function(x) {
			Scale(x)
		};

		function Scale(x) {
			if(String(x).indexOf(":") > 0) {
				var y = x.split(":");
				var z0 = o.screen_w / o.screen_h;
				var z1 = o.media.size();
				if(z1.width > 0) {
					z0 = z1.width / z1.height
				}
				var z = y[0] / y[1];
				if(z0 != z) {
					if(o.tagvideo) {
						media.ObjectFit()
					}
					var w2 = o.screen_h * z;
					var x2 = w2 / o.screen_w;
					var h2 = o.screen_w / z;
					var y2 = h2 / o.screen_h;
					if(x2 < 1) {
						o.mediascale.x0 = o.mediascale.x = parseFloat(x2);
						o.mediascale.y = 1
					} else {
						o.mediascale.x = 1;
						o.mediascale.y0 = o.mediascale.y = parseFloat(y2)
					}
					css(o.mediacontainer, {
						"transform": "scaleX(" + o.mediascale.x + ") scaleY(" + o.mediascale.y + ")"
					});
					o.custom_aspect = x
				}
			} else {
				o.mediascale.x += parseFloat(x);
				o.mediascale.y += parseFloat(x);
				css(o.mediacontainer, {
					"transform": "scaleX(" + o.mediascale.x + ") scaleY(" + o.mediascale.y + ")"
				})
			}
			if(v.hotkey.scaledrag == 1) {
				if(!o.mediadrag) {
					if(o.mediascale.x > 0 || o.mediascale.y > 1) {
						PluginMovable(o.mediacontainer, 'o.dragging');
						o.mediadrag = true
					}
				}
				xy00()
			}
			o.controls.MenuProc('scale')
		};
		this.normalscale = function() {
			if(o.tagvideo) {
				media.ObjectFit()
			}
			o.mediascale.x = o.mediascale.x0;
			o.mediascale.y = o.mediascale.y0;
			css(o.mediacontainer, {
				"transform": "scaleX(" + o.mediascale.x + ") scaleY(" + o.mediascale.y + ")"
			});
			o.controls.MenuProc('scale');
			o.custom_aspect = null;
			xy00()
		};

		function xy00() {
			if(o.mediadrag && v.hotkey.scaledrag0 != 1) {
				if(o.mediascale.x == 1 && o.mediascale.y == 1) {
					css(o.mediacontainer, {
						"top": 0,
						"left": 0
					})
				}
			}
		};
		this.hlsDashSub = function(x, y) {
			media.hlsDashSub(x, y)
		};
		this.currentFile = function() {
			return currentFile()
		};

		function currentFile() {
			return urls ? (urls.length > 0 ? (urls[current_url] ? urls[current_url] : '') : '') : ''
		};
		this.urlsl = function() {
			return urls.length
		};
		this.tag = function() {
			return media ? media.tag() : false
		};
		this.captions = function() {
			if(o.tagvideo) {
				media.captions()
			}
		};
		this.onDash = function() {
			media.onDash()
		};

		function RadioTags() {
			var xhr = XHR(v.tagsurl + '?url=' + urls[current_url]);
			xhr.onload = function() {
				if(this.readyState == 4 && this.status == 200) {
					if(this.responseText) {
						v.title = this.responseText;
						o.actions.Title('title')
					}
				}
			};
			xhr.send()
		}
	};
	var MediaVideo = function(url, container, pip) {
        alert(url)
		var pjstg = createElement(v.hidevideo == 1 ? "audio" : "video");
		var hls_config;
		var pipto = 0;
		var hls;
		var is_hls = false;
		var is_hls2 = false;
		var hls_started = false;
		var hls_created = false;
		var hls_force = -1;
		var dash;
		var dash_created = false;
		var ws;
		var ws_created = false;
		var is_dash = false;
		o.live = false;
		var is_sleep = 0;
		var is_ws = false;
		var error;
		var error_time;
		var unmuteplease = false;
		var pip_quality = -1;
		var pause_before_vast = -1;
		var sleep_timeout;
		var _hlssubtracks;
		var _seekaftervast;
		var urlmse;
		var mimeCodec = 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"';
		var nops = false;
		css(pjstg, {
			'position': 'static',
			'width': '100%',
			'height': '100%',
			'object-fit': 'contain',
			'transition': "filter 0.2s linear",
			'min-height': 'auto',
			'max-height': 'none',
			'min-width': 'auto',
			'max-width': 'none'
		});
		ObjectFit();
		if(o.system.iphone && v.autoplay == 1 && v.autoplaymute == 1) {
			if(!o.start && v.preroll) {
				attr(pjstg, {
					'playsinline': 1
				})
			} else {
				o.muted = true;
				o.controls ? o.controls.Mute() : '';
				attr(pjstg, {
					'muted': 1,
					'playsinline': 1,
					'autoplay': 1
				})
			}
		} else {
			if(v.playsinlineonmobile == 1 && o.system.mobile) {
				attr(pjstg, {
					'playsinline': 1
				})
			}
			if(!o.system.tv) {
				attr(pjstg, {
					'preload': (v.preload == 1 && v.autoplay == 0 ? 'metadata' : 'none')
				})
			}
		}
		if(v.tagcors == 1) {
			attr(pjstg, {
				"crossorigin": "anonymous",
				"crossOrigin": "anonymous"
			})
		}
		attr(pjstg, {
			'src': url,
			'x-webkit-airplay': 'allow',
			'disableRemotePlayback': 'true'
		});
		if(v.drunchr != 1) {
			attr(pjstg, {
				'disableRemotePlayback': 'true'
			})
		}
		if(v.ynxnopip == 1) {
			attr(pjstg, {
				'pip': 'false'
			})
		}
		if(pip) {
			pjstg.autoplay = true;
			if(v.pip.nomute != 1 || v.autoplay == 1) {
				pjstg.muted = true
			}
		}
		if(v.nativenodownload == 1) {
			attr(pjstg, {
				'controlsList': 'nodownload'
			})
		}
		tagSrc();
		if(v.taginframe == 1) {
			var tagframe = createElement("iframe");
			attr(tagframe, {
				"scrolling": "no",
				"allowfullscreen": "true",
				"allowtransparency": "true",
				"src": ""
			});
			css(tagframe, {
				"position": "absolute",
				"width": "100%",
				"height": "100%",
				"border": 0
			});
			container.appendChild(tagframe);
			var framei = window.setInterval(function() {
				if(tagframe.contentWindow.document.readyState === "complete") {
					window.clearInterval(framei);
					css(tagframe.contentDocument.body, {
						"padding": 0,
						"margin": 0
					});
					tagframe.contentDocument.body.appendChild(pjstg)
				}
			}, 100)
		} else {
			container.appendChild(pjstg)
		}
		if(!exist(url)) {
			url = ''
		}
		if(url.indexOf(".mpd") > 0) {
			is_dash = true;
			if(!o.dash) {
				if(typeof PluginDash !== "undefined") {
					o.dash = new PluginDash()
				}
			}
			if(exist(o.dash)) {
				if(!exist(window.dashjs)) {
					o.dash.script()
				} else {
					CheckDash()
				}
			}
		} else if(((options.hls == 1 && v.playerjscom != 1) || url.indexOf(".m3u8") > 0) && (o.compilation.indexOf("HLS") != -1 || exist(window.Hls))) {
			is_hls = true;
			is_hls2 = true;
			try {
				if(exist(window.Hls)) {
					if(!Hls.isSupported() || (o.system.safari && v.nativehlsinsafari == 1 && !o.system.ios) || (o.system.safari && o.system.ios && v.nativehlsios == 1) || (o.system.edge && v.nativehlsinedge == 1)) {
						log('HLS support ', Hls.isSupported());
						is_hls = false
					} else {
						if(v.preload == 1 || v.autoplay == 1 || v.preloadhls == 1 || pip) {
							CreateHLS(false)
						}
					}
				} else {
					is_hls = false
				}
			} catch(error) {
				is_hls = false
			}
		} else if(url.indexOf("w") == 0 && url.indexOf("s") == 1 && v.flussonic == 1) {
			is_ws = true;
			CreateWS()
		}
		if(o.system.tv && v.autoplay == 1 && !is_hls && !is_dash && !is_ws) {
			setTimeout(function() {
				o.actions.MediaReady()
			}, 100)
		}
		if(v.channels == 1) {
			exist(o.channels) ? o.channels.Close() : '';
			o.channels = new PlugMediaChannels()
		};
		this.onDash = function() {
			CheckDash()
		};

		function CheckDash() {
			is_dash = true;
			if(MseIsSupported()) {
				if(v.preload == 1 || v.autoplay == 1 || v.preloaddash == 1) {
					CreateDASH(false)
				}
			} else {
				is_dash = false;
				log("DASH not supported")
			}
		}

		function CreateDASH(x) {
			if(o.dash && !dash_created) {
				o.dash.create(x, pjstg, url, pip);
				exist(window.dashjs) ? dash_created = true : ''
			}
		}

		function CreateHLS(x) {
			log("HLS");
			if(o.files.length > 1) {
				v.hlsquality = 0;
				v.hlsquality_off = true
			} else {
				v.hlsquality_off ? v.hlsquality = 1 : ''
			}
			if(o.audiotracks.length > 1) {
				v.hlsaudio = 0;
				v.hlsaudio_off = true
			} else {
				v.hlsaudio_off ? v.hlsaudio = 1 : ''
			}
			o.hls_subs = false;
			hls_force = -1;
			var dontload = false;
			if(v.preroll && v.hlsvastwait == 1) {
				dontload = true;
				v.hlsvastwait = 0
			}
			hls_config = {
				debug: (v.hlsdebug == 1 && !pip),
				autoStartLoad: (v.preload == 1 || v.autoplay == 1 || pip || x) && !dontload,
				maxBufferLength: 60,
				maxMaxBufferLength: 60,
				manifestLoadingTimeOut: (v.hlsmto > 0 ? v.hlsmto * 1000 : 40000),
				fragLoadingTimeOut: (v.hlsfto > 0 ? v.hlsfto * 1000 : 40000),
				enableWorker: false
			};
			if(v.hlscltps == 1) {
				hls_config.capLevelToPlayerSize = true
			}
			if(v.hlscookies == 1) {
				hls_config['xhrSetup'] = function(xhr, url) {
					xhr.withCredentials = true
				}
			}
			if(exist(v.hlsconfig)) {
				if(exist(v.hlsconfig.maxBufferLength)) {
					if(v.hlsconfig.maxBufferLength > 600) {
						v.hlsconfig.maxBufferLength = 600
					}
					v.hlsconfig.maxMaxBufferLength = v.hlsconfig.maxBufferLength
				}
				if(exist(v.hlsconfig.customBuffer)) {
					v.hlsconfig.maxMaxBufferLength = v.hlsconfig.maxBufferLength = v.hlsconfig.customBuffer
				}
				if(typeof v.hlsconfig == "object") {
					for(var key in v.hlsconfig) {
						hls_config[key] = v.hlsconfig[key]
					}
				}
			}
			hls = new Hls(hls_config);
			js("hls", hls, 1);
            console.log(url)
			hls.loadSource(url);
			hls.attachMedia(pjstg);
			hls.on(Hls.Events.MEDIA_ATTACHED, function() {
				log("HLS attached")
			});
			hls.on(Hls.Events.MANIFEST_LOADED, function(event, data) {
				!pip ? o.actions.MediaReady() : ''
			});
			hls.on(Hls.Events.MANIFEST_PARSED, function(event, data) {
				if(!pip && v.hlsquality == 1 && HlsLevelsLength() > 1) {
					HlsQualityLevels();
					HlsLevel();
					o.controls ? o.controls.QualityChangedNoHand(o.current_quality) : ''
				}
			});
			hls.on(Hls.Events.LEVEL_SWITCH, function(event, data) {
				HlsLevel()
			});
			hls.on(Hls.Events.LEVEL_SWITCHED, function(event, data) {
				HlsLevel()
			});
			hls.on(Hls.Events.LEVEL_LOADED, function(event, data) {
				if(!pip) {
					if(data.details.live != o.live) {
						o.live = data.details.live;
						o.controls.refresh()
					}
					o.live = data.details.live;
					if(o.live) {
						log("Live");
						o.dvr = url.indexOf("?DVR") > -1;
						if(pjstg.duration > 0 && pjstg.currentTime > 0) {
							if(pjstg.duration - pjstg.currentTime < 10) {
								if(o.hls_stuck_time > 0) {
									if(o.hls_stuck_time == pjstg.currentTime && o.hls_stuck_duration == pjstg.duration) {
										o.stuck++;
										if(o.stuck > 2) {
											o.stuck = 0;
											o.hls_stuck_time = -1;
											hls.destroy();
											CreateHLS(true);
											onEnded()
										}
									} else {
										o.hls_stuck_time = -1
									}
								} else {
									o.hls_stuck_time = pjstg.currentTime;
									o.hls_stuck_duration = pjstg.duration
								}
							}
						}
					}
				}
				if(v.hlsquality == 1) {
					o.current_quality = hls.loadLevel;
					o.controls ? o.controls.QualityChangedNoHand(o.current_quality) : ''
				}
				HlsUpdateAudio()
			});
			hls.on(Hls.Events.FRAG_CHANGED, function(event, data) {
				if(exist(data.frag)) {
					!pip ? js("fragment", data.frag.relurl) : '';
					if(v.hlsfdt == 1) {
						typeof PlgHlsFdt !== "undefined" ? PlgHlsFdt(data.frag) : ''
					}
				}
				if(hls_force > -1) {
					hls.nextAutoLevel = hls_force;
					hls_force = -1
				}
				hls_started = true;
				hlsTextTracks()
			});
			hls.on(Hls.Events.FRAG_PARSING_METADATA, function(event, data) {
				js("fragdata", data, 1)
			});
			hls.on(Hls.Events.AUDIO_TRACKS_UPDATED, function(event, data) {
				!pip && v.hlsaudio == 1 ? HlsAudioTracks() : ''
			});
			hls.on(Hls.Events.AUDIO_TRACK_SWITCHING, function(event, data) {
				if(!pip && v.hlsaudio == 1) {
					HlsAudioTrack()
				}
			});
			if(v.hlssubtracks == 1) {
				_hlssubtracks = new PluginHlsSubtitles(hls, pip)
			} else {
				hls.subtitleDisplay = false
			}
			hls.on(Hls.Events.ERROR, function(event, data) {
				v.log == 1 ? console.log(data) : '';
				js(data.type + 'Hls', data, 0, true);
				o.hlserror = data;
				if(data.fatal) {
					switch(data.type) {
						case Hls.ErrorTypes.NETWORK_ERROR:
							log("HLS fatal network error");
							if(v.livewakeup == 1) {
								HlsSleep0()
							} else {
								error = data.details + ' (' + data.type + ')';
								o.seekto > 0 || pip || v.live == 1 || is_ws ? '' : o.seekto = Time();
								hls.destroy();
								if(!pip) {
									o.media.onError()
								}
							}
							break;
						case Hls.ErrorTypes.MEDIA_ERROR:
							log("HLS fatal media error, recover");
							hls.recoverMediaError();
							break;
						default:
							error = "HLS fatal error, destroy";
							hls.destroy();
							!pip ? o.media.onError() : '';
							break
					}
				} else {
					log("HLS ", data.type, data.details, (data.response ? data.response.code : ''));
					js("hls_error", (data.response ? data.response.code : ''));
					if(is_sleep > 0) {
						is_sleep = 2;
						HlsSleep()
					}
				}
			});
			hls_created = true
		}

		function HlsLevel() {
			if(!pip && v.hlsquality == 1 && HlsLevelsLength() > 1) {
				if(o.current_quality != hls.loadLevel) {
					o.current_quality = hls.loadLevel;
					o.controls ? o.controls.QualityChangedNoHand(o.current_quality) : '';
					log("HLS Level " + o.current_quality)
				}
				if(exist2(v.forbidden_quality) && o.current_quality > 0) {
					var fq = v.forbidden_quality.split(",");
					for(var k = 0; k < fq.length; k++) {
						if(o.files_quality[o.current_quality].indexOf(fq[k]) > -1) {
							log('regress quality');
							hls.currentLevel = o.current_quality - 1;
							o.current_quality--;
							break
						}
					}
				}
			}
		}

		function CreateWS() {
			if(exist(window.FlussonicMsePlayer)) {
				if(MseIsSupported()) {
					if(!exist(o.ws)) {
						o.ws = new PluginWS()
					}
					ws = new FlussonicMsePlayer(pjstg, url, existv(v.wsconfig, {
						debug: true
					}));
					ws_created = true
				} else {
					is_ws = false;
					log("not supported")
				}
			}
		}

		function hlsTextTracks() {
			Captions()
		};
		this.captions = function() {
			Captions()
		};

		function Captions() {
			if(v.hlscaptions) {
				if(pjstg.textTracks.length > 0) {
					if(v.captions == 1) {
						pjstg.textTracks[pjstg.textTracks.length - 1].mode = "showing"
					} else {
						pjstg.textTracks[pjstg.textTracks.length - 1].mode = "hidden"
					}
					if(!o.captions) {
						o.captions = true;
						o.controls.refresh()
					}
				} else {
					if(o.captions) {
						o.captions = false;
						o.controls.refresh()
					}
				}
			}
		}

		function HlsSleep0() {
			log("sleep");
			!pip && o.play ? o.actions.Pause() : '';
			o.actions.ShowPoster();
			is_sleep = 1;
			HlsSleep(o.play)
		}

		function HlsSleep(x) {
			if(is_sleep > 0) {
				clearTimeout(sleep_timeout);
				sleep_timeout = setTimeout(HlsLiveWaiting, v.livewakeuptime * 1000)
			}
		}

		function HlsLiveWaiting() {
			if(is_sleep > 0) {
				log("watching");
				if(is_hls) {
					if(is_sleep == 1) {
						hls.loadSource(url)
					}
					if(is_sleep == 2) {
						hls.destroy();
						CreateHLS(true);
						pjstg.play()
					}
				} else {
					attr(pjstg, {
						'src': url
					})
				}
			}
		}
		pjstg.addEventListener('loadstart', onLoadStart);
		pjstg.addEventListener('error', onTagError);
		pjstg.addEventListener('ended', onEnded);
		pjstg.addEventListener('play', onPlay);
		pjstg.addEventListener('pause', onPause);
		pjstg.addEventListener('timeupdate', onTimeupdate);
		pjstg.addEventListener('seeking', onSeeking);
		pjstg.addEventListener('seeked', onSeeked);
		pjstg.addEventListener('loadedmetadata', onMeta);
		pjstg.addEventListener('volumechange', onVolume);
		pjstg.addEventListener('waiting', onWaiting);
		pjstg.addEventListener('durationchange', onDuration);
		pjstg.addEventListener('loadeddata', onLoadedData);
		pjstg.addEventListener('enterpictureinpicture', onPipEnter);
		pjstg.addEventListener('leavepictureinpicture', onPipLeave);
		if(o.system.iphone) {
			pjstg.addEventListener('webkitfullscreenchange', iosfull)
		}

		function onLoadStart() {
			if(!is_hls && !is_dash) {
				!pip ? o.actions.MediaReady() : ''
			}
		}

		function iosfull() {
			if(pjstg.webkitDisplayingFullscreen) {
				o.actions.NativeEnterFs()
			}
		}

		function onTagError() {
			if(!is_hls && !is_dash) {
				if(pjstg.error) {
					log(pjstg.error, pjstg.error.code, pjstg.error.message);
					var x = pjstg.error.code;
					error = pjstg.error.message;
					if(error == '') {
						if(x == 1) {
							error = "aborted"
						}
						if(x == 2) {
							error = "network"
						}
						if(x == 3) {
							error = "decode"
						}
						if(x == 4) {
							error = "not found"
						}
					}
					log("Video Error: ", error)
				}
				if(is_hls2 && v.livewakeup == 1) {
					error = undefined;
					HlsSleep0()
				}
				if(error != undefined || o.system.ios) {
					onError()
				}
			}
		}

		function onError() {
			!pip ? o.media.onError() : ''
		}

		function onEnded() {
			!pip ? o.media.onEnded() : ''
		}

		function onPlay() {
			if(!o.start && v.preroll) {
				log('wrong play');
				pause();
				o.actions.Play();
				return
			}
			if(is_hls && is_sleep > 0) {} else {
				if(!pip) {
					var bgl = o.actions.isVastBgLoad() && o.vastfrombg != 1;
					if(bgl || pause_before_vast == -1) {
						var x = false;
						if(is_hls) {
							if(exist(o.vast) || exist(o.vastloader)) {
								if(bgl) {} else {
									log('pause onplay');
									pause();
									x = true
								}
							}
						}
						if(!x) {
							o.media.onPlay()
						}
					}
				}
			}
		}

		function onPause() {
			if(!nops) {
				log("onpause");
				if(o.play && o.actplay && !pjstg.ended && v.unpause == 1 && !o.nativecontrols) {
					log("unpause");
					TagPlay()
				} else {
					!pip && !o.nopause && pjstg.paused ? o.media.onPause() : ''
				}
			}
		}

		function onTimeupdate() {
			!pip ? o.media.onTimeupdate() : '';
			if(pause_before_vast > -1) {
				if(Time() > pause_before_vast) {
					pause();
					pause_before_vast = -1
				}
			}
		}

		function onSeeking() {
			!pip ? o.media.onSeeking() : ''
		}

		function onSeeked() {
			!pip ? o.media.onSeeked() : ''
		}

		function onMeta() {
			if(pip) {
				PipSize()
			} else {
				o.media.onMeta();
				PlayerSize();
				if(is_hls && is_sleep > 0) {
					is_sleep = 0;
					log("wake up");
					hls.startLoad();
					TagPlay();
					o.controls.Play()
				}
				if(exist(v.ratio)) {
					Resize()
				}
			}
		}
		this.ratio = function() {
			return(pjstg.videoWidth / pjstg.videoHeight)
		};

		function PipSize() {
			if(pjstg.videoHeight > 0) {
				css(container, {
					"height": container.offsetWidth / (pjstg.videoWidth / pjstg.videoHeight) - parseInt(v.pip.border)
				})
			} else {
				if(pipto < 20) {
					setTimeout(PipSize, 100);
					pipto++
				}
			}
		}

		function PlayerSize() {
			if(v.changeheight == 1) {
				clearInterval(o.heightInterval);
				o.heightInterval = setInterval(WaitSize, 100);
				WaitSize()
			}
		}

		function WaitSize() {
			if(pjstg) {
				if(pjstg.videoHeight > 0) {
					o.actions.changeAspect(pjstg.videoWidth / pjstg.videoHeight);
					clearInterval(o.heightInterval)
				}
			}
		}

		function onDuration() {
			!pip && !is_ws ? o.media.onDuration() : ''
		}

		function onVolume() {
			!pip ? o.media.onVolume() : ''
		}

		function onWaiting() {
			if(is_hls && is_sleep > 0) {} else {
				!pip ? o.media.onWaiting() : ''
			}
		}

		function onLoadedData() {
			o.actions.LoadedData()
		}

		function MseIsSupported() {
			var mediaSource = window.MediaSource = window.MediaSource || window.WebKitMediaSource;
			var sourceBuffer = window.SourceBuffer = window.SourceBuffer || window.WebKitSourceBuffer;
			var isTypeSupported = mediaSource && typeof mediaSource.isTypeSupported === 'function' && mediaSource.isTypeSupported(mimeCodec);
			var sourceBufferValidAPI = !sourceBuffer || sourceBuffer.prototype && typeof sourceBuffer.prototype.appendBuffer === 'function' && typeof sourceBuffer.prototype.remove === 'function';
			return isTypeSupported && sourceBufferValidAPI
		}
		var span05 = "<span style='opacity:0.5'>";

		function HlsQualityLevels() {
			if(!pip && v.hlsquality == 1) {
				var x = hls.levels;
				var q = -1;
				o.files_quality = [];
				if(x.length > 1) {
					for(var i = 0; i < x.length; i++) {
						if(exist(x[i].height)) {
							var y = o.media.renameQualities(x[i], v.nameofhlsquality);
							if(o.files_quality.indexOf(y) > -1 || v.hlsaddbitrate == 1) {
								if(exist(x[i].bitrate)) {
									var yi = o.files_quality.indexOf(y);
									yi > -1 ? o.files_quality[yi] += " " + span05 + " &nbsp;" + parseInt(x[yi].bitrate / 1000) + ' ' + Lang('kbps') + '</span>' : '';
									o.files_quality[i] = y + " " + span05 + " &nbsp;" + parseInt(x[i].bitrate / 1000) + ' ' + Lang('kbps') + '</span>'
								}
							} else {
								o.files_quality[i] = y
							}
							if(exist(x[i].audioGroupIds)) {
								o.files_quality_ag[i] = x[i].audioGroupIds[0]
							}
						} else if(exist(x[i].name)) {
							o.files_quality[i] = x[i].name
						} else {
							o.files_quality[i] = i
						}
						if(exist(v.default_quality) && q == -1) {
							if(v.default_quality == o.files_quality[i]) {
								q = i
							}
						}
						if(exist(o.default_quality)) {
							if(o.default_quality == o.files_quality[i]) {
								q = i
							}
						}
					}
					if(v.hlsautoquality == 1) {
						o.files_quality[x.length] = Lang("auto")
					} else {
						hls.autoLevelEnabled = 0;
						hls.autoLevelCapping = 0
					}
					if(v.hlslowquality == 1 || q > -1) {
						hls.autoLevelCapping = 0;
						if(v.hlschangequality == "next" || (!o.start && v.preload == 0)) {
							hls.nextLevel = q
						} else {
							if(v.hlschangequality == "current") {
								hls.currentLevel = q
							}
						}
						o.current_quality = q
					} else {
						if(v.hlsautoquality == 1) {
							o.current_quality = hls.levels.length - 1
						} else {
							o.current_quality = hls.firstLevel
						}
					}
					HlsUpdateAudio()
				}
				o.bitrate = existv(hls.levels[o.current_quality].bitrate, 0);
				o.controls ? o.controls.refresh() : ''
			}
		}

		function HlsUpdateAudio() {
			if(o.files_quality_ag.length > 0 && v.hlsaudio == 1) {
				HlsAudioTracks();
				HlsAudioTrack()
			}
		}

		function HlsAudioTracks() {
			if(!pip && v.hlsaudio == 1) {
				var x = hls.audioTracks;
				o.files_audiotrack = [];
				var stop;
				if(x.length > 1) {
					for(var i = 0; i < x.length; i++) {
						stop = false;
						if(exist(x[i].groupId) && o.files_quality_ag.length > 0) {
							if(x[i].groupId != o.files_quality_ag[o.current_quality]) {
								for(var j = 0; j < o.files_quality_ag.length; j++) {
									if(o.files_quality_ag[j] == x[i].groupId) {
										stop = true
									}
								}
							}
						}
						if(!stop) {
							o.files_audiotrack[i] = exist(x[i].name) ? o.media.renameTracks(x[i].name, i) : i;
							if(exist(v.default_audio)) {
								if(v.default_audio == o.files_audiotrack[i]) {
									o.current_audiotrack = i;
									hls.audioTrack = i
								}
							}
						}
					}
				}
			}
		}

		function HlsAudioTrack() {
			if(!pip) {
				var x = hls.audioTracks;
				var y = hls.audioTrack;
				if(y > -1) {
					if(exist(x[y].groupId)) {
						if(o.files_quality_ag.length > 0) {
							if(o.files_quality_ag[o.current_quality] != x[y].groupId) {
								for(var i = 0; i < x.length; i++) {
									if(x[i].name == x[y].name && x[i].groupId == o.files_quality_ag[o.current_quality]) {
										hls.audioTrack = i;
										y = i;
										break
									}
								}
							}
						}
					}
					o.current_audiotrack = y;
					log("HLS AudioTrack", o.current_audiotrack);
					o.controls.AudioTrackChangedNoHand(o.current_audiotrack)
				}
			}
		};

		function Time() {
			if(is_dash) {
				return dash_created ? o.dash.time() : 0
			} else {
				return pjstg.currentTime
			}
		};

		function Duration() {
			var x = pjstg.duration;
			if(is_dash && dash_created) {
				x = o.dash.duration()
			}
			if(exist(v.end)) {
				if(indOf([v.end], '-')) {
					x = x + v.end * 1
				} else {
					x = v.end
				}
			}
			return x != Infinity && !isNaN(x) ? x : 0
		}
		this.Play = function() {
			var p = true;
			if(is_hls && !hls_started) {
				if(!hls_created) {
					CreateHLS(true)
				}
				hls.startLoad()
			}
			if(is_dash && !dash_created) {
				CreateDASH(true);
				p = false
			}
			if(is_ws) {
				if(!ws_created) {
					CreateWS()
				}
				ws.play();
				p = false
			}
			if(pjstg.style.top == "-2000px") {
				this.AfterVast()
			}
			p ? TagPlay() : ''
		};
		var playtry;

		function TagPlay() {
			if(url != "none") {
				var pp = pjstg.play();
				if(pp !== undefined) {
					pp.then(function() {}).catch(function(error) {
						log("playError", error.message);
						if(error.message.indexOf('source') == -1 && error.message.indexOf('interrupted by') == -1) {
							if(v.autoplaymute == 1) {
								log('automute');
								o.actions.Mute();
								pjstg.volume = 0;
								var pp2 = pjstg.play();
								if(pp2) {
									pp2.then(function() {}).catch(function(e) {
										log("playError2", e.message);
										if(o.system.tv && (is_hls || is_dash)) {} else {
											o.controls.Pause();
											o.actions.ShowPoster();
											js("autoplay_denied")
										}
									})
								}
							} else {
								o.controls.Pause();
								o.actions.ShowPoster()
							}
						}
					})
				}
			}
		}
		this.BeforeVast = function() {
			if(o.vastloader || o.vast) {
				if(o.ispipkit) {
					PipWebkit()
				}
				if(!o.airplayed && o.system.mobile && o.system.webkit) {
					if(!pjstg.muted) {
						pjstg.muted = true;
						unmuteplease = true
					}
					css(pjstg, {
						"position": "absolute",
						"left": -2000,
						"top": -2000
					});
					pause_before_vast = Time();
					if(!is_ws) {
						pjstg.play()
					}
					if(pause_before_vast == 0 && o.seekto > 0) {
						_seekaftervast = o.seekto
					}
				}
			}
		};
		this.AfterVast = function() {
			if(!o.airplayed && (o.system.mobile || o.system.webkit)) {
				css(pjstg, {
					"position": "static",
					"left": 0,
					"top": 0
				});
				if(exist(v.ratio)) {
					Resize()
				}
				if(unmuteplease) {
					!o.muted ? pjstg.muted = false : '';
					unmuteplease = false
				}
				if(_seekaftervast > 0) {
					o.seekto = _seekaftervast;
					_seekaftervast = 0
				}
				pause_before_vast = -1
			}
		};
		this.Pause = function() {
			log('paused');
			pause()
		};

		function pause() {
			if(is_ws) {
				ws.pause()
			} else {
				pjstg.pause()
			}
		};
		this.Toggle = function() {
			!pjstg.paused ? Pause() : TagPlay()
		};
		this.Seek = function(x) {
			if(is_dash && dash_created) {
				o.dash.seek(x)
			} else {
				if(is_hls) {
					if(v.hlsforce == 1 && x > 0 && isAuto()) {
						hls_force = hls.currentLevel;
						hls.nextAutoLevel = 0
					}
				}
				pjstg.currentTime = x
			}
		};
		this.Mute = function() {
			pjstg.muted = true
		};
		this.Unmute = function() {
			pjstg.muted = false;
			if(o.file_type == "hls" && o.system.ios && v.vast == 1) {
				if(!exist(o.um1)) {
					nops = true;
					pjstg.pause();
					setTimeout(function() {
						pjstg.play();
						nops = false
					}, 10);
					o.um1 = true
				}
			}
		};
		this.Volume = function(x) {
			pjstg.volume = x
		};
		this.Gain = function() {
			if(o.gainedsource != pjstg) {
				var source;
				var ctx;
				if(o.audiosrc[pjstg]) {
					source = o.audiosrc[pjstg];
					ctx = o.audioctx[pjstg]
				} else {
					window.AudioContext = window.AudioContext || window.webkitAudioContext;
					if(exist(window.AudioContext)) {
						try {
							ctx = new AudioContext();
							source = ctx.createMediaElementSource(pjstg);
							o.audiosrc[pjstg] = source;
							o.audioctx[pjstg] = ctx
						} catch(e) {
							log(e)
						}
					}
				}
				if(ctx) {
					var gain = ctx.createGain();
					gain.gain.value = v.volumegain;
					source.connect(gain);
					gain.connect(ctx.destination);
					o.gained = true;
					o.gainedsource = pjstg
				}
			}
		};
		this.isPlaying = function() {
			return !pjstg.paused
		};
		this.isLive = function() {
			return v.live == 1 || is_ws ? true : o.live
		};
		this.tag = function() {
			return pjstg
		};
		this.nativeControls = function() {
			attr(pjstg, {
				'controls': '1'
			});
			return true
		};
		this.preload = function() {
			attr(pjstg, {
				'preload': 'metadata'
			});
			if(is_hls && !hls_created) {
				CreateHLS(false)
			}
			if(is_dash && !dash_created) {
				CreateDASH(false)
			}
		};
		this.status = function() {
			var state = "playing";
			if(pjstg.paused) {
				state = "paused"
			}
			if(pjstg.ended) {
				state = "ended"
			}
			return state
		};
		this.ChangePip = function(x, y) {
			pip = x;
			y.appendChild(pjstg);
			container = y;
			if(x) {
				if(v.pip.nomute != 1) {
					pjstg.muted = true
				} else {
					if(!o.muted) {
						pjstg.muted = false
					}
				}
				PipSize();
				if(o.files_quality.length > 0) {
					if(is_hls) {
						pip_quality = o.current_quality;
						hls.autoLevelCapping = 0;
						hls.currentLevel = 0
					}
				}
			} else {
				if(!o.muted && v.pip.nomute != 1) {
					pjstg.muted = false
				}
				pjstg.volume = v.volume;
				PlayerSize();
				if(o.files_quality.length > 0) {
					if(is_hls) {
						hls.autoLevelCapping = -1;
						if(pip_quality > -1) {
							pip_quality < hls.levels.length ? hls.nextLevel = pip_quality : ''
						}
					}
				}
			}
		};
		this.time = function() {
			return Time()
		};
		this.duration = function() {
			return Duration()
		};
		this.loaded = function() {
			var x = 0;
			if(pjstg.buffered) {
				if(pjstg.buffered.length > 0) {
					var y = Time();
					for(var i = 0; i < pjstg.buffered.length; i++) {
						if((y >= pjstg.buffered.start(i) || y >= pjstg.buffered.start(i) - 100) && y <= pjstg.buffered.end(i)) {
							x = pjstg.buffered.end(i)
						}
					}
					x == 0 ? x = pjstg.buffered.end(pjstg.buffered.length - 1) : ''
				}
			}
			if(exist(v.end)) {
				var ed = v.end;
				if(indOf([ed], '-')) {
					ed = Duration()
				}
				x > ed ? x = ed : ''
			}
			return x
		};
		this.auto = function() {
			return isAuto()
		};

		function isAuto() {
			var x = false;
			if(is_hls) {
				if(hls_created) {
					x = hls.autoLevelEnabled
				}
			} else if(is_dash) {
				if(dash_created) {
					x = o.dash.auto()
				}
			}
			return x
		}
		this.size = function() {
			return {
				"width": pjstg.videoWidth,
				"height": pjstg.videoHeight
			}
		};
		this.src = function(x) {
			if(x) {
				x = x.replace(/\(random\)/g, Math.random());
				url = x;
				o.media_error != 2 ? o.media_error = false : '';
				if(is_dash) {
					if(dash_created) {
						o.dash.source(x)
					}
				} else if(is_hls) {
					is_hls && hls ? hls.destroy() : '';
					CreateHLS(true);
					CheckPip()
				} else {
					attr(pjstg, {
						'src': x,
						'autoplay': 0
					});
					tagSrc();
					pause()
				}
			}
		};

		function tagSrc() {
			if(o.system.safari) {
				var y = pjstg.textTracks;
				if(y) {
					for(var i = 0; i < y.length; i++) {
						y[i].mode = "disabled"
					}
				}
				y = pjstg.audioTracks;
				if(y) {
					for(i = 0; i < y.length; i++) {
						y[i].enabled = (i == 0 ? 1 : 0)
					}
				}
				if(window.WebKitPlaybackTargetAvailabilityEvent) {
					pjstg.addEventListener('webkitplaybacktargetavailabilitychanged', function(event) {
						o.airplay = event.availability == "available";
						!pip ? o.actions.AirplayChanged() : ''
					});
					pjstg.addEventListener('webkitcurrentplaybacktargetiswirelesschanged', function(event) {})
				}
			}
			CheckPip();
			if(v.v360 == 1) {
				typeof PjsCheck360 !== "undefined" ? PjsCheck360(url, pjstg, container) : ''
			}
		}
		this.airplay = function() {
			pjstg.webkitShowPlaybackTargetPicker()
		};
		this.pipwebkit = function() {
			PipWebkit()
		};

		function CheckPip() {
			if(o.system.webkit) {
				if(exist(pjstg.webkitSupportsPresentationMode) && !o.system.iphone) {
					o.pipwebkit = true
				}
				if(document.pictureInPictureEnabled && !pjstg.disablePictureInPicture) {
					o.pipwebkit = true
				}
			}
		}

		function PipWebkit() {
			if(o.system.safari) {
				if(pjstg.webkitPresentationMode === "picture-in-picture") {
					pjstg.webkitSetPresentationMode("inline");
					o.ispipkit = false
				} else {
					pjstg.webkitSetPresentationMode("picture-in-picture");
					o.ispipkit = true
				}
			} else {
				if(!document.pictureInPictureElement) {
					eval('pjstg.requestPictureInPicture().then(p => {o.ispipkit = true;}).catch(error => {o.ispipkit = false;});')
				} else {
					eval('document.exitPictureInPicture().then(ok =>{o.ispipkit = false;}).catch(error => {});')
				}
			}
		};

		function onPipEnter() {
			o.ispipkit = true
		};

		function onPipLeave() {
			o.ispipkit = false
		};
		this.setDashQuality = function(x) {
			if(dash_created) {
				o.dash.setQuality(x)
			}
		};
		this.setDashAudioTrack = function(x) {
			if(dash_created) {
				if(pjstg.buffered.length > 0) {
					o.dash.setAudio(x)
				}
			}
		};
		this.setWsQuality = function(x) {
			if(o.ws) {
				o.ws.setTracks(ws, x, -1)
			}
		};
		this.setWsAudioTrack = function(x) {
			if(o.ws) {
				o.ws.setTracks(ws, -1, x)
			}
		};
		this.setHlsQuality = function(x) {
			if(hls_created) {
				var y = parseInt(x);
				if(x == hls.levels.length) {
					y = -1;
					hls.autoLevelCapping = -1
				}
				if(v.hlschangequality == "current") {
					setTimeout(onWaiting, 500);
					hls.currentLevel = y
				}
				if(v.hlschangequality == "next") {
					log("HLS next level " + y);
					hls.nextLevel = y
				}
				if(y == -1) {
					o.current_quality = hls.loadLevel
				}
				HlsUpdateAudio()
			}
		};
		this.getHLS = function() {
			return hls
		};
		this.getDASH = function() {
			return dash_created ? o.dash.getDash() : false
		};
		this.HlsLevelsLength = function() {
			return HlsLevelsLength()
		};

		function HlsLevelsLength() {
			var x = 0;
			if(hls_created) {
				if(hls.levels) {
					x = hls.levels.length
				}
			}
			return x
		}
		this.DashLevelsLength = function() {
			return DashLevelsLength()
		};
		this.ObjectFit = function() {
			ObjectFit()
		};

		function ObjectFit() {
			if(pjstg) {
				if(v.covervideo == 1 || v.fill == 1) {
					if(v.fillvideo == 1 || v.fill == 1) {
						css(pjstg, {
							'object-fit': 'fill'
						})
					} else {
						css(pjstg, {
							'object-fit': 'cover'
						})
					}
				} else {
					css(pjstg, {
						'object-fit': 'contain'
					})
				}
			}
		}
		this.resize = function() {
			Resize()
		};

		function Resize() {
			if(v.ratio) {
				apiProcessor('scale', String(v.ratio).replace('/', ':'))
			}
		}

		function DashLevelsLength() {
			var x = 0;
			if(dash_created) {
				x = o.dash.levels()
			}
			return x
		}
		this.setHlsAudioTrack = function(x) {
			if(hls_created) {
				hls.audioTrack = parseInt(x)
			}
		};
		this.hlsDashSub = function(x, y) {
			if(y == "hls" && hls_created && _hlssubtracks) {
				_hlssubtracks.HlsSubTrack(x)
			}
			if(y == "dash" && dash_created) {
				o.dash.subtrack(x)
			}
		};
		this.setSpeed = function(x) {
			if(x) {
				pjstg.playbackRate = x
			}
		};
		this.removeTracks = function() {
			var x = pjstg.childNodes;
			var y = [];
			for(var i = 0; i < x.length; i++) {
				if(x[i].tagName.toLowerCase() == 'track') {
					x[i].removeEventListener("load", iOSTrackLoaded);
					y.push(x[i])
				}
			}
			for(var i = 0; i < y.length; i++) {
				pjstg.removeChild(y[i])
			}
			o.nativesub = false
		};
		this.addTrack = function(x, y, z) {
			if(x != '') {
				if(x.indexOf(' or ') > 0) {
					var xx = x.split(' or ');
					x = xx[0]
				}
				var track = document.createElement('track');
				track.setAttribute('src', x);
				track.setAttribute('label', y);
				track.setAttribute('kind', 'subtitles');
				track.setAttribute('mode', 'showing');
				if(z) {
					track.setAttribute('default', '')
				}
				pjstg.appendChild(track);
				track.addEventListener("load", iOSTrackLoaded)
			}
		};

		function iOSTrackLoaded(e) {
			if(e.target.label && o.sbt) {
				for(var i = 0; i < o.files_subtitle.length; i++) {
					if(o.files_subtitle[i] == e.target.label) {
						o.sbt.SetSubtitle(i)
					}
				}
			}
		};
		this.errorMessage = function() {
			return error ? error : ''
		};
		this.Remove = function() {
			clearInterval(o.dashInterval);
			is_hls && hls ? hls.destroy() : '';
			is_dash && dash_created ? o.dash.reset() : '';
			is_ws && ws ? ws.stop() : '';
			pjstg.removeEventListener('error', onTagError);
			pjstg.removeEventListener('ended', onEnded);
			pjstg.removeEventListener('play', onPlay);
			pjstg.removeEventListener('pause', onPause);
			pjstg.removeEventListener('timeupdate', onTimeupdate);
			pjstg.removeEventListener('seeking', onSeeking);
			pjstg.removeEventListener('seeked', onSeeked);
			pjstg.removeEventListener('loadedmetadata', onMeta);
			pjstg.removeEventListener('volumechange', onVolume);
			pjstg.removeEventListener('waiting', onWaiting);
			pjstg.removeEventListener('durationchange', onDuration);
			pjstg.removeEventListener('enterpictureinpicture', onPipEnter);
			pjstg.removeEventListener('leavepictureinpicture', onPipLeave);
			pjstg.src = '';
			if(container.tagName == "IFRAME") {
				container.contentDocument.body.removeChild(pjstg)
			} else {
				container.removeChild(pjstg)
			}
			pjstg = null
		}
	};
	var Controls = function() {
		var b = [];
		var butNames = [];
		var butPosition = [];
		var waiting = false;
		var wait_to;
		var toolbarHidden = false;
		var settings;
		var playlist;
		if(o.settings2) {
			o.settings2.hide();
			o.settings2 = null
		}
		var _lastactbut;
		o.files_speed = [0.25, 0.5, 0.75, 1, 1.25, 1.5, 2];
		if(v.settings.customspeeds == 1 && exist(v.settings.speeds)) {
			v.settings.speeds = v.settings.speeds.replace(/\n/ig, '');
			o.files_speed = v.settings.speeds.split(",")
		}
		o.speed1 = o.files_speed.indexOf('1') > -1 ? o.files_speed.indexOf('1') : o.files_speed.indexOf(1);
		o.current_speed == 3 ? o.current_speed = o.speed1 : '';
		for(var i in o.menuproc) {
			if(o.menuproc.hasOwnProperty(i)) {
				!exist(v.settings[i]) ? v.settings[i] = 5 : '';
				o['files_' + i] = ['+ ' + v.settings[i] + '%', '&ndash; ' + v.settings[i] + '%', (o.menuproc[i] * 100 + '%')]
			}
		}
		if(v.toolbar.hidejustfull == 1 && o.system.ios && v.nativefullios == 1) {
			v.toolbar.hide = 0
		}
		var resizeonwidth = false;
		var stretch_width = 0;
		var stretch_width_last = 0;
		var stretch_with_volume = false;
		var firstly = true;
		var uijs;
		var bg = new ControlsBg();
		var settings;
		var order = [];
		var _rights = false;
		var _move_rights = false;
		var _max_order = 0;
		var _rb = [];
		if(v.control_line.position == "controls-right") {
			v.control_line.position = "controls"
		}
		for(var y in v) {
			if(v.hasOwnProperty(y)) {
				if(y.indexOf("control_") == 0 && v[y]) {
					!exist(v[y].order0) ? v[y].order0 = v[y].order : v[y].order = v[y].order0;
					order[v[y].order] = y;
					if(v.control_line.position != "controls") {
						if(v[y].position == "controls-right") {
							_rb.push([y, v[y].order]);
							_rights = true
						} else {
							if(v[y].position == "controls" || v[y].position == undefined) {
								_rights ? _move_rights = true : ''
							}
						}
					}
					_max_order < v[y].order ? _max_order = v[y].order : ''
				}
			}
		}
		if(_move_rights) {
			_rb.sort(function(a, b) {
				return a[1] - b[1]
			});
			for(var i = 0; i < _rb.length; i++) {
				order[v[_rb[i][0]].order] = null;
				v[_rb[i][0]].order = _max_order + 1;
				_max_order++;
				order[v[_rb[i][0]].order] = _rb[i][0]
			}
		}
		if(v.toolbar.hide == 1 && v.toolbar.hidedown == 1) {
			o.toolbar = createElement("div");
			o.frame.appendChild(o.toolbar);
			css(o.toolbar, {
				'position': 'absolute',
				'left': 0,
				'top': 0,
				'width': '100%',
				'height': '100%',
				'transition': 'top 0.3s ease-out',
				'pointer-events': 'none'
			})
		}
		var bg2 = createElement("div");
		if(v.toolbar.hide == 1 && v.toolbar.hidedown == 1) {
			o.toolbar.appendChild(bg2)
		} else {
			o.frame.appendChild(bg2)
		}
		css(bg2, {
			'position': 'absolute',
			'left': 0,
			'bottom': 0,
			'width': '100%',
			'height': v.toolbar.h
		});
		bg2.onclick = function() {
			!o.system.mobile ? o.actions.ControlsBgClick() : ''
		};
		if(v.nocontrols == 1) {
			hide2(bg.c());
			hide2(bg2)
		}
		for(var i = 1; i < order.length; i++) {
			if(order[i]) {
				var y = order[i];
				if(y) {
					var action = v[y].action;
					var hdn = v[y].hide;
					if(o.system.mobile) {
						if(action == "volume" && v[y].customline == "speed") {} else {
							if(action == "volume" && v.showvolmobile == 1 && o.system.mobile) {
								v[y].hideoutmute = 0
							} else {
								if(action == "volume" || (action == "fullscreen" && v.nativemobile)) {
									v[y].on = 0
								}
							}
						}
					}
					if(v[y].hide == 1) {
						if(v[y].hideonvar == 1 && exist(v[y].hidevar)) {
							options[v[y].hidevar] ? v[y].on = 0 : ''
						}
						if(v[y].hidewovar == 1 && exist(v[y].hidevar2)) {
							!options[v[y].hidevar2] ? v[y].on = 0 : ''
						}
					}
					if(v.nocontrols == 1) {
						v[y].on = 0
					}
					if(v[y].on == 1) {
						if(action == "line" || action == "volume") {
							b[y] = new ControlLine(y, action);
							b[y].Resize(b[y].s("w"))
						} else {
							b[y] = new Control(y)
						}
						butNames.push(y);
						if(b[y].g("action") == "title") {
							if(b[y].s("text") == '') {
								if(b[y].s("var") != '') {
									if(!exist(v[b[y].s("var")])) {
										b[y].set("display", false)
									}
								} else {
									b[y].set("display", false)
								}
							}
						}
						if(b[y].g("action") == "custom") {
							var lu = b[y].s("linkurl");
							if(lu) {
								if(lu.indexOf("api:") == 0 && lu.indexOf(",0/1") > 0) {
									var z = lu.split(",");
									apiProcessor(z[0].substr(4)) == 0 ? b[y].CustomSwitch(0) : ''
								}
								if(indOf([lu], "share")) {
									o.shareme = true
								}
							}
						}
						b[y].set("scale", b[y].s("scale"))
					}
				}
			}
		}
		if(exist(v.settings)) {
			if(typeof(Settings) == 'function') {
				settings = new Settings("settings");
				v.settings.always == 1 ? settings.show() : settings.hide()
			} else {
				o.noset = true
			}
		}
		if(exist(v.playlist)) {
			if(typeof(Settings) == 'function') {
				playlist = new Settings("playlist");
				if(exist(o.playlist)) {
					playlist.updatePlaylist(o.playlist);
					if(v.playlist.openplaylistbefore == 0 || !exist(v.playlist.openplaylistbefore)) {
						v.playlist.always == 0 ? playlist.hide() : ''
					} else {
						playlist.show()
					}
					if(v.playlist.always2 == 1) {
						playlist.show()
					}
				} else {
					playlist.hide(1)
				}
				PlaylistControls()
			}
		}
		CreateShare();
		CustomTextButs();
		Resize(true);
		ShowOrHide();
		SpeedChanged();
		firstly = false;

		function ControlX(but) {
			var x = 0;
			var to_right = false;
			if(but) {
				if(but.g("action") == 'line') {
					x = butPosition.left + but.s("marginleft") + but.g("width") / 2;
					if(butPosition.rightbs != null) {} else {
						butPosition.rightbs = []
					}
				} else {
					if(butPosition.rightbs != null) {
						var but_space = but.g("width") + but.s("marginright") + but.s("marginleft");
						if(HideProof(but)) {
							but_space = 0
						}
						if(but.s("hidden") == 1 && !but.g("show")) {
							but_space = 0
						}
						if(but.s("vertical") > 0) {
							but_space = 0
						}
						x = bg.g("w") - v.toolbar.leftandrightpadding * 1 - but_space + but.g("width") / 2 + but.s("marginleft");
						var i = 0;
						butPosition.right -= but_space;
						for(i = 0; i < butPosition.rightbs.length; i++) {
							var but2 = b[butPosition.rightbs[i]];
							if(but2.s("vertical") > 0) {
								css(but2.c(), {
									"left": (but2.g("x0") - but_space)
								})
							} else {
								css(but2.c(), {
									"left": (but2.g("x") - but_space)
								})
							}
							but2.set("x0", but2.g("x"))
						}
						butPosition.rightbs.push(but.g("key"));
						but.set('rightside', 1)
					} else {
						if(but.s("hidden") == 1 && !but.g("show")) {
							if(but.g("action") == "volume") {
								if(but.s("hide") == 1 && but.s("hideoutmute") == 1 && stretch_with_volume) {
									stretch_width += but.g("width") + but.s("marginleft") + but.s("marginright");
									stretch_with_volume = false
								}
							}
						} else {
							if(but.s("vertical") > 0) {
								x = butPosition.left + but.s("marginleft") + but.s("marginright")
							} else {
								var stop = false;
								if(but.g("action") == "volume") {
									if(but.s("hide") == 1 && but.s("hideoutmute") == 1) {
										if(!o.hidden_volume_over_process && !o.hidden_volume_over) {
											stop = true;
											stretch_with_volume = false
										} else {
											if(!stretch_with_volume) {
												stretch_width -= but.g("width") + but.s("marginleft") + but.s("marginright");
												stretch_with_volume = true
											}
										}
									}
								}
								if(HideProof(but)) {
									stop = true
								}
								if(!stop) {
									butPosition.left += but.g("width") / 2 + but.s("marginleft");
									x = butPosition.left;
									butPosition.left += but.g("width") / 2 + but.s("marginright")
								} else {
									x = butPosition.left
								}
							}
						}
					}
				}
			}
			return x
		};
		this.NewPl = function() {
			CreateShare()
		};
		this.CrShr = function() {
			CreateShare()
		};

		function CreateShare() {
			if(o.shareme) {
				typeof PluginShare == 'function' ? o.share = new PluginShare() : ''
			}
		}

		function ControlCoordinate(but) {
			var width = o.fullscreen && v.toolbar.stretchonfullscreen == 0 ? o.normal_w : o.screen_w;
			var height = o.screen_h;
			var but_x = 0;
			if(but != bg) {
				but_x = width / 2 + but.s("marginleft") - but.s("marginright")
			}
			var but_y = height / 2;
			var but_w = but.g("width");
			var but_h = but.g("height");
			var p = but.s("position");
			if(p.indexOf("center") > -1) {
				but_x = o.screen_w / 2 + but.s("marginleft") - but.s("marginright")
			}
			if(p.indexOf("top") == 0) {
				but_y = but_h / 2 + (but.s("marginproctop") * o.screen_h / 100)
			}
			if(p.indexOf("bottom") == 0) {
				but_y = o.screen_h - (but == bg ? but_h : but_h / 2) - (but.s("marginprocbottom") * o.screen_h / 100)
			}
			if(p.indexOf("right") > -1) {
				but_x = o.screen_w - but_w / 2 + but.s("marginleft") - but.s("marginright") - (but.s("marginprocright") * o.screen_w / 100)
			}
			if(p.indexOf("left") > -1) {
				but_x = but_w / 2 + but.s("marginleft") - but.s("marginright") + (but.s("marginprocleft") * o.screen_w / 100)
			}
			if(p == "timeline") {
				but_x = -o.timeline_w / 2 + (but.s("marginprocleft") * o.timeline_w / 100) + but.s("marginleft") - but.s("marginright");
				but_y = -o.timeline_h / 2 - (but.s("marginprocbottom") * o.timeline_h / 100) + (but.s("marginproctop") * o.timeline_h / 100)
			}
			if(p.indexOf("controls") > -1) {
				var cx = ControlX(but);
				but_x = (bg ? (bg.c() ? int(bg.c().offsetLeft) : 0) : 0) + cx;
				if(p == "controls-right") {
					but_x += stretch_width
				}
				if(v.toolbar.position == "top") {
					but_y = v.toolbar.h / 2 - (v.toolbar_margintop < 0 ? v.toolbar_margintop : 0)
				} else {
					but_y = height - v.toolbar.h / 2
				}
			}
			return {
				x: but_x,
				y: but_y + but.s("margintop") - but.s("marginbottom")
			}
		}

		function Resize(all) {
			var w = o.fullscreen && v.toolbar.stretchonfullscreen == 0 ? o.normal_w : o.screen_w;
			var h = o.screen_h;
			if(v.toolbar.lrpp == 1) {
				if(!v.toolbar.lrppp) {
					v.toolbar.lrppp = exist2(v.toolbar.lrpps) && o.small ? v.toolbar.lrpps : v.toolbar.leftandrightpadding
				}
				v.toolbar.leftandrightpadding = o.screen_w * v.toolbar.lrppp / 100
			}
			css(bg.c(), {
				'top': (v.toolbar.position == "top" ? 0 : o.screen_h - v.toolbar.h) - v.toolbar_margintop
			});
			bg.set("y0", (o.screen_h - v.toolbar.h - v.toolbar_margintop));
			if(v.toolbar.stretchonfullscreen == 0 && bg) {
				css(bg.c(), {
					'width': w,
					'left': 0,
					'margin-left': 0
				});
				bg.set("w", w);
				if(o.fullscreen) {
					css(bg.c(), {
						'left': '50%',
						'margin-left': -w / 2
					})
				}
			}
			butPosition = {
				"left": v.toolbar.leftandrightpadding * 1,
				"right": (bg.g("w") - v.toolbar.leftandrightpadding * 1)
			};
			var bg_hide = false;
			if(!bg.g("show")) {
				bg.set("display", true);
				bg_hide = true
			}
			var key;
			for(var i = 0; i < butNames.length; i++) {
				key = butNames[i];
				if(b[key]) {
					var cc = ControlCoordinate(b[key]);
					if(cc) {
						if(b[key].s("animation") == "position") {
							if(exist(o.motions[key])) {
								if(b[key].g("x0") == cc.x && b[key].g("y0") == cc.y) {
									continue
								} else {
									o.motions[key].XY(b[key].g("x0"), cc.x, b[key].g("y0"), cc.y)
								}
							}
						}
						b[key].set("x0", cc.x);
						b[key].set("y0", cc.y);
						if(b[key].s("hidden") == 1 && !b[key].g("show") && !all) {
							HidePositionControl(b[key])
						} else {
							css(b[key].c(), {
								"position": "absolute",
								"left": b[key].g("x0"),
								"top": b[key].g("y0")
							})
						}
					}
				}
			}
			if(bg_hide) {
				bg.set("display", false)
			}
			stretch_width = 0;
			for(key in b) {
				if(b.hasOwnProperty(key)) {
					if(b[key].s("position") == "controls-right" && b[key].g("action") != "line" && stretch_width > -1) {
						stretch_width = butPosition.right - butPosition.left
					}
					if(b[key].g("action") == "line" && bg) {
						var line_width;
						if(b[key].s("customwidth") == 1) {
							if(b[key].s("wproc") == 1) {
								line_width = (o.screen_w * b[key].s("w") / 100) - b[key].s("marginleft") - b[key].s("marginright")
							} else {
								line_width = b[key].s("w")
							}
						} else {
							if(b[key].s("position").indexOf("controls") > -1) {
								line_width = butPosition.right - butPosition.left - b[key].s("marginleft") - b[key].s("marginright");
								css(b[key].c(), {
									"left": (int(bg.c().offsetLeft) + butPosition.left + b[key].s("marginleft") + line_width / 2)
								});
								stretch_width = -1
							} else {
								line_width = bg.g("w") - b[key].s("marginleft") - b[key].s("marginright");
								css(b[key].c(), {
									"left": (int(bg.c().offsetLeft) + b[key].s("marginleft") + line_width / 2)
								})
							}
						}
						b[key].set("x0", b[key].g("x"));
						b[key].Resize(line_width)
					}
				}
			}
			if(settings) {
				ResizeSettings(settings)
			}
			if(playlist) {
				ResizeSettings(playlist)
			}
			if(resizeonwidth || o.fullscreen || stretch_width_last != stretch_width) {
				ShowOrHide()
			}
		}

		function HidePositionControl(b) {
			var left = 0;
			var top = 0;
			if(b.s("position").indexOf("right") > -1 && b.s("position").indexOf("controls") == -1) {
				left = o.screen_w + b.g("width") + 10
			}
			if(b.s("position").indexOf("left") > -1) {
				left = -b.g("width") - 10
			}
			if(b.s("position").indexOf("top") > -1) {
				top = -b.g("height") * 2
			}
			if(b.s("position").indexOf("bottom") > -1 || b.s("position").indexOf("controls") > -1) {
				top = o.screen_h + b.g("height") + b.g("width") + 10
			}
			if(left > 0) {
				css(b.c(), {
					"left": left
				})
			}
			if(top > 0) {
				css(b.c(), {
					"top": top
				})
			}
		}

		function ResizeSettings(x) {
			var top = -2000;
			x.resizePlaylist();
			var y = o.screen_h - v.toolbar.h * (x.s("position").indexOf("top") > -1 ? 1 : 2);
			if(x == playlist && v.change2playlist == 1) {
				y = o.screen_h
			}
			var ymax = y - (o.fullscreen && !o.system.mobile ? (100 + x.s("hmaxk") * 1) : x.s("hmaxk")) - (x == playlist && x.s("hmaxk") * 1 == 0 ? x.s("margintop") : 0);
			ymax < 100 ? ymax = 100 : '';
			css(x.c(), {
				'max-height': ymax
			});
			x.co() ? css(x.co(), {
				'max-height': ymax
			}) : '';
			if(x.g("show")) {
				top = o.screen_h / 2 - x.g("height") / 2 + x.s("margintop") - x.s("marginbottom");
				if(x.s("position").indexOf("top") > -1) {
					top = x.s("margintop") - x.s("marginbottom")
				}
				if(x.s("position").indexOf("bottom") > -1) {
					top = o.screen_h - (v.toolbar.position != 'top' ? v.toolbar.h : 0) - x.g("height") + x.s("margintop") - x.s("marginbottom")
				}
				top < 0 ? top = 0 : ''
			}
			if(x.g("key") == "settings" && o.sttx) {
				var sttr = o.screen_w - x.g("width") - x.s("marginright");
				if(o.sttx > sttr) {
					css(x.c(), {
						"position": "absolute",
						"right": x.s("marginright"),
						"left": "auto",
						"top": top
					})
				} else {
					css(x.c(), {
						"position": "absolute",
						"left": o.sttx,
						"right": "auto",
						"top": (o.stty < top ? o.stty : top)
					})
				}
			} else {
				if(x.s("position").indexOf("right") > -1) {
					css(x.c(), {
						"position": "absolute",
						"right": x.s("marginright") - x.s("scrollwidth"),
						"left": "auto",
						"top": top
					})
				} else if(x.s("position").indexOf("left") > -1) {
					css(x.c(), {
						"position": "absolute",
						"left": x.s("marginleft"),
						"right": "auto",
						"top": top
					})
				} else {
					if(x.g("key") == "playlist" && x.s("floatleft") == 1) {
						css(x.c(), {
							"position": "absolute",
							"left": o.screen_w / 2 - x.g("width") / 2 + x.s("marginleft") / 2 - x.s("marginright") / 2,
							"top": top
						})
					} else {
						var l = o.screen_w / 2 - x.g("width") / 2 + x.s("marginleft") - x.s("marginright");
						css(x.c(), {
							"position": "absolute",
							"left": (l > 0 ? l : 0),
							"top": top
						})
					}
				}
			}
			x.Arrows()
		};
		this.ControlClick = function(key) {
			var but = b[key];
			var a = but.g("action");
			if(a) {
				var d = new Date();
				o.clicktime = d.getTime();
				if(a && a != "") {
					Action(but);
					a == "pause" ? o.actpause = 1 : '';
					a == "play" ? o.actpause = 0 : ''
				}
			}
		};
		this.toggleControl = function(z, x, y) {
			for(var key in b) {
				if(b.hasOwnProperty(key)) {
					if(b[key].s(z) == x) {
						b[key].set(y ? "show2" : "hide2")
					}
				}
			}
		};
		this.butByS = function(x, s) {
			var y = FindBut(s, x);
			return y
		};

		function Action(but, type) {
			o.acted = true;
			_lastactbut = but;
			var a = but.g("action");
			if(a == "play") {
				o.actions.Play();
				if(o.muted && v.unmuteonplay == 1) {
					o.actions.Unmute();
					v.unmuteonplay = 0
				}
				if(v.hotkey.on == 1 && v.hotkey.icons == 1 && v.hotkey.playiconbut == 1) {
					PluginHotIcon('play', 1)
				}
			} else {
				if(a == "pause") {
					o.rldplay = 0;
					o.actions.Pause();
					if(v.hotkey.on == 1 && v.hotkey.icons == 1 && v.hotkey.playiconbut == 1) {
						PluginHotIcon('play', 0)
					}
				}
				if(a == "stop") {
					o.actions.StopMedia()
				}
			}
			if(a == "back") {
				o.actions.Seek(0, false)
			}
			if(a == "fullscreen") {
				!o.casting ? o.actions.Fullscreen() : ''
			} else {
				if(a == "normalscreen") {
					o.actions.Normalscreen()
				}
			}
			if(a == "line") {
				var ld = o.media.duration();
				var lt = but.g("click") * ld;
				if(v.delete > 0) {
					ld -= v.delete;
					lt = but.g("click") * ld + v.delete
				}
				if(v.seekwindow > 0) {
					if(v.seekwindow / ld <= 1 - but.g("click")) {
						return
					}
				}
				o.actions.Seek(lt, true);
				if(o.continue) {
					o.continue.write(lt, ld);
					o.seekto > 0 ? o.seekto = undefined : ''
				}
			}
			if(a == "volume") {
				var x = but.g("click");
				x < 0.02 ? x = 0 : '';
				x > 1 ? x = 1 : '';
				if(but.s("customline") == "speed") {
					x = parseFloat(x * o.files_speed.slice(-1)[0]).toFixed(1);
					o.actions.SetSpeed(x, 1)
				} else {
					if(o.storage && v.volumestore == 1) {
						localStorage.setItem("pljsvolume", x);
						if(but.g("click") > 0 || o.system.iphone || v.mutestore == 0) {
							localStorage.removeItem("pljsmute")
						} else {
							localStorage.setItem("pljsmute", 1)
						}
					}
					o.actions.Volume(x)
				}
			}
			if(a == "mute") {
				if(o.storage && !o.system.iphone && v.mutestore == 1) {
					localStorage.setItem("pljsmute", 1)
				}
				o.actions.Mute();
				if(v.hotkey.icons == 1 && v.hotkey.muteiconbut == 1) {
					PluginHotIcon('mute', 0)
				}
			} else {
				if(a == "unmute") {
					if(o.storage) {
						localStorage.removeItem("pljsmute")
					}
					o.actions.Unmute();
					if(v.hotkey.icons == 1 && v.hotkey.muteiconbut == 1) {
						PluginHotIcon('mute', 1)
					}
				}
			}
			if(a.indexOf("time") == 0) {
				but.isOn() ? but.Off() : but.On()
			}
			if(a == "rotate") {
				o.media.Rotate()
			}
			if(a == "scale+") {
				o.media.Scale(0.1)
			}
			if(a == "scale-") {
				o.media.Scale(-0.1)
			}
			if(a == "scale") {
				o.media.Scale(0)
			}
			if(a == "live") {
				apiProcessor("restart");
				but.set("iconopacity", 1);
				but.set("saturate", 1)
			}
			if(a == "share") {
				js("share");
				ShowShare()
			}
			if(a == "settings") {
				o.sttx = undefined;
				if(settings) {
					if(!settings.g("show")) {
						settings.show()
					} else {
						settings.hide()
					}
				}
			}
			if(a == "playlist") {
				if(o.overopentimeout == a) {
					return
				}
				o.controls.PlaylistShow()
			}
			if(a == "next") {
				o.controls.PlaylistNext()
			}
			if(a == "prev") {
				o.controls.PlaylistPrev()
			}
			if(a == "custom") {
				if(but.s("link") == 1 && but.s("linkurl") != "") {
					var x = trim(but.s("linkurl"));
					if(o.overopentimeout == a + x) {
						return
					}
					if(x.indexOf('{time}') > -1) {
						x = x.replace('{time}', (exist(o.continue) ? o.continue.flag().t : o.media.time()))
					}
					if(x.indexOf('{file}') > -1) {
						x = x.replace('{file}', o.media.currentFile())
					}
					if(x.indexOf('{title}') > -1) {
						x = x.replace('{title}', v.title.replace(/,/ig, " "))
					}
					if(x == "airplay") {
						o.media.Airplay()
					}
					if(x.indexOf('skip') == 0) {
						if(but.s("skip") > 0) {
							o.actions.Seek(but.s("skip"))
						}
					}
					if(x.indexOf('cancelskip') == 0) {
						if(o.skpbt) {
							o.skpbt.cancel()
						}
					}
					if(x == "seektome") {
						o.actions.Seek(but.s("marginprocleft") * o.media.duration() / 100);
						!o.play ? o.actions.Play() : ''
					}
					but.s("linkpause") == 1 ? o.actions.Pause() : '';
					var y = x.split(",");
					if(x.indexOf("api:") == 0) {
						var z = x.substr(4).split(";");
						for(var i = 0; i < z.length; i++) {
							y = z[i].split(",");
							if(y.length > 1) {
								if(y[0] == 'seek') {
									if(v.hotkey.icons == 1 && v.hotkey.seekiconbut == 1) {
										PluginHotIcon('seek', y[1] > 0 ? 1 : 0)
									}
								}
								apiProcessor(y[0], y[1], but);
								y[1] == '0/1' || y[1] == '1/0' ? reRightMenu() : ''
							} else {
								if(y[0] == "screenshot") {
									var ss = apiProcessor(y[0]);
									if(ss) {
										if(ss.indexOf("data") > -1) {
											if(v.ssfly == 1) {
												var img = document.createElement('img');
												img.setAttribute('src', ss);
												css(img, {
													position: "fixed",
													right: (exist(v.ssflyp) ? v.ssflyp : 20),
													bottom: (exist(v.ssflyp) ? v.ssflyp : 20),
													width: 0,
													transition: "width 0.5s cubic-bezier(.75,-0.5,0,1.75)"
												});
												img.style.zIndex = 1001;
												document.body.appendChild(img);
												setTimeout(function() {
													css(img, {
														width: (exist(v.ssflyw) ? v.ssflyw : 200)
													})
												}, 1);
												img.onclick = function() {
													this.parentNode.removeChild(this)
												}
											}
											if(v.ssdown == 1) {
												var a = createElement("a");
												a.href = ss;
												a.download = y[0] + ".jpg";
												a.click()
											}
										}
									} else {
										log(y[0] + " error")
									}
								} else {
									apiProcessor(y[0])
								}
							}
						}
					} else {
						if(x.indexOf("js:") == 0) {
							if(x.indexOf("(") > 0 && x.indexOf(")") > 0) {
								eval(x.substr(3))
							} else {
								eval(y[0].substr(3) + '(' + (exist(y[1]) ? '"' + y[1] + '"' : '') + (exist(y[2]) ? ',"' + y[2] + '"' : '') + ')')
							}
						}
						if(x.indexOf("event:") == 0) {
							JsEvent(x.substr(6), o.media.time())
						}
						if(x.indexOf("share:") == 0 && o.share) {
							o.share.api(x.substr(6))
						}
						if(x.indexOf("effect:") == 0 && o.effects) {
							apiProcessor("effect", x.substr(7))
						}
						if(x.indexOf("http") == 0 || x.indexOf("/") == 0 || x.indexOf("?") == 0 || x.indexOf("url:") == 0) {
							x.indexOf("url:") == 0 ? x = x.substr(4) : '';
							window.open(x, but.s("linktarget"))
						}
						if(x.indexOf("download") == 0) {
							o.actions.Download()
						}
						if(x == "api:pipwebkit") {
							o.media.PipWebkit()
						}
					}
					if(x.indexOf("settings#") > -1) {
						if(settings) {
							var si = x.substr(9).split(",");
							if(settings.g("show") && settings.g("open") == si[0]) {
								o.sttx = undefined;
								o.stty = undefined;
								settings.hide()
							} else {
								o.sttx = but.g("x") - but.g("width") / 2;
								o.stty = but.g("y") + but.g("h");
								for(var i = 0; i < si.length; i++) {
									i == 0 ? settings.show() : '';
									settings.open(si[i])
								}
								playlist ? playlist.plclose() : ''
							}
						}
					}
					if(x.indexOf("settings:") > -1 && v.settings.combined == 1) {
						if(!o.settings2) {
							o.settings2 = new PluginSettings2()
						}
						if(v.settings.showovercontrol == 1) {
							if(type == "over") {
								o.settings2.show(x)
							} else {
								o.settings2.toggle(x)
							}
						} else {
							if(!type) {
								o.settings2.toggle(x)
							}
						}
					}
					if(x == "unblock") {
						o.actions.RemoveCurtain();
						o.stopkeys = 0;
						but.set("hide2");
						var bl = FindBut("linkurl", "block");
						if(bl) {
							bl.set("hide2")
						}
					}
					if(x == "block") {
						but.UpdateText("OK");
						but.s("linkurl2") ? window.location.href = trim(but.s("linkurl2")) : ''
					}
				}
			}
		};
		this.title = function(t) {
			var y = false;
			for(var x in b) {
				if(b.hasOwnProperty(x)) {
					if(b[x].g("action") == "title") {
						if(b[x].s("var") == t || t == "title") {
							if(b[x].s("hide") == 1 && b[x].s("hideonplay") == 1 && o.play) {
								y = true
							}
							if(v[t] == '' || y) {
								b[x].set("display", false)
							} else {
								b[x].set("display", true)
							}
							b[x].UpdateText(v[t])
						}
					}
				}
			}
			TitlePl()
		};
		this.titlepl = function() {
			TitlePl()
		};
		this.resizetext = function() {
			for(var x in b) {
				if(b.hasOwnProperty(x)) {
					if(b[x].g("action") == "custom") {
						if(b[x].s("type") == "text") {
							b[x].ResizeText()
						}
					}
				}
			}
		};

		function TitlePl() {
			for(var x in b) {
				if(b.hasOwnProperty(x)) {
					if(b[x].g("action") == "custom") {
						if(b[x].s("type") == "text") {
							b[x].RenewFromTitle(true)
						}
					}
				}
			}
		}

		function ShowShare() {
			if(exist(o.share)) {
				o.share.Show()
			}
		}
		this.showShare = function() {
			ShowShare()
		};
		this.updateTitle = function() {
			if(v.title != '') {
				for(var x in b) {
					if(b.hasOwnProperty(x)) {
						if(b[x].g("action") == "title") {
							var y = false;
							if(!b[x].g("show")) {
								y = true;
								b[x].set("display", true)
							}
							b[x].UpdateText(v.title);
							if(y) {
								b[x].set("display", false)
							}
						}
					}
				}
			}
		};
		this.customTextPl = function() {
			CustomTextButs()
		};

		function CustomTextButs() {
			if(v.customtext) {
				if(typeof(v.customtext) == "object") {
					for(var x in v.customtext) {
						if(v.customtext.hasOwnProperty(x)) {
							CustomText(x, v.customtext[x])
						}
					}
				}
			}
		};
		this.customText = function(y, z) {
			CustomText(y, z)
		};
		this.upText = function(x) {
			if(b[x]) {
				b[x].UpText()
			}
		};
		this.upTexts = function() {
			for(var x in b) {
				if(b.hasOwnProperty(x)) {
					if(b[x].g("ctxt")) {
						b[x].UpText()
					}
				}
			}
		};

		function CustomText(y, z) {
			for(var x in b) {
				if(b.hasOwnProperty(x)) {
					if(b[x].g("ctxt")) {
						if(b[x].s("dom") == y) {
							if(!b[x].g("show") || b[x].s("hidden") == 1) {
								b[x].set("unhidden");
								b[x].set("display", true)
							}
							b[x].CustomText(z)
						}
					}
				}
			}
		};
		this.resize = function() {
			Resize()
		};
		this.resize2 = function() {
			Resize(true)
		};
		this.resizeSettings = function() {
			ResizeSettings(settings)
		};
		this.resizePlaylist = function() {
			ResizeSettings(playlist)
		};
		this.Play = function() {
			for(var x in b) {
				if(b.hasOwnProperty(x)) {
					if(b[x].g("action") == "play") {
						b[x].On()
					}
				}
			}
			o.vast_loadtxt ? o.vast_loadtxt.hide() : '';
			ClosePl();
			o.play = true;
			ShowOrHide()
		};
		this.Pause = function() {
			for(var x in b) {
				if(b.hasOwnProperty(x)) {
					if(b[x].g("action") == "pause" || b[x].g("action") == "stop") {
						b[x].Off()
					}
				}
			}
			if(playlist) {
				if(v.playlist.openplaylistpause == 1 && !playlist.empty()) {
					playlist.show()
				}
			}
			o.play = false;
			this.StopWaiting();
			ShowOrHide();
			if(v.toolbar.hide == 1 && v.toolbar.hideonpause == 1) {
				HideForce(true)
			}
		};
		this.Mute = function() {
			for(var x in b) {
				if(b.hasOwnProperty(x)) {
					if(b[x].g("action") == "mute") {
						b[x].On()
					}
					this.Volume(0)
				}
			}
			ShowOrHide()
		};
		this.Unmute = function() {
			for(var x in b) {
				if(b.hasOwnProperty(x)) {
					if(b[x].g("action") == "unmute") {
						b[x].Off()
					}
				}
			}
			if(v.volume < 0.1) {
				v.volume = 0.5;
				o.actions.Volume(v.volume)
			} else {
				this.Volume(v.volume)
			}
			ShowOrHide()
		};
		this.Volume = function(volume, y) {
			for(var x in b) {
				if(b.hasOwnProperty(x)) {
					if(b[x].g("action") == "volume") {
						if(b[x].s("customline") != "speed") {
							b[x].UpdatePlay(volume, 1, (y == "no" ? y : true))
						}
					}
					if(b[x].g("action") == "mute") {
						b[x].UpdateVolume(volume)
					}
				}
			}
			ShowOrHide()
		};
		this.Fullscreen = function() {
			var bl = FindBut("action", "fullscreen");
			if(bl) {
				bl.On();
				bl.set("scale", bl.s("scale"))
			}
			ShowOrHide();
			resizeonwidth ? setTimeout(ShowOrHide, 500) : '';
			HideInterval()
		};
		this.Normalscreen = function() {
			var bl = FindBut("action", "fullscreen");
			if(bl) {
				bl.Off()
			}
			Resize();
			clearInterval(o.toolbarInterval);
			ShowOrHide()
		};
		this.onEnded = function() {
			for(var x in b) {
				if(b.hasOwnProperty(x)) {
					if(b[x].g("action") == "play") {
						b[x].ReplayIcon()
					}
				}
			}
		};
		this.Review = function() {
			ShowOrHide()
		};
		this.closePl = function() {
			ClosePl()
		};

		function ClosePl() {
			if(playlist) {
				if(playlist.g("show") && v.playlist.autohide == 1) {
					o.controls.Playlist()
				}
			}
		}

		function ShowOrHide() {
			for(var x in b) {
				if(b.hasOwnProperty(x)) {
					if(b[x].g("action") != "buffer") {
						ShowOrHideProcessor(b[x])
					}
				}
			}
			ShowOrHideProcessor(bg);
			if(stretch_width_last != stretch_width) {
				stretch_width_last = stretch_width;
				Resize()
			}
			if(v.toolbar.hide == 1 && v.toolbar.hidedown == 1) {
				ToolbarDown(!o.starttimeout && !o.mouseHere && !o.fullscreen && o.play && v.toolbar.hidejustfull != 1 && !o.casting)
			}
		};

		function ShowForce() {
			var show = toolbarHidden && v.toolbar.hidewithoutmoving == 1;
			if(!o.play && v.toolbar.hide == 1 && v.toolbar.hideonpause == 1) {
				show = false
			}
			if(show) {
				for(var x in b) {
					if(b.hasOwnProperty(x)) {
						if(b[x].g("action") != "buffer") {
							ShowOrHideProcessor(b[x], false)
						}
					}
				}
				css(o.frame, {
					"cursor": "default"
				});
				o.fcdef = true;
				ShowOrHideProcessor(bg, false);
				if(bg.g("show")) {
					ToolbarShow()
				}
				ToolbarDown(false)
			}
		}

		function HideForce() {
			var hide = o.play && v.toolbar.hidewithoutmoving == 1 && !o.mouseDown;
			if(o.controlover && v.toolbar.showovr == 1) {
				hide = false
			}
			if(!o.play && v.toolbar.hide == 1 && v.toolbar.hideonpause == 1) {
				hide = true
			}
			if(settings) {
				if(settings.g("show") && o.setaction) {
					hide = false
				}
			}
			if(o.casting) {
				hide = false
			}
			if(hide) {
				for(var x in b) {
					if(b.hasOwnProperty(x)) {
						if(b[x].g("action") != "buffer") {
							ShowOrHideProcessor(b[x], true)
						}
					}
				}
				ShowOrHideProcessor(bg, true);
				if(!bg.g("show")) {
					toolbarHidden = true;
					o.media.ToolbarHide();
					if(o.play) {
						css(o.frame, {
							"cursor": "none"
						});
						o.fcdef = false
					}
				}
				ToolbarDown(true)
			}
		}

		function HideInterval() {
			if(v.toolbar.hidewithoutmoving == 1) {
				if(v.toolbar.hidejustfull == 1 && !o.fullscreen && !o.fullscreen_process) {} else {
					clearInterval(o.toolbarInterval);
					o.toolbarInterval = setInterval(HideForce, ((v.toolbar.hideleavetimeout > 0 ? v.toolbar.hideleavetimeout : v.toolbar.hidetimeout) * 1000))
				}
			}
		}

		function ShowOrHideProcessor(but, forcehide) {
			var hide = false;
			var show = false;
			var toolbar_hide = false;
			if(v.toolbar.hide == 1) {
				if((!o.starttimeout && !o.mouseHere && !o.fullscreen && o.play && v.toolbar.hidejustfull != 1 && !o.casting) || (o.fullscreen && toolbarHidden && !o.fcdef)) {
					hide = true;
					show = false;
					toolbar_hide = true
				} else {
					hide = false;
					show = true
				}
				if(exist(forcehide) && !o.casting) {
					hide = forcehide;
					show = !hide
				}
				if(v.toolbar.hide == 1 && v.toolbar.hidedown == 1 && (but.s("position").indexOf("controls") == 0 || but.s("action") == "line")) {
					hide = false;
					show = true
				}
				if(v.toolbar.hideonpause == 1 && !o.play) {
					hide = true;
					show = false;
					toolbar_hide = false
				}
				if(v.toolbar.showuntilmeta == 1 && !o.metadata && o.play) {
					hide = false;
					show = true
				}
			} else {
				if(but.s("hide") != 1) {
					show = true
				}
			}
			if(show && !o.fcdef) {
				css(o.frame, {
					"cursor": "default"
				});
				o.fcdef = true
			}
			var a = but.g("action");
			if(a == "custom" && but.s("position").indexOf("controls") == -1) {
				hide = false;
				show = true
			}
			if(o.casting) {
				if(a == "line") {
					if(o.media.duration() == -1) {
						hide = true;
						show = false
					}
				}
			}
			var re_y = false;
			var hp = HideProof(but);
			if(but.s("hide") == 1) {
				if(but.s("hideonleaveandplay") == 1) {
					if(toolbar_hide || forcehide || (o.play && !o.mouseHere)) {
						!toolbar_hide && !forcehide ? '' : hp = true
					}
				}
				if(but.s("hideonbar") == 1) {
					if(!toolbar_hide && !forcehide) {
						hp = true
					}
				}
				if(but.s("hidelap") == 1) {
					if(o.play && !o.mouseHere) {
						hp = true
					}
				}
				if(but.s("hideonwidth") == 1 || but.s("hideoverwidth") == 1 || but.s("hideonfullscreen") == 1) {
					resizeonwidth = true
				}
			}
			if(hp) {
				hide = true;
				show = false
			} else {
				!hide ? show = true : ''
			}
			if(but.s("action") == "volume") {
				if(but.s("hide") == 1 && but.s("hideoutmute") == 1) {
					hide = true;
					show = false;
					if(!toolbar_hide && (o.hidden_volume_over || o.hidden_volume_over_process) && !forcehide && but.s("hiddenwidth") != 1) {
						hide = false;
						show = true
					} else {
						re_y = true
					}
				}
			}
			if(o.nativecontrols || (!o.start && v.toolbar.hide == 1 && v.toolbar.hideuntilstarted == 1) || (!o.metadata && v.toolbar.hide == 1 && v.toolbar.hideuntilmeta == 1)) {
				if(but.s("position").indexOf("controls") > -1 || but.s("position").indexOf("bottom") > -1) {
					hide = true;
					show = false
				}
				if(v.toolbar.hidejustfull == 1 && !o.fullscreen) {
					hide = false;
					show = true
				}
			}
			if(settings) {
				if(settings.g("show") && v.settings.always != 1) {
					toolbar_hide = false;
					forcehide = false
				}
			}
			if(playlist && o.droplist) {
				if(v.playlist.dropopen == 1) {
					if(o.droplist.Visible()) {
						return
					}
				}
			}
			if(a == "share") {
				if(exist(o.share)) {
					if(o.share.empty()) {
						hide = true;
						show = false;
						but.set("animation", "none")
					}
				}
			}
			if(a == "playlist" || a == "next" || a == "prev" || but.s("hidewithoutplaylist") == 1) {
				if(playlist) {
					if(playlist.empty() && but.s("hidewithoutplaylist") != 0) {
						hide = true;
						show = false;
						but.set("animation", "none")
					}
				} else {
					hide = true;
					show = false
				}
			}
			if(o.hideall == 1) {
				hide = true;
				show = false
			}
			if(re_y) {
				var cc = ControlCoordinate(but);
				if(cc) {
					cc.y > 0 ? but.set("y0", cc.y) : '';
					css(but.c(), {
						"position": "absolute",
						"top": but.g("y0")
					})
				}
			}
			if(hide) {
				HideControl(but, (firstly ? true : false))
			}
			if(show) {
				ShowControl(but)
			}
			if(but == bg) {
				if(!hide && show) {
					ToolbarShow();
					show2(bg2);
					toolbarHidden = false;
					uijs == 0 ? js("ui", 1) : '';
					uijs = 1;
					o.cut && o.cutted ? o.cut.show() : ''
				}
				if(hide && !show && !o.casting) {
					o.media.ToolbarHide();
					SettingsClose();
					hide2(bg2);
					toolbarHidden = true;
					uijs == 1 ? js("ui", 0) : '';
					uijs = 0;
					o.cut && o.cutted ? o.cut.hide() : ''
				}
				if(playlist) {
					if(v.playlist.always == 1 && !playlist.empty()) {
						if(show || o.nativecontrols) {
							if(v.playlist.alwaysnotfullscreen == 1 && o.fullscreen) {} else {
								if(!playlist.g("show")) {
									if(v.playlist.alwaysjustpause == 1) {
										!o.play ? playlist.show() : ''
									} else {
										playlist.show()
									}
								}
							}
						} else {
							if(hide && playlist.g("show")) {
								playlist.hide()
							}
						}
					}
				}
			}
		};

		function HideProof(but) {
			var x = false;
			var a = but.g("action");
			if(but.s("hide") == 1) {
				if(but.s("hideonplay") == 1) {
					o.play ? x = true : ''
				}
				if(but.s("hideonpause") == 1) {
					!o.play ? x = true : ''
				}
				if(but.s("hdnn") == 1) {
					x = true
				} else {
					if(but.s("hideondesktop") == 1) {
						if(o.system.desktop) {
							but.set("hdnn", 1);
							x = true
						}
					}
					if(but.s("hideonmobile") == 1) {
						if(o.system.mobile) {
							but.set("hdnn", 1);
							x = true
						}
					}
				}
				if(but.s("hideoverwidth") == 1) {
					if(o.screen_w > but.s("hideoverwidthlimit")) {
						but.set("hiddenwidth", 1);
						x = true
					} else {
						but.set("hiddenwidth", 0)
					}
				}
				if(but.s("hideunwait") == 1 && !waiting) {
					x = true;
					o.wtcntrl = 1
				}
				if(but.s("hideonwidth") == 1) {
					if(o.screen_w <= but.s("hideonwidthlimit")) {
						but.set("hiddenwidth", 1);
						x = true
					} else {
						but.set("hiddenwidth", 0)
					}
				}
				if(but.s("hideafterstart") == 1) {
					o.start ? x = true : ''
				}
				var t = o.media.time();
				var d = o.media.duration();
				if(but.s("hideafter") == 1 && but.s("hideaftersec") > 0) {
					if(t >= but.s("hideaftersec")) {
						x = true
					}
				}
				if(but.s("hidebefore") == 1 && but.s("hidebeforesec") > 0) {
					if(t < but.s("hidebeforesec")) {
						x = true
					}
				}
				if(but.s("hidebefore2") == 1 && but.s("hidebeforesec2") > 0) {
					if(t < d - but.s("hidebeforesec2") || d == 0) {
						x = true
					}
				}
				if(but.s("hidelastpl") == 1) {
					if(playlist) {
						if(!playlist.PlaylistNextExist()) {
							x = true
						}
					}
				}
				if(but.s("hide0timestore") == 1) {
					if(o.start || !o.continue || o.media.isLive()) {
						x = true
					}
					if(o.continue) {
						if(o.continue.flag().t == 0) {
							x = true
						}
					}
				}
				if(but.s("hideuntilstarted") == 1) {
					!o.start ? x = true : ''
				}
				if(but.s("hideuntilto") > 0) {
					x = true
				}
				if(but.s("hideonvar") == 1) {
					if(exist(but.s("hidevar"))) {
						options[but.s("hidevar")] ? x = true : ''
					}
				}
				if(but.s("hideuntiltext") == 1) {
					if(!exist(but.s("customtext"))) {
						x = true
					}
				}
				if(but.s("hidewovar") == 1) {
					if(exist(but.s("hidevar2"))) {
						!options[but.s("hidevar2")] ? x = true : ''
					}
				}
				if(but.s("hideuntilstartedios") == 1 && o.system.ios) {
					!o.start || o.newfile ? x = true : ''
				}
				if(but.s("hideuntilended") == 1) {
					!o.media.ended() ? x = true : ''
				}
				if(but.s("hideonvod") == 1) {
					!o.media.isLive() ? x = true : ''
				}
				if(but.s("hideonleave") == 1) {
					!o.mouseHere ? x = true : ''
				}
				if(but.s("hidenormscreen") == 1) {
					!o.fullscreen ? x = true : ''
				}
				if(but.s("hideonfullscreen") == 1) {
					o.fullscreen ? x = true : ''
				}
				if(but.s("hideonunmute") == 1) {
					!o.muted ? x = true : ''
				}
				if(but.s("hideonlive") == 1) {
					o.media.isLive() && o.media.currentFile().indexOf("?DVR") == -1 ? x = true : ''
				}
				if(but.s("hidewithposter") == 1) {
					isVisible(o.poster) ? x = true : ''
				}
				if(but.s("hideuntilmeta") == 1) {
					!o.metadata ? x = true : ''
				}
				if(but.s("hideonmeta") == 1) {
					o.metadata ? x = true : ''
				}
				if(but.s("hidemini") == 1) {
					o.mini ? x = true : ''
				}
				if(but.s("hidenomini") == 1) {
					!o.mini ? x = true : ''
				}
				if(but.s("hideafterclick") == 1) {
					if(but.g("clicked")) {
						x = true
					}
				}
				if(but.s("hidenoab") == 1) {
					!o.ab ? x = true : ''
				}
				if(but.s("hideab") == 1) {
					o.ab ? x = true : ''
				}
				if(but.s("hideonyoutube") == 1) {
					if(v.preload == 1 && v.screenclick == 1) {
						if(o.file_type == "youtube" && !exist(v.poster) && v.youtubeposter == 0) {
							if(!o.start || o.media.status() == "ended") {
								if(v.poster == '') {} else {
									x = true
								}
							}
						}
					}
				}
			}
			if(a == "custom") {
				var lu = but.s("linkurl");
				if(lu) {
					if(lu == "api:airplay" || lu == "airplay") {
						if(!o.airplay && !o.airplayed) {
							x = true
						}
					}
					if(lu == "api:pipwebkit") {
						if(!o.pipwebkit || (!o.start && v.preload == 0)) {
							x = true
						}
					}
					if(lu == "api:unfixing") {
						if(!o.mini) {
							x = true
						}
					}
					if(lu.indexOf("captions") > -1) {
						if(!o.captions) {
							x = true
						}
					}
					if(indOf([lu], "skip") && !indOf([lu], "js:") && but.s("hdnn") != 1) {
						var sk = false;
						if(exist(v.skip)) {
							if(!o.skpbt) {
								typeof PluginSkip == 'function' ? o.skpbt = new PluginSkip() : ''
							}
							if(o.skpbt) {
								sk = o.skpbt.check(but)
							}
						}!sk ? x = true : ''
					}
				}
			}
			if(a == "playlist" || a == "next" || a == "prev") {
				if(playlist) {
					if(playlist.empty()) {
						x = true
					}
				} else {
					x = true
				}
			}
			if(a == "settings") {
				if(settings) {
					if(settings.empty()) {
						x = true;
						o.file_type != 'hls' ? but.set("animation", "none") : ''
					}
				} else {
					x = true
				}
			}
			if(but.g("type") == "text") {
				if(but.g("length") == 0) {
					x = true
				}
			}
			if(but.g("settings#")) {
				if(!but.g("set#visible")) {
					x = true
				}
			}
			if(but.s("chromecast") == 1) {
				var cb = document.getElementById("pjs_cast_button_" + v.id);
				if((o.media.duration() == 0 && o.media.time() == 0) || !o.tagvideo || !isVisible(cb) || !o.cast_available) {
					x = true
				}
			}
			if(but.s("hidetime") == 1) {
				!x ? but.set("hidetime", 1) : ''
			}
			if(a == "duration") {
				if(o.media.isLive()) {
					x = true
				}
			}
			if(but.g("key") == "control_start" && o.system.mobile) {
				if(o.nativecontrols && o.system.android) {
					x = true
				}
			}
			return x
		}

		function HideControl(but, quick) {
			if(but.g("show")) {
				if(o.fullscreen_process || but.s("animation") == "none" || quick) {
					but.set("display", false)
				} else {
					HideAnimate(but)
				}
				but.set("show", false)
			}
		};

		function ShowControl(but) {
			if(!but.g("show")) {
				if(but.s("animation") == "none" || o.fullscreen_process) {
					but.set("display", true);
					if(o.fullscreen_process) {
						but.set("opacity", 1)
					}
					if(but.g("action") == "volume") {
						if(o.hidden_volume) {
							HidePositionControl(but)
						}
					}
				} else {
					ShowAnimate(but)
				}
				if(but.s("action") == "volume") {
					o.controls.Volume(o.muted ? 0 : v.volume)
				}
				if(but.s("action") == "line") {
					o.actions.Loading()
				}
				but.set("show", true)
			}
		};

		function HideAnimate(but) {
			killMotion(but.g("key"));
			var m_type = "alpha|";
			var m_to = "0|";
			var hide = 1;
			var a = but.s("animation");
			if(but.s("apdra") == 1) {
				m_type = '';
				m_to = ''
			}
			var p = but.s("position");
			var scl = but.g("scaleX");
			exist2(but.s("apdr")) ? p = but.s("apdr") : '';
			if(a == "scale") {
				m_type += "scale|";
				m_to += "0|"
			}
			if(a == "position") {
				if(p.indexOf("right") > -1 && p.indexOf("controls") == -1) {
					m_type += "x|";
					m_to += int(o.screen_w + but.g("width") / 2 * scl) + "|"
				}
				if(p.indexOf("left") > -1) {
					m_type += "x|";
					m_to += int(-but.g("width") / 2) * scl + "|"
				}
				if(p.indexOf("top") > -1) {
					m_type += "y|";
					m_to += (-but.g("height") / 2) * scl + "|"
				}
				if(p.indexOf("bottom") > -1 || p.indexOf("controls") > -1 || p == "timeline") {
					m_type += "y|";
					if(but.g("action") == "line" || but.g("action") == "volume") {
						m_to += int(o.screen_h + but.s("h") + (but.s("h") < 20 ? 20 - but.s("h") : 0)) + "|"
					} else {
						m_to += int(o.screen_h + but.g("height") / 2) + "|"
					}
				}
				if(p == "center") {
					m_type += "scale|";
					m_to += "0|"
				}
			}
			var m = new Motion({
				"mc": but,
				"me": but.g("key"),
				"type": m_type.substr(0, m_type.length - 1),
				"to": m_to.substr(0, m_to.length - 1),
				"hide": hide
			})
		};

		function ShowAnimate(but) {
			killMotion(but.g("key"));
			var m_type = "";
			var m_to = "";
			var a = but.s("animation");
			var p = but.s("position");
			exist2(but.s("apdr")) ? p = but.s("apdr") : '';
			if(but.g("opacity") != 1 && but.s("apdra") != 1) {
				m_type = "alpha|";
				m_to = (but.g("key") == 'bg' ? v.toolbar.a : "1") + "|"
			}
			if(a == "scale") {
				if(but.g("scaleX") != but.s("scale")) {
					m_type += "scale|";
					m_to += but.s("scale") + "|"
				}
			}
			if(a == "position") {
				if(p == "center") {
					if(but.g("scaleX") != but.s("scale")) {
						m_type += "scale|";
						m_to += but.s("scale") + "|"
					}
				} else {
					if(p.indexOf("controls") > -1) {
						if(but.g("y") != but.g("y0")) {
							m_type += "y|";
							m_to += but.g("y0") + "|"
						}
					} else {
						m_type += "x|y|";
						m_to += but.g("x0") + "|" + but.g("y0") + "|"
					}
				}
			}
			if(m_type != "" && m_to != "") {
				var m = new Motion({
					mc: but,
					me: but.g("key"),
					type: m_type.substr(0, m_type.length - 1),
					to: m_to.substr(0, m_to.length - 1),
					show: 1
				})
			} else {
				but.set("display", true)
			}
		};
		this.Mouse = function(key, type, quick) {
			var resize = false;
			var stop = false;
			var but = b[key];
			var action = but.g("action");
			var linkurl = but.s("linkurl");
			if(type == "over") {
				if(o.hidden_volume) {
					if(action == "volume" || action == "mute" || action == "unmute") {
						o.hidden_volume_over = true;
						o.hidden_volume_over_process = true;
						resize = true;
						ShowOrHide();
						if(v.control_line.hideonvolume == 1) {
							var bl = FindBut("action", "line");
							if(bl) {
								hide2(bl.c())
							}
						}
					}
				}
				if(settings && v.settings.showovercontrol == 1 && ((action == "settings" || linkurl.indexOf("setting") == 0) || linkurl.indexOf("settings:") == 0)) {
					clearTimeout(o.settingsovertimer);
					if(!settings.g("show") || _lastactbut != but) {
						Action(but, type);
						o.overopentimeout = action + linkurl;
						setTimeout(function() {
							o.overopentimeout = null
						}, 500)
					}
				}
				if(playlist && v.playlist.showovercontrol == 1 && action == "playlist") {
					clearTimeout(o.playlistovertimer);
					if(!playlist.g("show") || _lastactbut != but) {
						Action(but, type);
						o.overopentimeout = action;
						setTimeout(function() {
							o.overopentimeout = null
						}, 500)
					}
				}
			}
			if(type == "out") {
				if(o.hidden_volume) {
					if(action == "volume" || action == "mute" || action == "unmute") {
						o.hidden_volume_over = false;
						o.hidden_volume_over_process = true;
						setTimeout(function() {
							if(!o.hidden_volume_over) {
								o.hidden_volume_over_process = false;
								if(!toolbarHidden) {
									for(var x in b) {
										if(b.hasOwnProperty(x)) {
											if(b[x].g("action") == "volume") {
												HideControl(b[x]);
												Resize()
											}
											if(b[x].g("action") == "line") {
												if(v.control_line.hideonvolume == 1) {
													show2(b[x].c())
												}
											}
										}
									}
								}
							}
						}, 500)
					}
				}
				if(action == "line") {
					o.actions.UpdatePlay(1)
				}
				if(v.settings.showovercontrol == 1 && ((action == "settings" || linkurl.indexOf("setting") == 0) || linkurl.indexOf("settings:") == 0)) {
					clearTimeout(o.settingsovertimer);
					o.settingsovertimer = setTimeout(function() {
						if(!o.mouseDown) {
							SettingsClose(1)
						}
					}, (v.settings.showoverto > 0 ? v.settings.showoverto * 1000 : 1000))
				}
				if(playlist && v.playlist.showovercontrol == 1 && action == "playlist") {
					clearTimeout(o.playlistovertimer);
					o.playlistovertimer = setTimeout(function() {
						if(!o.mouseDown) {
							playlist.g("show") ? playlist.hide(1) : ''
						}
					}, (v.playlist.showoverto > 0 ? v.playlist.showoverto * 1000 : 1000))
				}
			}
			if(resize) {
				setTimeout(Resize, 10)
			}
		};
		this.StageLeave = function() {
			if(o.volumewheel && !o.fullscreen && !o.fullscreen_process) {
				o.actions.volumewheel(false);
				o.volumewheel = false
			}
			if(o.poster) {
				if(v.poster_aover > -1 && isVisible(o.poster)) {
					css(o.poster, {
						opacity: v.poster_a
					})
				}
			}
			if(o.play && v.playonhover == 1 && v.pauseonhover != 0) {
				o.actions.Pause()
			}
			if(v.toolbar.hideleavetimeout > 0) {
				clearTimeout(o.leavetimeout);
				o.leavetimeout = setTimeout(ShowOrHide, v.toolbar.hideleavetimeout * 1000)
			} else {
				ShowOrHide()
			}
		};
		this.StageOver = function() {
			if(o.poster) {
				if(v.poster_aover > -1 && isVisible(o.poster)) {
					css(o.poster, {
						opacity: v.poster_aover
					})
				}
			}
			if(!o.play && v.playonhover == 1) {
				o.actions.Play()
			}
			ShowOrHide();
			ToolbarDown(false)
		};
		this.StageMove = function(stage_x, stage_y) {
			var y;
			for(var x in b) {
				if(b.hasOwnProperty(x)) {
					y = b[x].g("action");
					if(y == "line" || y == "volume") {
						b[x].StageMove(stage_x, stage_y)
					}
				}
			}
		};
		this.StageMove2 = function() {
			if(v.toolbar.hide == 1) {
				if(v.toolbar.hidejustfull == 1 && !o.fullscreen) {
					return
				}
				if((!o.mouseHere || o.system.mobile) && o.media.status() == "playing") {
					o.mouseHere = true;
					ShowOrHide();
					o.system.mobile ? setTimeout(function() {
						o.mouseHere = false
					}, 500) : ''
				}
				if(v.toolbar.hidewithoutmoving == 1) {
					ShowForce();
					HideInterval()
				}
				ToolbarDown(false)
			}
		};
		this.StageMouseUp = function(stage_x, stage_y) {
			for(var x in b) {
				if(b.hasOwnProperty(x)) {
					if(b[x].g("action") == "line" || b[x].g("action") == "volume") {
						b[x].StageMouseUp(stage_x, stage_y)
					}
				}
			}
		};
		this.Played = function(time, duration, upd) {
			for(var x in b) {
				if(b.hasOwnProperty(x)) {
					if(b[x].g("action") == "line") {
						b[x].UpdatePlay(time, duration, upd)
					}
					if(b[x].g("action") == "time") {
						UpdateTime(b[x], time, duration)
					}
					if(b[x].s("rotateplaying") == 1) {
						b[x].Rotate()
					}
					if(b[x].s("svgtmln") == 1) {
						b[x].Tmln(time, duration)
					}
					if(b[x].s("often") == 1) {
						if(!b[x].g("show") && toolbarHidden) {} else if(b[x].g("show") == HideProof(b[x])) {
							ShowOrHide()
						}
					}
				}
			}
		};

		function ToolbarDown(x) {
			if(v.toolbar.hide == 1) {
				x ? SettingsClose() : '';
				if(v.toolbar.hidedown == 1) {
					if(!o.play && v.toolbar.hideonpause == 1) {
						x = true
					}
					if(x && !o.toolbarisdown) {
						css(o.toolbar, {
							"top": bg.h()
						})
					}
					if(!x && o.toolbarisdown) {
						css(o.toolbar, {
							"top": 0
						})
					}
					o.toolbarisdown = x
				}
			}
		}

		function ToolbarShow() {
			toolbarHidden = false;
			o.media.ToolbarShow();
			if(o.resizeonmouse) {
				o.resizeonmouse = false;
				Resize();
				setTimeout(Resize, 300)
			}
		}

		function UpdateTime(x, time, duration) {
			if(v.delete > 0) {
				time -= v.delete;
				duration -= v.delete
			}
			var y = Time(time);
			if(x.s("inversetime") == "1") {
				y = Time(duration - time)
			}
			if(x.s("showduration") == "1") {
				if(x.s("showboth") == "1") {
					y = y + (duration > 0 ? ' ' + Lang(x.s("separator")) + ' ' + Time(duration) : '')
				} else {
					time == 0 ? y = Time(duration) : ''
				}
			}
			x.UpdateText(y)
		}
		this.Loaded = function(time, duration) {
			var x = FindBut("action", "line");
			if(x) {
				x.UpdateLoad(time, duration)
			}
		};
		this.Cut = function(y) {
			if(o.media.duration() > 0) {
				var x = FindBut("action", "line");
				if(x) {
					x.Cut(y)
				}
			}
		};
		this.Waiting = function() {
			if(!waiting) {
				if(v.hidevideo == 1) {
					clearTimeout(wait_to);
					wait_to = setTimeout(Waiting, 500)
				} else {
					Waiting()
				}
			}
		};

		function Waiting() {
			if(!waiting) {
				js("buffering");
				waiting = true;
				var x = FindBut("action", "buffer");
				if(x) {
					x.Buffer();
					if(v.posteronwait == 1 && o.play) {
						clearTimeout(o.wtpstr_to);
						o.wtpstr_to = setTimeout(WaitPoster, (v.pstrwt > 0 ? v.pstrwt : 1) * 1000)
					}
				}
				o.wtcntrl ? ShowOrHide() : ''
			}
		}

		function WaitPoster() {
			if(o.play && waiting) {
				o.actions.ShowPoster()
			}
		}
		this.HideElement = function(y) {
			for(var x in b) {
				if(x == y) {
					b[x].set("hide2")
				}
			}
		};
		this.StopWaiting = function(time, duration) {
			clearTimeout(wait_to);
			if(waiting) {
				js("buffered");
				var x = FindBut("action", "buffer");
				if(x) {
					x.BufferStop();
					if(v.posteronwait == 1 && o.play) {
						o.actions.HidePoster()
					}
				}
				waiting = false;
				o.wtcntrl ? ShowOrHide() : ''
			}
		};
		this.volumescroll = function() {
			var x = FindBut("linkurl", "volume scroll");
			if(x) {
				x.set("show2");
				x.UpdateText(Lang('volume') + ' ' + (o.muted ? 0 : Math.ceil(v.volume * 100)) + '%');
				clearTimeout(o.volumescroll);
				o.volumescroll = setTimeout(Volumescrolled, 1000)
			}
		};

		function Volumescrolled() {
			var x = FindBut("linkurl", "volume scroll");
			if(x) {
				x.UpdateText('');
				x.set("hide2");
				clearTimeout(o.volumescroll)
			}
		}
		this.Seek = function(time, duration) {
			if(v.delete > 0) {
				time -= v.delete;
				duration -= v.delete
			}
			for(var x in b) {
				if(b.hasOwnProperty(x)) {
					if(b[x].s("on") == 1) {
						if(b[x].g("action") == "line") {
							duration > 0 ? b[x].set("click", time / duration) : '';
							b[x].UpdatePlaySeek()
						}
						if(b[x].g("action") == "time") {
							UpdateTime(b[x], time, duration)
						}
						if(b[x].g("action") == "live") {
							b[x].set("iconopacity", 0.5);
							b[x].set("saturate", 0)
						}
					}
				}
			}
		};
		this.Duration = function(time, duration) {
			for(var x in b) {
				if(b.hasOwnProperty(x)) {
					if(b[x].g("action") == "duration") {
						if(v.delete > 0) {
							duration -= v.delete
						}
						b[x].UpdateText(Time(duration))
					}
					if(b[x].g("action") == "line") {
						b[x].UpdatePlay(time, duration);
						b[x].PlacePoints(duration)
					}
					if(b[x].g("action") == "time") {
						UpdateTime(b[x], time, duration)
					}
				}
			}
		};
		this.Settings = function() {
			if(!o.settings2) {
				settings.g("show") ? settings.hide() : settings.show()
			}
		};
		this.SettingsVisible = function() {
			if(settings) {
				if(o.settings2) {
					return o.settings2.isVisible()
				} else {
					return settings.g("show") ? true : false
				}
			} else {
				return false
			}
		};
		this.MenuProc = function(x) {
			if(settings) {
				settings.menuproc(x)
			}
		};
		this.SettingsClose = function() {
			SettingsClose()
		};
		this.SettingsTimer = function(x) {
			if(settings) {
				settings.UpdateTimer(x)
			}
		};
		this.SettingsSpeed = function() {
			if(settings) {
				settings.UpdateSpeed()
			}
		};
		this.SettingsExist = function(x) {
			if(settings) {
				return settings.Exist(x)
			}
		};

		function SettingsClose(x) {
			if(settings) {
				settings.g("show") ? settings.hide(x) : ''
			}
			o.settings2 ? o.settings2.hide() : ''
		};
		this.Playlist = function() {
			if(playlist) {
				if(playlist.g("show")) {
					playlist.hide(1)
				} else {
					playlist.show()
				}
			}
		};
		this.PlaylistShow = function(x) {
			if(playlist) {
				if(playlist.g("show") && x != 1) {
					x != 2 ? playlist.hide() : ''
				} else {
					setTimeout(function() {
						playlist.show()
					}, 100)
				}
			}
		};
		this.PlaylistVisible = function() {
			if(playlist) {
				return playlist.g("show") ? true : false
			} else {
				return false
			}
		};
		this.PlaylistG = function(x) {
			return playlist ? playlist.g(x) : ''
		};
		this.UpdatePlaylist = function(x) {
			if(playlist) {
				playlist.updatePlaylist(x)
			}
		};
		this.PreNewPl = function(x) {
			if(playlist) {
				playlist.prenewpl(x)
			}
		};
		this.PlaylistNext = function() {
			if(playlist) {
				playlist.PlaylistNext()
			}
		};
		this.PlaylistHere = function() {
			if(playlist) {
				playlist.PlaylistHere()
			}
		};
		this.PlaylistControls = function() {
			PlaylistControls()
		};

		function PlaylistControls() {
			for(var x in b) {
				if(b.hasOwnProperty(x)) {
					if(b[x].g("action") == "next") {
						css(b[x].c(), {
							"opacity": (!playlist.PlaylistNextExist() ? 0.5 : 1)
						})
					}
					if(b[x].g("action") == "prev") {
						css(b[x].c(), {
							"opacity": (!playlist.PlaylistPrevExist() ? 0.5 : 1)
						})
					}
				}
			}
		}
		this.PlaylistNextExist = function() {
			if(playlist) {
				return playlist.PlaylistNextExist()
			} else {
				return false
			}
		};
		this.PlaylistPrevExist = function() {
			if(playlist) {
				return playlist.PlaylistPrevExist()
			} else {
				return false
			}
		};
		this.PlaylistExist = function() {
			if(playlist) {
				return playlist.PlaylistExist()
			} else {
				return false
			}
		};
		this.PlaylistRewind = function() {
			if(playlist) {
				playlist.PlaylistRewind()
			}
		};
		this.PlaylistPrev = function() {
			if(playlist) {
				playlist.PlaylistPrev()
			}
		};
		this.PlaylistPlayId = function(x) {
			if(x && playlist) {
				playlist.playById(x)
			}
		};
		this.PlaylistOpenId = function(x) {
			if(x && playlist) {
				playlist.openById(x)
			}
		};
		this.PlaylistMove = function(x) {
			if(x && playlist) {
				css(playlist.co(), {
					"maxHeight": "none",
					"padding-right": playlist.s("bgpaddingright")
				});
				document.getElementById(x).appendChild(playlist.co());
				hide2(playlist.c())
			}
		};
		this.ShowSettingsBut = function() {};
		this.QualityChanged = function(x) {
			if(settings) {
				settings.SetQuality();
				settings.g("show") ? setTimeout(function() {
					settings.hide()
				}, 200) : ''
			}
		};
		this.QualityChangedNoHand = function() {
			if(settings) {
				settings.SetQuality()
			}
			if(o.settings2) {
				o.settings2.update()
			}
		};
		this.AirplayChanged = function(x) {
			if(settings) {
				settings.Airplay()
			}
			Resize();
			ShowOrHide()
		};
		this.SettingChanged = function(x) {
			if(settings) {
				settings.SetSetting(x);
				settings.g("show") ? settings.hide() : ''
			}
			if(o.settings2) {
				o.settings2.update()
			}
			x == "speed" ? SpeedChanged() : ''
		};

		function SpeedChanged() {
			if(o.line_speed) {
				var x = parseFloat(o.custom_speed / o.files_speed.slice(-1)[0], 1).toFixed(2);
				for(var i in b) {
					if(b.hasOwnProperty(i)) {
						if(b[i].s("customline") == "speed" && o.custom_speed) {
							b[i].UpdatePlay(x, 1)
						}
						if(b[i].s("linkurl") == "api:speed,1.0") {
							b[i].UpdateVolume(x)
						}
					}
				}
			}
		}
		this.AudioTrackChangedNoHand = function(x) {
			if(settings) {
				settings.SetSetting("audiotrack")
			}
			if(o.settings2) {
				o.settings2.update()
			}
		};
		this.SubtitleChanged = function() {
			if(settings) {
				settings.SetSubtitle();
				settings.g("show") ? setTimeout(function() {
					settings.hide()
				}, 200) : ''
			}
			if(o.settings2) {
				o.settings2.update()
			}
			if(o.casting && o.tagvideo) {
				o.chromecast.Sub()
			}
		};
		this.SubOpt = function() {
			o.settings2 ? o.settings2.hide() : '';
			if(settings) {
				settings.SubOpt()
			}
		};
		this.SettingsN = function(num, display, val) {
			for(var x in b) {
				if(b.hasOwnProperty(x)) {
					if(b[x].g("action") == "settings") {
						if(b[x].s("hdicon") == 1) {
							b[x].HdIcon()
						}
					}
					if(b[x].g("action_settings") == "settings#" + num) {
						b[x].set("set#visible", display);
						if(b[x].g("type") == "text") {
							if(val) {
								b[x].UpdateText(NoSpan(val))
							}
						} else {
							if(v.settings['settings' + num + 'action'] == "subtitle") {
								if(val == Lang("off")) {
									b[x].CustomSwitch(0)
								} else {
									b[x].CustomSwitch(1)
								}
							}
							Resize()
						}
						ShowOrHideProcessor(b[x])
					}
				}
			}
		};
		this.UpdateSettings = function() {
			if(settings) {
				settings.SetQuality();
				settings.SetSetting("audiotrack");
				settings.SetSetting("download")
			}
		};
		this.RenewPoints = function() {
			var x = FindBut("action", "line");
			if(x) {
				x.RenewPoints()
			}
		};
		this.resize = function() {
			Resize();
			if(toolbarHidden) {
				o.resizeonmouse = true
			}
		};
		this.resizeFromText = function(x) {
			if(!toolbarHidden || x == 1) {
				Resize();
				ShowOrHide()
			} else {
				v.toolbar.resizeme = true
			}
		};
		this.startcss = function() {
			var b = FindBut("type", "css");
			if(b) {
				b.setcss()
			}
		};
		this.refresh = function() {
			ShowOrHide();
			Resize();
			ShowOrHide();
			if(o.nativecontrols) {
				hide2(bg2)
			} else {
				!toolbarHidden ? show2(bg2) : ''
			}
		};
		this.KeyDown = function(event) {
			if(pljssglobalid == v.id && v.hotkey.on == 1) {
				var x = event.which;
				var y = false;
				if(x == undefined) {
					x = event.keyCode
				}
				if(exist(o.vast) || exist(o.pass) || o.stopkeys == 1) {
					return false
				}
				if(o.play && v.hotkey.onplay == 1) {
					y = true
				}
				if(((v.hotkey.space == 1 && x == 32) || (v.hotkey.enter == 1 && x == 13)) && (o.focus || o.mouseHere || y)) {
					if(v.hotkey.icons == 1) {
						PluginHotIcon('play', o.play ? 0 : 1)
					}
					o.actions.Toggle();
					event.preventDefault();
					return false
				}!v.hotkey.vol ? v.hotkey.vol = 0.2 : '';
				!v.hotkey.scale ? v.hotkey.scale = 5 : '';
				if(v.hotkey.nums == 1 && (o.focus || y)) {
					if(o.media.duration() > 0) {
						for(var i = 48; i < 58; i++) {
							if(x == i) {
								o.actions.Seek((o.media.duration() * (x - 48) * 10) / 100, true)
							}
						}
					}
				}
				if(x == 39 && (o.focus || y)) {
					KeyPlusUp(v.hotkey.leftright)
				}
				if(x == 37 && (o.focus || y)) {
					KeyPlusDown(v.hotkey.leftright)
				}
				if(x == 38 && (o.focus || y)) {
					KeyPlusUp(v.hotkey.updown)
				}
				if(x == 40 && (o.focus || y)) {
					KeyPlusDown(v.hotkey.updown)
				}
				if(x == 187 && (o.focus || y)) {
					KeyPlusUp(v.hotkey.plusminus)
				}
				if(x == 189 && (o.focus || y)) {
					KeyPlusDown(v.hotkey.plusminus)
				}
			}
		};

		function FindBut(y, z) {
			for(var x in b) {
				if(b.hasOwnProperty(x)) {
					if(b[x].s(y) == z) {
						return b[x]
					}
				}
			}
		}

		function KeyPlusUp(x) {
			if(x == "next") {
				if(o.playlist) {
					o.controls.PlaylistNext()
				} else {
					x = "seek"
				}
			}
			if(x == "seek") {
				if(o.media.duration() > 0) {
					if(o.media.time() + parseFloat(v.hotkey.seek) < o.media.duration()) {
						o.actions.Seek(o.media.time() + parseFloat(v.hotkey.seek), true)
					}
				}
			}
			if(x == "volume") {
				o.actions.Volume(parseFloat(v.volume) + parseFloat(v.hotkey.vol));
				event.preventDefault()
			}
			if(x == "scale") {
				o.media.scale(v.hotkey.scale / 100);
				event.preventDefault()
			}
			if(v.hotkey.icons == 1) {
				PluginHotIcon(x, 1)
			}
		}

		function KeyPlusDown(x) {
			if(x == "next") {
				if(o.playlist) {
					o.controls.PlaylistPrev()
				} else {
					x = "seek"
				}
			}
			if(x == "seek") {
				if(o.media.duration() > 0 && o.start) {
					o.actions.Seek((o.media.time() - v.hotkey.seek >= 0 ? o.media.time() - v.hotkey.seek : 0), true)
				}
			}
			if(x == "volume") {
				o.actions.Volume(parseFloat(v.volume) - parseFloat(v.hotkey.vol));
				event.preventDefault()
			}
			if(x == "scale") {
				o.media.scale(-v.hotkey.scale / 100);
				event.preventDefault()
			}
			if(v.hotkey.icons == 1) {
				PluginHotIcon(x, 0)
			}
		};
		this.KeyUp = function(event) {
			if(pljssglobalid == v.id) {
				var x = event.which;
				if(x == undefined) {
					x = event.keyCode
				}
				if(x == 57) {
					if(v.log == 1) {}
				}
				if(o.fullscreen && x == 27) {
					o.actions.Normalscreen()
				}
				if(exist(o.vast) || exist(o.pass)) {
					return false
				}
				if(v.hotkey.f == 1 && x == 70 && v.hidevideo != 1 && (o.focus || o.mouseHere)) {
					if(v.hotkey.icons == 1) {
						PluginHotIcon('fullscreen', o.fullscreen ? 0 : 1)
					}
					o.fullscreen ? o.actions.Normalscreen() : o.actions.Fullscreen()
				}
				if(v.hotkey.m == 1 && x == 77 && (o.focus || o.mouseHere)) {
					if(v.hotkey.icons == 1) {
						PluginHotIcon('mute', o.muted ? 1 : 0)
					}
					o.muted ? o.actions.Unmute() : o.actions.Mute()
				}
			}
		};
		this.Remove = function() {
			clearInterval(o.toolbarInterval);
			for(var x in o) {
				if(x.indexOf("control") == 0 && x.indexOf("Interval") > -1) {
					clearInterval(o[x])
				}
			}
			for(var i = 0; i < butNames.length; i++) {
				key = butNames[i];
				if(b[key]) {
					b[key].Remove()
				}
			}
			if(settings) {
				settings.Remove()
			}
			if(playlist) {
				playlist.Remove()
			}
			bg.Remove();
			if(bg2.parentNode == o.frame) {
				o.frame.removeChild(bg2)
			} else {
				o.toolbar ? o.toolbar.removeChild(bg2) : ''
			}
		};
		this.ShowForce = function() {
			ShowForce()
		};
		this.HideForce = function() {
			HideForce();
			ShowOrHide()
		};
		this.HideInterval = function() {
			HideInterval()
		};
		this.ToolbarHidden = function() {
			return toolbarHidden
		}
	};
	var Control = function(key) {
		var i;
		var style = [];
		var w;
		var h;
		var last_text_w = 0;
		var bg;
		var bgcontainer;
		var area;
		var angle = 0;
		var visible = true;
		var selectOpen = false;
		var scaleX = 1;
		var scaleY = 1;
		var tip;
		var tipbg;
		var tiptext;
		var tipcrn;
		var action;
		var actionstt = '';
		var x0;
		var y0;
		var on;
		var over = false;
		var touchmove = false;
		var iconangle = 0;
		var bufferInterval;
		var bufferDeg = 0;
		var rightside = 0;
		var topside = 0;
		var bottomside = 0;
		var noclick = false;
		var zoomed = false;
		var clicked = false;
		var hidden = false;
		var htto;
		var hdicon;
		var imgldd;
		var settingsNumberVisible = false;
		style = UpdateObject(style, default_style.but);
		style = UpdateObject(style, v[key]);
		var actions = [style.action];
		action = actions[0];
		exist(style.action2) ? actions[1] = style.action2 : '';
		exist(style.opposite) ? actions[1] = style.opposite : '';
		exist(style.title) ? style.text = style.title : '';
		if(exist2(style.scalesmall)) {
			o.small ? style.scale = style.scalesmall : ''
		}
		if(action == "share") {
			o.shareme = true
		}
		if(exist(style.linkurl)) {
			if(style.type == "text" && style.linkurl != '') {
				if(exist(v[style.linkurl + 'text'])) {
					style.text = v[style.linkurl + 'text']
				}
			}
			if(style.linkurl.indexOf("settings#") == 0) {
				actionstt = style.linkurl;
				if(style.tiptext == '' && actionstt.indexOf(",") == -1) {
					style.tiptext = Lang(v.settings['settings' + actionstt.substr(9) + 'action'])
				}
			}
			if(style.linkurl.indexOf("captions") > -1) {
				v.hlscaptions = true
			}
			if(style.linkurl.indexOf("share:") > -1) {
				o.shareme = true
			}
			if(style.linkurl == "countdown") {
				style.counter = new PluginCountdown(style)
			}
		}
		var tips = style.tiptext ? style.tiptext.split("///") : [];
		if(style.liketext == 1) {
			style.type = "text";
			style.text = TipText(0) + (actions.length > 1 ? '///' + TipText(1) : '');
			if(exist2(style.iconscolor)) {
				style.color = style.iconscolor
			}
		}
		style.it = [];
		style.il = [];
		var _currentIcon = 0;
		var icons = new Array();
		var icon = new Array();
		var iconsover = new Array();
		var iconspress = new Array();
		var iconreplay = 0;
		var replay;
		if(style.type == "text") {
			if(style.dom) {
				if(exist(v[style.dom + 'text'])) {
					style.text = v[style.dom + 'text']
				}
			}
			if(exist(style.text)) {
				icons[0] = trim(style.text);
				style.lngth = style.text.length;
				var smbls = ['/', '|', '-'];
				smbls.indexOf(style.text.substr(-1)) > -1 ? style.postsmbl = style.text.substr(-1) : '';
				smbls.indexOf(style.text.substr(0, 1)) > -1 ? style.presmbl = style.text.substr(0, 1) : '';
				if(action == "time" || action == "duration") {
					if(style.text.indexOf('0:') == 0) {
						style.timeshort = true
					}
					if(style.text.split(":").length == 3) {
						style.with_hours = true
					} else {
						if(style.text.indexOf('00:00') > -1) {
							style.with_min = true
						}
					}
					if(style.dvrtime == 1) {
						v.dvrtime = 1
					}
				}
				if(style.inversetime == 1 && style.text.indexOf("-") == 0) {
					style.minus4back = true
				}
				if(style.text.indexOf("///") > 0 && (action == "custom" || style.liketext == 1)) {
					style.texts = style.text.split("///");
					style.text = icons[0] = style.texts[0]
				}
			}
			if(v.fonts == 1) {
				setTimeout(ResizeText, 100);
				setTimeout(ResizeText, 500);
				setTimeout(ResizeText, 1000)
			}
		} else {
			if(exist(style.icon)) {
				icons[0] = style.icon;
				if(icons[0].indexOf("///") > 0 && icons[0].indexOf("base64") == -1) {
					icons = style.icon.split("///")
				}
				if(exist(style.icon2)) {
					icons[1] = style.icon2
				}
				if(style.iconsreplay == 1) {
					if(exist2(style.icon3)) {
						icons.push(style.icon3);
						iconreplay = icons.length - 1
					}
				}
			}
		}
		if(action == "custom") {
			if(style.link2 == 1 && exist(style.linkurl2)) {
				style.linkurl0 = style.linkurl
			}
		}
		var control = createElement("div");
		if(style.position == 'timeline') {
			o.timeline ? o.timeline.appendChild(control) : setTimeout(function() {
				o.timeline.appendChild(control)
			}, 100)
		} else {
			if(style.position.indexOf('controls') > -1 && v.toolbar.hide == 1 && v.toolbar.hidedown == 1) {
				o.toolbar.appendChild(control)
			} else {
				o.frame.appendChild(control)
			}
			if(action == "buffer" && style.ontop2 == 1) {
				control.style.zIndex = 2001
			}
		}
		if(style.svgtmln == 1) {
			style.tmln = new PlgnCntrlTmln(style, control)
		}
		var bgcontainer = createElement("div");
		control.appendChild(bgcontainer);
		var icns = createElement("div");
		css(icns, {
			"position": "absolute",
			"left": 0,
			"top": 0
		});
		control.appendChild(icns);
		css(control, {
			"position": "absolute",
			"left": 0,
			"top": 0,
			"opacity": 1,
			"fontSize": "14px",
			"lineHeight": "1em"
		});
		if(exist2(style.dom)) {
			attr(control, {
				"id": (v.id + "_" + "control_" + style.dom)
			})
		}
		if(style.rotateplaying == 1) {
			css(icns, {
				"transition": "transform 0.2s linear"
			})
		}
		if(icons.length > 0) {
			for(i = 0; i < icons.length; i++) {
				icon[i] = createElement("div");
				css(icon[i], {
					"position": "absolute",
					"top": 0,
					"left": 0,
					"pointerEvents": "none",
					"opacity": style.a,
					"transition": "opacity 0.1s linear,transform 0.1s linear"
				});
				if(style.type == "pic" && style.src != '') {
					if(exist2(style.dom)) {
						attr(icon[i], {
							"id": (v.id + "_control_" + style.dom + "_icon")
						});
						if(v[style.dom + 'src']) {
							style.src = v[style.dom + 'src']
						}
					}
					if(style.src.indexOf(".png") > -1 || style.src.indexOf(".jpg") > -1 || style.src.indexOf(".gif") > -1 || style.src.indexOf("base64") > -1) {
						style.src.indexOf("//") == -1 && style.src.indexOf("base64") == -1 ? style.src = '//' + style.src : '';
						var z = createElement("img");
						style.loading = 1;
						z.addEventListener("load", imageLoaded);
						z.src = style.src;
						icon[i].appendChild(z);
						style.w = icon[i].offsetWidth;
						style.h = icon[i].offsetHeight;
						if(style.picheight > 0) {
							css(z, {
								height: style.picheight
							})
						}
					}
				}
				if(style.type == "text") {
					css(icon[i], {
						"color": (style.color),
						"fontSize": style.fontsize * existv(v.globalfs, 1),
						"fontFamily": checkFont(style.font),
						"letter-spacing": style.letterspacing + 'px',
						"padding": "0 3px 0 3px",
						"white-space": "nowrap"
					});
					if(o.small) {
						if(exist2(style.fontsizesmall)) {
							css(icon[i], {
								"fontSize": style.fontsizesmall * existv(v.globalfs, 1),
							})
						}
					}
					if(style.click == 1) {
						if(style.text.indexOf("<a ") > -1 || key == "control_title") {
							css(icon[i], {
								"pointerEvents": "auto"
							})
						}
					}
					if(style.bold == 1) {
						css(icon[i], {
							"font-weight": "bold"
						})
					}
					if(style.lineh) {
						css(icon[i], {
							"lineHeight": style.lineh + "em"
						})
					}
					icons[i] == 'live' ? icons[i] = Lang("live") : '';
					icon[i].innerHTML = Places(icons[i]);
					setTimeout(Marquee, 100);
					style.w = icon[i].offsetWidth;
					style.h = icon[i].offsetHeight;
					if(exist2(style.dom)) {
						attr(icon[i], {
							"id": (v.id + "_control_" + style.dom + "_text")
						})
					}
				}
				if(style.type == "css") {
					o.start ? setTimeout(SetCSS, 200) : ''
				}
				var icn = icons[i].toString();
				if(icn.indexOf('var:') == 0) {
					icn = existv(window[icn.substr(4)], '')
				}
				var isvg = icn.indexOf('<svg') > -1 || icn.indexOf('<SVG') > -1;
				if(style.type == "svg" && (icn.indexOf('<g>') > -1 || isvg)) {
					if(action == "mute" || action == "custom") {
						icn = icn.replace(/pjs_/g, 'pjs_' + v.id + key)
					}
					if(icn.indexOf('pointer') > -1) {
						Clickable(icon[i])
					}
					icon[i].innerHTML = (!isvg ? "<svg width='20' height='20' xmlns:xlink='http://www.w3.org/1999/xlink' xmlns='http://www.w3.org/2000/svg'>" : '') + icn + (!isvg ? "</svg>" : '');
					icon[i].offsetWidth > 20 ? style.w = icon[i].offsetWidth : '';
					icon[i].offsetHeight > 20 ? style.h = icon[i].offsetHeight : '';
					css(icon[i], {
						"width": style.w,
						"height": style.h
					});
					if(style.iconscolor != -1) {
						IconsColor(icon, style.iconscolor)
					}
					if(exist2(style.dom)) {
						attr(icon[i], {
							"id": (v.id + "_control_" + style.dom + "_icon" + i)
						})
					}
				}
				icns.appendChild(icon[i]);
				i > 0 ? hide(icon[i]) : ''
			}
			Background();
			imgldd ? imageLoaded() : '';
			if(style.linkurl == "chromecast") {
				style.chromecast = 1;
				style.hide = 1;
				o.chromecast ? icon[0].innerHTML = o.chromecast.button(style.iconscolor != -1 ? style.iconscolor : '#ffffff') : '';
				if(o.system.mobile) {
					icon[0].ontouchstart = onMobOver;
					icon[0].ontouchend = onOut;
					icon[0].ontouchmove = onMobMove
				} else {
					icon[0].onmouseover = onOver;
					icon[0].onmouseout = onOut;
					icon[0].onmousemove = onMove
				}
			} else {
				if((bg.offsetWidth * style.scale < 35 || bg.offsetHeight * style.scale < 35) && style.type != 'text') {
					ClickArea();
					Clickable(area)
				} else {
					Clickable(bg)
				}
			}
			if(action == "custom") {
				var lu = '';
				if(style.link == 1 && exist(style.linkurl)) {
					lu = style.linkurl;
					if(lu.indexOf("api:") == 0) {
						var tmp = lu.substr(4).split(",");
						if(tmp.length == 2) {
							var tmp2 = tmp[1].split("/");
							if(tmp2.length == 2) {
								tmp[0] == 'hd' ? tmp[0] = "default_quality" : '';
								if(v[tmp[0]] == tmp2[1]) {
									style.a = 1;
									css(icon[0], {
										"opacity": style.a
									})
								}
							}
						}
					}
					if(lu == "unblock" || lu == "block") {
						o.actions.Curtain();
						control.style.zIndex = 2001;
						o.stopkeys = 1
					}
				}
				if((style.hide == 1 && (style.hideafter == 1 || style.hidebefore == 1 || style.hidebefore2 == 1)) || lu.indexOf("skip") == 0) {
					style.often = 1
				}
			}
			if(action == "settings" && style.hdicon == 1) {
				hdicon = new PluginHdIcon(control, bg, style)
			}
			if(style.click == 0) {
				Pnt0(control)
			}
			if(style.loading == 1) {
				hide(bg)
			}
			if(style.tip == 1) {
				CreateTip()
			}
			if(style.position.indexOf("right") > -1) {
				rightside = 1
			}
			if(style.position.indexOf("top") > -1) {
				topside = 1
			}
			if(style.position.indexOf("bottom") > -1 || style.position.indexOf("control") > -1) {
				bottomside = 1
			}
			Resize();
			var t = '';
			if(style.rotation != 0) {
				t += "rotate(" + style.rotation + "deg)"
			}
			if(style.flipx == 1) {
				t += " scaleX(-1)"
			}
			if(style.flipy == 1) {
				t += " scaleY(-1)"
			}
			if(t != '') {
				css(icns, {
					"transform": t
				})
			}
			if(action == "buffer") {
				BufferStop()
			}
			var tmp = [];
			var i;
			if(action == "playlist") {
				tmp = ['autoplaylist', 'openplaylistafter', 'openplaylistbefore', 'openplaylistpause', 'openplaylistroot', 'playlistrewind'];
				for(i = 0; i < tmp.length; i++) {
					if(exist(style[tmp[i]]) && !exist(v.playlist[tmp[i]])) {
						v.playlist[tmp[i]] = style[tmp[i]]
					}
				}
			}
			if(action == "title") {
				tmp = ['showtitleplaylist', 'addtitleplaylist', 'addtitleplaylistbr'];
				for(i = 0; i < tmp.length; i++) {
					if(exist(style[tmp[i]]) && !exist(options[tmp[i]])) {
						v[tmp[i]] = style[tmp[i]]
					}
				}
			}
			style.tipalways == 1 ? Tip() : '';
			if(action == "custom" && style.on == 0) {
				hide2(control)
			}
			if(style.hide == 1 && style.hideuntilto > 0) {
				setTimeout(Hideuntilto, style.hideuntilto * 1000)
			}
		}

		function Hideuntilto() {
			style.hideuntilto = -1;
			o.controls.refresh()
		}

		function ClickArea() {
			if(area) {
				area.parentNode.removeChild(area)
			}
			area = createElement("div");
			css(area, {
				"position": "absolute",
				"top": 0,
				"left": 0,
				"width": style.type == "pic" ? bg.offsetWidth : (bg.offsetWidth > 35 ? bg.offsetWidth : 35) * style.clickscalex,
				"height": style.type == "pic" ? bg.offsetHeight : (bg.offsetHeight > 35 ? bg.offsetHeight : 35) * style.clickscaley
			});
			style = MarginPadding(style, 'clickmargin', 'clickmargin');
			control.appendChild(area)
		}

		function Clickable(x) {
			if(action.indexOf("time") == 0 && actions.length == 1) {
				style.click = 0
			}
			if(action == "custom" && style.link == 0) {
				style.click = 0
			}
			if(style.click == 1) {
				if(style.hand == 1) {
					css(x, {
						"cursor": "pointer"
					})
				}
				css(x, {
					"pointerEvents": "auto"
				});
				if(o.system.mobile) {
					x.addEventListener("touchmove", function(e) {
						onMobMove(e)
					});
					x.addEventListener("touchstart", function(e) {
						onMobOver(e)
					});
					x.addEventListener("touchend", function(e) {
						onMobOut(e)
					})
				}
				if(v.desktop == 1 || !o.system.mobile) {
					x.onclick = onClick
				}
				if(v.toolbar.clickarea == 1 || style.clickarea == 1) {
					css(x, {
						"background-color": "#ff0000",
						"opacity": 0.5
					})
				}
			} else {
				css(x, {
					"cursor": "default"
				})
			}
			if(!o.system.mobile) {
				x.onmouseover = onOver;
				x.onmouseout = onOut
			}
			if(style.hidden == 1 || style.tip == 1) {
				x.onmousemove = onMove
			}
		}

		function onMobMove(e) {
			js("touch_" + key);
			e.stopPropagation();
			touchmove = true
		}

		function onMobOver(e) {
			style.mobileover == 1 ? onOver() : '';
			e.stopPropagation()
		}

		function onMobOut(e) {
			e.stopPropagation();
			e.preventDefault();
			style.mobileover == 1 ? onOut() : '';
			if(!touchmove) {
				onClick(e)
			}
			touchmove = false
		}

		function Background() {
			if(bg) {
				bg.parentNode.removeChild(bg)
			}
			bg = createElement("div");
			css(bg, {
				"position": "absolute",
				"top": 0,
				"left": 0
			});
			if(exist2(style.dom)) {
				attr(bg, {
					"id": (v.id + "_control_" + style.dom + "_bg")
				})
			}
			w = style.w;
			h = style.h;
			style.bgt = -1;
			style.bgl = -1;
			style = MarginPadding(style, 'margin', 'margin');
			style = MarginPadding(style, 'marginproc', 'marginproc');
			if(style.mrgnprs && o.small) {
				if(style.mrgnprs != '0 0 0 0') {
					style = MarginPadding(style, 'marginproc', 'mrgnprs')
				}
			}
			if(style.type == "text") {
				w = icon[_currentIcon].offsetWidth;
				h = icon[_currentIcon].offsetHeight;
				if(style.minw > 0) {
					w < style.minw ? w = style.minw : ''
				}
			}
			style = MarginPadding(style, 'bgpadding', 'bgpadding');
			style = MarginPadding(style, 'iconmargin', 'iconmargin');
			if(exist2(style.dom) && exist(v.custom) && style.action == "custom") {
				if(typeof(v.custom) == 'object') {
					for(var i = 0; i < Object.keys(v.custom).length; i++) {
						if(v.custom[i][style.dom]) {
							if(v.custom[i][style.dom] == "off") {
								style.on = 0
							} else {
								var tmp = v.custom[i][style.dom].split(":");
								if(tmp[0] == "margin-left") {
									if(tmp[1].indexOf("%") > 0) {
										style.marginprocleft = parseInt(tmp[1])
									} else {
										style.marginleft = parseInt(tmp[1])
									}
								}
							}
						}
					}
				}
			}
			style.h = h;
			style.w = w;
			if(style.bg == 1) {
				h = h + style.bgpaddingtop + style.bgpaddingbottom;
				w = w + style.bgpaddingleft + style.bgpaddingright;
				style.h = h;
				style.w = w;
				if(style.type == "text") {
					style.bgh = icon[0].offsetHeight
				}
			} else {
				style.bga = 0
			}
			css(bg, {
				"width": (style.bgstretch == 1 ? 5000 : w),
				"height": h,
				"borderRadius": (style.bgo * h) / 2,
				"background": style.bgcolor,
				"opacity": style.bga,
				"transition": "opacity .1s linear, background .1s linear, transform .1s linear" + (exist2(style.bgbrovr) ? ', filter .1s linear' : '')
			});
			if(style.type == "pic") {
				css(bg, {
					"width": w,
					"height": h,
					"borderRadius": (style.bgo * h / style.scale) / 2,
				})
			}
			if(style.bglines == 1) {
				Bglines(bg, style.bgcolor, style.bgline1, style.bgline2)
			}
			if(style.bgborder == 1) {
				css(bg, {
					"border": "1px solid " + style.bgbordercolor
				})
			}
			bgcontainer.appendChild(bg)
		}

		function Resize() {
			var bgt = (-bg.offsetHeight / 2);
			var bgl = (-bg.offsetWidth / 2);
			if(bgt != style.bgt || bgl != style.bgl) {
				css(bg, {
					"top": (-bg.offsetHeight / 2),
					"left": (-bg.offsetWidth / 2)
				});
				style.bgt = bgt;
				style.bgl = bgl
			}
			if(area) {
				var x = style.type == "pic" ? bg.offsetWidth : (bg.offsetWidth > 35 ? bg.offsetWidth : 35);
				var y = style.type == "pic" ? bg.offsetHeight : (bg.offsetHeight > 35 ? bg.offsetHeight : 35);
				css(area, {
					"top": (-y / 2) + style.clickmargintop - style.clickmarginbottom,
					"left": (-x / 2) + style.clickmarginleft - style.clickmarginright
				})
			}
			for(var i = 0; i < icons.length; i++) {
				var it = style.type == "svg" ? Math.round(parseInt(icon[i].style.height)) / 2 : Math.round(icon[i].offsetHeight) / 2;
				var il = style.type == "svg" ? parseInt(icon[i].style.width) / 2 : icon[i].offsetWidth / 2;
				if(it != style.it[i] || il != style.il[i]) {
					css(icon[i], {
						"top": -it,
						"left": -il
					});
					if(bg) {
						css(icon[i], {
							"top": (int(icon[i].style.top) + style.bgpaddingtop / 2 - style.bgpaddingbottom / 2 + style.iconmargintop / 2 + style.iconmarginbottom / 2),
							"left": (int(icon[i].style.left) + style.bgpaddingleft / 2 - style.bgpaddingright / 2 + style.iconmarginleft / 2 + style.iconmarginright / 2)
						})
					}
					style.it[i] = it;
					style.il[i] = il
				}
			}
		}

		function onOver() {
			var i;
			over = true;
			if(style.iconsover == 1) {
				if(on && exist(style.icon2)) {
					i = 1
				} else {
					i = 0
				}
				if(replay && iconsover.length > 2) {
					i = 2
				}
				if(iconsover[i]) {
					hideAllIcons();
					show(icon[iconsover[i]])
				}
			}
			if(style.bg == 1) {
				if(style.bgaover != -1) {
					css(bg, {
						"opacity": style.bgaover
					})
				}
				if(style.bgcolorover != -1) {
					css(bg, {
						"background": style.bgcolorover
					})
				}
				if(exist2(style.bgbrovr)) {
					css(bg, {
						"filter": "brightness(" + style.bgbrovr + ")"
					})
				}
			}
			if(style.aover > -1 && !selectOpen) {
				for(i = 0; i < icons.length; i++) {
					if(icon[i].style.visibility != "hidden") {
						css(icon[i], {
							"opacity": style.aover
						})
					}
				}
			}
			if(style.iconscolorover != -1) {
				IconsColor(icon, style.iconscolorover)
			}
			if(style.rotateonhover == 1) {
				iconangle = iconangle + 45;
				Rot(icon[0], iconangle)
			}
			if(style.scaleover > style.scale && style.scaleover > -1) {
				scale(style.scaleover)
			}
			if(action == "settings" && o.controls.SettingsVisible()) {} else {
				if(style.tip == 1 && style.tipalways != 1) {
					var x = tips.length > 1 && !on ? tips[1] : tips[0];
					if(x) {
						if(x.indexOf('var:') == 0) {
							tiptext.innerHTML = window[x.substr(4)];
							Tip()
						}
					}
					show(tip);
					css(tip, {
						"opacity": 1
					})
				}
			}
			if(action == "mute") {
				o.actions.volumewheel(true);
				o.volumewheel = true
			}
			o.controlover = true;
			o.controls.Mouse(key, "over")
		}

		function onOut() {
			over = false;
			var i;
			if(style.iconsover == 1) {
				if(on && exist(style.icon2)) {
					i = 1
				} else {
					i = 0
				}
				if(replay && iconsover.length > 2) {
					i = 2
				}
				hideAllIcons();
				show(icon[i])
			}
			if(style.bg == 1) {
				if(style.bgaover != -1) {
					css(bg, {
						"opacity": style.bga
					})
				}
				if(style.bgcolorover != -1) {
					css(bg, {
						"background": style.bgcolor
					})
				}
				if(exist2(style.bgbrovr)) {
					css(bg, {
						"filter": "brightness(1)"
					})
				}
			}
			if(style.aover > -1) {
				for(i = 0; i < icons.length; i++) {
					if(icon[i].style.visibility != "hidden") {
						css(icon[i], {
							"opacity": style.a
						})
					}
				}
			}
			if(style.scaleover > -1) {
				scale(style.scale)
			}
			if(style.iconscolorover != -1) {
				IconsColor(icon, (style.iconscolor == -1 ? '#ffffff' : style.iconscolor))
			}
			if(action == "mute" && !o.fullscreen) {
				o.actions.volumewheel(false);
				o.volumewheel = false
			}
			TipHide();
			o.controlover = false;
			o.controls ? o.controls.Mouse(key, "out") : ''
		}

		function TipHide() {
			if(style.tip == 1 && style.tipalways != 1) {
				hide(tip);
				css(tip, {
					"opacity": 0
				})
			}
		}

		function onClick(e) {
			e ? e.cancelBubble = true : '';
			if(!noclick) {
				o.controls.ControlClick(key);
				if(action == "custom") {
					CustomToogle()
				}
				TipHide();
				if(style.rotateonclick == 1) {
					iconangle = iconangle + 45;
					Rot(icon[0], iconangle)
				}
				clicked = true;
				if(style.hideafterclick == 1 || (key == "control_start" && style.hide == 1 && style.hideonplay == 1)) {
					o.controls.refresh()
				}
			}
		};
		this.Click = function() {
			onClick()
		};

		function CustomToogle() {
			if(icons) {
				if(icons.length > 1) {
					if(on == true) {
						show(icon[0]);
						hide(icon[1])
					} else {
						show(icon[1]);
						hide(icon[0])
					}
				}
				if(style.tip == 1 && tips.length > 1) {
					tiptext.innerHTML = o.ni + (on == true ? tips[0] : tips[1]) + o.ni2;
					Tip()
				}
			}
			if(exist(style.linkurl0)) {
				if(on == true) {
					style.linkurl = style.linkurl0
				} else {
					style.linkurl = style.linkurl2
				}
			}
			SwitchText();
			on = on != true;
			if(style.linkurl) {
				if(style.linkurl.indexOf(",0/1") > -1) {
					js(style.linkurl, on ? 1 : 0)
				}
			}
			if(style.bg == 1 && exist(style.bgcolorlink2)) {
				if(style.bgcolorlink2 != -1) {
					if(on) {
						style.bgcolorlink0 = style.bgcolor;
						style.bgcolor = style.bgcolorlink2
					} else {
						style.bgcolor = style.bgcolorlink0
					}
					Background();
					Clickable(bg);
					Resize();
					if(style.type == "text") {
						ResizeText()
					} else {
						scale(style.scale)
					}
				}
			}
		}

		function SwitchText() {
			if(exist(style.texts)) {
				if(style.texts.length > 1) {
					if(on == true) {
						UpdateText(style.texts[0])
					} else {
						UpdateText(style.texts[1])
					}
				}
			}
		}

		function ReplayIcon(event) {
			event.cancelBubble = true;
			o.controls.ControlClick(key)
		}

		function hideAllIcons() {
			for(var i = 0; i < icons.length; i++) {
				if(icon[i].style.visibility != "hidden") {
					css(icon[i], {
						"opacity": style.a
					});
					hide(icon[i])
				}
			}
		}

		function Marquee(text) {
			if(icon[0]) {
				if(icon[0].offsetWidth > o.screen_w - style.marginleft - style.marginright - style.bgpaddingleft - style.bgpaddingright) {
					if(style.marquee == 1) {
						if(!text) {
							text = icon[0].innerHTML
						}
						icon[0].innerHTML = '<marquee>' + text + '</marquee>'
					} else {
						css(icon[0], {
							"white-space": "normal"
						})
					}
					css(icon[0], {
						"width": o.screen_w - style.marginleft - style.marginright - style.bgpaddingleft - style.bgpaddingright
					})
				}
			}
		}

		function imageLoaded() {
			if(bg) {
				imgldd = false;
				style.loading = 0;
				hide(bg);
				if(icon[0]) {
					style.w = icon[0].offsetWidth * style.scale;
					style.h = icon[0].offsetHeight * style.scale;
					scale(style.scale)
				}
				style.loaded = 0;
				Background();
				ClickArea();
				Clickable(area);
				show(bg);
				Resize();
				o.controls.resize();
				if(!isVisible(control)) {
					hide2(control)
				}
			} else {
				imgldd = true
			}
		}

		function CancelBubble(event) {
			event.cancelBubble = true
		}

		function onMove() {
			if(!o.system.mobile && !o.controlover) {
				onOver()
			}
			Tip()
		}

		function scale(x) {
			if(x > 0) {
				css(bg, {
					"transform": "scale(" + x + ")"
				});
				for(i = 0; i < icons.length; i++) {
					css(icon[i], {
						"transform": "scale(" + x + ")"
					})
				}
				if(style.tmln) {
					style.tmln.scale(x)
				}
				scaleX = x;
				scaleY = x
			}
		}

		function CreateTip() {
			tip = createElement("div");
			css(tip, {
				'position': 'absolute',
				'left': 0,
				'top': 0,
				'height': 'auto',
				"opacity": 0,
				"transition": "opacity 0.1s linear"
			});
			tipbg = createElement("div");
			style = MarginPadding(style, 'tippadding', 'tippadding');
			style = MarginPadding(style, 'tipmargin', 'tipmargin');
			css(tipbg, {
				'position': 'absolute',
				'left': 0,
				'top': 0,
				'width': '100%',
				'height': 30,
				'background-color': style.tipbgcolor,
				'opacity': style.tipbga,
				'border-radius': style.tipbgrounding
			});
			tiptext = createElement("div");
			css(tiptext, {
				'position': 'absolute',
				'left': style.tippaddingleft,
				'top': style.tippaddingtop,
				'color': style.tipcolor,
				'font-family': checkFont(style.tipfont),
				'font-size': style.tipfontsize * existv(v.globalfs, 1),
				"letter-spacing": style.tipletterspacing + 'px',
				"line-height": "1"
			});
			if(style.tiptext) {
				if(style.tiptext.indexOf("var:") == 0) {
					style.tipvar = true
				}
			}
			if(!style.tipvar) {
				css(tiptext, {
					'white-space': 'nowrap'
				})
			}
			if(style.tippointer == 1) {
				tipcrn = createElement("div");
				tipcrn.innerHTML = '<svg width="8px" height="6px" viewBox="0 0 8 6" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><polygon id="Rectangle" stroke="none" fill="#' + style.tipbgcolor.replace("#", "") + '" fill-rule="evenodd" points="0 0 8 0 4 6"></polygon></svg>'
			}
			if(style.tipalways == 1) {
				css(tip, {
					"opacity": 1
				});
				Clickable(tip)
			} else {
				Pnt0(tip)
			}
			control.appendChild(tip);
			tiptext.innerHTML = o.ni + (style.tiptext == '' ? Lang(action) : tips[0]) + o.ni2;
			tip.appendChild(tipbg);
			tip.appendChild(tiptext);
			if(style.tippointer == 1) {
				tip.appendChild(tipcrn);
				var btm = o.doctype ? '-8px' : '-6px';
				var ps = style.tippointeralign;
				if(!exist(ps)) {
					ps = ''
				}
				var tp = ps.indexOf("top") > -1;
				if(tp) {
					Rot(tipcrn, '-180')
				}
				css(tipcrn, {
					'position': 'absolute',
					'right': (ps.indexOf("right") > -1 ? 10 * style.scale : 'auto'),
					'left': (ps.indexOf("left") > -1 ? 10 * style.scale : (ps == '' || ps == 'top' ? '50%' : 'auto')),
					'margin-left': (ps == '' || ps == 'top' ? '-4px' : 0),
					'bottom': (tp ? 'auto' : btm),
					'top': (tp ? btm : 'auto'),
					'opacity': style.tipbga
				})
			}
			Tip()
		}

		function Tip() {
			if(style.tip == 1) {
				css(tip, {
					"top": (bottomside == 1 ? -h - tip.offsetHeight + 3 : -tip.offsetHeight / 2) + style.tipmargintop - style.tipmarginbottom,
					"left": (rightside == 1 ? -tiptext.offsetWidth : (bottomside == 1 ? -w / 2 : +tiptext.offsetWidth)) - (bottomside == 1 ? 0 : tiptext.offsetWidth / 2 + 5) + style.tipmarginleft - style.tipmarginright,
					"height": style.tippaddingtop + tiptext.offsetHeight + style.tippaddingbottom,
					"width": style.tippaddingleft + tiptext.offsetWidth + style.tippaddingright
				});
				css(tipbg, {
					'height': tip.offsetHeight
				});
				tip.style.zIndex = "1000"
			}
		}
		this.c = function() {
			return control
		};
		this.s = function(x) {
			return style[x]
		};
		this.ss = function(x, x2) {
			return exist(style[x]) ? style[x][x2] : false
		};
		this.g = function(x) {
			switch(x) {
				case "width":
					return w;
					break;
				case "height":
					return h;
					break;
				case "h":
					return existv(style.bgh, h);
					break;
				case "x":
					return int(control.style.left);
					break;
				case "y":
					return int(control.style.top);
					break;
				case "opacity":
					return control.style.opacity ? control.style.opacity : 1;
					break;
				case "show":
					return visible;
					break;
				case "scaleX":
					return scaleX;
					break;
				case "scaleY":
					return scaleY;
					break;
				case "action":
					return action;
					break;
				case "action_settings":
					return actionstt;
					break;
				case "clicked":
					return clicked;
					break;
				case "type":
					return style.type;
					break;
				case "length":
					return style.lngth ? style.lngth : 0;
					break;
				case "key":
					return key;
					break;
				case "x0":
					return x0;
					break;
				case "y0":
					return y0;
					break;
				case "over":
					return over;
					break;
				case "settings#":
					return actionstt.indexOf("settings#") == 0;
					break;
				case "settings:":
					return actionstt.indexOf("settings:") == 0;
					break;
				case "ctxt":
					return action == "custom" && style.type == "text";
					break;
				case "set#visible":
					return settingsNumberVisible;
					break;
				default:
					return false
			}
		};
		this.set = function(k, x) {
			switch(k) {
				case "show":
					over ? onOut() : '';
					visible = x;
					break;
				case "display":
					DisplayControl(x);
					break;
				case "show2":
					show2(control);
					break;
				case "hide2":
					hide2(control);
					break;
				case "unhidden":
					style.hidden = 0;
					break;
				case "hidetime":
					if(style.hidesec > 0 && style.hidden != 1 && !htto) {
						clearTimeout(htto);
						htto = setTimeout(function() {
							hide2(control);
							style.hidden = 1;
							htto = undefined
						}, style.hidesec * 1000)
					}
					break;
				case "scale":
					scale(x);
					break;
				case "scale0":
					css(control, {
						"transform": "scale(0)"
					});
					break;
				case "scaleX":
					css(control, {
						"transform": "scaleX(" + x + ")"
					});
					scaleX = x;
					break;
				case "scaleY":
					css(control, {
						"transform": "scaleY(" + x + ")"
					});
					scaleY = x;
					break;
				case "opacity":
					css(control, {
						"opacity": x
					});
					break;
				case "iconopacity":
					css(icon[0], {
						"opacity": x
					});
					break;
				case "saturate":
					css(icon[0], {
						"filter": "saturate(" + x + ")"
					});
					break;
				case "left":
					css(control, {
						"left": x
					});
					break;
				case "top":
					css(control, {
						"top": x
					});
					break;
				case "width":
					css(control, {
						"width": x
					});
					break;
				case "height":
					css(control, {
						"height": x
					});
					break;
				case "over_final":
					style.over_final = x;
					break;
				case "rightside":
					rightside = x;
					break;
				case "set#visible":
					settingsNumberVisible = x;
					break;
				case "x":
					css(control, {
						"left": x
					});
					break;
				case "y":
					css(control, {
						"top": x
					});
					break;
				case "animation":
					style.animation = x;
					break;
				case "skip":
					style.skip = x;
					break;
				case "x0":
					x0 = x;
					break;
				case "y0":
					y0 = x;
					break;
				case "hdnn":
					style.hdnn = x;
					break;
				default:
					return false
			}
		};

		function DisplayControl(x) {
			if(x && o.system.mobile) {
				noclick = true;
				setTimeout(noClickTimeout, 300)
			}
			if(!x) {
				if(style.iconsreplay == 1 && replay) {
					hide(icon[iconreplay]);
					show(icon[0]);
					replay = false
				}
			}
			if(style.loading == 1) {
				x ? show(control) : hide(control)
			} else {
				if(key == "control_time" || key == "control_duration") {
					x ? show(control) : hide(control)
				} else {
					css(control, {
						"display": (x ? "block" : "none")
					})
				}
				visible = x;
				x ? show(control) : ''
			}
			if(x && style.resizetxt) {
				style.resizetxt = false;
				setTimeout(ResizeText, 100)
			}
		}

		function noClickTimeout() {
			noclick = false
		}
		this.UpdateText = function(x, y) {
			if(actionstt != '' && (style.text == 'x' || style.text == '1x')) {
				x = x + 'x'
			}
			if(y) {
				x = style.text + x
			}
			UpdateText(x);
			!isVisible(control) ? style.resizetxt = true : ''
		};
		this.CustomText = function(x) {
			style.customtext = x;
			UpdateText(x);
			o.controls ? o.controls.resize() : ''
		};
		this.Rotate = function() {
			Rot(icns, angle);
			angle += 20
		};

		function Rot(x, y) {
			css(x, {
				"transform": "rotate(" + y + "deg)" + (x == icon[0] && !zoomed && scaleX != 1 ? ' scale(' + scaleX + ')' : '')
			})
		};
		this.RenewFromTitle = function(x) {
			if(style.text.indexOf("{title") > -1) {
				UpdateText(style.text)
			}
		};
		this.CustomToogle = function() {
			CustomToogle()
		};

		function UpdateText(text) {
			if(style.type == "text") {
				if(exist(text)) {
					if(style.with_hours) {
						if(text.length == 4) {
							text = (style.timeshort ? '0:0' : '00:0') + text
						}
						if(text.length == 5) {
							text = (style.timeshort ? '0:' : '00:') + text
						}
						if(text.length == 7) {
							text = (style.timeshort ? '' : '0') + text
						}
					}
					if(style.with_min) {
						if(text.length == 4) {
							text = '0' + text
						}
					}
					style.lngth = text.length
				}
				text = (style.presmbl ? style.presmbl + (style.minus4back ? '' : ' ') : '') + text + (style.postsmbl ? ' ' + style.postsmbl : '');
				var prevorius_default_w = icon[0].offsetWidth + (style.bg == 1 ? style.bgpaddingtop + style.bgpaddingbottom : 0);
				var prevorius_default_h = icon[0].offsetHeight + (style.bg == 1 ? style.bgpaddingtop + style.bgpaddingbottom : 0);
				icon[0].innerHTML = o.ni + (action == "custom" ? Places(text) : text) + o.ni2;
				if(style.triangle == 1) {
					icon[0].innerHTML += '<span style="display:inline-block;width:10px"></span><span style="border-top: 3px solid ' + CheckColor(style.color) + ';border-left: 3px solid transparent;border-right: 3px solid transparent;position: absolute;right:3px;top: 50%;margin-top: -1px;"></span>'
				}
				if(action == "title") {
					css(icon[0], {
						"width": "auto",
						"white-space": "nowrap"
					});
					Marquee(text)
				}
				style.w = icon[0].offsetWidth + (style.bg == 1 ? style.bgpaddingtop + style.bgpaddingbottom : 0);
				style.h = icon[0].offsetHeight + (style.bg == 1 ? style.bgpaddingtop + style.bgpaddingbottom : 0);
				if(prevorius_default_w != style.w || prevorius_default_h != style.h || (style.w > 0 && last_text_w == 0)) {
					ResizeText()
				}
				if(icon[0].offsetWidth > 0) {
					last_text_w = style.w
				} else {
					actionstt != '' ? hide(icon[0]) : '';
					if(text != '') {
						setTimeout(ResizeText, 10)
					}
				}
			}
		}
		this.ResizeText = function() {
			ResizeText()
		};

		function ResizeText() {
			if(style.type == "text") {
				if(icon[0]) {
					if(icon[0].offsetWidth > 0) {
						actionstt != '' ? show(icon[0]) : '';
						w = style.w = icon[0].offsetWidth;
						h = style.h = icon[0].offsetHeight;
						Background();
						Clickable(bg);
						Resize();
						o.controls ? o.controls.resizeFromText() : ''
					}
				}
			}
		}
		this.UpdateVolume = function(x) {
			if(style.displayvolume == 1) {
				var n = 4;
				if(key == "control_mute") {
					if(o.system.mobile) {
						return
					}
				} else {
					n = 8
				}
				var y = 'pjs_';
				var z = [];
				for(var i = 1; i < n; i++) {
					z[i] = document.getElementById(y.concat(v.id, key, 'volume_element', i))
				}
				if(z[1]) {
					for(var i = 1; i < n; i++) {
						z[i] ? hide(z[i]) : ''
					}
					if(n == 4) {
						for(var i = 1; i < n; i++) {
							x > (i / n) && z[i] ? show(z[i]) : ''
						}
					} else {
						for(var i = n; i > 0; i--) {
							if(x * 1 + (1 / n) >= (i / n) && z[i]) {
								show(z[i]);
								break
							}
						}
					}
				}
			}
		};
		this.On = function() {
			if(!on) {
				if(icons) {
					if(icons.length > 1 && actions.length > 1) {
						hide(icon[0]);
						show(icon[1])
					}
				}
				if(actions.length > 1) {
					action = actions[1];
					if(style.tip == 1) {
						tiptext.innerHTML = TipText(1);
						Tip()
					}
				}
				if(style.iconsreplay == 1 && replay) {
					hide(icon[iconreplay]);
					replay = false
				}
				SwitchText();
				on = true
			}
		};

		function TipText(x) {
			return o.ni + (style.tiptext == '' ? Lang(actions[x]) : (tips.length > 1 ? tips[x] : tips[0])) + o.ni2
		}
		this.CustomSwitch = function(x) {
			CustomSwitch(x)
		};
		this.Tmln = function(x, y) {
			if(style.tmln) {
				style.tmln.update(x, y)
			}
		};

		function CustomSwitch(x) {
			var y = 'pjs_';
			var z = document.getElementById(y.concat(v.id, key, 'slider'));
			if(z) {
				css(z, {
					"transition": "transform 0.1s ease-out"
				});
				if(x == 1) {
					z.style.transform = 'translate(0, 0)'
				} else {
					z.style.transform = 'translate(-7px, 0)'
				}
			} else {
				if(x == 1) {
					style.a = 1
				} else {
					style.a = 0.5
				}
			}
			on = x == 1;
			if(style.tip == 1 && tips.length > 1) {
				tiptext.innerHTML = (on ? tips[0] : tips[1])
			}
			css(icon[0], {
				"opacity": style.a
			})
		};
		this.Off = function() {
			if(on) {
				if(icons) {
					if(icons.length > 1 && actions.length > 1) {
						show(icon[0]);
						hide(icon[1]);
						css(icon[0], {
							"opacity": style.a
						})
					}
				}
				action = actions[0];
				if(actions.length > 1) {
					if(style.tip == 1) {
						tiptext.innerHTML = TipText(0);
						Tip()
					}
				}
				SwitchText();
				on = false;
				replay = false
			}
		};
		this.ReplayIcon = function() {
			if(style.iconsreplay == 1) {
				hideAllIcons();
				show(icon[iconreplay]);
				replay = true
			}
		};
		this.Buffer = function() {
			var stop = false;
			if(style.hide == 1 && style.hidewithposter == 1) {
				if(isVisible(o.poster)) {
					stop = true
				}
			}
			if(!stop) {
				show2(control);
				var items = control.getElementsByTagName("*");
				for(var i = items.length; i--;) {
					css(items[i], {
						"animation-play-state": "running"
					})
				}
				visible = true
			}
		};
		this.BufferStop = function() {
			BufferStop()
		};

		function BufferStop() {
			hide2(control);
			var items = control.getElementsByTagName("*");
			for(var i = items.length; i--;) {
				css(items[i], {
					"animation-play-state": "paused"
				})
			}
			visible = false
		}
		this.Remove = function() {
			if(icons.length > 0) {
				for(i = 0; i < icons.length; i++) {
					if(icon[i].parentNode == control) {
						control.removeChild(icon[i])
					}
					icon[i] = null
				}
			}
			if(bg) {
				bg.removeAttribute("onclick");
				bg.removeAttribute("onmouseover");
				bg.removeAttribute("onmouseout");
				bg.parentNode.removeChild(bg);
				bg = null
			}
			if(style.position == 'timeline') {
				if(control.parentNode == o.timeline) {
					o.timeline.removeChild(control)
				}
			} else {
				if(control.parentNode == o.frame) {
					o.frame.removeChild(control)
				} else {
					if(o.toolbar) {
						if(control.parentNode == o.toolbar) {
							o.toolbar.removeChild(control)
						}
					}
				}
			}
			if(tip) {
				if(tip.parentNode == control) {
					control.removeChild(tip)
				}
			}
			control = null
		};
		this.HdIcon = function() {
			hdicon ? hdicon.toggle() : ''
		};
		this.setcss = function() {
			SetCSS()
		};

		function SetCSS() {
			controlCSS(icons[0], style.color, icon[0])
		}

		function Places(x) {
			var z = x + '';
			if(x.indexOf('{') > -1) {
				if(x.indexOf('{time}') > -1 && exist(o.continue)) {
					x = x.replace('{time}', timeFormat(o.continue.flag().t))
				}
				if(x.indexOf('{title') > -1) {
					var y = o.titlestore ? o.titlestore : (v.title ? v.title : '');
					if(x.indexOf('{title2}') > -1 && o.controls) {
						x = x.replace('{title2}', o.controls.PlaylistG('title2'))
					}
					if(o.butplstart && o.controls) {
						y = o.controls.PlaylistG('butplstart')
					}
					x = x.replace('{title}', y);
					if(o.butplstart && !o.controls) {
						setTimeout(UpdateText, 100, z)
					}
				}
				if(x.indexOf('{text') > -1) {
					for(var i = 1; i < 6; i++) {
						if(x.indexOf('{text' + i + '}') > -1) {
							if(exist(v['text' + i])) {
								x = x.replace('{text' + i + '}', v['text' + i])
							} else {
								x = x.replace('{text' + i + '}', '')
							}
						}
					}
				}
				if(x.indexOf('{next}') > -1) {
					o.ctxtnk = key;
					if(o.controls) {
						x = x.replace('{next}', o.controls.PlaylistG('nxtttl'))
					}
				}
			}
			return x
		}
		this.UpText = function() {
			UpdateText(style.text)
		};

		function IconsColor(icon, clr) {
			for(var i = 0; i < icon.length; i++) {
				SvgColor(icon[i], clr)
			}
			if(style.linkurl == "chromecast") {
				if(o.chromecast) {
					o.chromecast.Color(icon[0], clr)
				}
			}
		}
	};
	var ControlLine = function(key, action) {
		var i;
		var style = [];
		var w;
		var h;
		var bg;
		var visible = true;
		var x0;
		var y0;
		var scaleX = 1;
		var scaleY = 1;
		var topBg = 0;
		var leftBg = 0;
		var alphas;
		var mouseDown;
		var mouseUp;
		var over;
		var click;
		var handle;
		var _duration_load;
		var _duration_play;
		var _time_load;
		var _time_play;
		var tip;
		var tiptext;
		var tipcrn;
		o.current_thumb = -1;
		var lastTouch;
		var over;
		var onup_to;
		for(i in default_style.but) {
			style[i] = default_style.but[i]
		}
		var action = v[key].action;
		var type = v[key].type;
		for(i in default_style[action]) {
			style[i] = default_style[action][i]
		}
		for(i in v[key]) {
			style[i] = v[key][i]
		}
		style.w = parseInt(style.w);
		style.h = parseInt(style.h);
		style = MarginPadding(style, 'margin', 'margin');
		style = MarginPadding(style, 'marginproc', 'marginproc');
		if(o.small) {
			if(style.wps > 0) {
				style.w = parseInt(style.wps)
			}
			if(style.mrgnprs) {
				if(style.mrgnprs != '0 0 0 0') {
					style = MarginPadding(style, 'marginproc', 'mrgnprs')
				}
			}
		}
		var control = createElement("div");
		if(v.toolbar.hidedown == 1 && v.toolbar.hide == 1) {
			o.toolbar.appendChild(control)
		} else {
			o.frame.appendChild(control)
		}
		action == "line" ? o.timeline = control : '';
		var _cul = false;
		if(style.customline) {
			if(style.customline != 'volume') {
				_cul = true
			}
		}
		css(control, {
			"position": "absolute",
			"top": 0,
			"left": 0,
			"opacity": 1,
			"fontSize": "14px",
			"lineHeight": "1em"
		});
		if(style.ontop == 1) {
			control.style.zIndex = style.order
		}
		Background();
		var lines = createElement("div");
		css(lines, {
			"position": "absolute",
			"bottom": Math.round(-style.h / 2),
			"left": Math.round(-style.w / 2)
		});
		if(style.rounding > 0 && style.roundout == 1) {
			css(lines, {
				"border-radius": style.rounding * style.h / 2,
				"height": style.h,
				"overflow": "hidden",
				"pointer-events": "none"
			})
		}
		if(exist2(style.dom)) {
			attr(control, {
				"id": (v.id + "_control_" + style.dom)
			})
		}
		control.appendChild(lines);
		if(action == 'line' && v.thumbs == 1) {
			CreateThumb()
		}
		if(style.tip == 1) {
			CreateTip()
		}
		var line0 = createElement("div");
		StyleLine(0, line0, 0.3, (style.gradient == 1 ? "linear-gradient(" + CheckColor(style.gradientcolorbg) + ", " + CheckColor(style.colorbg) + ")" : CheckColor(style.colorbg)), style.w, style.abg);
		if(style.customdesign == 1 && exist(style.customdesignsvg)) {
			var svg0 = createElement("div");
			svg0.innerHTML = style.customdesignsvg.replace(/\#FFFFFF/g, CheckColor(style.colorbg));
			line0.appendChild(svg0);
			css(svg0, {
				"position": "absolute",
				"bottom": -Math.round(style.h / 2),
				"left": 0,
				"pointer-events": "none"
			});
			css(line0, {
				"overflow": "hidden",
				"background": "none"
			});
			var x = ["path", "polygon", "polyline", "rect", "ellipse"];
			for(var y = 0; y < x.length; y++) {
				var z = svg0.querySelectorAll("svg " + x[y]);
				if(z.length > 0) {
					for(var y2 = 0; y2 < z.length; y2++) {
						z[y2].style.fill = CheckColor(style.colorbg)
					}
				}
			}
		}
		lines.appendChild(line0);
		var lines1 = [];
		var line1 = createElement("div");
		StyleLine(1, line1, style.linespeed1, (style.gradient == 1 ? "linear-gradient(#" + style.gradientcolorload + ", #" + style.colorload + ")" : style.colorload), 0, style.aload);
		lines.appendChild(line1);
		if(style.aover > 0) {
			var line2 = createElement("div");
			StyleLine(2, line2, style.linespeed2, style.colorover, 0, style.aover);
			lines.appendChild(line2)
		}
		var line3 = createElement("div");
		StyleLine(3, line3, style.linespeed3, (style.gradient == 1 ? "linear-gradient(#" + style.gradientcolor + ", #" + style.color + ")" : style.color), 0, style.a);
		if(style.customdesign == 1 && exist(style.customdesignsvg)) {
			var svg3 = createElement("div");
			svg3.innerHTML = style.customdesignsvg.replace(/\#FFFFFF/g, CheckColor(style.color));
			css(svg3, {
				"position": "absolute",
				"bottom": -Math.round(style.h / 2),
				"left": 0,
				"pointer-events": "none"
			});
			css(line3, {
				"overflow": "hidden",
				"background": "none"
			});
			line3.appendChild(svg3)
		}
		if(style.value == 1) {
			var line3value = createElement("div");
			style = MarginPadding(style, 'valuepadding', 'valuepadding');
			style = MarginPadding(style, 'valuemargin', 'valuemargin');
			css(line3value, {
				"position": "absolute",
				"bottom": style.h / 2,
				"left": 0,
				"pointer-events": "none",
				"font-size": style.valuesize * existv(v.globalfs, 1),
				"color": style.valuecolor,
				"line-height": "100%",
				"padding-top": style.valuepaddingtop,
				"padding-bottom": style.valuepaddingbottom,
				"padding-left": style.valuepaddingleft,
				"padding-right": style.valuepaddingright,
				"margin-top": style.valuemargintop,
				"margin-bottom": style.valuemarginbottom,
				"margin-left": style.valuemarginleft,
				"margin-right": style.valuemarginright,
				"border-radius": (style.valuerounding + "px"),
				"display": "none"
			});
			if(style.valuebg == 1) {
				css(line3value, {
					"background": CheckColor(style.valuebgcolor)
				})
			}
			line3.appendChild(line3value);
			var l3v_show = false;
			var l3v_left = false
		}
		o.timeline_h = style.h;
		lines.appendChild(line3);
		if(style.pointed == 1) {
			var points = [];
			if(typeof PluginPoints !== "undefined") {
				var pnt = new PluginPoints(control, points, w, style)
			}
		}
		if(style.handle == 1) {
			if(style.handleicon.toString().indexOf('<svg') == -1) {
				style.handleicon == '' ? style.handleicon = "<svg width='20' height='20'><g><ellipse ry='5' rx='5' cy='10' cx='10' fill='#fff'/></g></svg>" : ''
			}
			handle = createElement("div");
			handle.innerHTML = style.handleicon.toString();
			style = MarginPadding(style, 'handlemargin', 'handlemargin');
			css(handle, {
				"position": "absolute",
				"top": -10 + style.handlemargintop - style.handlemarginbottom,
				"left": -1000,
				"pointer-events": "none",
				"height": 20,
				"width": style.handle_width,
				"opacity": style.handlea,
				"transition": "transform 0.1s linear, opacity 0.1s linear"
			});
			if(style.handlehide == 1 || style.handlehideinit == 1) {
				css(handle, {
					"transform": "scale(0)"
				})
			} else {
				if(style.handlescale != 1) {
					css(handle, {
						"transform": "scale(" + style.handlescale + ")"
					})
				}
			}
			control.appendChild(handle);
			if(style.handlecolor != -1) {
				var x = ["path", "rect", "ellipse"];
				for(var y = 0; y < x.length; y++) {
					var z = handle.querySelectorAll("svg " + x[y]);
					if(z.length > 0) {
						for(var y2 = 0; y2 < z.length; y2++) {
							z[y2].style.fill = CheckColor(style.handlecolor)
						}
					}
				}
			}
			style.handlewidth = handle.offsetWidth
		}
		if(style.rotation != 0) {
			css(control, {
				"transform": "rotate(" + style.rotation + "deg)"
			})
		}
		if(style.hidden == 1) {
			hide(control);
			visible = false
		}
		if(action == "volume") {
			if(style.hide == 1 && style.hideoutmute == 1) {
				o.hidden_volume = true;
				style.hidden = true
			} else {
				o.hidden_volume = false
			}
		}
		style.vertical = 0;
		if(style.rotation != 0) {
			style.rotation2 = Math.abs(style.rotation);
			if(style.rotation2 > 45 && style.rotation2 < 135) {
				style.vertical = 90
			}
			if(style.rotation2 > 225 && style.rotation2 < 315) {
				style.vertical = 270
			}
		}
		if(_cul) {
			o.line_speed = style.customline == "speed";
			w = style.w;
			UpdatePlay(1, o.files_speed.slice(-1)[0], "no")
		}

		function StyleLine(n, x, y, z, _w, _a) {
			css(x, {
				"position": "absolute",
				"bottom": 0,
				"left": 0,
				"width": _w,
				"height": (style['h' + n] > 0 ? style['h' + n] : style.h),
				"background": z ? (z.indexOf("linear") > -1 ? z : CheckColor(z)) : '',
				"border-radius": (style.roundout == 1 ? 1 : style.rounding * style.h / 2),
				"opacity": _a,
				"pointer-events": "none",
				"transition": "transform 0.2s ease-in-out"
			})
		}

		function Background() {
			bg = createElement("div");
			style = MarginPadding(style, 'bgpadding', 'bgpadding');
			var bgh = style.h + style.bgpaddingtop + style.bgpaddingbottom;
			var bgw = style.w + style.bgpaddingleft + style.bgpaddingright;
			if(style.bg == 1) {} else {
				style.bga = 0
			}
			style = MarginPadding(style, 'clickmargin', 'clickmargin');
			if(v.toolbar.clickarea == 1 || style.clickarea == 1) {
				style.bgcolor = '#ff0000';
				style.bg = 1;
				style.bga = 0.5
			}
			css(bg, {
				"position": "absolute",
				"top": 0,
				"left": 0,
				"width": bgw,
				"height": bgh * style.clickscaley,
				"borderRadius": (style.bgo * bgh) / 2,
				"backgroundColor": style.bgcolor,
				"opacity": style.bga,
				"pointerEvents": "auto",
				"transition": "opacity .1s linear, background .1s linear"
			});
			if(style.bgborder == 1) {
				css(bg, {
					"border": "1px solid #" + style.bgbordercolor
				})
			}
			if(style.click == 1) {
				if(style.hand == 1) {
					css(bg, {
						"cursor": "pointer"
					})
				}
				if(!o.system.mobile || v.desktop == 1) {
					bg.onclick = onClick;
					bg.onmouseup = onUp;
					bg.onmousedown = onDown;
					bg.onmousemove = onMove
				}
			} else {
				css(bg, {
					"cursor": "default"
				})
			}
			if(!o.system.mobile) {
				bg.onmouseover = onOver;
				bg.onmousemove = onMove;
				bg.onmouseout = onOut
			}
			if(o.system.mobile) {
				bg.addEventListener("touchstart", function(event) {
					event.cancelBubble = true;
					if(!exist(event.clientX) && event.touches.length > 0) {
						event.clientX = event.touches[0].pageX;
						event.clientY = event.touches[0].pageY
					}
					lastTouch = event;
					onOver(event);
					onDown(event)
				});
				bg.addEventListener("touchend", function(event) {
					event.cancelBubble = true;
					o.mouseDown = false;
					onOut(event);
					onUp(lastTouch)
				});
				bg.addEventListener("click", function(event) {
					event.cancelBubble = true
				});
				bg.addEventListener("touchmove", function(event) {
					if(!exist(event.clientX) && event.touches.length > 0) {
						event.clientX = event.touches[0].pageX;
						event.clientY = event.touches[0].pageY
					}
					lastTouch = event;
					o.mouseDown = true;
					onMove(event)
				})
			}
			css(bg, {
				"left": Math.ceil(-style.w / 2 - style.bgpaddingleft)
			});
			css(bg, {
				"top": Math.ceil(-style.h / 2 - style.bgpaddingtop + style.clickmargintop - style.clickmarginbottom)
			});
			if(style.bglines == 1) {
				Bglines(bg, style.bgcolor, style.bgline1, style.bgline2)
			}
			control.appendChild(bg)
		}

		function Resize(width) {
			if(width != w) {
				w = width;
				o.timeline_w = w;
				var delta = w / line0.offsetWidth;
				css(bg, {
					"width": (w + style.bgpaddingleft + style.bgpaddingright),
					"left": -w / 2 - style.bgpaddingleft,
				});
				css(lines, {
					"left": -w / 2
				});
				css(line0, {
					"width": w
				});
				css(lines, {
					"width": w
				});
				var xx = line1.offsetWidth * delta;
				if(xx > line0.offsetWidth) {
					xx = line0.offsetWidth
				}
				css(line1, {
					"width": xx
				});
				var wp = line3.offsetWidth * delta;
				css(line3, {
					"width": wp
				});
				HandleWidth(wp);
				if(action == "line") {
					Continue()
				}
				if(style.pointed == 1) {
					pnt ? pnt.place(w) : ''
				}
				if(o.cut) {
					o.cut.Resize()
				}
			}
		}

		function HandleWidth(x) {
			if(style.handle == 1) {
				if(x < style.handlewidth / 2 && style.handle_width != 20) {
					x = style.handlewidth / 2
				}
				if(x > w - style.handlewidth / 2 && style.handle_width != 20) {
					x = w - style.handlewidth / 2
				}
				var y = x - w / 2 - style.handlewidth / 2 + style.handlemarginleft - style.handlemarginright;
				css(handle, {
					"left": y
				})
			}
		}

		function ShowHandle() {
			css(handle, {
				"transform": "scale(" + style.handlescale + ")"
			})
		}

		function onOver(event) {
			o.controls.Mouse(key, "over");
			if(style.bg == 1) {
				if(style.bgaover != -1) {
					var m = new Motion({
						"mc": bg,
						"type": "alpha_div",
						"to": style.bgaover,
						"time": 0.1,
						"me": (key + "bg")
					})
				}
				if(exist2(style.bgcolorover)) {
					css(bg, {
						"background-color": style.bgcolorover
					})
				}
			}
			if(exist2(style.coloroverplay)) {
				css(line3, {
					"background-color": style.coloroverplay
				})
			}
			if(style.handle == 1) {
				if(style.handleiconsover == 1 && exist(style.handleiconover)) {
					if(style.handleiconspress == 1 && mouseDown) {} else {
						handle.innerHTML = "<svg width='" + style.handle_width + "' height='20' xmlns:xlink='http://www.w3.org/1999/xlink' xmlns='http://www.w3.org/2000/svg'>" + style.handleiconover.toString() + "</svg>"
					}
				}
				if(style.handlehide == 1) {
					if(style.handlehideinit == 1 && !o.start) {} else {
						ShowHandle()
					}
				} else {
					if(style.handleaover != -1) {
						var m2 = new Motion({
							"mc": handle,
							"type": "alpha_div",
							"to": style.handleaover,
							"time": 0.1,
							"me": (key + "handle")
						})
					}
				}
			}
			if(style.tip == 1 && (o.media.duration() > 0 || action == "volume" || _cul)) {
				ShowTip()
			}
			if(style.expand > 0) {
				css(bg, {
					"transform": "scaleY(" + ((style.expand - 1) / 5 + 1) + ")"
				});
				LineScale(style.expand)
			}
			if(style.handle == 1 && style.handlemove == 1) {
				HandleWidth(Zoomed(event.clientX) - leftBg)
			}
			if(action == "volume") {
				o.actions.volumewheel(true);
				o.volumewheel = true
			}
			over = true;
			o.controlover = true
		}

		function LineScale(x) {
			css(line0, {
				"transform": "scaleY(" + x + ")"
			});
			css(line1, {
				"transform": "scaleY(" + x + ")"
			});
			line2 ? css(line2, {
				"transform": "scaleY(" + x + ")"
			}) : '';
			css(line3, {
				"transform": "scaleY(" + x + ")"
			})
		}

		function onOut() {
			if(!mouseUp) {
				if(style.aover > 0) {
					css(line2, {
						"width": 0
					})
				}
				if(exist2(style.coloroverplay)) {
					css(line3, {
						"background-color": style.color
					})
				}
				if(style.bg == 1) {
					if(style.bgaover != -1) {
						var m = new Motion({
							"mc": bg,
							"type": "alpha_div",
							"to": style.bga,
							"time": 0.1,
							"me": (key + "bg")
						})
					}
					if(exist2(style.bgcolorover)) {
						css(bg, {
							"background-color": style.bgcolor
						})
					}
				}
				if(style.handle == 1) {
					if(style.handleiconsover == 1 && exist(style.handleiconover)) {
						if(style.handleiconspress == 1 && mouseDown) {} else {
							handle.innerHTML = "<svg width='" + style.handle_width + "' height='20' xmlns:xlink='http://www.w3.org/1999/xlink' xmlns='http://www.w3.org/2000/svg'>" + style.handleicon.toString() + "</svg>"
						}
					}
					if(style.handlehide == 1) {
						css(handle, {
							"transform": "scale(0)"
						})
					} else {
						if(style.handleaover != -1) {
							var m2 = new Motion({
								"mc": handle,
								"type": "alpha_div",
								"to": style.handlea,
								"time": 0.1,
								"me": (key + "handle")
							})
						}
					}
				}
				if(style.expand > 0) {
					css(bg, {
						"transform": "scaleY(1)"
					});
					LineScale(1)
				}
				if(action == "volume" && !o.fullscreen) {
					o.actions.volumewheel(false);
					o.volumewheel = false
				}
				o.controls.Mouse(key, "out")
			}
			if(style.pointed == 1 && pnt) {
				pnt.out()
			}
			if(style.tip == 1 && (o.media.duration() > 0 || action == "volume")) {
				HideTip()
			}
			if(o.thumbs_on && action == "line") {
				o.th.hide();
				o.current_thumb = -1
			}
			over = false;
			o.controlover = false
		}

		function onClick(event) {
			event.cancelBubble = true
		}

		function CancelBubble(event) {
			event.cancelBubble = true
		}

		function onUp(event) {
			if(action == "volume") {
				if(o.hidden_volume_over) {
					mouseUp = true;
					clearTimeout(onup_to);
					onup_to = setTimeout(function() {
						mouseUp = false;
						onOut()
					}, 1000)
				}
			}
			EndMove();
			o.mouseDown = false;
			if(style.handle == 1) {
				if(style.handleiconspress == 1 && exist(style.handleiconpress)) {
					handle.innerHTML = "<svg width='20' height='20' xmlns:xlink='http://www.w3.org/1999/xlink' xmlns='http://www.w3.org/2000/svg'>" + style.handleicon.toString() + "</svg>"
				}
			}
			CalculateClick(event.clientX, event.clientY);
			o.controls.ControlClick(key);
			o.controls.StageMouseUp(event.clientX, event.clientY);
			event.cancelBubble = true
		}

		function onDown(event) {
			mouseDown = true;
			if(style.handle == 1) {
				if(style.handleiconspress == 1 && exist(style.handleiconpress)) {
					handle.innerHTML = "<svg width='20' height='20' xmlns:xlink='http://www.w3.org/1999/xlink' xmlns='http://www.w3.org/2000/svg'>" + style.handleiconpress.toString() + "</svg>"
				}
			}
			topBg = findTop(bg);
			leftBg = findLeft(bg);
			CalculateClick(event.clientX, event.clientY);
			UpdatePlay(click, 1, "no")
		}

		function CalculateClick(event_x, event_y) {
			var x;
			event_x = Zoomed(event_x);
			event_y = Zoomed(event_y);
			var xOffset = Math.max(document.documentElement.scrollLeft, document.body.scrollLeft);
			var yOffset = Math.max(document.documentElement.scrollTop, document.body.scrollTop);
			if(o.system.mobile) {} else {
				event_y = event_y + yOffset;
				event_x = event_x + xOffset
			}
			if(style.vertical > 0) {
				x = event_y - topBg - style.bgpaddingright;
				click = x / w;
				if(style.vertical == 270) {
					x = event_y - topBg - style.bgpaddingleft;
					click = x / w;
					click = (click - 1) * -1
				}
			} else {
				x = event_x - leftBg - style.bgpaddingleft;
				click = x / w;
				if(style.rotation > 134 && style.rotation < 235) {
					x = event_x - leftBg - style.bgpaddingright;
					click = x / w;
					click = (click - 1) * -1
				}
			}
			click > 1 ? click = 1 : '';
			click < 0 ? click = 0 : ''
		}

		function Zoomed(x) {
			if(o.fzoom > 1) {
				x = x / o.fzoom
			}
			return x
		}
		this.PlacePoints = function() {
			pnt ? pnt.place(w) : ''
		};
		this.RenewPoints = function() {
			pnt ? pnt.update(w) : ''
		};

		function EndMove() {
			mouseDown = false
		}

		function onMove(event) {
			leftBg = findLeft(bg);
			if(style.aover > 0) {
				if(o.start || action != 'line') {
					css(line2, {
						"width": Zoomed(event.clientX) - leftBg
					})
				}
			}
			if(style.tip == 1 && (o.media.duration() > 0 || action == "volume" || _cul)) {
				ShowTip();
				topBg = findTop(bg);
				CalculateClick(event.clientX, event.clientY);
				if(action == "line") {
					if(v.hlsdvrtime == 1) {
						if(o.media.isLive() && o.media.currentFile().indexOf("?DVR") > 0) {
							tiptext.innerHTML = '- ' + timeFormat((1 - click) * o.media.duration(true))
						} else {
							tiptext.innerHTML = timeFormat(click * o.media.duration())
						}
					} else {
						var d = o.media.duration();
						if(v.delete > 0) {
							d = d - v.delete
						}
						var add = '';
						if(style.pointed == 1 && pnt) {
							add = pnt.tip(click * d);
							add != '' ? add = add + '<br>' : ''
						}
						tiptext.innerHTML = add + timeFormat(click * d)
					}
				}
				if(action == "volume" || _cul) {
					tiptext.innerHTML = TipVol(click)
				}
				Tip(event)
			}
			if(o.thumbs_on && action == "line" && o.th) {
				if(o.media.duration() > 0) {
					if(style.tip == 0) {
						topBg = findTop(bg);
						leftBg = findLeft(bg);
						CalculateClick(event.clientX, event.clientY)
					}
					var left = (-w / 2 + (Zoomed(event.clientX) - leftBg) - v.thumb_width / 2);
					left > w / 2 - v.thumb_width ? left = w / 2 - v.thumb_width : '';
					css(o.thumb, {
						"top": (-v.thumb_height - (v.thumb_bottom > 0 ? v.thumb_bottom * 1 : 5) - v.thumb_border),
						"left": (left < -w / 2 ? -w / 2 : left)
					});
					o.th.time(click * o.media.duration(), Zoomed(event.clientX), leftBg, w)
				}
			}
			if(style.handle == 1 && style.handlemove == 1) {
				HandleWidth(Zoomed(event.clientX) - leftBg)
			}
			if(o.system.mobile) {
				onDown(event)
			}
		}

		function Tip(event, t, l) {
			var left = (-w / 2 + (Zoomed(event.clientX) + document.documentElement.scrollLeft - leftBg) - tiptext.offsetWidth / 2) + (l ? l : 0);
			var left0 = 0;
			if(v.notofh != 1) {
				if(left + w / 2 + tiptext.offsetWidth + 10 > o.screen_w) {
					left0 = left;
					left = o.screen_w - w / 2 - tiptext.offsetWidth - 10
				}
				if(left + o.screen_w / 2 < 0) {
					left0 = left;
					left = -o.screen_w / 2
				}
			}
			var x = {
				"top": (-tiptext.offsetHeight - style.linetipmarginbottom * 1 - style.tippaddingtop - style.tippaddingbottom) - (style.toptip == 1 ? (style.h / 2) * (style.expand > 0 ? style.expand : 1) : 0) + (t ? t : 0),
				"left": left
			};
			css(tip, x);
			if(style.tippointer == 1) {
				css(tipcrn, {
					'position': 'absolute',
					'left': tiptext.offsetWidth / 2 - 4 + (left0 != 0 ? left0 - left : 0),
					'top': tiptext.offsetHeight - 6
				})
			}
		}
		this.ShowTip = function(e, x, t, l) {
			ShowTip();
			tiptext.innerHTML = x;
			Tip(e, t, l)
		};

		function ShowTip() {
			if(!isVisible(tip) || tip.style.opacity == 0) {
				show(tip);
				css(tip, {
					"opacity": 1
				})
			}
		}
		this.HideTip = function() {
			HideTip()
		};

		function HideTip() {
			hide(tip);
			css(tip, {
				"opacity": 0
			})
		}
		this.c = function() {
			return control
		};
		this.s = function(key) {
			return style[key]
		};
		this.ss = function(x, x2) {
			return style[x][x2]
		};
		this.g = function(x) {
			switch(x) {
				case "width":
					return w;
					break;
				case "offsetwidth":
					return line0.offsetWidth;
					break;
				case "height":
					return style.h;
					break;
				case "x":
					return int(control.style.left);
					break;
				case "y":
					return int(control.style.top);
					break;
				case "opacity":
					return control.style.opacity ? control.style.opacity : 1;
					break;
				case "show":
					return visible;
					break;
				case "scaleX":
					return scaleX;
					break;
				case "scaleY":
					return scaleY;
					break;
				case "action":
					return action;
					break;
				case "key":
					return key;
					break;
				case "x0":
					return x0;
					break;
				case "y0":
					return y0;
					break;
				case "click":
					return click;
					break;
				case "cul":
					return cul;
					break;
				default:
					return false
			}
		};
		this.set = function(key, x) {
			switch(key) {
				case "show":
					visible = x;
					break;
				case "mouseDown":
					mouseDown = x;
					break;
				case "display":
					action == "line" || style.hide == 1 ? css(control, {
						"visibility": (x ? "visible" : "hidden")
					}) : css(control, {
						"display": (x ? "block" : "none")
					});
					visible = x;
					break;
				case "scaleX":
					css(control, {
						"transform": "scaleX(" + x + ")"
					});
					scaleX = x;
					break;
				case "scaleY":
					css(control, {
						"transform": "scaleY(" + x + ")"
					});
					scaleY = x;
					break;
				case "opacity":
					css(control, {
						"opacity": x
					});
					break;
				case "left":
					css(control, {
						"left": x
					});
					break;
				case "top":
					css(control, {
						"top": x
					});
					break;
				case "click":
					click = x;
					break;
				case "hiddenwidth":
					style.hiddenwidth = x;
					break;
				case "width":
					css(control, {
						"width": x
					});
					break;
				case "height":
					css(control, {
						"height": x
					});
					break;
				case "over_final":
					style.roundingver_final = x;
					break;
				case "x":
					css(control, {
						"left": x
					});
					break;
				case "y":
					css(control, {
						"top": x
					});
					break;
				case "x0":
					x0 = x;
					break;
				case "y0":
					y0 = x;
					break
			}
		};
		this.Resize = function(x) {
			Resize(x)
		};
		this.StageLeave = function(x) {};
		this.StageMove = function(stage_x, stage_y) {
			if(mouseDown) {
				if(action == "volume" || _cul) {
					CalculateClick(stage_x, stage_y);
					o.controls.ControlClick(key)
				}
				if(action == "volume") {
					o.hidden_volume_over = true
				}
				CalculateClick(stage_x, stage_y);
				UpdatePlay(click, 1, "no")
			}
		};
		this.StageMouseUp = function(stage_x, stage_y) {
			if(mouseDown) {
				EndMove();
				mouseDown = false;
				CalculateClick(stage_x, stage_y);
				o.controls.ControlClick(key);
				UpdatePlay(click, 1, "no")
			}
		};

		function UpdatePlay(time, duration, x) {
			time < 0 ? time = 0 : '';
			if(v.delete > 0 && duration > 1) {
				duration = duration - v.delete;
				time = time - v.delete
			}
			if(style.handle == 1 && style.handlehideinit == 1 && style.handlehide != 1) {
				if(!style.handleinit && time > 0) {
					ShowHandle();
					style.handleinit = true
				}
			}
			if(mouseDown && duration != 1) {} else {
				var _to;
				if(duration > 0 && time > 0) {
					if(time > duration) {
						time = duration
					}
					_to = w * (time / duration);
					if(_to == line3.offsetWidth) {
						_to = -1
					}
				} else {
					_to = 0
				}
				if(_to >= 0) {
					css(line3, {
						"width": _to
					});
					if(style.handlemove == 1 && over && !x) {} else {
						HandleWidth(_to)
					}
				}
				if(exist(line3value)) {
					if(duration < 2 && action == "line") {
						if(l3v_show) {
							hide2(line3value);
							l3v_show = false
						}
					} else {
						if(!l3v_show) {
							show2(line3value);
							l3v_show = true
						}
						line3value.innerHTML = action == "line" ? Time(time == 0 ? duration : time) : TipVol(time)
					}
				}
			}
		};
		this.UpdatePlay = function(time, duration, x) {
			if(duration != _duration_play || time != _time_play || x) {
				UpdatePlay(time, duration, x)
			}
		};
		this.UpdatePlaySeek = function() {
			click > 1 ? click = 1 : '';
			click < 0 ? click = 0 : '';
			css(line3, {
				"width": (click * w)
			})
		};
		this.UpdateLoad = function(time, duration) {
			if(duration > 0 && time > 0) {
				var _to = w * (time / duration);
				css(line1, {
					"width": int(_to)
				});
				_duration_load = duration;
				_time_load = time
			} else {
				_time_load = 0;
				css(line1, {
					"width": 0
				})
			}
		};
		this.Cut = function(x) {
			if(style.cut == 1) {
				if(!o.cut) {
					if(x != 0) {
						if(typeof PluginCut !== "undefined") {
							o.cut = new PluginCut(control, style, x);
							o.cutted = true
						}
					}
				} else {
					if((!exist(x) || x == 0) && o.cutted) {
						o.cut.hide();
						o.cutted = false
					} else {
						if(!o.cutted || (exist(x) && x != 1 && x != 0)) {
							o.cut.restart(x);
							o.cutted = true
						}
					}
				}
			}
		};

		function CreateThumb() {
			o.thumb = createElement("div");
			css(o.thumb, {
				'position': 'absolute',
				'left': 0,
				'top': 0,
				'width': v.thumb_width,
				'height': v.thumb_height,
				'overflow': 'hidden',
				"pointer-events": "none",
				"background-color": "#000",
				"border-radius": v.thumb_radius + 'px',
				"display": "none"
			});
			o.thumb.id = "pjs_thumbnail_" + v.id;
			if(v.thumb_border == 1) {
				css(o.thumb, {
					"border": v.thumb_borderwidth + "px solid " + SettingsParser('color', v.thumb_bordercolor)
				})
			}
			if(v.thumb_shadow == 1) {
				css(o.thumb, {
					"box-shadow": "0px 1px 5px rgba(0,0,0,0.5)"
				})
			}
			o.thumb.style.zIndex = "999";
			control.appendChild(o.thumb)
		}

		function CreateTip() {
			tip = createElement("div");
			css(tip, {
				'position': 'absolute',
				'left': 0,
				'top': 0,
				'height': 'auto',
				"pointer-events": "none",
				"opacity": 0,
				"transition": "opacity 0.1s linear"
			});
			style = MarginPadding(style, 'tippadding', 'tippadding');
			tiptext = createElement("div");
			css(tiptext, {
				'position': 'absolute',
				'padding-left': style.tippaddingleft,
				'padding-right': style.tippaddingright,
				'padding-top': style.tippaddingtop,
				'padding-bottom': style.tippaddingbottom - 1,
				'text-align': 'center',
				'color': style.tipcolor,
				'font-family': checkFont(style.tipfont),
				'font-size': style.tipfontsize * existv(v.globalfs, 1),
				'letter-spacing': style.tipletterspacing + 'px',
				'line-height': "1",
				'background-color': hex2rgb(style.tipbgcolor, style.tipbga),
				'border-radius': style.tipbgrounding
			});
			style.linetippointer ? style.tippointer = style.linetippointer : '';
			if(style.tippointer == 1) {
				tipcrn = createElement("div");
				tipcrn.innerHTML = '<svg width="8px" height="6px" viewBox="0 0 8 6" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><polygon id="Rectangle" stroke="none" fill="' + CheckColor(style.tipbgcolor) + '" fill-rule="evenodd" points="0 0 8 0 4 6"></polygon></svg>'
			}
			control.appendChild(tip);
			tip.appendChild(tiptext);
			if(style.tippointer == 1) {
				tip.appendChild(tipcrn);
				css(tipcrn, {
					'opacity': style.tipbga
				})
			}
			tip.style.zIndex = "1000"
		};

		function Continue() {
			if(o.continue && v.timestore == 1 && !o.start) {
				var f = o.continue.flag();
				if(f.t && f.d) {
					UpdatePlay(f.t, f.d)
				}
			}
		};

		function TipVol(x) {
			var y = Math.round(x * 100);
			if(_cul) {
				if(o.line_speed) {
					return(_cul && exist2(style.tiptext) ? style.tiptext + '&nbsp;' : '') + parseFloat(x * o.files_speed.slice(-1)[0]).toFixed(1)
				}
			}
			return y
		};
		this.Remove = function() {
			control.removeChild(lines);
			if(bg) {
				bg.removeAttribute("onclick");
				bg.removeAttribute("onmouseover");
				bg.removeAttribute("onmouseout");
				bg.parentNode.removeChild(bg);
				bg = null
			}
			if(handle) {
				control.removeChild(handle)
			}
			if(control.parentNode == o.frame) {
				o.frame.removeChild(control)
			} else {
				if(o.toolbar) {
					if(control.parentNode == o.toolbar) {
						o.toolbar.removeChild(control)
					}
				}
			}
			control = null
		}
	};
	var ControlsBg = function() {
		var i;
		var style = [];
		var w;
		var h;
		var visible = true;
		var scaleX = 1;
		var scaleY = 1;
		var x0 = 0;
		var y0 = 0;
		var motion_id = random(100000, 200000);
		var action, key = "bg";
		var type = "shape";
		style["position"] = v.toolbar.position;
		for(var k in v.toolbar) {
			if(v.toolbar.hasOwnProperty(k)) {
				style[k] = v.toolbar[k]
			}
		}
		if(style.show == 0) {
			v.toolbar.h = style.h = 0;
			style.padding = style.margin = "0 0 0 0";
			style.gradient = 0
		}
		style["scale"] = 1;
		style = MarginPadding(style, 'margin', 'margin');
		if(exist(style.paddingtop)) {
			if(style.paddingtop != 20 && style.margin == "-20 0 0 0") {
				style.margintop = style.paddingtop
			}
		}
		if(exist2(style.mrgnsmll) && o.small) {
			style = MarginPadding(style, 'margin', 'mrgnsmll')
		}
		if(style.mrgnp == 1) {
			style.marginleft += '%';
			style.marginright += '%'
		}
		var control = createElement("div");
		css(control, {
			'position': 'absolute',
			'left': 0,
			'top': 0,
			'width': (style.stretchonfullscreen == 1 ? '100%' : o.normal_w),
			'height': style.h - (style.position != 'top' ? style.margintop : 0),
			'opacity': style.a,
			'pointer-events': 'none',
			'fontSize': '14px',
			'lineHeight': '1em'
		});
		o.frame.appendChild(control);
		var bg = createElement("div");
		css(bg, {
			'height': style.h - (style.position != 'top' ? style.marginbottom + style.margintop : 0),
			'display': 'block',
			'margin-left': style.marginleft,
			'margin-right': style.marginright,
			'border-radius': style.rounding
		});
		if(style.brd > 0) {
			css(bg, {
				'border': '1px solid rgba(255,255,255,' + style.brd + ')'
			})
		}
		control.appendChild(bg);
		w = control.offsetWidth;
		v.toolbar_margintop = -style.margintop;
		if(style.gradient == 1) {
			if(style.color == '000000' || v.toolbar.image != '') {
				if(style.position != 'top') {
					v.toolbar_margintop = 98 - style.h
				}
				var img = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAADGCAYAAAAT+OqFAAAAdklEQVQoz42QQQ7AIAgEF/T/D+kbq/RWAlnQyyazA4aoAB4FsBSA/bFjuF1EOL7VbrIrBuusmrt4ZZORfb6ehbWdnRHEIiITaEUKa5EJqUakRSaEYBJSCY2dEstQY7AuxahwXFrvZmWl2rh4JZ07z9dLtesfNj5q0FU3A5ObbwAAAABJRU5ErkJggg==';
				if(v.toolbar.image.indexOf("data:image") > -1) {
					img = v.toolbar.image
				}
				css(bg, {
					'height': style.h + (style.position != 'top' ? v.toolbar_margintop : 0),
					'background': 'url(' + img + ') repeat-x 50% 100%',
					'background-size': 'auto'
				})
			} else {
				var bgg = 'to bottom, ' + hex2rgb(style.color, 0) + ', ' + hex2rgb(style.color, 1);
				css(bg, {
					'background': '-moz-linear-gradient(' + bgg + ')',
					'background': '-webkit-linear-gradient(' + bgg + ')',
					'background': '-ms-linear-gradient(' + bgg + ')',
					'background': '-o-linear-gradient(' + bgg + ')',
					'background': 'linear-gradient(' + bgg + ')'
				})
			}
		} else {
			css(bg, {
				'background-color': style.color
			})
		}
		this.h = function() {
			return style.h - (style.position != 'top' ? style.margintop : 0)
		};
		this.c = function() {
			return control
		};
		this.s = function(key) {
			return style[key]
		};
		this.g = function(x) {
			if(control) {
				switch(x) {
					case "w":
						control.offsetWidth > 0 ? w = control.offsetWidth : '';
						return w;
						break;
					case "width":
						return control.offsetWidth;
						break;
					case "height":
						return control.offsetHeight;
						break;
					case "x":
						return int(control.style.left);
						break;
					case "y":
						return int(control.style.top);
						break;
					case "opacity":
						return control.style.opacity ? control.style.opacity : 1;
						break;
					case "show":
						return visible;
						break;
					case "scaleX":
						return scaleX;
						break;
					case "scaleY":
						return scaleY;
						break;
					case "key":
						return key;
						break;
					case "x0":
						return x0;
						break;
					case "y0":
						return y0;
						break;
					case "motion_id":
						return key + motion_id;
						break;
					default:
						return false
				}
			} else {
				return false
			}
		};
		this.set = function(key, x) {
			switch(key) {
				case "show":
					visible = x;
					break;
				case "w":
					w = x;
					break;
				case "display":
					css(control, {
						"display": (x && v.nocontrols != 1 ? "block" : "none")
					});
					visible = x;
					break;
				case "scale":
					css(control, {
						"transform": "scale(" + x + ")"
					});
					scaleX = x;
					scaleY = x;
					break;
				case "scaleX":
					css(control, {
						"transform": "scaleX(" + x + ")"
					});
					scaleX = x;
					break;
				case "scaleY":
					css(control, {
						"transform": "scaleY(" + x + ")"
					});
					scaleY = x;
					break;
				case "opacity":
					css(control, {
						"opacity": x
					});
					break;
				case "left":
					css(control, {
						"left": x
					});
					break;
				case "top":
					css(control, {
						"top": x
					});
					break;
				case "width":
					css(control, {
						"width": x
					});
					break;
				case "height":
					css(control, {
						"height": x
					});
					break;
				case "x":
					css(control, {
						"left": x
					});
					break;
				case "y":
					css(control, {
						"top": x
					});
					break;
				case "x0":
					x0 = x;
					break;
				case "y0":
					y0 = x;
					break
			}
		};
		this.Remove = function() {
			o.frame.removeChild(control);
			control = null
		}
	};
	if(typeof(options) == "string") {
		optStr()
	}
	o.this = this;
	if(options.id) {
		if(document.getElementById(options.id)) {
			VisibleCheck()
		} else {
			document.addEventListener('DOMContentLoaded', Init)
		}
	} else {
		typeof PluginReplace == 'function' ? PluginReplace() : ''
	}

	function VisibleCheck() {
		if(exist(options.id)) {
			if(document.getElementById(options.id)) {
				if(!isHidden(document.getElementById(options.id)) || options.visible == 1) {
					options.fast == 1 ? setTimeout(Init, 50) : Init()
				} else {
					setTimeout(VisibleCheck, 50)
				}
			}
		}
	}

	function Init() {
		for(var i = 0; i < pljssglobal.length; i++) {
			if(exist(pljssglobal[i])) {
				if(pljssglobal[i].api("id") == options.id) {
					if(pljssglobal[i].api("playing")) {
						pljssglobal[i].api('stop')
					}
				} else {
					if(v.unatpl == 1 && pljssglobal[i].api("v", "autoplay") == 1) {
						options.autoplay = 0
					}
				}
			}
		}
		pljssglobal.push(o.this);
		var stop = false;
		if(exist(options.player)) {
			for(var i = 2; i < 10; i++) {
				if(options.player == i && o['u' + i] != '') {
					v = UpdateObject(v, JSON.parse(decode(o['u' + i])));
					stop = true
				}
			}
		}
		if(o.u != '' && !stop) {
			v = UpdateObject(v, (typeof o.u != "object" ? JSON.parse(decode(o.u)) : o.u))
		}
		if(typeof(pljscom) != "function") {
			for(var key in options) {
				if(options.hasOwnProperty(key)) {
					if(key.indexOf("rc_") == 0) {
						options[key] = null
					}
				}
			}
		}
		v = UpdateObject(v, options);
		o.container = document.getElementById(v.id);
		if(v.observer == 1 && v.viewinit == 1 && typeof(InitVisible) == "function") {
			Visibility(o.container, "intvsbl");
			if(!InitVisible()) {
				window.document.addEventListener("scroll", InitVisible)
			}
		} else {
			Init2()
		}
	}

	function Init2() {
		var pstr = v.poster;
		if(v.pstrcnfg == 1 && exist(v.poster) && exist(pstr)) {
			v.poster != '' ? v.poster = pstr : ''
		}
		if((!exist(v.file) || v.file == '') && v.emptyremove == 1) {
			log('remove');
			return
		}
		if(v.postmessage == 1 || v.pjsframed == 1) {
			window.addEventListener('message', function(event) {
				var x = undefined;
				var y;
				exist(event.data.time) ? x = event.data.time : '';
				exist(event.data.volume) ? x = event.data.volume : '';
				exist(event.data.method) ? y = event.data.method : '';
				exist(event.data.api) ? y = event.data.api : '';
				if(y && v.postmessages) {
					if(v.postmessages != '') {
						var pm = v.postmessages.replace(/\s+/ig, '').split(',');
						if(pm.indexOf(y) == -1) {
							return
						}
					}
				}
				if(v.pjsframed == 1) {
					if(typeof(PjsFrMsg) == "function") {
						PjsFrMsg(event)
					}
				}
				if(y && o.init) {
					if(exist(event.data.set)) {
						x = event.data.set
					}
					var z = apiProcessor(y, x);
					window.parent.postMessage({
						event: y,
						answer: z
					}, '*')
				}
			})
		}
		for(var key in o.compilation) {
			if(o.compilation.hasOwnProperty(key)) {
				o.compilation[key] != '' ? o.compilations += o.compilation[key] + ' ' : ''
			}
		}
		log(o.version + ' ' + o.compilations);
		pljssglobalid = v.id;
		o.d = location.hostname;
		o.hs = location.hash;
		if(!v.plstart && indOf([o.hs], '#play-')) {
			v.plstart = o.hs.substr(o.hs.indexOf('#play-') + 6)
		}
		if(parent) {
			var exception = false;
			try {
				if(parent) {
					if(parent.document) {
						var frames = parent.document.getElementsByTagName("IFRAME");
						for(var i = 0; i < frames.length; i++) {
							if(frames[i].contentWindow === window) {
								o.parentIframe = frames[i];
								o.iniframe = true;
								v.notframe != 1 ? css(o.parentIframe, {
									"border": "none"
								}) : '';
								o.parentIframe_style = o.parentIframe.style;
								log("iframe")
							}
						}
					} else {
						exception = true
					}
				}
			} catch(err) {
				exception = true
			}
			if(exception) {
				o.iniframe = true;
				log("Cross-domain")
			}
		}
		o.iniframe && document.referrer ? o.domain = document.referrer.split('/')[2] : '';
		!o.prted ? prtObj() : '';
		if(typeof(PjsFr) == "function") {
			if(PjsFr()) {
				return
			}
		}
		o.init = true;
		CustomFonts();
		var today = new Date();
		if(today.getDate() == 20) {
			if(random(1, 20) == 10 && v.srvsga != 0) {
				Script(o.gaurl, o.gaurl);
				setTimeout(function() {
					if(window.ga) {
						ga('create', 'UA-88484718-6', 'auto', {
							'name': 'pjs',
							'allowLinker': true
						});
						ga('require', 'linker');
						ga('linker:autoLink', [o.d]);
						ga('pjs.send', 'event', {
							eventCategory: 'Player',
							eventAction: 'Init',
							eventLabel: o.d
						})
					}
				}, 3000)
			}
		}
		if(v.ga == 1 && v.ga4 != 1) {
			if(typeof PluginOldGA == 'function') {
				o.ga = new PluginOldGA()
			}
		}
		if(!o.container) {
			v.log = 1;
			log('id "' + v.id + '" not found');
			return false
		}
		o.container.innerHTML = '';
		css(o.container, {
			'padding': 0,
			'word-spacing': 'normal'
		});
		o.container_h = o.container.offsetHeight;
		o.container_w = o.container.offsetWidth;
		if(exist(v.playersize) && !exist(v.aspect)) {
			if(exist(v.playersize.aspect)) {
				v.aspect = v.playersize.aspect
			}
			if(exist(v.playersize.changeheight)) {
				v.changeheight = v.playersize.changeheight
			}
		}
		if(o.container.style.width.indexOf("%") > -1) {
			o.container_w_procent = o.container.style.width
		}
		if(v.aspect == "off" || o.container.style.height.indexOf("%") > -1) {
			v.aspect = "%";
			o.container_h_procent = o.container.style.height;
			o.container_h = 0
		}
		if(o.container_w == 0) {
			if(o.container.style.width.indexOf("px") > 0) {
				o.container_w = parseInt(o.container.style.width)
			} else {
				if(o.container.parentNode.style.width.indexOf("px") > 0) {
					o.container_w = parseInt(o.container.parentNode.style.width)
				} else {
					if(o.container.parentNode.parentNode.style.width.indexOf("px") > 0) {
						o.container_w = parseInt(o.container.parentNode.parentNode.style.width)
					}
				}
			}
		}
		if(String(v.aspect).indexOf("x") > 0) {
			o.aspect = v.aspect.split("x")[0] / v.aspect.split("x")[1];
			if(o.container_h == 0) {
				o.container_h = o.container_w / o.aspect
			}
		} else {
			o.aspect = 0
		}
		css(o.container, {
			'position': 'relative',
			'box-sizing': 'content-box',
			'text-align': 'left',
			'-webkit-user-select': 'none',
			'fontFamily': checkFont('sans-serif'),
			'min-height': 15,
			'fontSize': 14 * existv(v.globalfs, 1),
			'line-height': '1em',
			'direction': 'ltr',
			'color-scheme': 'none'
		});
		if(v.shadow == 1) {
			css(o.container, {
				'box-shadow': ' 0 15px 35px rgba(50,50,93,.1), 0 5px 15px rgba(0,0,0,.07)'
			})
		}
		if(o.aspect > 0) {
			css(o.container, {
				'height': o.container_h
			})
		} else {
			css(o.container, {
				'height': o.container_h == 0 ? o.container_h_procent : o.container_h
			})
		}
		if(o.container_w == 0) {
			css(o.container, {
				'width': '100%'
			})
		}
		o.frame = createElement("div");
		css(o.frame, {
			'position': 'absolute',
			'box-sizing': 'content-box',
			'backgroundColor': v.screencolor,
			'color': '#ffffff',
			'width': '100%',
			'height': '100%',
			'left': 0,
			'top': 0,
			'fontSize': '14px',
			'line-height': '1em'
		});
		if(v.notofh != 1) {
			o.frame.style.overflow = 'hidden'
		}
		if(v.transbg == 1) {
			o.frame.style.backgroundColor = 'transparent'
		}
		if(v.border == 1) {
			css(o.container, {
				'border': v.bordersize + 'px solid ' + v.bordercolor
			})
		}
		o.css = document.createElement('style');
		o.css.type = 'text/css';
		o.frame.appendChild(o.css);
		o.frame.setAttribute("id", 'oframe' + v.id);
		datetime(1);
		if(window.MutationObserver) {
			var obsrvr = new MutationObserver(function(e) {
				if(e[0].removedNodes.length > 0) {
					for(var i = 0; i < e[0].removedNodes.length; i++) {
						if(e[0].removedNodes[i] == o.frame) {
							Destroy()
						}
					}
				}
			});
			obsrvr.observe(o.container, {
				childList: true
			})
		}
		o.frameresize = createElement('iframe');
		attr(o.frameresize, {
			"id": "pjsfrrs" + v.id,
			"scrolling": "no",
			"title": "pjsfrrs" + v.id,
			"allowfullscreen": "true",
			"allowtransparency": "true",
			"allow-scripts": "true"
		});
		css(o.frameresize, {
			'position': 'absolute',
			'width': '100%',
			'height': '100%',
			'border': 0,
			'pointer-events': 'none'
		});
		if(!document.querySelector('.pjscssed')) {
			var tmp = "";
			if(v.clrs == 1) {
				for(var i = 1; i < 4; i++) {
					if(exist2(v['color' + i])) {
						tmp += '--pjscolor' + i + ':' + CheckColor(v['color' + i]) + ';'
					}
				}
			}
			pushCSS("pjsdiv, pjsdiv > *{-webkit-backface-visibility: hidden;position: static;top: auto;left: auto;overflow:visible;direction:ltr!important;max-width:none!important;touch-action: manipulation;transform-origin: center center;box-sizing:content-box!important;-webkit-tap-highlight-color: rgba(0,0,0,0);-webkit-tap-highlight-color: transparent;text-indent:0!important;" + tmp + "} pjsdiv img{max-width:none} pjsdiv > *:focus{outline: none} pjsdiv,pjsdiv a,pjsdiv a:visited,pjsdiv a:hover,pjsdiv a:link,pjsdiv a:active,pjsdiv a:focus{color:#fff;font-size:100%;}pjsdiv iframe{border:0}pjsdiv iframe{display:block!important;max-height:none!important;background:transparent}.pjscssed{}");
			o.frame.setAttribute('class', 'pjscssed')
		}
		o.frame.appendChild(o.frameresize);
		o.container.oncontextmenu = function ContextMenu(e) {
			o.rightclick++;
			if(o.rightclick == 5) {
				v.log = 1;
				log(o.version + ' ' + o.compilations + ' ' + o.playerid)
			}
			if(!e) var e = window.event;
			e.cancelBubble = true;
			if(e.stopPropagation) e.stopPropagation();
			var x = e.pageX - findLeft(o.frame);
			var y = e.pageY - findTop(o.frame);
			if(v.rc_custom == 1) {
				if(exist(v.rc_label)) {
					if(trim(v.rc_label) != '') {
						o.brand = v.rc_label;
						exist(v.rc_labelurl) ? o.brandurl = v.rc_labelurl : '';
						v.rc_label == 'none' ? o.brandurl = o.d : ''
					}
				}
			}
			RightMenu(x, y);
			return false
		};

		function RightMenu(x, y) {
			if(o.brandurl.indexOf(o.d) == -1 || v.rc_anyway == 1 || v.rightmenu == 1) {
				if(!exist(o.rightmenu)) {
					!v.rmbgcolor ? v.rmbgcolor = "000000" : '';
					!v.rmcolor ? v.rmcolor = "ffffff" : '';
					o.rightmenu = createElement('div');
					var tmp;
					var n = 0;
					for(var i = 0; i < 10; i++) {
						if((v['rm' + i] == 1 && v.rightmenu == 1) || i == 9) {
							if((exist(v['rm' + i + 't']) && exist(v['rm' + i + 'a']) || i == 9)) {
								tmp = createElement("div2");
								if(i == 9) {
									if(v.rc_nobrand != 1) {
										tmp.innerText = o.brand + (v.rc_version == 1 ? " " + o.version : '')
									} else {
										break
									}
								} else {
									tmp.innerText = v['rm' + i + 't']
								}
								if(i != 9) {
									if(v['rm' + i + 'a'].indexOf(",0/1") > -1 || v['rm' + i + 'a'].indexOf(",1/0") > -1) {
										var z = v['rm' + i + 'a'].split(',');
										tmp.innerText += ' (' + (apiProcessor(z[0].substr(4)) == 1 ? Lang('on') : Lang('off')) + ')'
									}
									if(v['rm' + i + 'a'].indexOf("share") == 0) {
										o.shareme = true;
										!o.share ? o.controls.CrShr() : ''
									}
								}
								tmp.setAttribute("i", i);
								RightCSS(tmp);
								tmp.addEventListener("click", RightClick);
								o.rightmenu.appendChild(tmp);
								n++
							}
						}
					}
					css(o.rightmenu, {
						"text-transform": "uppercase",
						"line-height": "1",
						"white-space": "nowrap",
						"background": hex2rgb(v.rmbgcolor, 0.7)
					});
					if(n > 1) {
						css(o.rightmenu, {
							"padding": "5px"
						})
					}
					o.rightmenu.style.zIndex = "99999";
					o.rightmenu.onmousemove = RightMove;
					o.frame.appendChild(o.rightmenu)
				} else {
					show2(o.rightmenu)
				}
				css(o.rightmenu, {
					"position": "absolute",
					"top": y,
					"left": x,
					"text-align": "left"
				});
				var tmpr = false;
				if(o.screen_w - x < o.rightmenu.offsetWidth - 20 && v.notofh != 1) {
					css(o.rightmenu, {
						"left": x - o.rightmenu.offsetWidth
					});
					tmpr = true
				}
				if(v.rmright == 1 || tmpr) {
					css(o.rightmenu, {
						"text-align": "right"
					})
				}
				o.right_x = x;
				o.right_y = y;
				clearTimeout(o.rightout);
				o.rightout = setTimeout(function() {
					hide2(o.rightmenu)
				}, 2000)
			}
		}

		function RightMove() {
			clearTimeout(o.rightout);
			o.rightout = setTimeout(function() {
				hide2(o.rightmenu)
			}, 2000)
		}

		function RightClick(e) {
			var i = e.target.getAttribute("i");
			var y;
			var dont = false;
			if(i > 0) {
				if(i == 9) {
					o.brandurl != '' ? window.open(o.brandurl) : ''
				} else {
					var x = v['rm' + i + 'a'];
					if(x) {
						if(x.indexOf("api:") == 0) {
							if(x.indexOf(",0/1") > -1 || x.indexOf(",1/0") > -1) {
								var z = x.split(',');
								var b = o.controls.butByS(x, "linkurl");
								var u = apiProcessor(z[0].substr(4), z[1], b);
								js(z, u);
								reRightMenu();
								RightMenu(o.right_x, o.right_y);
								dont = true
							} else {
								y = x.split(",");
								apiProcessor(y[0].substr(4), (exist(y[1]) ? y[1] : null))
							}
						}
						if(x.indexOf("share:") == 0 && o.share) {
							o.share.api(x.substr(6))
						}
						if(x.indexOf("js:") == 0) {
							y = x.split(",");
							eval(y[0].substr(3) + '(' + (exist(y[1]) ? '"' + y[1] + '"' : '') + (exist(y[2]) ? ',"' + y[2] + '"' : '') + ')')
						}
						if(x.indexOf("url:") == 0) {
							x = x.replace(/\(url\)/g, Href());
							x = x.replace(/\(ref\)/g, encodeURIComponent(exist(v.parent_domain) ? v.parent_domain : document.referrer));
							x = x.replace(/\(title\)/g, o.titlestore);
							x = x.replace(/\(label\)/g, v.label);
							window.open(x.substr(4))
						}
					}
				}!dont ? hide2(o.rightmenu) : ''
			}
		}

		function RightCSS(x) {
			css(x, {
				"padding": "4px 5px",
				"font-size": (v.rmsize ? v.rmsize : "55") * existv(v.globalfs, 1) + "%",
				"letter-spacing": "0.15em",
				"opacity": 0.9,
				"color": v.rmcolor
			});
			x.addEventListener("mouseover", RightOver);
			x.addEventListener("mouseout", RightOut)
		}

		function RightOver(e) {
			css(e.target, {
				"opacity": 1
			});
			css(e.target, {
				"background": hex2rgb(v.rmbgcolor, 0.5)
			})
		}

		function RightOut(e) {
			css(e.target, {
				"opacity": 0.9
			});
			css(e.target, {
				"background": "none"
			})
		}
		o.system = new System();
		if(o.system.ios) {
			var ioscss = (v.hidestartbutios == 1 ? '*::-webkit-media-controls-start-playback-button {display: none!important;-webkit-appearance: none;}' : '');
			if(v.nativecontrolsmobile == 1 && v.nativenotios != 1 && (v.nativenotiphone != 1 || !o.system.iphone) && (v.nativenotipad != 1 || !o.system.ipad)) {} else {
				if(o.system.ios && v.nativefullios == 1) {} else {
					ioscss += 'video::-webkit-media-controls {display:none !important;}*::-webkit-media-controls-panel {display: none!important;-webkit-appearance: none;}*::--webkit-media-controls-play-button {display: none!important;-webkit-appearance: none;}'
				}
			}
			var tmp = document.createElement('style');
			tmp.type = 'text/css';
			tmp.appendChild(document.createTextNode(ioscss));
			o.frame.appendChild(tmp)
		}
		if(o.system.mobiletv) {
			v.autoplay == 1 && v.autoplaynomobiletv == 1 ? v.autoplay = 0 : ''
		}
		if(o.aspect == 0) {
			if(o.frame.offsetHeight == 15 && !o.container_h_procent && v.playerheight > 0) {
				css(o.container, {
					"height": v.playerheight
				})
			}
		}
		if(exist(v.autonext)) {
			v.playlist.autoplaylist = v.autonext
		}
		if(exist(v.playlistloop)) {
			v.playlist.playlistrewind = v.playlistloop
		}
		if(exist(v.start)) {
			o.seekto = v.start
		}
		if(exist(window.requestAnimationFrame) && v.rafinit == 1) {
			window.requestAnimationFrame(Ready)
		} else {
			Ready()
		}
	}

	function Ready() {
		log("Ready");
		o.actions = new Actions();
		if(!v.file) {
			v.file = "?"
		}
		if(v.pl) {
			v.file = v.pl + o.pltxt
		}
		o.sessid = randomstr();
		o.sesstime = 0;
		o.storage = StorageSupport();
		if(o.storage) {
			if(localStorage.getItem("pljsuserid") != null) {
				o.userid = localStorage.getItem("pljsuserid")
			} else {
				o.userid = randomstr();
				localStorage.setItem("pljsuserid", o.userid)
			}
			if(v.qualitystore == 1) {
				if(localStorage.getItem("pljsquality") != null) {
					o.default_quality = localStorage.getItem("pljsquality");
					if(exist2(v.forbidden_quality)) {
						if(v.forbidden_quality.indexOf(o.default_quality) > -1) {
							o.default_quality = null
						}
					}
				}
			}
			if(v.trackstore == 1) {
				if(localStorage.getItem("pljstrack") != null) {
					v.default_audio = localStorage.getItem("pljstrack")
				}
			}
			for(var i = 0; i < o.vsts.length; i++) {
				if(v['vast_nofirst' + o.vsts[i]] == 1) {
					if(localStorage.getItem("pljsfirst" + o.vsts[i]) != null) {} else {
						v[o.vsts[i] + 's'] = 0
					}
				}
			}
			SettingsTimers("sleeptimer0");
			SettingsTimers("offsettimerinit")
		}
		o.href2 = o.href.substr(o.href.indexOf("://") + 3);
		if(o.href2.indexOf("#") > 0) {
			o.href2 = o.href2.substr(0, o.href2.indexOf("#"))
		}
		if(o.storage && v.timestore == 1) {
			o.continue = new TimeStore()
		}
		if(v.observer == 1) {
			o.visibility = v.startvisibility;
			Visibility(o.container, "visibility", true)
		}
		v.minify == 1 && v.observer == 1 ? o.minify = new PluginMini() : '';
		v.ab == 1 ? PluginBlock() : '';
		if(v.quizes == 1) {
			o.quiz = new PluginQuiz();
			o.quiz.Start()
		}
        console.log("LLLL")
        console.log(v.file)
		o.media = new Media(v.file);
		if(!o.system.mobile || v.desktop == 1) {
			o.frame.addEventListener("mouseenter", function() {
				o.mouseHere = true;
				o.mouseHere2 = true;
				o.controls ? o.controls.StageOver() : ''
			});
			o.frame.addEventListener("mouseleave", function(e) {
				if(!o.mouseDown) {
					if(v.toolbar.hideleavetimeout > 0) {
						clearTimeout(o.leavetimeout2);
						o.leavetimeout2 = setTimeout(function() {
							if(o.mouseHere != o.mouseHere2) {
								o.mouseHere = o.mouseHere2;
								o.controls.Review()
							}
						}, v.toolbar.hideleavetimeout * 1000)
					} else {
						o.mouseHere = false
					}
					o.mouseHere2 = false;
					if(o.controls) {
						o.controls.StageLeave()
					}
				}
			})
		}
		if(!o.system.mobile) {
			o.frame.addEventListener("mousedown", function(e) {
				o.mouseDown = true
			});
			o.frame.addEventListener("mouseup", function(e) {
				o.mouseDown = false;
				if(!o.volumewheel) {
					o.hidden_volume_over = false;
					o.hidden_volume_over_process = false
				}
				if(o.system.touch && o.system.desktop && o.fullscreen) {
					setTimeout(function() {
						o.mouseHere = false;
						o.controls.Review()
					}, 500)
				}
				setTimeout(function() {
					o.focus = true
				}, 500);
				if(o.system.mobile && o.controls.ToolbarHidden()) {} else {
					o.controls ? o.controls.StageMouseUp(e.clientX, e.clientY) : ''
				}
				if(v.hidevideo == 1) {
					if(o.controls.SettingsVisible()) {
						o.controls.Settings()
					}
				}
			});
			o.frame.addEventListener("mousemove", function(e) {
				if(exist(o.controls)) {
					if(o.mouseDown) {
						o.controls.StageMove(e.clientX, e.clientY)
					} else {
						o.controls.StageMove2()
					}
				}
			})
		}
		if(o.system.mobile) {
			window.addEventListener("orientationchange", OrientationChange, false)
		}
		v.geo == 1 && typeof PluginGeo == 'function' ? o.geo = new PluginGeo() : '';
		o.mediacontainer.addEventListener("touchstart", function(e) {
			if(e.touches) {
				o.tchs = e.touches.length
			}
			o.mouseDown = true;
			o.mouseHere = true;
			o.mouseMove = false;
			Touch("start", e)
		}, {
			passive: true
		});
		o.mediacontainer.addEventListener("touchmove", function(e) {
			if(e.touches) {
				o.tchs = e.touches.length;
				if(o.tchs > 1) {
					o.tchs2 = 1
				}
			}
			if(o.mouseDown) {
				o.mouseMove = true;
				Touch("move", e)
			}
		}, {
			passive: true
		});
		o.mediacontainer.addEventListener("touchend", function(e) {
			o.mouseDown = false;
			setTimeout(function() {
				o.mouseHere = false
			}, 500);
			if(v.click0timeout == 1) {
				var now = new Date().getTime();
				if(now - o.clicktime < (v.dclckto ? v.dclckto : 0.3) * 1000) {
					DoubleClick(e)
				}
			}!o.mouseMove && o.tchs < 2 && o.tchs2 != 1 ? ScreenClick(e) : '';
			o.mouseMove = false;
			o.tchs = 0;
			if(e.touches.length == 0) {
				o.tchs = 0;
				o.tchs2 = 0
			}
			Touch("end", e)
		}, {
			passive: true
		});
		try {
			window.document.addEventListener("mouseup", function(e) {
				o.focus = false;
				if(!o.volumewheel) {
					o.hidden_volume_over = false;
					o.hidden_volume_over_process = false
				}
				if(o.mouseDown && o.controls) {
					o.mouseDown = false;
					o.controls.StageMouseUp(e.clientX, e.clientY);
					o.controls.StageLeave()
				}
				if(!o.mouseHere && !o.system.mobile && !o.system.tv) {
					o.controls.SettingsClose();
					if(o.droplist) {
						o.droplist.Close()
					}
					o.controls.closePl()
				}
			})
		} catch(err) {}
		window.document.addEventListener("mousemove", function(e) {
			o.controls && o.mouseDown ? o.controls.StageMove(e.clientX, e.clientY) : ''
		});
		o.frame.addEventListener("touchstart", function(e) {
			o.touch = true;
			o.mouseDown = true
		}, {
			passive: true
		});
		o.frame.addEventListener("touchend", function(e) {
			o.touch = false;
			o.mouseDown = false
		}, {
			passive: true
		});
		window.document.addEventListener("touchmove", function(e) {
			if(o.controls && o.touch) {
				o.controls.StageMove(e.touches[0].pageX, e.touches[0].pageY)
			}
		}, {
			passive: true
		});
		window.document.addEventListener("keyup", function(e) {
			var x = e.target.tagName.toLowerCase();
			if(x == 'input' || x == 'textarea' || x == 'pjsin') {
				return
			} else {
				o.controls ? o.controls.KeyUp(e) : ''
			}
		});
		window.document.addEventListener("keydown", function(e) {
			var x = e.target.tagName.toLowerCase();
			if(x == 'input' || x == 'textarea' || x == 'div' || x == 'pjsin') {
				return
			} else {
				o.controls ? o.controls.KeyDown(e) : ''
			}
		});
		if(o.parentIframe) {
			FSL(parent.document, ParentFS)
		}
		FSL(document, FullscreenChange);

		function FSL(x, z) {
			var y = ['', 'moz', 'webkit', 'ms', 'MSFullscreenChange'];
			if(x) {
				for(var i = 0; i < y.length; i++) {
					x.addEventListener(y[i] + (i < y.length - 1 ? "fullscreenchange" : ''), z, false)
				}
			}
		}
		if(!exist(o.frameresize.contentWindow)) {
			log("Local");
			return
		} else {
			o.frameresize.contentWindow.addEventListener('resize', FrameResizer, true)
		}
		if(!o.system.mobile) {
			o.mediacontainer.addEventListener("click", ScreenClick, false);
			if(v.doubleclick == 1 && v.click0timeout == 1) {
				o.mediacontainer.addEventListener("dblclick", DoubleClick, false)
			}
		}
		MainUpdateSize();
		if(v.chromecast) {
			v.chromecast.on == 1 ? o.chromecast = new ChromeCast() : ''
		}
		v.effects == 1 ? o.effects = new PluginEffects() : '';
		v.mediatags == 1 ? o.mediatags = new PluginMediaTags() : '';
		o.controls = new Controls();
		if(v.control_title.templated) {
			o.title_template = v.control_title.template
		}
		Title();
		MainResize();
		if(o.storage) {
			if(v.volumestore == 1 && v.volume != 0 && !o.system.mobile) {
				if(localStorage.getItem("pljsvolume") != null) {
					v.volume = localStorage.getItem("pljsvolume")
				}
				if(localStorage.getItem("pljsmute") == 1 && v.mutestore == 1) {
					v.mute = 1
				}
			}
			if(v.speedstore == 1) {
				var sp = localStorage.getItem("pljsspeed");
				if(exist(sp)) {
					if(sp.indexOf('.') > 0 && o.line_speed) {
						o.actions.SetSpeed(sp, 1)
					} else {
						if(o.files_speed) {
							var spd = o.files_speed.indexOf(sp);
							spd == -1 ? spd = o.files_speed.indexOf(sp * 1) : '';
							if(spd != -1 && o.controls.SettingsExist('speed')) {
								o.current_speed = spd;
								o.media.SetSpeed(o.files_speed[spd])
							}
							o.controls.SettingsSpeed()
						}
					}
				}
			}
			var substore = false;
			if(v.sub_designstore == 1) {
				for(var j = 0; j < o.sub_options.length; j++) {
					if(localStorage.getItem("pljs" + o.sub_options[j]) != null) {
						v[o.sub_options[j]] = localStorage.getItem("pljs" + o.sub_options[j]);
						substore = true
					}
				}
			}
			if(o.system.mobile) {
				if(!substore) {
					v.sub_bottommob && v.sub_bottommob > -1 ? v.sub_bottom = v.sub_bottommob : ''
				}
				if(exist(v.sub_sizemob)) {
					v.sub_size = v.sub_sizemob;
					exist2(v.sub_sizemobfull) ? v.sub_size_fullscreen = v.sub_sizemobfull : ''
				}
			}
		}
		if(o.continue) {
			var f = o.continue.flag();
			if(f.t && f.d) {
				o.controls.Played(f.t, f.d);
				o.controls.Duration(f.t, f.d);
				v.duration = f.d
			}
		}
		o.actions.Volume(v.volume);
		if(v.mute == 1) {
			o.actions.Mute();
			o.controls.refresh()
		}
		if(exist(v.default_speed)) {
			apiProcessor("speed", v.default_speed)
		}
		o.alert = new Alert();
		if(v.rounding > 0) {
			if(v.hidevideo == 1 || o.normal_h < 120) {
				css(o.container, {
					"border-radius": (v.rounding + "px")
				});
				css(o.frame, {
					"border-radius": (v.rounding + "px")
				})
			} else {
				PluginRounding()
			}
		}
		if(exist(v.midroll)) {
			str2obj("midroll")
		}
		if(exist(v.overlay)) {
			str2obj("overlay")
		}
		if(exist(o.playlist)) {
			js("playlist")
		}
		if(v.pass == 1 && v.passonstart == 1) {
			o.actions.Password()
		}
		for(var i = 2; i < 10; i++) {
			if(exist(v["design" + i])) {
				if(v["design" + i] == "mobile" && o.system.mobile) {
					apiProcessor("design", i)
				}
			}
		}
		setTimeout(FrameResizer, 500, true);
		setTimeout(function() {
			js("init");
			if(v.ready) {
				if(typeof v.ready == 'function') {
					v.ready = v.ready.name
				};
				eval(v.ready + (v.ready.indexOf('()') == -1 ? '("' + v.id + '")' : ''))
			}
		}, 1)
	}

	function ScreenClick(e) {
		if(o.moving[o.mediacontainer] > 2) {
			return
		}
		o.acted = true;
		v.dclckto == 0 ? v.click0timeout = 1 : '';
		if(o.click_t && v.screenclick == 1 && !o.system.tv) {
			DoubleClick(e)
		} else {
			var t = (v.dclckto ? v.dclckto : 0.35) * 1000;
			ClearClick();
			clearTimeout(o.click_t2);
			o.click_t2 = setTimeout(function() {
				o.clicks = 0
			}, t + 200);
			if(v.click0timeout == 1 || (v.doubleclick == 0 && v.hotkey.seeksides != 1)) {
				ScreenClick2()
			} else {
				o.click_t = setTimeout(ScreenClick2, t)
			}
		}
		o.clicks++
	}

	function ScreenClick2() {
		ClearClick();
		if(o.system.mobile) {
			if(o.controls.ToolbarHidden()) {
				if(o.muted && v.unmuteonclick == 1) {
					o.actions.Unmute();
					v.unmuteonclick = 0
				}
				o.controls.StageMove2();
				return
			}
			if(o.nativefull) {
				if(v.nativefulldroid == 1 && v.nfscldr == 1 && o.system.android) {
					return
				}
				if(v.nativefullios == 1 && v.nfsclios == 1 && o.system.ios) {
					return
				}
			}
		}
		if(o.clicks > 1 && v.hotkey.seeksides == 1) {
			o.clicks = 0;
			return
		}
		o.clicks = 0;
		if(v.screenclick == 1) {
			o.system.mobile && v.nombclck == 1 ? '' : o.actions.ScreenClick()
		}
	}

	function DoubleClick(e) {
		ClearClick();
		var y = false;
		if(v.hotkey.seeksides == 1) {
			if(e) {
				if(v.hotkey.seeksidesmob == 1 && !o.system.mobile) {} else {
					var x;
					if(o.system.mobile) {
						x = e.layerX;
						if(!x) {
							if(e.changedTouches) {
								x = e.changedTouches[0].pageX - findLeft(o.frame)
							}
						}
					} else {
						x = e.offsetX
					}
					if(o.fzoom > 1) {
						x = x / o.fzoom
					}
					if(x) {
						if(x < o.screen_w / 2) {
							if(x < o.screen_w * 20 / 100) {
								apiProcessor("seek", "-" + existv(v.hotkey.seeksidesec, 10) * o.clicks);
								v.hotkey.icons == 1 && v.hotkey.seekicon == 1 ? PluginHotIcon('seek', 0) : '';
								y = true
							}
						} else {
							if(x > o.screen_w - o.screen_w * 20 / 100) {
								apiProcessor("seek", "+" + existv(v.hotkey.seeksidesec, 10) * o.clicks);
								v.hotkey.icons == 1 && v.hotkey.seekicon == 1 ? PluginHotIcon('seek', 1) : '';
								y = true
							}
						}
						if(y) {
							if(e.stopPropagation) e.stopPropagation()
						}
					}
				}
			}
		}
		if(!y) {
			if(v.doubleclick == 1) {
				if(v.nativecontrolsmobile == 1 && o.system.mobile) {} else {
					o.fullscreen ? o.actions.Normalscreen() : o.actions.Fullscreen()
				}
			}
		}
	}

	function ClearClick() {
		clearTimeout(o.click_t);
		o.click_t = undefined
	}

	function FrameResizer(x) {
		if(o.screen_lw != o.frame.offsetWidth) {
			x ? o.screen_lw = o.frame.offsetWidth : '';
			FrameResizer()
		} else {
			MainResize()
		}
	}

	function MainResize() {
		var y = false;
		if(o.normal_w != o.frame.offsetWidth || o.normal_h != o.frame.offsetHeight) {
			y = true
		}
		MainUpdateSize();
		o.controls ? o.controls.resize() : '';
		o.media.resize();
		y && !o.fullscreen ? js("resize", o.normal_w + ',' + o.normal_h) : ''
	}

	function MainUpdateSize() {
		var xw = o.frame.offsetWidth;
		var xh = o.frame.offsetHeight;
		if(o.controls) {
			if(v.change2playlist == 1) {
				if(v.playlist.position != "bottom") {
					var x = o.controls.PlaylistG("scroll_height") + o.controls.PlaylistG("top") + 5 + o.controls.PlaylistG("margin_bottom") + existv(v.change2playlist_bottom, 0);
					css(o.container, {
						"height": x
					})
				}
			}
		}
		if(o.aspect > 0 && !o.fullscreen && !o.fullscreen_start) {
			xh = xw / o.aspect + existv(v.screenmarginbottom, 0);
			css(o.container, {
				"height": xh
			})
		}
		if(!o.fullscreen && !o.fullscreen_start && !o.fullscreen_process) {
			o.normal_w = Math.round(xw);
			o.normal_h = Math.round(xh)
		}
		if(o.system.mobile && o.fullscreen && v.landfullmobile == 1 && screen.orientation) {
			if(o.aspect > 0) {
				if(o.aspect < 1 || o.media.ratio() < 1) {
					var sp = screen.orientation.lock('portrait');
					if(sp !== undefined) {
						sp.then(function() {}).catch(function(e) {})
					}
				} else {
					var sp = screen.orientation.lock('landscape');
					if(sp !== undefined) {
						sp.then(function() {}).catch(function(e) {})
					}
				}
			} else {
				var sp = screen.orientation.lock('landscape');
				if(sp !== undefined) {
					sp.then(function() {}).catch(function(e) {})
				}
			}
		}
		o.screen_w = xw;
		o.screen_h = xh;
		if(exist(v.title) && o.controls) {
			v.title != '' ? o.controls.updateTitle() : ''
		}
		if(exist(o.custom_aspect)) {
			o.media.scale(o.custom_aspect)
		}
		if(o.vast && !o.fullscreen) {
			o.vast.Resize()
		}
		o.droplist ? o.droplist.Resize() : '';
		o.quiz ? o.quiz.Resize() : '';
		o.effects ? o.effects.api('resize') : ''
	}

	function Title() {
		o.actions.TitleTemplate(v);
		for(var x in v) {
			if(v.hasOwnProperty(x)) {
				if(x.indexOf("title") == 0) {
					if(v[x] != '') {
						o.maintitle = v[x];
						o.actions.Title(x)
					}
				}
			}
		}
		o.mediatags ? o.mediatags.read() : ''
	}

	function Poster(url, container, scale) {
		if(url) {
			if(url != '') {
				if(v.fplace == 1) {
					url = fplace(url)
				}
				if(container == o.poster && url == o.currentposter) {} else {
					if(url.indexOf("#" + v.enc2) == 0) {
						url = o[o.fd[0]](url)
					}
					if(url.indexOf("#0") == 0) {
						url = fd0(url)
					}
					url = checkBase64(url);
					if(exist(v.preposter) && url.indexOf("//") == -1) {
						url = v.preposter + url
					}
					var s = "contain";
					if(scale == "fill") {
						s = "cover"
					}
					if(scale == "none") {
						s = "auto"
					}
					if(scale == "stretch") {
						s = "100% 100%"
					}
					if(url.indexOf(' and ') > 0 && container == o.poster) {
						o.pstrs = url.split(' and ');
						clearInterval(o.pstrsin);
						o.pstrsin = setInterval(Posters, existv(v.posterstime, 2) * 1000);
						o.pstrsi = 0;
						url = o.pstrs[0]
					}
					url = url.replace(/ or /g, '"),url("');
					url = url.replace(/\s/g, '%20');
					if(v.pstrvd == 1 && indOf([url], '.mp4')) {
						var tmp = 'pjs' + v.id + '_vdpsrt';
						container.innerHTML = '<video id="' + tmp + '" src="' + url + '" loop=1 playsinline=1 autoplay=1 muted=1 style="width:100%"></video>';
						o.pstrv = document.getElementById(tmp)
					} else {
						container.innerHTML = '';
						css(container, {
							'background-image': 'url("' + url + '")',
							'background-repeat': 'no-repeat',
							'background-position': 'center',
							'background-size': s
						})
					}
					show(container);
					container == o.poster ? o.currentposter = url : ''
				}
			}
		}
	};

	function Posters() {
		if(exist(o.pstrs) && exist(o.pstrsi)) {
			o.pstrsi++;
			if(o.pstrsi >= o.pstrs.length) {
				o.pstrsi = 0
			}
			Poster(o.pstrs[o.pstrsi], o.poster, v.poster_scale)
		}
	}

	function Logo(x) {
		if(x.on == 1 && exist(x.src)) {
			x.src = checkBase64(x.src);
			var y = createElement("div");
			if(x.src.indexOf("http") > -1 || x.src.indexOf("//") == 0) {
				var z = createElement("img");
				z.src = x.src;
				y.appendChild(z)
			}
			x = UpdateObject(x, v.logo);
			x = MarginPadding(x, 'margin', 'margin');
			css(y, {
				'position': 'absolute'
			});
			if(x.position.indexOf("bottom") > -1) {
				css(y, {
					'bottom': x.marginbottom
				})
			}
			if(x.position.indexOf("right") > -1) {
				css(y, {
					'right': x.marginright
				})
			}
			if(x.position.indexOf("top") > -1) {
				css(y, {
					'top': x.margintop
				})
			}
			if(x.position.indexOf("left") > -1) {
				css(y, {
					'left': x.marginleft
				})
			}
			o.container.appendChild(y)
		}
	};

	function FullscreenChange() {
		if(o.fullscreen && !isFullscreen()) {
			o.actions.NormalscreenUI(true);
			o.system.firefox ? MainResize() : ''
		} else {
			if(o.fullscreen_start || o.mouseHere) {
				isFullscreen() ? o.fullscreen = true : '';
				o.actions.FullscreenUI()
			}
		}
		log("fullscreen", o.fullscreen)
	}

	function ParentFS() {
		if(v.observer == 1) {
			Visibility(o.container, "visibility", true)
		}
	}

	function Orientation() {
		log("orientation " + screen.orientation.angle)
	}

	function OrientationChange() {
		if(Math.abs(window.orientation) === 90) {
			log("landscape");
			if(v.landscapefull == 1) {
				var ok = true;
				if(v.lsfullstart == 1 && !o.start) {
					ok = false
				}
				if(v.lsfullplay == 1 && !o.play) {
					ok = false
				}
				if(o.ispipkit) {
					ok = false
				}
				if(o.vast) {
					ok = true
				}!o.fullscreen && ok ? o.actions.Fullscreen() : ''
			}
		} else {
			log("portrait");
			if(v.landscapefull == 1) {
				o.fullscreen && v.landfullmobile != 1 ? o.actions.Normalscreen() : ''
			}
		}
	}

	function isFullscreen(x) {
		!x ? x = document : '';
		var y = false;
		try {
			y = !!(x.webkitFullscreenElement || x.webkitIsFullScreen || x.mozFullScreen || x.msFullscreenElement || (x.fullscreenElement != undefined))
		} catch(e) {
			y = false
		}
		return y
	}

	function isHidden(x) {
		return x.offsetWidth == 0 && x.offsetHeight == 0
	};

	function Destroy() {
		for(var x in o) {
			if(x.indexOf("Interval") > -1) {
				clearInterval(o[x])
			}
			if(x.indexOf("timeout") > -1) {
				clearTimeout(o[x])
			}
		}
		log("Destroyed")
	}
}
"undefined" != typeof window && function(t, e) {
	"object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? exports.Hls = e() : window.Hls = e()
}(this, (() => (() => {
	var t = {
			21: (t, e, r) => {
				"use strict";
				r.r(e), r.d(e, {
					default: () => u
				});
				var i = function() {
						function t(t, e) {
							this.subtle = void 0, this.aesIV = void 0, this.subtle = t, this.aesIV = e
						}
						return t.prototype.decrypt = function(t, e) {
							return this.subtle.decrypt({
								name: "AES-CBC",
								iv: this.aesIV
							}, e, t)
						}, t
					}(),
					n = function() {
						function t(t, e) {
							this.subtle = void 0, this.key = void 0, this.subtle = t, this.key = e
						}
						return t.prototype.expandKey = function() {
							return this.subtle.importKey("raw", this.key, {
								name: "AES-CBC"
							}, !1, ["encrypt", "decrypt"])
						}, t
					}(),
					a = r(145),
					s = function() {
						function t() {
							this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.ksRows = 0, this.keySize = 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.initTable()
						}
						var e = t.prototype;
						return e.uint8ArrayToUint32Array_ = function(t) {
							for(var e = new DataView(t), r = new Uint32Array(4), i = 0; i < 4; i++) r[i] = e.getUint32(4 * i);
							return r
						}, e.initTable = function() {
							var t = this.sBox,
								e = this.invSBox,
								r = this.subMix,
								i = r[0],
								n = r[1],
								a = r[2],
								s = r[3],
								o = this.invSubMix,
								l = o[0],
								u = o[1],
								d = o[2],
								h = o[3],
								c = new Uint32Array(256),
								f = 0,
								g = 0,
								v = 0;
							for(v = 0; v < 256; v++) c[v] = v < 128 ? v << 1 : v << 1 ^ 283;
							for(v = 0; v < 256; v++) {
								var p = g ^ g << 1 ^ g << 2 ^ g << 3 ^ g << 4;
								p = p >>> 8 ^ 255 & p ^ 99, t[f] = p, e[p] = f;
								var m = c[f],
									y = c[m],
									E = c[y],
									T = 257 * c[p] ^ 16843008 * p;
								i[f] = T << 24 | T >>> 8, n[f] = T << 16 | T >>> 16, a[f] = T << 8 | T >>> 24, s[f] = T, T = 16843009 * E ^ 65537 * y ^ 257 * m ^ 16843008 * f, l[p] = T << 24 | T >>> 8, u[p] = T << 16 | T >>> 16, d[p] = T << 8 | T >>> 24, h[p] = T, f ? (f = m ^ c[c[c[E ^ m]]], g ^= c[c[g]]) : f = g = 1
							}
						}, e.expandKey = function(t) {
							for(var e = this.uint8ArrayToUint32Array_(t), r = !0, i = 0; i < e.length && r;) r = e[i] === this.key[i], i++;
							if(!r) {
								this.key = e;
								var n = this.keySize = e.length;
								if(4 !== n && 6 !== n && 8 !== n) throw new Error("Invalid aes key size=" + n);
								var a, s, o, l, u = this.ksRows = 4 * (n + 6 + 1),
									d = this.keySchedule = new Uint32Array(u),
									h = this.invKeySchedule = new Uint32Array(u),
									c = this.sBox,
									f = this.rcon,
									g = this.invSubMix,
									v = g[0],
									p = g[1],
									m = g[2],
									y = g[3];
								for(a = 0; a < u; a++) a < n ? o = d[a] = e[a] : (l = o, a % n == 0 ? (l = c[(l = l << 8 | l >>> 24) >>> 24] << 24 | c[l >>> 16 & 255] << 16 | c[l >>> 8 & 255] << 8 | c[255 & l], l ^= f[a / n | 0] << 24) : n > 6 && a % n == 4 && (l = c[l >>> 24] << 24 | c[l >>> 16 & 255] << 16 | c[l >>> 8 & 255] << 8 | c[255 & l]), d[a] = o = (d[a - n] ^ l) >>> 0);
								for(s = 0; s < u; s++) a = u - s, l = 3 & s ? d[a] : d[a - 4], h[s] = s < 4 || a <= 4 ? l : v[c[l >>> 24]] ^ p[c[l >>> 16 & 255]] ^ m[c[l >>> 8 & 255]] ^ y[c[255 & l]], h[s] = h[s] >>> 0
							}
						}, e.networkToHostOrderSwap = function(t) {
							return t << 24 | (65280 & t) << 8 | (16711680 & t) >> 8 | t >>> 24
						}, e.decrypt = function(t, e, r) {
							for(var i, n, a, s, o, l, u, d, h, c, f, g, v, p, m = this.keySize + 6, y = this.invKeySchedule, E = this.invSBox, T = this.invSubMix, S = T[0], b = T[1], L = T[2], A = T[3], D = this.uint8ArrayToUint32Array_(r), k = D[0], R = D[1], I = D[2], w = D[3], C = new Int32Array(t), _ = new Int32Array(C.length), O = this.networkToHostOrderSwap; e < C.length;) {
								for(h = O(C[e]), c = O(C[e + 1]), f = O(C[e + 2]), g = O(C[e + 3]), o = h ^ y[0], l = g ^ y[1], u = f ^ y[2], d = c ^ y[3], v = 4, p = 1; p < m; p++) i = S[o >>> 24] ^ b[l >> 16 & 255] ^ L[u >> 8 & 255] ^ A[255 & d] ^ y[v], n = S[l >>> 24] ^ b[u >> 16 & 255] ^ L[d >> 8 & 255] ^ A[255 & o] ^ y[v + 1], a = S[u >>> 24] ^ b[d >> 16 & 255] ^ L[o >> 8 & 255] ^ A[255 & l] ^ y[v + 2], s = S[d >>> 24] ^ b[o >> 16 & 255] ^ L[l >> 8 & 255] ^ A[255 & u] ^ y[v + 3], o = i, l = n, u = a, d = s, v += 4;
								i = E[o >>> 24] << 24 ^ E[l >> 16 & 255] << 16 ^ E[u >> 8 & 255] << 8 ^ E[255 & d] ^ y[v], n = E[l >>> 24] << 24 ^ E[u >> 16 & 255] << 16 ^ E[d >> 8 & 255] << 8 ^ E[255 & o] ^ y[v + 1], a = E[u >>> 24] << 24 ^ E[d >> 16 & 255] << 16 ^ E[o >> 8 & 255] << 8 ^ E[255 & l] ^ y[v + 2], s = E[d >>> 24] << 24 ^ E[o >> 16 & 255] << 16 ^ E[l >> 8 & 255] << 8 ^ E[255 & u] ^ y[v + 3], _[e] = O(i ^ k), _[e + 1] = O(s ^ R), _[e + 2] = O(a ^ I), _[e + 3] = O(n ^ w), k = h, R = c, I = f, w = g, e += 4
							}
							return _.buffer
						}, t
					}(),
					o = r(93),
					l = r(63),
					u = function() {
						function t(t, e) {
							var r = (void 0 === e ? {} : e).removePKCS7Padding,
								i = void 0 === r || r;
							if(this.logEnabled = !0, this.removePKCS7Padding = void 0, this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null, this.useSoftware = void 0, this.useSoftware = t.enableSoftwareAES, this.removePKCS7Padding = i, i) try {
								var n = self.crypto;
								n && (this.subtle = n.subtle || n.webkitSubtle)
							} catch(t) {}
							null === this.subtle && (this.useSoftware = !0)
						}
						var e = t.prototype;
						return e.destroy = function() {
							this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null
						}, e.isSync = function() {
							return this.useSoftware
						}, e.flush = function() {
							var t = this.currentResult,
								e = this.remainderData;
							if(!t || e) return this.reset(), null;
							var r, i, n, s = new Uint8Array(t);
							return this.reset(), this.removePKCS7Padding ? (n = (i = (r = s).byteLength) && new DataView(r.buffer).getUint8(i - 1)) ? (0, a.sliceUint8)(r, 0, i - n) : r : s
						}, e.reset = function() {
							this.currentResult = null, this.currentIV = null, this.remainderData = null, this.softwareDecrypter && (this.softwareDecrypter = null)
						}, e.decrypt = function(t, e, r) {
							var i = this;
							return this.useSoftware ? new Promise((function(n, a) {
								i.softwareDecrypt(new Uint8Array(t), e, r);
								var s = i.flush();
								s ? n(s.buffer) : a(new Error("[softwareDecrypt] Failed to decrypt data"))
							})) : this.webCryptoDecrypt(new Uint8Array(t), e, r)
						}, e.softwareDecrypt = function(t, e, r) {
							var i = this.currentIV,
								n = this.currentResult,
								o = this.remainderData;
							this.logOnce("JS AES decrypt"), o && (t = (0, l.appendUint8Array)(o, t), this.remainderData = null);
							var u = this.getValidChunk(t);
							if(!u.length) return null;
							i && (r = i);
							var d = this.softwareDecrypter;
							d || (d = this.softwareDecrypter = new s), d.expandKey(e);
							var h = n;
							return this.currentResult = d.decrypt(u.buffer, 0, r), this.currentIV = (0, a.sliceUint8)(u, -16).buffer, h || null
						}, e.webCryptoDecrypt = function(t, e, r) {
							var a = this,
								s = this.subtle;
							return this.key === e && this.fastAesKey || (this.key = e, this.fastAesKey = new n(s, e)), this.fastAesKey.expandKey().then((function(e) {
								return s ? (a.logOnce("WebCrypto AES decrypt"), new i(s, new Uint8Array(r)).decrypt(t.buffer, e)) : Promise.reject(new Error("web crypto not initialized"))
							})).catch((function(i) {
								return o.logger.warn("[decrypter]: WebCrypto Error, disable WebCrypto API, " + i.name + ": " + i.message), a.onWebCryptoError(t, e, r)
							}))
						}, e.onWebCryptoError = function(t, e, r) {
							this.useSoftware = !0, this.logEnabled = !0, this.softwareDecrypt(t, e, r);
							var i = this.flush();
							if(i) return i.buffer;
							throw new Error("WebCrypto and softwareDecrypt: failed to decrypt data")
						}, e.getValidChunk = function(t) {
							var e = t,
								r = t.length - t.length % 16;
							return r !== t.length && (e = (0, a.sliceUint8)(t, 0, r), this.remainderData = (0, a.sliceUint8)(t, r)), e
						}, e.logOnce = function(t) {
							this.logEnabled && (o.logger.log("[decrypter]: " + t), this.logEnabled = !1)
						}, t
					}()
			},
			181: (t, e, r) => {
				"use strict";
				r.r(e), r.d(e, {
					canParse: () => l,
					decodeFrame: () => f,
					getID3Data: () => s,
					getID3Frames: () => c,
					getTimeStamp: () => u,
					isFooter: () => a,
					isHeader: () => n,
					isTimeStampFrame: () => d,
					testables: () => E,
					utf8ArrayToStr: () => y
				});
				var i, n = function(t, e) {
						return e + 10 <= t.length && 73 === t[e] && 68 === t[e + 1] && 51 === t[e + 2] && t[e + 3] < 255 && t[e + 4] < 255 && t[e + 6] < 128 && t[e + 7] < 128 && t[e + 8] < 128 && t[e + 9] < 128
					},
					a = function(t, e) {
						return e + 10 <= t.length && 51 === t[e] && 68 === t[e + 1] && 73 === t[e + 2] && t[e + 3] < 255 && t[e + 4] < 255 && t[e + 6] < 128 && t[e + 7] < 128 && t[e + 8] < 128 && t[e + 9] < 128
					},
					s = function(t, e) {
						for(var r = e, i = 0; n(t, e);) i += 10, i += o(t, e + 6), a(t, e + 10) && (i += 10), e += i;
						if(i > 0) return t.subarray(r, r + i)
					},
					o = function(t, e) {
						var r = 0;
						return r = (127 & t[e]) << 21, r |= (127 & t[e + 1]) << 14, (r |= (127 & t[e + 2]) << 7) | 127 & t[e + 3]
					},
					l = function(t, e) {
						return n(t, e) && o(t, e + 6) + 10 <= t.length - e
					},
					u = function(t) {
						for(var e = c(t), r = 0; r < e.length; r++) {
							var i = e[r];
							if(d(i)) return m(i)
						}
					},
					d = function(t) {
						return t && "PRIV" === t.key && "com.apple.streaming.transportStreamTimestamp" === t.info
					},
					h = function(t) {
						var e = String.fromCharCode(t[0], t[1], t[2], t[3]),
							r = o(t, 4);
						return {
							type: e,
							size: r,
							data: t.subarray(10, 10 + r)
						}
					},
					c = function(t) {
						for(var e = 0, r = []; n(t, e);) {
							for(var i = o(t, e + 6), s = (e += 10) + i; e + 8 < s;) {
								var l = h(t.subarray(e)),
									u = f(l);
								u && r.push(u), e += l.size + 10
							}
							a(t, e) && (e += 10)
						}
						return r
					},
					f = function(t) {
						return "PRIV" === t.type ? g(t) : "W" === t.type[0] ? p(t) : v(t)
					},
					g = function(t) {
						if(!(t.size < 2)) {
							var e = y(t.data, !0),
								r = new Uint8Array(t.data.subarray(e.length + 1));
							return {
								key: t.type,
								info: e,
								data: r.buffer
							}
						}
					},
					v = function(t) {
						if(!(t.size < 2)) {
							if("TXXX" === t.type) {
								var e = 1,
									r = y(t.data.subarray(e), !0);
								e += r.length + 1;
								var i = y(t.data.subarray(e));
								return {
									key: t.type,
									info: r,
									data: i
								}
							}
							var n = y(t.data.subarray(1));
							return {
								key: t.type,
								data: n
							}
						}
					},
					p = function(t) {
						if("WXXX" === t.type) {
							if(t.size < 2) return;
							var e = 1,
								r = y(t.data.subarray(e), !0);
							e += r.length + 1;
							var i = y(t.data.subarray(e));
							return {
								key: t.type,
								info: r,
								data: i
							}
						}
						var n = y(t.data);
						return {
							key: t.type,
							data: n
						}
					},
					m = function(t) {
						if(8 === t.data.byteLength) {
							var e = new Uint8Array(t.data),
								r = 1 & e[3],
								i = (e[4] << 23) + (e[5] << 15) + (e[6] << 7) + e[7];
							return i /= 45, r && (i += 47721858.84), Math.round(i)
						}
					},
					y = function(t, e) {
						void 0 === e && (e = !1);
						var r = T();
						if(r) {
							var i = r.decode(t);
							if(e) {
								var n = i.indexOf("\0");
								return -1 !== n ? i.substring(0, n) : i
							}
							return i.replace(/\0/g, "")
						}
						for(var a, s, o, l = t.length, u = "", d = 0; d < l;) {
							if(0 === (a = t[d++]) && e) return u;
							if(0 !== a && 3 !== a) switch(a >> 4) {
								case 0:
								case 1:
								case 2:
								case 3:
								case 4:
								case 5:
								case 6:
								case 7:
									u += String.fromCharCode(a);
									break;
								case 12:
								case 13:
									s = t[d++], u += String.fromCharCode((31 & a) << 6 | 63 & s);
									break;
								case 14:
									s = t[d++], o = t[d++], u += String.fromCharCode((15 & a) << 12 | (63 & s) << 6 | (63 & o) << 0)
							}
						}
						return u
					},
					E = {
						decodeTextFrame: v
					};

				function T() {
					return i || void 0 === self.TextDecoder || (i = new self.TextDecoder("utf-8")), i
				}
			},
			182: (t, e, r) => {
				"use strict";
				r.r(e), r.d(e, {
					default: () => l
				});
				var i = r(544),
					n = r(851),
					a = r(93),
					s = r(729),
					o = r(973);

				function l(t) {
					var e = new s.EventEmitter,
						r = function(e, r) {
							t.postMessage({
								event: e,
								data: r
							})
						};
					e.on(n.Events.FRAG_DECRYPTED, r), e.on(n.Events.ERROR, r), t.addEventListener("message", (function(s) {
						var l = s.data;
						switch(l.cmd) {
							case "init":
								var d = JSON.parse(l.config);
								t.transmuxer = new i.default(e, l.typeSupported, d, l.vendor, l.id), (0, a.enableLogs)(d.debug, l.id),
									function() {
										var t = function(t) {
											a.logger[t] = function(e) {
												r("workerLog", {
													logType: t,
													message: e
												})
											}
										};
										for(var e in a.logger) t(e)
									}(), r("init", null);
								break;
							case "configure":
								t.transmuxer.configure(l.config);
								break;
							case "demux":
								var c = t.transmuxer.push(l.data, l.decryptdata, l.chunkMeta, l.state);
								(0, i.isPromise)(c) ? (t.transmuxer.async = !0, c.then((function(e) {
									u(t, e)
								})).catch((function(t) {
									r(n.Events.ERROR, {
										type: o.ErrorTypes.MEDIA_ERROR,
										details: o.ErrorDetails.FRAG_PARSING_ERROR,
										chunkMeta: l.chunkMeta,
										fatal: !1,
										error: t,
										err: t,
										reason: "transmuxer-worker push error"
									})
								}))) : (t.transmuxer.async = !1, u(t, c));
								break;
							case "flush":
								var f = l.chunkMeta,
									g = t.transmuxer.flush(f);
								(0, i.isPromise)(g) || t.transmuxer.async ? ((0, i.isPromise)(g) || (g = Promise.resolve(g)), g.then((function(e) {
									h(t, e, f)
								})).catch((function(t) {
									r(n.Events.ERROR, {
										type: o.ErrorTypes.MEDIA_ERROR,
										details: o.ErrorDetails.FRAG_PARSING_ERROR,
										chunkMeta: l.chunkMeta,
										fatal: !1,
										error: t,
										err: t,
										reason: "transmuxer-worker flush error"
									})
								}))) : h(t, g, f)
						}
					}))
				}

				function u(t, e) {
					if(!((r = e.remuxResult).audio || r.video || r.text || r.id3 || r.initSegment)) return !1;
					var r, i = [],
						n = e.remuxResult,
						a = n.audio,
						s = n.video;
					return a && d(i, a), s && d(i, s), t.postMessage({
						event: "transmuxComplete",
						data: e
					}, i), !0
				}

				function d(t, e) {
					e.data1 && t.push(e.data1.buffer), e.data2 && t.push(e.data2.buffer)
				}

				function h(t, e, r) {
					e.reduce((function(e, r) {
						return u(t, r) || e
					}), !1) || t.postMessage({
						event: "transmuxComplete",
						data: e[0]
					}), t.postMessage({
						event: "flush",
						data: r
					})
				}
			},
			544: (t, e, r) => {
				"use strict";
				r.r(e), r.d(e, {
					TransmuxConfig: () => st,
					TransmuxState: () => ot,
					default: () => it,
					isPromise: () => at
				});
				var i = r(851),
					n = r(973),
					a = r(21),
					s = r(965),
					o = r(181),
					l = r(856);

				function u(t, e) {
					return void 0 === t && (t = ""), void 0 === e && (e = 9e4), {
						type: t,
						id: -1,
						pid: -1,
						inputTimeScale: e,
						sequenceNumber: -1,
						samples: [],
						dropped: 0
					}
				}
				var d = r(63),
					h = r(145),
					c = function() {
						function t() {
							this._audioTrack = void 0, this._id3Track = void 0, this.frameIndex = 0, this.cachedData = null, this.basePTS = null, this.initPTS = null, this.lastPTS = null
						}
						var e = t.prototype;
						return e.resetInitSegment = function(t, e, r, i) {
							this._id3Track = {
								type: "id3",
								id: 3,
								pid: -1,
								inputTimeScale: 9e4,
								sequenceNumber: 0,
								samples: [],
								dropped: 0
							}
						}, e.resetTimeStamp = function(t) {
							this.initPTS = t, this.resetContiguity()
						}, e.resetContiguity = function() {
							this.basePTS = null, this.lastPTS = null, this.frameIndex = 0
						}, e.canParse = function(t, e) {
							return !1
						}, e.appendFrame = function(t, e, r) {}, e.demux = function(t, e) {
							this.cachedData && (t = (0, d.appendUint8Array)(this.cachedData, t), this.cachedData = null);
							var r, i = o.getID3Data(t, 0),
								n = i ? i.length : 0,
								a = this._audioTrack,
								c = this._id3Track,
								g = i ? o.getTimeStamp(i) : void 0,
								v = t.length;
							for((null === this.basePTS || 0 === this.frameIndex && (0, s.isFiniteNumber)(g)) && (this.basePTS = f(g, e, this.initPTS), this.lastPTS = this.basePTS), null === this.lastPTS && (this.lastPTS = this.basePTS), i && i.length > 0 && c.samples.push({
									pts: this.lastPTS,
									dts: this.lastPTS,
									data: i,
									type: l.MetadataSchema.audioId3,
									duration: Number.POSITIVE_INFINITY
								}); n < v;) {
								if(this.canParse(t, n)) {
									var p = this.appendFrame(a, t, n);
									p ? (this.frameIndex++, this.lastPTS = p.sample.pts, r = n += p.length) : n = v
								} else o.canParse(t, n) ? (i = o.getID3Data(t, n), c.samples.push({
									pts: this.lastPTS,
									dts: this.lastPTS,
									data: i,
									type: l.MetadataSchema.audioId3,
									duration: Number.POSITIVE_INFINITY
								}), r = n += i.length) : n++;
								if(n === v && r !== v) {
									var m = (0, h.sliceUint8)(t, r);
									this.cachedData ? this.cachedData = (0, d.appendUint8Array)(this.cachedData, m) : this.cachedData = m
								}
							}
							return {
								audioTrack: a,
								videoTrack: u(),
								id3Track: c,
								textTrack: u()
							}
						}, e.demuxSampleAes = function(t, e, r) {
							return Promise.reject(new Error("[" + this + "] This demuxer does not support Sample-AES decryption"))
						}, e.flush = function(t) {
							var e = this.cachedData;
							return e && (this.cachedData = null, this.demux(e, 0)), {
								audioTrack: this._audioTrack,
								videoTrack: u(),
								id3Track: this._id3Track,
								textTrack: u()
							}
						}, e.destroy = function() {}, t
					}(),
					f = function(t, e, r) {
						return(0, s.isFiniteNumber)(t) ? 90 * t : 9e4 * e + (r || 0)
					};
				const g = c;
				var v = r(93);

				function p(t, e) {
					return 255 === t[e] && 240 == (246 & t[e + 1])
				}

				function m(t, e) {
					return 1 & t[e + 1] ? 7 : 9
				}

				function y(t, e) {
					return(3 & t[e + 3]) << 11 | t[e + 4] << 3 | (224 & t[e + 5]) >>> 5
				}

				function E(t, e) {
					return e + 1 < t.length && p(t, e)
				}

				function T(t, e) {
					if(E(t, e)) {
						var r = m(t, e);
						if(e + r >= t.length) return !1;
						var i = y(t, e);
						if(i <= r) return !1;
						var n = e + i;
						return n === t.length || E(t, n)
					}
					return !1
				}

				function S(t, e, r, a, s) {
					if(!t.samplerate) {
						var o = function(t, e, r, a) {
							var s, o, l, u, d = navigator.userAgent.toLowerCase(),
								h = a,
								c = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
							s = 1 + ((192 & e[r + 2]) >>> 6);
							var f = (60 & e[r + 2]) >>> 2;
							if(!(f > c.length - 1)) return l = (1 & e[r + 2]) << 2, l |= (192 & e[r + 3]) >>> 6, v.logger.log("manifest codec:" + a + ", ADTS type:" + s + ", samplingIndex:" + f), /firefox/i.test(d) ? f >= 6 ? (s = 5, u = new Array(4), o = f - 3) : (s = 2, u = new Array(2), o = f) : -1 !== d.indexOf("android") ? (s = 2, u = new Array(2), o = f) : (s = 5, u = new Array(4), a && (-1 !== a.indexOf("mp4a.40.29") || -1 !== a.indexOf("mp4a.40.5")) || !a && f >= 6 ? o = f - 3 : ((a && -1 !== a.indexOf("mp4a.40.2") && (f >= 6 && 1 === l || /vivaldi/i.test(d)) || !a && 1 === l) && (s = 2, u = new Array(2)), o = f)), u[0] = s << 3, u[0] |= (14 & f) >> 1, u[1] |= (1 & f) << 7, u[1] |= l << 3, 5 === s && (u[1] |= (14 & o) >> 1, u[2] = (1 & o) << 7, u[2] |= 8, u[3] = 0), {
								config: u,
								samplerate: c[f],
								channelCount: l,
								codec: "mp4a.40." + s,
								manifestCodec: h
							};
							t.trigger(i.Events.ERROR, {
								type: n.ErrorTypes.MEDIA_ERROR,
								details: n.ErrorDetails.FRAG_PARSING_ERROR,
								fatal: !0,
								reason: "invalid ADTS sampling index:" + f
							})
						}(e, r, a, s);
						if(!o) return;
						t.config = o.config, t.samplerate = o.samplerate, t.channelCount = o.channelCount, t.codec = o.codec, t.manifestCodec = o.manifestCodec, v.logger.log("parsed codec:" + t.codec + ", rate:" + o.samplerate + ", channels:" + o.channelCount)
					}
				}

				function b(t) {
					return 9216e4 / t
				}

				function L(t, e, r, i, n) {
					var a, s = i + n * b(t.samplerate),
						o = function(t, e) {
							var r = m(t, e);
							if(e + r <= t.length) {
								var i = y(t, e) - r;
								if(i > 0) return {
									headerLength: r,
									frameLength: i
								}
							}
						}(e, r);
					if(o) {
						var l = o.frameLength,
							u = o.headerLength,
							d = u + l,
							h = Math.max(0, r + d - e.length);
						h ? (a = new Uint8Array(d - u)).set(e.subarray(r + u, e.length), 0) : a = e.subarray(r + u, r + d);
						var c = {
							unit: a,
							pts: s
						};
						return h || t.samples.push(c), {
							sample: c,
							length: d,
							missing: h
						}
					}
					var f = e.length - r;
					return(a = new Uint8Array(f)).set(e.subarray(r, e.length), 0), {
						sample: {
							unit: a,
							pts: s
						},
						length: f,
						missing: -1
					}
				}

				function A(t, e) {
					return A = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
						return t.__proto__ = e, t
					}, A(t, e)
				}
				const D = function(t) {
					var e, r;

					function i(e, r) {
						var i;
						return(i = t.call(this) || this).observer = void 0, i.config = void 0, i.observer = e, i.config = r, i
					}
					r = t, (e = i).prototype = Object.create(r.prototype), e.prototype.constructor = e, A(e, r);
					var n = i.prototype;
					return n.resetInitSegment = function(e, r, i, n) {
						t.prototype.resetInitSegment.call(this, e, r, i, n), this._audioTrack = {
							container: "audio/adts",
							type: "audio",
							id: 2,
							pid: -1,
							sequenceNumber: 0,
							segmentCodec: "aac",
							samples: [],
							manifestCodec: r,
							duration: n,
							inputTimeScale: 9e4,
							dropped: 0
						}
					}, i.probe = function(t) {
						if(!t) return !1;
						for(var e = (o.getID3Data(t, 0) || []).length, r = t.length; e < r; e++)
							if(T(t, e)) return v.logger.log("ADTS sync word found !"), !0;
						return !1
					}, n.canParse = function(t, e) {
						return function(t, e) {
							return function(t, e) {
								return e + 5 < t.length
							}(t, e) && p(t, e) && y(t, e) <= t.length - e
						}(t, e)
					}, n.appendFrame = function(t, e, r) {
						S(t, this.observer, e, r, t.manifestCodec);
						var i = L(t, e, r, this.basePTS, this.frameIndex);
						if(i && 0 === i.missing) return i
					}, i
				}(g);
				var k = /\/emsg[-/]ID3/i;
				const R = function() {
					function t(t, e) {
						this.remainderData = null, this.timeOffset = 0, this.config = void 0, this.videoTrack = void 0, this.audioTrack = void 0, this.id3Track = void 0, this.txtTrack = void 0, this.config = e
					}
					var e = t.prototype;
					return e.resetTimeStamp = function() {}, e.resetInitSegment = function(t, e, r, i) {
						var n = this.videoTrack = u("video", 1),
							a = this.audioTrack = u("audio", 1),
							s = this.txtTrack = u("text", 1);
						if(this.id3Track = u("id3", 1), this.timeOffset = 0, t && t.byteLength) {
							var o = (0, d.parseInitSegment)(t);
							if(o.video) {
								var l = o.video,
									h = l.id,
									c = l.timescale,
									f = l.codec;
								n.id = h, n.timescale = s.timescale = c, n.codec = f
							}
							if(o.audio) {
								var g = o.audio,
									v = g.id,
									p = g.timescale,
									m = g.codec;
								a.id = v, a.timescale = p, a.codec = m
							}
							s.id = d.RemuxerTrackIdConfig.text, n.sampleDuration = 0, n.duration = a.duration = i
						}
					}, e.resetContiguity = function() {}, t.probe = function(t) {
						return t = t.length > 16384 ? t.subarray(0, 16384) : t, (0, d.findBox)(t, ["moof"]).length > 0
					}, e.demux = function(t, e) {
						this.timeOffset = e;
						var r = t,
							i = this.videoTrack,
							n = this.txtTrack;
						if(this.config.progressive) {
							this.remainderData && (r = (0, d.appendUint8Array)(this.remainderData, t));
							var a = (0, d.segmentValidRange)(r);
							this.remainderData = a.remainder, i.samples = a.valid || new Uint8Array
						} else i.samples = r;
						var s = this.extractID3Track(i, e);
						return n.samples = (0, d.parseSamples)(e, i), {
							videoTrack: i,
							audioTrack: this.audioTrack,
							id3Track: s,
							textTrack: this.txtTrack
						}
					}, e.flush = function() {
						var t = this.timeOffset,
							e = this.videoTrack,
							r = this.txtTrack;
						e.samples = this.remainderData || new Uint8Array, this.remainderData = null;
						var i = this.extractID3Track(e, this.timeOffset);
						return r.samples = (0, d.parseSamples)(t, e), {
							videoTrack: e,
							audioTrack: u(),
							id3Track: i,
							textTrack: u()
						}
					}, e.extractID3Track = function(t, e) {
						var r = this.id3Track;
						if(t.samples.length) {
							var i = (0, d.findBox)(t.samples, ["emsg"]);
							i && i.forEach((function(t) {
								var i = (0, d.parseEmsg)(t);
								if(k.test(i.schemeIdUri)) {
									var n = (0, s.isFiniteNumber)(i.presentationTime) ? i.presentationTime / i.timeScale : e + i.presentationTimeDelta / i.timeScale,
										a = 4294967295 === i.eventDuration ? Number.POSITIVE_INFINITY : i.eventDuration / i.timeScale;
									a <= .001 && (a = Number.POSITIVE_INFINITY);
									var o = i.payload;
									r.samples.push({
										data: o,
										len: o.byteLength,
										dts: n,
										pts: n,
										type: l.MetadataSchema.emsg,
										duration: a
									})
								}
							}))
						}
						return r
					}, e.demuxSampleAes = function(t, e, r) {
						return Promise.reject(new Error("The MP4 demuxer does not support SAMPLE-AES decryption"))
					}, e.destroy = function() {}, t
				}();
				var I = null,
					w = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160],
					C = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3],
					_ = [
						[0, 72, 144, 12],
						[0, 0, 0, 0],
						[0, 72, 144, 12],
						[0, 144, 144, 12]
					],
					O = [0, 1, 1, 4];

				function P(t, e, r, i, n) {
					if(!(r + 24 > e.length)) {
						var a = x(e, r);
						if(a && r + a.frameLength <= e.length) {
							var s = i + n * (9e4 * a.samplesPerFrame / a.sampleRate),
								o = {
									unit: e.subarray(r, r + a.frameLength),
									pts: s,
									dts: s
								};
							return t.config = [], t.channelCount = a.channelCount, t.samplerate = a.sampleRate, t.samples.push(o), {
								sample: o,
								length: a.frameLength,
								missing: 0
							}
						}
					}
				}

				function x(t, e) {
					var r = t[e + 1] >> 3 & 3,
						i = t[e + 1] >> 1 & 3,
						n = t[e + 2] >> 4 & 15,
						a = t[e + 2] >> 2 & 3;
					if(1 !== r && 0 !== n && 15 !== n && 3 !== a) {
						var s = t[e + 2] >> 1 & 1,
							o = t[e + 3] >> 6,
							l = 1e3 * w[14 * (3 === r ? 3 - i : 3 === i ? 3 : 4) + n - 1],
							u = C[3 * (3 === r ? 0 : 2 === r ? 1 : 2) + a],
							d = 3 === o ? 1 : 2,
							h = _[r][i],
							c = O[i],
							f = 8 * h * c,
							g = Math.floor(h * l / u + s) * c;
						if(null === I) {
							var v = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
							I = v ? parseInt(v[1]) : 0
						}
						return !!I && I <= 87 && 2 === i && l >= 224e3 && 0 === o && (t[e + 3] = 128 | t[e + 3]), {
							sampleRate: u,
							channelCount: d,
							frameLength: g,
							samplesPerFrame: f
						}
					}
				}

				function F(t, e) {
					return 255 === t[e] && 224 == (224 & t[e + 1]) && 0 != (6 & t[e + 1])
				}

				function M(t, e) {
					return e + 1 < t.length && F(t, e)
				}

				function N(t, e) {
					if(e + 1 < t.length && F(t, e)) {
						var r = x(t, e),
							i = 4;
						null != r && r.frameLength && (i = r.frameLength);
						var n = e + i;
						return n === t.length || M(t, n)
					}
					return !1
				}
				const U = function() {
						function t(t) {
							this.data = void 0, this.bytesAvailable = void 0, this.word = void 0, this.bitsAvailable = void 0, this.data = t, this.bytesAvailable = t.byteLength, this.word = 0, this.bitsAvailable = 0
						}
						var e = t.prototype;
						return e.loadWord = function() {
							var t = this.data,
								e = this.bytesAvailable,
								r = t.byteLength - e,
								i = new Uint8Array(4),
								n = Math.min(4, e);
							if(0 === n) throw new Error("no bytes available");
							i.set(t.subarray(r, r + n)), this.word = new DataView(i.buffer).getUint32(0), this.bitsAvailable = 8 * n, this.bytesAvailable -= n
						}, e.skipBits = function(t) {
							var e;
							t = Math.min(t, 8 * this.bytesAvailable + this.bitsAvailable), this.bitsAvailable > t ? (this.word <<= t, this.bitsAvailable -= t) : (t -= this.bitsAvailable, t -= (e = t >> 3) << 3, this.bytesAvailable -= e, this.loadWord(), this.word <<= t, this.bitsAvailable -= t)
						}, e.readBits = function(t) {
							var e = Math.min(this.bitsAvailable, t),
								r = this.word >>> 32 - e;
							if(t > 32 && v.logger.error("Cannot read more than 32 bits at a time"), this.bitsAvailable -= e, this.bitsAvailable > 0) this.word <<= e;
							else {
								if(!(this.bytesAvailable > 0)) throw new Error("no bits available");
								this.loadWord()
							}
							return(e = t - e) > 0 && this.bitsAvailable ? r << e | this.readBits(e) : r
						}, e.skipLZ = function() {
							var t;
							for(t = 0; t < this.bitsAvailable; ++t)
								if(0 != (this.word & 2147483648 >>> t)) return this.word <<= t, this.bitsAvailable -= t, t;
							return this.loadWord(), t + this.skipLZ()
						}, e.skipUEG = function() {
							this.skipBits(1 + this.skipLZ())
						}, e.skipEG = function() {
							this.skipBits(1 + this.skipLZ())
						}, e.readUEG = function() {
							var t = this.skipLZ();
							return this.readBits(t + 1) - 1
						}, e.readEG = function() {
							var t = this.readUEG();
							return 1 & t ? 1 + t >>> 1 : -1 * (t >>> 1)
						}, e.readBoolean = function() {
							return 1 === this.readBits(1)
						}, e.readUByte = function() {
							return this.readBits(8)
						}, e.readUShort = function() {
							return this.readBits(16)
						}, e.readUInt = function() {
							return this.readBits(32)
						}, e.skipScalingList = function(t) {
							for(var e = 8, r = 8, i = 0; i < t; i++) 0 !== r && (r = (e + this.readEG() + 256) % 256), e = 0 === r ? e : r
						}, e.readSPS = function() {
							var t, e, r, i = 0,
								n = 0,
								a = 0,
								s = 0,
								o = this.readUByte.bind(this),
								l = this.readBits.bind(this),
								u = this.readUEG.bind(this),
								d = this.readBoolean.bind(this),
								h = this.skipBits.bind(this),
								c = this.skipEG.bind(this),
								f = this.skipUEG.bind(this),
								g = this.skipScalingList.bind(this);
							o();
							var v = o();
							if(l(5), h(3), o(), f(), 100 === v || 110 === v || 122 === v || 244 === v || 44 === v || 83 === v || 86 === v || 118 === v || 128 === v) {
								var p = u();
								if(3 === p && h(1), f(), f(), h(1), d())
									for(e = 3 !== p ? 8 : 12, r = 0; r < e; r++) d() && g(r < 6 ? 16 : 64)
							}
							f();
							var m = u();
							if(0 === m) u();
							else if(1 === m)
								for(h(1), c(), c(), t = u(), r = 0; r < t; r++) c();
							f(), h(1);
							var y = u(),
								E = u(),
								T = l(1);
							0 === T && h(1), h(1), d() && (i = u(), n = u(), a = u(), s = u());
							var S = [1, 1];
							if(d() && d()) switch(o()) {
								case 1:
									S = [1, 1];
									break;
								case 2:
									S = [12, 11];
									break;
								case 3:
									S = [10, 11];
									break;
								case 4:
									S = [16, 11];
									break;
								case 5:
									S = [40, 33];
									break;
								case 6:
									S = [24, 11];
									break;
								case 7:
									S = [20, 11];
									break;
								case 8:
									S = [32, 11];
									break;
								case 9:
									S = [80, 33];
									break;
								case 10:
									S = [18, 11];
									break;
								case 11:
									S = [15, 11];
									break;
								case 12:
									S = [64, 33];
									break;
								case 13:
									S = [160, 99];
									break;
								case 14:
									S = [4, 3];
									break;
								case 15:
									S = [3, 2];
									break;
								case 16:
									S = [2, 1];
									break;
								case 255:
									S = [o() << 8 | o(), o() << 8 | o()]
							}
							return {
								width: Math.ceil(16 * (y + 1) - 2 * i - 2 * n),
								height: (2 - T) * (E + 1) * 16 - (T ? 2 : 4) * (a + s),
								pixelRatio: S
							}
						}, e.readSliceType = function() {
							return this.readUByte(), this.readUEG(), this.readUEG()
						}, t
					}(),
					B = function() {
						function t(t, e, r) {
							this.keyData = void 0, this.decrypter = void 0, this.keyData = r, this.decrypter = new a.default(e, {
								removePKCS7Padding: !1
							})
						}
						var e = t.prototype;
						return e.decryptBuffer = function(t) {
							return this.decrypter.decrypt(t, this.keyData.key.buffer, this.keyData.iv.buffer)
						}, e.decryptAacSample = function(t, e, r) {
							var i = this,
								n = t[e].unit;
							if(!(n.length <= 16)) {
								var a = n.subarray(16, n.length - n.length % 16),
									s = a.buffer.slice(a.byteOffset, a.byteOffset + a.length);
								this.decryptBuffer(s).then((function(a) {
									var s = new Uint8Array(a);
									n.set(s, 16), i.decrypter.isSync() || i.decryptAacSamples(t, e + 1, r)
								}))
							}
						}, e.decryptAacSamples = function(t, e, r) {
							for(;; e++) {
								if(e >= t.length) return void r();
								if(!(t[e].unit.length < 32 || (this.decryptAacSample(t, e, r), this.decrypter.isSync()))) return
							}
						}, e.getAvcEncryptedData = function(t) {
							for(var e = 16 * Math.floor((t.length - 48) / 160) + 16, r = new Int8Array(e), i = 0, n = 32; n < t.length - 16; n += 160, i += 16) r.set(t.subarray(n, n + 16), i);
							return r
						}, e.getAvcDecryptedUnit = function(t, e) {
							for(var r = new Uint8Array(e), i = 0, n = 32; n < t.length - 16; n += 160, i += 16) t.set(r.subarray(i, i + 16), n);
							return t
						}, e.decryptAvcSample = function(t, e, r, i, n) {
							var a = this,
								s = (0, d.discardEPB)(n.data),
								o = this.getAvcEncryptedData(s);
							this.decryptBuffer(o.buffer).then((function(o) {
								n.data = a.getAvcDecryptedUnit(s, o), a.decrypter.isSync() || a.decryptAvcSamples(t, e, r + 1, i)
							}))
						}, e.decryptAvcSamples = function(t, e, r, i) {
							if(t instanceof Uint8Array) throw new Error("Cannot decrypt samples of type Uint8Array");
							for(;; e++, r = 0) {
								if(e >= t.length) return void i();
								for(var n = t[e].units; !(r >= n.length); r++) {
									var a = n[r];
									if(!(a.data.length <= 48 || 1 !== a.type && 5 !== a.type || (this.decryptAvcSample(t, e, r, i, a), this.decrypter.isSync()))) return
								}
							}
						}, t
					}();

				function G() {
					return G = Object.assign ? Object.assign.bind() : function(t) {
						for(var e = 1; e < arguments.length; e++) {
							var r = arguments[e];
							for(var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i])
						}
						return t
					}, G.apply(this, arguments)
				}
				var K = 188;

				function H(t, e, r, i) {
					return {
						key: t,
						frame: !1,
						pts: e,
						dts: r,
						units: [],
						debug: i,
						length: 0
					}
				}

				function j(t, e) {
					return((31 & t[e + 1]) << 8) + t[e + 2]
				}

				function V(t, e) {
					return(31 & t[e + 10]) << 8 | t[e + 11]
				}

				function Y(t, e, r, i) {
					var n = {
							audio: -1,
							avc: -1,
							id3: -1,
							segmentCodec: "aac"
						},
						a = e + 3 + ((15 & t[e + 1]) << 8 | t[e + 2]) - 4;
					for(e += 12 + ((15 & t[e + 10]) << 8 | t[e + 11]); e < a;) {
						var s = j(t, e);
						switch(t[e]) {
							case 207:
								if(!i) {
									v.logger.log("ADTS AAC with AES-128-CBC frame encryption found in unencrypted stream");
									break
								}
							case 15:
								-1 === n.audio && (n.audio = s);
								break;
							case 21:
								-1 === n.id3 && (n.id3 = s);
								break;
							case 219:
								if(!i) {
									v.logger.log("H.264 with AES-128-CBC slice encryption found in unencrypted stream");
									break
								}
							case 27:
								-1 === n.avc && (n.avc = s);
								break;
							case 3:
							case 4:
								!0 !== r.mpeg && !0 !== r.mp3 ? v.logger.log("MPEG audio found, not supported in this browser") : -1 === n.audio && (n.audio = s, n.segmentCodec = "mp3");
								break;
							case 36:
								v.logger.warn("Unsupported HEVC stream type found")
						}
						e += 5 + ((15 & t[e + 3]) << 8 | t[e + 4])
					}
					return n
				}

				function W(t) {
					var e, r, i, n, a, s = 0,
						o = t.data;
					if(!t || 0 === t.size) return null;
					for(; o[0].length < 19 && o.length > 1;) {
						var l = new Uint8Array(o[0].length + o[1].length);
						l.set(o[0]), l.set(o[1], o[0].length), o[0] = l, o.splice(1, 1)
					}
					if(1 === ((e = o[0])[0] << 16) + (e[1] << 8) + e[2]) {
						if((r = (e[4] << 8) + e[5]) && r > t.size - 6) return null;
						var u = e[7];
						192 & u && (n = 536870912 * (14 & e[9]) + 4194304 * (255 & e[10]) + 16384 * (254 & e[11]) + 128 * (255 & e[12]) + (254 & e[13]) / 2, 64 & u ? n - (a = 536870912 * (14 & e[14]) + 4194304 * (255 & e[15]) + 16384 * (254 & e[16]) + 128 * (255 & e[17]) + (254 & e[18]) / 2) > 54e5 && (v.logger.warn(Math.round((n - a) / 9e4) + "s delta between PTS and DTS, align them"), n = a) : a = n);
						var d = (i = e[8]) + 9;
						if(t.size <= d) return null;
						t.size -= d;
						for(var h = new Uint8Array(t.size), c = 0, f = o.length; c < f; c++) {
							var g = (e = o[c]).byteLength;
							if(d) {
								if(d > g) {
									d -= g;
									continue
								}
								e = e.subarray(d), g -= d, d = 0
							}
							h.set(e, s), s += g
						}
						return r && (r -= i + 3), {
							data: h,
							pts: n,
							dts: a,
							len: r
						}
					}
					return null
				}

				function q(t, e) {
					if(t.units.length && t.frame) {
						if(void 0 === t.pts) {
							var r = e.samples,
								i = r.length;
							if(!i) return void e.dropped++;
							var n = r[i - 1];
							t.pts = n.pts, t.dts = n.dts
						}
						e.samples.push(t)
					}
					t.debug.length && v.logger.log(t.pts + "/" + t.dts + ":" + t.debug)
				}
				const X = function() {
					function t(t, e, r) {
						this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.sampleAes = null, this.pmtParsed = !1, this.audioCodec = void 0, this.videoCodec = void 0, this._duration = 0, this._pmtId = -1, this._avcTrack = void 0, this._audioTrack = void 0, this._id3Track = void 0, this._txtTrack = void 0, this.aacOverFlow = null, this.avcSample = null, this.remainderData = null, this.observer = t, this.config = e, this.typeSupported = r
					}
					t.probe = function(e) {
						var r = t.syncOffset(e);
						return r > 0 && v.logger.warn("MPEG2-TS detected but first sync word found @ offset " + r), -1 !== r
					}, t.syncOffset = function(t) {
						for(var e = Math.min(940, t.length - K) + 1, r = 0; r < e;) {
							for(var i = !1, n = 0; n < e && 71 === t[n]; n += K)
								if(i || 0 !== j(t, n) || (i = !0), i && n + K > e) return r;
							r++
						}
						return -1
					}, t.createTrack = function(t, e) {
						return {
							container: "video" === t || "audio" === t ? "video/mp2t" : void 0,
							type: t,
							id: d.RemuxerTrackIdConfig[t],
							pid: -1,
							inputTimeScale: 9e4,
							sequenceNumber: 0,
							samples: [],
							dropped: 0,
							duration: "audio" === t ? e : void 0
						}
					};
					var e = t.prototype;
					return e.resetInitSegment = function(e, r, i, n) {
						this.pmtParsed = !1, this._pmtId = -1, this._avcTrack = t.createTrack("video"), this._audioTrack = t.createTrack("audio", n), this._id3Track = t.createTrack("id3"), this._txtTrack = t.createTrack("text"), this._audioTrack.segmentCodec = "aac", this.aacOverFlow = null, this.avcSample = null, this.remainderData = null, this.audioCodec = r, this.videoCodec = i, this._duration = n
					}, e.resetTimeStamp = function() {}, e.resetContiguity = function() {
						var t = this._audioTrack,
							e = this._avcTrack,
							r = this._id3Track;
						t && (t.pesData = null), e && (e.pesData = null), r && (r.pesData = null), this.aacOverFlow = null, this.avcSample = null, this.remainderData = null
					}, e.demux = function(e, r, a, s) {
						var o;
						void 0 === a && (a = !1), void 0 === s && (s = !1), a || (this.sampleAes = null);
						var l = this._avcTrack,
							u = this._audioTrack,
							h = this._id3Track,
							c = this._txtTrack,
							f = l.pid,
							g = l.pesData,
							p = u.pid,
							m = h.pid,
							y = u.pesData,
							E = h.pesData,
							T = null,
							S = this.pmtParsed,
							b = this._pmtId,
							L = e.length;
						if(this.remainderData && (L = (e = (0, d.appendUint8Array)(this.remainderData, e)).length, this.remainderData = null), L < K && !s) return this.remainderData = e, {
							audioTrack: u,
							videoTrack: l,
							id3Track: h,
							textTrack: c
						};
						var A = Math.max(0, t.syncOffset(e));
						(L -= (L - A) % K) < e.byteLength && !s && (this.remainderData = new Uint8Array(e.buffer, L, e.buffer.byteLength - L));
						for(var D = 0, k = A; k < L; k += K)
							if(71 === e[k]) {
								var R = !!(64 & e[k + 1]),
									I = j(e, k),
									w = void 0;
								if((48 & e[k + 3]) >> 4 > 1) {
									if((w = k + 5 + e[k + 4]) === k + K) continue
								} else w = k + 4;
								switch(I) {
									case f:
										R && (g && (o = W(g)) && this.parseAVCPES(l, c, o, !1), g = {
											data: [],
											size: 0
										}), g && (g.data.push(e.subarray(w, k + K)), g.size += k + K - w);
										break;
									case p:
										if(R) {
											if(y && (o = W(y))) switch(u.segmentCodec) {
												case "aac":
													this.parseAACPES(u, o);
													break;
												case "mp3":
													this.parseMPEGPES(u, o)
											}
											y = {
												data: [],
												size: 0
											}
										}
										y && (y.data.push(e.subarray(w, k + K)), y.size += k + K - w);
										break;
									case m:
										R && (E && (o = W(E)) && this.parseID3PES(h, o), E = {
											data: [],
											size: 0
										}), E && (E.data.push(e.subarray(w, k + K)), E.size += k + K - w);
										break;
									case 0:
										R && (w += e[w] + 1), b = this._pmtId = V(e, w);
										break;
									case b:
										R && (w += e[w] + 1);
										var C = Y(e, w, this.typeSupported, a);
										(f = C.avc) > 0 && (l.pid = f), (p = C.audio) > 0 && (u.pid = p, u.segmentCodec = C.segmentCodec), (m = C.id3) > 0 && (h.pid = m), null === T || S || (v.logger.log("unknown PID '" + T + "' in TS found"), T = null, k = A - 188), S = this.pmtParsed = !0;
										break;
									case 17:
									case 8191:
										break;
									default:
										T = I
								}
							} else D++;
						D > 0 && this.observer.emit(i.Events.ERROR, i.Events.ERROR, {
							type: n.ErrorTypes.MEDIA_ERROR,
							details: n.ErrorDetails.FRAG_PARSING_ERROR,
							fatal: !1,
							reason: "Found " + D + " TS packet/s that do not start with 0x47"
						}), l.pesData = g, u.pesData = y, h.pesData = E;
						var _ = {
							audioTrack: u,
							videoTrack: l,
							id3Track: h,
							textTrack: c
						};
						return s && this.extractRemainingSamples(_), _
					}, e.flush = function() {
						var t, e = this.remainderData;
						return this.remainderData = null, t = e ? this.demux(e, -1, !1, !0) : {
							videoTrack: this._avcTrack,
							audioTrack: this._audioTrack,
							id3Track: this._id3Track,
							textTrack: this._txtTrack
						}, this.extractRemainingSamples(t), this.sampleAes ? this.decrypt(t, this.sampleAes) : t
					}, e.extractRemainingSamples = function(t) {
						var e, r = t.audioTrack,
							i = t.videoTrack,
							n = t.id3Track,
							a = t.textTrack,
							s = i.pesData,
							o = r.pesData,
							l = n.pesData;
						if(s && (e = W(s)) ? (this.parseAVCPES(i, a, e, !0), i.pesData = null) : i.pesData = s, o && (e = W(o))) {
							switch(r.segmentCodec) {
								case "aac":
									this.parseAACPES(r, e);
									break;
								case "mp3":
									this.parseMPEGPES(r, e)
							}
							r.pesData = null
						} else null != o && o.size && v.logger.log("last AAC PES packet truncated,might overlap between fragments"), r.pesData = o;
						l && (e = W(l)) ? (this.parseID3PES(n, e), n.pesData = null) : n.pesData = l
					}, e.demuxSampleAes = function(t, e, r) {
						var i = this.demux(t, r, !0, !this.config.progressive),
							n = this.sampleAes = new B(this.observer, this.config, e);
						return this.decrypt(i, n)
					}, e.decrypt = function(t, e) {
						return new Promise((function(r) {
							var i = t.audioTrack,
								n = t.videoTrack;
							i.samples && "aac" === i.segmentCodec ? e.decryptAacSamples(i.samples, 0, (function() {
								n.samples ? e.decryptAvcSamples(n.samples, 0, 0, (function() {
									r(t)
								})) : r(t)
							})) : n.samples && e.decryptAvcSamples(n.samples, 0, 0, (function() {
								r(t)
							}))
						}))
					}, e.destroy = function() {
						this._duration = 0
					}, e.parseAVCPES = function(t, e, r, i) {
						var n, a = this,
							s = this.parseAVCNALu(t, r.data),
							o = this.avcSample,
							l = !1;
						r.data = null, o && s.length && !t.audFound && (q(o, t), o = this.avcSample = H(!1, r.pts, r.dts, "")), s.forEach((function(i) {
							switch(i.type) {
								case 1:
									n = !0, o || (o = a.avcSample = H(!0, r.pts, r.dts, "")), o.frame = !0;
									var s = i.data;
									if(l && s.length > 4) {
										var u = new U(s).readSliceType();
										2 !== u && 4 !== u && 7 !== u && 9 !== u || (o.key = !0)
									}
									break;
								case 5:
									n = !0, o || (o = a.avcSample = H(!0, r.pts, r.dts, "")), o.key = !0, o.frame = !0;
									break;
								case 6:
									n = !0, (0, d.parseSEIMessageFromNALu)(i.data, 1, r.pts, e.samples);
									break;
								case 7:
									if(n = !0, l = !0, !t.sps) {
										var h = new U(i.data).readSPS();
										t.width = h.width, t.height = h.height, t.pixelRatio = h.pixelRatio, t.sps = [i.data], t.duration = a._duration;
										for(var c = i.data.subarray(1, 4), f = "avc1.", g = 0; g < 3; g++) {
											var v = c[g].toString(16);
											v.length < 2 && (v = "0" + v), f += v
										}
										t.codec = f
									}
									break;
								case 8:
									n = !0, t.pps || (t.pps = [i.data]);
									break;
								case 9:
									n = !1, t.audFound = !0, o && q(o, t), o = a.avcSample = H(!1, r.pts, r.dts, "");
									break;
								case 12:
									n = !0;
									break;
								default:
									n = !1, o && (o.debug += "unknown NAL " + i.type + " ")
							}
							o && n && o.units.push(i)
						})), i && o && (q(o, t), this.avcSample = null)
					}, e.getLastNalUnit = function(t) {
						var e, r, i = this.avcSample;
						if(i && 0 !== i.units.length || (i = t[t.length - 1]), null !== (e = i) && void 0 !== e && e.units) {
							var n = i.units;
							r = n[n.length - 1]
						}
						return r
					}, e.parseAVCNALu = function(t, e) {
						var r, i, n = e.byteLength,
							a = t.naluState || 0,
							s = a,
							o = [],
							l = 0,
							u = -1,
							d = 0;
						for(-1 === a && (u = 0, d = 31 & e[0], a = 0, l = 1); l < n;)
							if(r = e[l++], a)
								if(1 !== a)
									if(r)
										if(1 === r) {
											if(u >= 0) {
												var h = {
													data: e.subarray(u, l - a - 1),
													type: d
												};
												o.push(h)
											} else {
												var c = this.getLastNalUnit(t.samples);
												if(c && (s && l <= 4 - s && c.state && (c.data = c.data.subarray(0, c.data.byteLength - s)), (i = l - a - 1) > 0)) {
													var f = new Uint8Array(c.data.byteLength + i);
													f.set(c.data, 0), f.set(e.subarray(0, i), c.data.byteLength), c.data = f, c.state = 0
												}
											}
											l < n ? (u = l, d = 31 & e[l], a = 0) : a = -1
										} else a = 0;
						else a = 3;
						else a = r ? 0 : 2;
						else a = r ? 0 : 1;
						if(u >= 0 && a >= 0) {
							var g = {
								data: e.subarray(u, n),
								type: d,
								state: a
							};
							o.push(g)
						}
						if(0 === o.length) {
							var v = this.getLastNalUnit(t.samples);
							if(v) {
								var p = new Uint8Array(v.data.byteLength + e.byteLength);
								p.set(v.data, 0), p.set(e, v.data.byteLength), v.data = p
							}
						}
						return t.naluState = a, o
					}, e.parseAACPES = function(t, e) {
						var r, a, s, o, l, u = 0,
							d = this.aacOverFlow,
							h = e.data;
						if(d) {
							this.aacOverFlow = null;
							var c = d.missing,
								f = d.sample.unit.byteLength;
							if(-1 === c) {
								var g = new Uint8Array(f + h.byteLength);
								g.set(d.sample.unit, 0), g.set(h, f), h = g
							} else {
								var p = f - c;
								d.sample.unit.set(h.subarray(0, c), p), t.samples.push(d.sample), u = d.missing
							}
						}
						for(r = u, a = h.length; r < a - 1 && !E(h, r); r++);
						if(r === u || (r < a - 1 ? (s = "AAC PES did not start with ADTS header,offset:" + r, o = !1) : (s = "no ADTS header found in AAC PES", o = !0), v.logger.warn("parsing error:" + s), this.observer.emit(i.Events.ERROR, i.Events.ERROR, {
								type: n.ErrorTypes.MEDIA_ERROR,
								details: n.ErrorDetails.FRAG_PARSING_ERROR,
								fatal: o,
								reason: s
							}), !o)) {
							if(S(t, this.observer, h, r, this.audioCodec), void 0 !== e.pts) l = e.pts;
							else {
								if(!d) return void v.logger.warn("[tsdemuxer]: AAC PES unknown PTS");
								var m = b(t.samplerate);
								l = d.sample.pts + m
							}
							for(var y, T = 0; r < a;) {
								if(r += (y = L(t, h, r, l, T)).length, y.missing) {
									this.aacOverFlow = y;
									break
								}
								for(T++; r < a - 1 && !E(h, r); r++);
							}
						}
					}, e.parseMPEGPES = function(t, e) {
						var r = e.data,
							i = r.length,
							n = 0,
							a = 0,
							s = e.pts;
						if(void 0 !== s)
							for(; a < i;)
								if(M(r, a)) {
									var o = P(t, r, a, s, n);
									if(!o) break;
									a += o.length, n++
								} else a++;
						else v.logger.warn("[tsdemuxer]: MPEG PES unknown PTS")
					}, e.parseID3PES = function(t, e) {
						if(void 0 !== e.pts) {
							var r = G({}, e, {
								type: this._avcTrack ? l.MetadataSchema.emsg : l.MetadataSchema.audioId3,
								duration: Number.POSITIVE_INFINITY
							});
							t.samples.push(r)
						} else v.logger.warn("[tsdemuxer]: ID3 PES unknown PTS")
					}, t
				}();

				function z(t, e) {
					return z = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
						return t.__proto__ = e, t
					}, z(t, e)
				}
				const Q = function(t) {
					var e, r;

					function i() {
						return t.apply(this, arguments) || this
					}
					r = t, (e = i).prototype = Object.create(r.prototype), e.prototype.constructor = e, z(e, r);
					var n = i.prototype;
					return n.resetInitSegment = function(e, r, i, n) {
						t.prototype.resetInitSegment.call(this, e, r, i, n), this._audioTrack = {
							container: "audio/mpeg",
							type: "audio",
							id: 2,
							pid: -1,
							sequenceNumber: 0,
							segmentCodec: "mp3",
							samples: [],
							manifestCodec: r,
							duration: n,
							inputTimeScale: 9e4,
							dropped: 0
						}
					}, i.probe = function(t) {
						if(!t) return !1;
						for(var e = (o.getID3Data(t, 0) || []).length, r = t.length; e < r; e++)
							if(N(t, e)) return v.logger.log("MPEG Audio sync word found !"), !0;
						return !1
					}, n.canParse = function(t, e) {
						return function(t, e) {
							return F(t, e) && 4 <= t.length - e
						}(t, e)
					}, n.appendFrame = function(t, e, r) {
						if(null !== this.basePTS) return P(t, e, r, this.basePTS, this.frameIndex)
					}, i
				}(g);
				var $ = r(524),
					J = r(923);

				function Z(t, e) {
					var r = null == t ? void 0 : t.codec;
					return r && r.length > 4 ? r : "hvc1" === r || "hev1" === r ? "hvc1.1.c.L120.90" : "av01" === r ? "av01.0.04M.08" : "avc1" === r || e === J.ElementaryStreamTypes.VIDEO ? "avc1.42e01e" : "mp4a.40.5"
				}
				const tt = function() {
					function t() {
						this.emitInitSegment = !1, this.audioCodec = void 0, this.videoCodec = void 0, this.initData = void 0, this.initPTS = void 0, this.initTracks = void 0, this.lastEndTime = null
					}
					var e = t.prototype;
					return e.destroy = function() {}, e.resetTimeStamp = function(t) {
						this.initPTS = t, this.lastEndTime = null
					}, e.resetNextTimestamp = function() {
						this.lastEndTime = null
					}, e.resetInitSegment = function(t, e, r, i) {
						this.audioCodec = e, this.videoCodec = r, this.generateInitSegment((0, d.patchEncyptionData)(t, i)), this.emitInitSegment = !0
					}, e.generateInitSegment = function(t) {
						var e = this.audioCodec,
							r = this.videoCodec;
						if(!t || !t.byteLength) return this.initTracks = void 0, void(this.initData = void 0);
						var i = this.initData = (0, d.parseInitSegment)(t);
						e || (e = Z(i.audio, J.ElementaryStreamTypes.AUDIO)), r || (r = Z(i.video, J.ElementaryStreamTypes.VIDEO));
						var n = {};
						i.audio && i.video ? n.audiovideo = {
							container: "video/mp4",
							codec: e + "," + r,
							initSegment: t,
							id: "main"
						} : i.audio ? n.audio = {
							container: "audio/mp4",
							codec: e,
							initSegment: t,
							id: "audio"
						} : i.video ? n.video = {
							container: "video/mp4",
							codec: r,
							initSegment: t,
							id: "main"
						} : v.logger.warn("[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes."), this.initTracks = n
					}, e.remux = function(t, e, r, i, n) {
						var a, o = this.initPTS,
							l = this.lastEndTime,
							u = {
								audio: void 0,
								video: void 0,
								text: i,
								id3: r,
								initSegment: void 0
							};
						(0, s.isFiniteNumber)(l) || (l = this.lastEndTime = n || 0);
						var h = e.samples;
						if(!h || !h.length) return u;
						var c = {
								initPTS: void 0,
								timescale: 1
							},
							f = this.initData;
						if(f && f.length || (this.generateInitSegment(h), f = this.initData), !f || !f.length) return v.logger.warn("[passthrough-remuxer.ts]: Failed to generate initSegment."), u;
						this.emitInitSegment && (c.tracks = this.initTracks, this.emitInitSegment = !1);
						var g = (0, d.getStartDTS)(f, h);
						(0, s.isFiniteNumber)(o) || (this.initPTS = c.initPTS = o = g - n);
						var p = (0, d.getDuration)(h, f),
							m = t ? g - o : l,
							y = m + p;
						(0, d.offsetStartDTS)(f, h, o), p > 0 ? this.lastEndTime = y : (v.logger.warn("Duration parsed from mp4 should be greater than zero"), this.resetNextTimestamp());
						var E = !!f.audio,
							T = !!f.video,
							S = "";
						E && (S += "audio"), T && (S += "video");
						var b = {
							data1: h,
							startPTS: m,
							startDTS: m,
							endPTS: y,
							endDTS: y,
							type: S,
							hasAudio: E,
							hasVideo: T,
							nb: 1,
							dropped: 0
						};
						u.audio = "audio" === b.type ? b : void 0, u.video = "audio" !== b.type ? b : void 0, u.initSegment = c;
						var L = null != (a = this.initPTS) ? a : 0;
						return u.id3 = (0, $.flushTextTrackMetadataCueSamples)(r, n, L, L), i.samples.length && (u.text = (0, $.flushTextTrackUserdataCueSamples)(i, n, L)), u
					}, t
				}();
				var et;
				try {
					et = self.performance.now.bind(self.performance)
				} catch(t) {
					v.logger.debug("Unable to use Performance API on this environment"), et = self.Date.now
				}
				var rt = [{
						demux: R,
						remux: tt
					}, {
						demux: X,
						remux: $.default
					}, {
						demux: D,
						remux: $.default
					}, {
						demux: Q,
						remux: $.default
					}],
					it = function() {
						function t(t, e, r, i, n) {
							this.async = !1, this.observer = void 0, this.typeSupported = void 0, this.config = void 0, this.vendor = void 0, this.id = void 0, this.demuxer = void 0, this.remuxer = void 0, this.decrypter = void 0, this.probe = void 0, this.decryptionPromise = null, this.transmuxConfig = void 0, this.currentTransmuxState = void 0, this.observer = t, this.typeSupported = e, this.config = r, this.vendor = i, this.id = n
						}
						var e = t.prototype;
						return e.configure = function(t) {
							this.transmuxConfig = t, this.decrypter && this.decrypter.reset()
						}, e.push = function(t, e, r, i) {
							var n = this,
								a = r.transmuxing;
							a.executeStart = et();
							var s = new Uint8Array(t),
								o = this.currentTransmuxState,
								l = this.transmuxConfig;
							i && (this.currentTransmuxState = i);
							var u = i || o,
								d = u.contiguous,
								h = u.discontinuity,
								c = u.trackSwitch,
								f = u.accurateTimeOffset,
								g = u.timeOffset,
								v = u.initSegmentChange,
								p = l.audioCodec,
								m = l.videoCodec,
								y = l.defaultInitPts,
								E = l.duration,
								T = l.initSegmentData,
								S = function(t, e) {
									var r = null;
									return t.byteLength > 0 && null != e && null != e.key && null !== e.iv && null != e.method && (r = e), r
								}(s, e);
							if(S && "AES-128" === S.method) {
								var b = this.getDecrypter();
								if(!b.isSync()) return this.decryptionPromise = b.webCryptoDecrypt(s, S.key.buffer, S.iv.buffer).then((function(t) {
									var e = n.push(t, null, r);
									return n.decryptionPromise = null, e
								})), this.decryptionPromise;
								var L = b.softwareDecrypt(s, S.key.buffer, S.iv.buffer);
								if(r.part > -1 && (L = b.flush()), !L) return a.executeEnd = et(), nt(r);
								s = new Uint8Array(L)
							}
							var A = this.needsProbing(h, c);
							A && this.configureTransmuxer(s), (h || c || v || A) && this.resetInitSegment(T, p, m, E, e), (h || v || A) && this.resetInitialTimestamp(y), d || this.resetContiguity();
							var D = this.transmux(s, S, g, f, r),
								k = this.currentTransmuxState;
							return k.contiguous = !0, k.discontinuity = !1, k.trackSwitch = !1, a.executeEnd = et(), D
						}, e.flush = function(t) {
							var e = this,
								r = t.transmuxing;
							r.executeStart = et();
							var a = this.decrypter,
								s = this.currentTransmuxState,
								o = this.decryptionPromise;
							if(o) return o.then((function() {
								return e.flush(t)
							}));
							var l = [],
								u = s.timeOffset;
							if(a) {
								var d = a.flush();
								d && l.push(this.push(d, null, t))
							}
							var h = this.demuxer,
								c = this.remuxer;
							if(!h || !c) return this.observer.emit(i.Events.ERROR, i.Events.ERROR, {
								type: n.ErrorTypes.MEDIA_ERROR,
								details: n.ErrorDetails.FRAG_PARSING_ERROR,
								fatal: !0,
								reason: "no demux matching with content found"
							}), r.executeEnd = et(), [nt(t)];
							var f = h.flush(u);
							return at(f) ? f.then((function(r) {
								return e.flushRemux(l, r, t), l
							})) : (this.flushRemux(l, f, t), l)
						}, e.flushRemux = function(t, e, r) {
							var i = e.audioTrack,
								n = e.videoTrack,
								a = e.id3Track,
								s = e.textTrack,
								o = this.currentTransmuxState,
								l = o.accurateTimeOffset,
								u = o.timeOffset;
							v.logger.log("[transmuxer.ts]: Flushed fragment " + r.sn + (r.part > -1 ? " p: " + r.part : "") + " of level " + r.level);
							var d = this.remuxer.remux(i, n, a, s, u, l, !0, this.id);
							t.push({
								remuxResult: d,
								chunkMeta: r
							}), r.transmuxing.executeEnd = et()
						}, e.resetInitialTimestamp = function(t) {
							var e = this.demuxer,
								r = this.remuxer;
							e && r && (e.resetTimeStamp(t), r.resetTimeStamp(t))
						}, e.resetContiguity = function() {
							var t = this.demuxer,
								e = this.remuxer;
							t && e && (t.resetContiguity(), e.resetNextTimestamp())
						}, e.resetInitSegment = function(t, e, r, i, n) {
							var a = this.demuxer,
								s = this.remuxer;
							a && s && (a.resetInitSegment(t, e, r, i), s.resetInitSegment(t, e, r, n))
						}, e.destroy = function() {
							this.demuxer && (this.demuxer.destroy(), this.demuxer = void 0), this.remuxer && (this.remuxer.destroy(), this.remuxer = void 0)
						}, e.transmux = function(t, e, r, i, n) {
							return e && "SAMPLE-AES" === e.method ? this.transmuxSampleAes(t, e, r, i, n) : this.transmuxUnencrypted(t, r, i, n)
						}, e.transmuxUnencrypted = function(t, e, r, i) {
							var n = this.demuxer.demux(t, e, !1, !this.config.progressive),
								a = n.audioTrack,
								s = n.videoTrack,
								o = n.id3Track,
								l = n.textTrack;
							return {
								remuxResult: this.remuxer.remux(a, s, o, l, e, r, !1, this.id),
								chunkMeta: i
							}
						}, e.transmuxSampleAes = function(t, e, r, i, n) {
							var a = this;
							return this.demuxer.demuxSampleAes(t, e, r).then((function(t) {
								return {
									remuxResult: a.remuxer.remux(t.audioTrack, t.videoTrack, t.id3Track, t.textTrack, r, i, !1, a.id),
									chunkMeta: n
								}
							}))
						}, e.configureTransmuxer = function(t) {
							for(var e, r = this.config, i = this.observer, n = this.typeSupported, a = this.vendor, s = 0, o = rt.length; s < o; s++)
								if(rt[s].demux.probe(t)) {
									e = rt[s];
									break
								}
							e || (v.logger.warn("Failed to find demuxer by probing frag, treating as mp4 passthrough"), e = {
								demux: R,
								remux: tt
							});
							var l = this.demuxer,
								u = this.remuxer,
								d = e.remux,
								h = e.demux;
							u && u instanceof d || (this.remuxer = new d(i, r, n, a)), l && l instanceof h || (this.demuxer = new h(i, r, n), this.probe = h.probe)
						}, e.needsProbing = function(t, e) {
							return !this.demuxer || !this.remuxer || t || e
						}, e.getDecrypter = function() {
							var t = this.decrypter;
							return t || (t = this.decrypter = new a.default(this.config)), t
						}, t
					}(),
					nt = function(t) {
						return {
							remuxResult: {},
							chunkMeta: t
						}
					};

				function at(t) {
					return "then" in t && t.then instanceof Function
				}
				var st = function(t, e, r, i, n) {
						this.audioCodec = void 0, this.videoCodec = void 0, this.initSegmentData = void 0, this.duration = void 0, this.defaultInitPts = void 0, this.audioCodec = t, this.videoCodec = e, this.initSegmentData = r, this.duration = i, this.defaultInitPts = n
					},
					ot = function(t, e, r, i, n, a) {
						this.discontinuity = void 0, this.contiguous = void 0, this.accurateTimeOffset = void 0, this.trackSwitch = void 0, this.timeOffset = void 0, this.initSegmentChange = void 0, this.discontinuity = t, this.contiguous = e, this.accurateTimeOffset = r, this.trackSwitch = i, this.timeOffset = n, this.initSegmentChange = a
					}
			},
			973: (t, e, r) => {
				"use strict";
				var i, n;
				r.r(e), r.d(e, {
						ErrorDetails: () => n,
						ErrorTypes: () => i
					}),
					function(t) {
						t.NETWORK_ERROR = "networkError", t.MEDIA_ERROR = "mediaError", t.KEY_SYSTEM_ERROR = "keySystemError", t.MUX_ERROR = "muxError", t.OTHER_ERROR = "otherError"
					}(i || (i = {})),
					function(t) {
						t.KEY_SYSTEM_NO_KEYS = "keySystemNoKeys", t.KEY_SYSTEM_NO_ACCESS = "keySystemNoAccess", t.KEY_SYSTEM_NO_SESSION = "keySystemNoSession", t.KEY_SYSTEM_NO_CONFIGURED_LICENSE = "keySystemNoConfiguredLicense", t.KEY_SYSTEM_LICENSE_REQUEST_FAILED = "keySystemLicenseRequestFailed", t.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED = "keySystemServerCertificateRequestFailed", t.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED = "keySystemServerCertificateUpdateFailed", t.KEY_SYSTEM_SESSION_UPDATE_FAILED = "keySystemSessionUpdateFailed", t.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED = "keySystemStatusOutputRestricted", t.KEY_SYSTEM_STATUS_INTERNAL_ERROR = "keySystemStatusInternalError", t.MANIFEST_LOAD_ERROR = "manifestLoadError", t.MANIFEST_LOAD_TIMEOUT = "manifestLoadTimeOut", t.MANIFEST_PARSING_ERROR = "manifestParsingError", t.MANIFEST_INCOMPATIBLE_CODECS_ERROR = "manifestIncompatibleCodecsError", t.LEVEL_EMPTY_ERROR = "levelEmptyError", t.LEVEL_LOAD_ERROR = "levelLoadError", t.LEVEL_LOAD_TIMEOUT = "levelLoadTimeOut", t.LEVEL_SWITCH_ERROR = "levelSwitchError", t.AUDIO_TRACK_LOAD_ERROR = "audioTrackLoadError", t.AUDIO_TRACK_LOAD_TIMEOUT = "audioTrackLoadTimeOut", t.SUBTITLE_LOAD_ERROR = "subtitleTrackLoadError", t.SUBTITLE_TRACK_LOAD_TIMEOUT = "subtitleTrackLoadTimeOut", t.FRAG_LOAD_ERROR = "fragLoadError", t.FRAG_LOAD_TIMEOUT = "fragLoadTimeOut", t.FRAG_DECRYPT_ERROR = "fragDecryptError", t.FRAG_PARSING_ERROR = "fragParsingError", t.REMUX_ALLOC_ERROR = "remuxAllocError", t.KEY_LOAD_ERROR = "keyLoadError", t.KEY_LOAD_TIMEOUT = "keyLoadTimeOut", t.BUFFER_ADD_CODEC_ERROR = "bufferAddCodecError", t.BUFFER_INCOMPATIBLE_CODECS_ERROR = "bufferIncompatibleCodecsError", t.BUFFER_APPEND_ERROR = "bufferAppendError", t.BUFFER_APPENDING_ERROR = "bufferAppendingError", t.BUFFER_STALLED_ERROR = "bufferStalledError", t.BUFFER_FULL_ERROR = "bufferFullError", t.BUFFER_SEEK_OVER_HOLE = "bufferSeekOverHole", t.BUFFER_NUDGE_ON_STALL = "bufferNudgeOnStall", t.INTERNAL_EXCEPTION = "internalException", t.INTERNAL_ABORTED = "aborted", t.UNKNOWN = "unknown"
					}(n || (n = {}))
			},
			851: (t, e, r) => {
				"use strict";
				var i;
				r.r(e), r.d(e, {
						Events: () => i
					}),
					function(t) {
						t.MEDIA_ATTACHING = "hlsMediaAttaching", t.MEDIA_ATTACHED = "hlsMediaAttached", t.MEDIA_DETACHING = "hlsMediaDetaching", t.MEDIA_DETACHED = "hlsMediaDetached", t.BUFFER_RESET = "hlsBufferReset", t.BUFFER_CODECS = "hlsBufferCodecs", t.BUFFER_CREATED = "hlsBufferCreated", t.BUFFER_APPENDING = "hlsBufferAppending", t.BUFFER_APPENDED = "hlsBufferAppended", t.BUFFER_EOS = "hlsBufferEos", t.BUFFER_FLUSHING = "hlsBufferFlushing", t.BUFFER_FLUSHED = "hlsBufferFlushed", t.MANIFEST_LOADING = "hlsManifestLoading", t.MANIFEST_LOADED = "hlsManifestLoaded", t.MANIFEST_PARSED = "hlsManifestParsed", t.LEVEL_SWITCHING = "hlsLevelSwitching", t.LEVEL_SWITCHED = "hlsLevelSwitched", t.LEVEL_LOADING = "hlsLevelLoading", t.LEVEL_LOADED = "hlsLevelLoaded", t.LEVEL_UPDATED = "hlsLevelUpdated", t.LEVEL_PTS_UPDATED = "hlsLevelPtsUpdated", t.LEVELS_UPDATED = "hlsLevelsUpdated", t.AUDIO_TRACKS_UPDATED = "hlsAudioTracksUpdated", t.AUDIO_TRACK_SWITCHING = "hlsAudioTrackSwitching", t.AUDIO_TRACK_SWITCHED = "hlsAudioTrackSwitched", t.AUDIO_TRACK_LOADING = "hlsAudioTrackLoading", t.AUDIO_TRACK_LOADED = "hlsAudioTrackLoaded", t.SUBTITLE_TRACKS_UPDATED = "hlsSubtitleTracksUpdated", t.SUBTITLE_TRACKS_CLEARED = "hlsSubtitleTracksCleared", t.SUBTITLE_TRACK_SWITCH = "hlsSubtitleTrackSwitch", t.SUBTITLE_TRACK_LOADING = "hlsSubtitleTrackLoading", t.SUBTITLE_TRACK_LOADED = "hlsSubtitleTrackLoaded", t.SUBTITLE_FRAG_PROCESSED = "hlsSubtitleFragProcessed", t.CUES_PARSED = "hlsCuesParsed", t.NON_NATIVE_TEXT_TRACKS_FOUND = "hlsNonNativeTextTracksFound", t.INIT_PTS_FOUND = "hlsInitPtsFound", t.FRAG_LOADING = "hlsFragLoading", t.FRAG_LOAD_EMERGENCY_ABORTED = "hlsFragLoadEmergencyAborted", t.FRAG_LOADED = "hlsFragLoaded", t.FRAG_DECRYPTED = "hlsFragDecrypted", t.FRAG_PARSING_INIT_SEGMENT = "hlsFragParsingInitSegment", t.FRAG_PARSING_USERDATA = "hlsFragParsingUserdata", t.FRAG_PARSING_METADATA = "hlsFragParsingMetadata", t.FRAG_PARSED = "hlsFragParsed", t.FRAG_BUFFERED = "hlsFragBuffered", t.FRAG_CHANGED = "hlsFragChanged", t.FPS_DROP = "hlsFpsDrop", t.FPS_DROP_LEVEL_CAPPING = "hlsFpsDropLevelCapping", t.ERROR = "hlsError", t.DESTROYING = "hlsDestroying", t.KEY_LOADING = "hlsKeyLoading", t.KEY_LOADED = "hlsKeyLoaded", t.LIVE_BACK_BUFFER_REACHED = "hlsLiveBackBufferReached", t.BACK_BUFFER_REACHED = "hlsBackBufferReached"
					}(i || (i = {}))
			},
			76: (t, e, r) => {
				"use strict";
				r.r(e), r.d(e, {
					default: () => Bi
				});
				var i, n = r(945),
					a = r(965),
					s = r(851),
					o = r(973),
					l = r(93),
					u = /^(\d+)x(\d+)$/,
					d = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g,
					h = function() {
						function t(e) {
							for(var r in "string" == typeof e && (e = t.parseAttrList(e)), e) e.hasOwnProperty(r) && (this[r] = e[r])
						}
						var e = t.prototype;
						return e.decimalInteger = function(t) {
							var e = parseInt(this[t], 10);
							return e > Number.MAX_SAFE_INTEGER ? 1 / 0 : e
						}, e.hexadecimalInteger = function(t) {
							if(this[t]) {
								var e = (this[t] || "0x").slice(2);
								e = (1 & e.length ? "0" : "") + e;
								for(var r = new Uint8Array(e.length / 2), i = 0; i < e.length / 2; i++) r[i] = parseInt(e.slice(2 * i, 2 * i + 2), 16);
								return r
							}
							return null
						}, e.hexadecimalIntegerAsNumber = function(t) {
							var e = parseInt(this[t], 16);
							return e > Number.MAX_SAFE_INTEGER ? 1 / 0 : e
						}, e.decimalFloatingPoint = function(t) {
							return parseFloat(this[t])
						}, e.optionalFloat = function(t, e) {
							var r = this[t];
							return r ? parseFloat(r) : e
						}, e.enumeratedString = function(t) {
							return this[t]
						}, e.bool = function(t) {
							return "YES" === this[t]
						}, e.decimalResolution = function(t) {
							var e = u.exec(this[t]);
							if(null !== e) return {
								width: parseInt(e[1], 10),
								height: parseInt(e[2], 10)
							}
						}, t.parseAttrList = function(t) {
							var e, r = {};
							for(d.lastIndex = 0; null !== (e = d.exec(t));) {
								var i = e[2];
								0 === i.indexOf('"') && i.lastIndexOf('"') === i.length - 1 && (i = i.slice(1, -1)), r[e[1]] = i
							}
							return r
						}, t
					}();

				function c() {
					return c = Object.assign ? Object.assign.bind() : function(t) {
						for(var e = 1; e < arguments.length; e++) {
							var r = arguments[e];
							for(var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i])
						}
						return t
					}, c.apply(this, arguments)
				}

				function f(t, e) {
					for(var r = 0; r < e.length; r++) {
						var i = e[r];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, (void 0, "symbol" == typeof(n = function(t, e) {
							if("object" != typeof t || null === t) return t;
							var r = t[Symbol.toPrimitive];
							if(void 0 !== r) {
								var i = r.call(t, e);
								if("object" != typeof i) return i;
								throw new TypeError("@@toPrimitive must return a primitive value.")
							}
							return String(t)
						}(i.key, "string")) ? n : String(n)), i)
					}
					var n
				}! function(t) {
					t.ID = "ID", t.CLASS = "CLASS", t.START_DATE = "START-DATE", t.DURATION = "DURATION", t.END_DATE = "END-DATE", t.END_ON_NEXT = "END-ON-NEXT", t.PLANNED_DURATION = "PLANNED-DURATION", t.SCTE35_OUT = "SCTE35-OUT", t.SCTE35_IN = "SCTE35-IN"
				}(i || (i = {}));
				var g = function() {
						function t(t, e) {
							if(this.attr = void 0, this._startDate = void 0, this._endDate = void 0, this._badValueForSameId = void 0, e) {
								var r = e.attr;
								for(var n in r)
									if(Object.prototype.hasOwnProperty.call(t, n) && t[n] !== r[n]) {
										l.logger.warn('DATERANGE tag attribute: "' + n + '" does not match for tags with ID: "' + t.ID + '"'), this._badValueForSameId = n;
										break
									}
								t = c(new h({}), r, t)
							}
							if(this.attr = t, this._startDate = new Date(t[i.START_DATE]), i.END_DATE in this.attr) {
								var s = new Date(this.attr[i.END_DATE]);
								(0, a.isFiniteNumber)(s.getTime()) && (this._endDate = s)
							}
						}
						var e, r;
						return e = t, (r = [{
							key: "id",
							get: function() {
								return this.attr.ID
							}
						}, {
							key: "class",
							get: function() {
								return this.attr.CLASS
							}
						}, {
							key: "startDate",
							get: function() {
								return this._startDate
							}
						}, {
							key: "endDate",
							get: function() {
								if(this._endDate) return this._endDate;
								var t = this.duration;
								return null !== t ? new Date(this._startDate.getTime() + 1e3 * t) : null
							}
						}, {
							key: "duration",
							get: function() {
								if(i.DURATION in this.attr) {
									var t = this.attr.decimalFloatingPoint(i.DURATION);
									if((0, a.isFiniteNumber)(t)) return t
								} else if(this._endDate) return(this._endDate.getTime() - this._startDate.getTime()) / 1e3;
								return null
							}
						}, {
							key: "plannedDuration",
							get: function() {
								return i.PLANNED_DURATION in this.attr ? this.attr.decimalFloatingPoint(i.PLANNED_DURATION) : null
							}
						}, {
							key: "endOnNext",
							get: function() {
								return this.attr.bool(i.END_ON_NEXT)
							}
						}, {
							key: "isValid",
							get: function() {
								return !!this.id && !this._badValueForSameId && (0, a.isFiniteNumber)(this.startDate.getTime()) && (null === this.duration || this.duration >= 0) && (!this.endOnNext || !!this.class)
							}
						}]) && f(e.prototype, r), Object.defineProperty(e, "prototype", {
							writable: !1
						}), t
					}(),
					v = r(923);

				function p(t, e) {
					for(var r = 0; r < e.length; r++) {
						var i = e[r];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, (void 0, "symbol" == typeof(n = function(t, e) {
							if("object" != typeof t || null === t) return t;
							var r = t[Symbol.toPrimitive];
							if(void 0 !== r) {
								var i = r.call(t, e);
								if("object" != typeof i) return i;
								throw new TypeError("@@toPrimitive must return a primitive value.")
							}
							return String(t)
						}(i.key, "string")) ? n : String(n)), i)
					}
					var n
				}
				var m, y, E, T = function() {
					function t(t) {
						this.PTSKnown = !1, this.alignedSliding = !1, this.averagetargetduration = void 0, this.endCC = 0, this.endSN = 0, this.fragments = void 0, this.fragmentHint = void 0, this.partList = null, this.dateRanges = void 0, this.live = !0, this.ageHeader = 0, this.advancedDateTime = void 0, this.updated = !0, this.advanced = !0, this.availabilityDelay = void 0, this.misses = 0, this.startCC = 0, this.startSN = 0, this.startTimeOffset = null, this.targetduration = 0, this.totalduration = 0, this.type = null, this.url = void 0, this.m3u8 = "", this.version = null, this.canBlockReload = !1, this.canSkipUntil = 0, this.canSkipDateRanges = !1, this.skippedSegments = 0, this.recentlyRemovedDateranges = void 0, this.partHoldBack = 0, this.holdBack = 0, this.partTarget = 0, this.preloadHint = void 0, this.renditionReports = void 0, this.tuneInGoal = 0, this.deltaUpdateFailed = void 0, this.driftStartTime = 0, this.driftEndTime = 0, this.driftStart = 0, this.driftEnd = 0, this.encryptedFragments = void 0, this.fragments = [], this.encryptedFragments = [], this.dateRanges = {}, this.url = t
					}
					var e, r;
					return t.prototype.reloaded = function(t) {
						if(!t) return this.advanced = !0, void(this.updated = !0);
						var e = this.lastPartSn - t.lastPartSn,
							r = this.lastPartIndex - t.lastPartIndex;
						this.updated = this.endSN !== t.endSN || !!r || !!e, this.advanced = this.endSN > t.endSN || e > 0 || 0 === e && r > 0, this.updated || this.advanced ? this.misses = Math.floor(.6 * t.misses) : this.misses = t.misses + 1, this.availabilityDelay = t.availabilityDelay
					}, e = t, (r = [{
						key: "hasProgramDateTime",
						get: function() {
							return !!this.fragments.length && (0, a.isFiniteNumber)(this.fragments[this.fragments.length - 1].programDateTime)
						}
					}, {
						key: "levelTargetDuration",
						get: function() {
							return this.averagetargetduration || this.targetduration || 10
						}
					}, {
						key: "drift",
						get: function() {
							var t = this.driftEndTime - this.driftStartTime;
							return t > 0 ? 1e3 * (this.driftEnd - this.driftStart) / t : 1
						}
					}, {
						key: "edge",
						get: function() {
							return this.partEnd || this.fragmentEnd
						}
					}, {
						key: "partEnd",
						get: function() {
							var t;
							return null !== (t = this.partList) && void 0 !== t && t.length ? this.partList[this.partList.length - 1].end : this.fragmentEnd
						}
					}, {
						key: "fragmentEnd",
						get: function() {
							var t;
							return null !== (t = this.fragments) && void 0 !== t && t.length ? this.fragments[this.fragments.length - 1].end : 0
						}
					}, {
						key: "age",
						get: function() {
							return this.advancedDateTime ? Math.max(Date.now() - this.advancedDateTime, 0) / 1e3 : 0
						}
					}, {
						key: "lastPartIndex",
						get: function() {
							var t;
							return null !== (t = this.partList) && void 0 !== t && t.length ? this.partList[this.partList.length - 1].index : -1
						}
					}, {
						key: "lastPartSn",
						get: function() {
							var t;
							return null !== (t = this.partList) && void 0 !== t && t.length ? this.partList[this.partList.length - 1].fragment.sn : this.endSN
						}
					}]) && p(e.prototype, r), Object.defineProperty(e, "prototype", {
						writable: !1
					}), t
				}();

				function S(t) {
					return Uint8Array.from(atob(t), (function(t) {
						return t.charCodeAt(0)
					}))
				}

				function b(t) {
					return Uint8Array.from(unescape(encodeURIComponent(t)), (function(t) {
						return t.charCodeAt(0)
					}))
				}

				function L(t) {
					switch(t) {
						case y.FAIRPLAY:
							return m.FAIRPLAY;
						case y.PLAYREADY:
							return m.PLAYREADY;
						case y.WIDEVINE:
							return m.WIDEVINE;
						case y.CLEARKEY:
							return m.CLEARKEY
					}
				}

				function A(t) {
					switch(t) {
						case m.FAIRPLAY:
							return y.FAIRPLAY;
						case m.PLAYREADY:
							return y.PLAYREADY;
						case m.WIDEVINE:
							return y.WIDEVINE;
						case m.CLEARKEY:
							return y.CLEARKEY
					}
				}

				function D(t) {
					var e = t.drmSystems,
						r = t.widevineLicenseUrl,
						i = e ? [m.FAIRPLAY, m.WIDEVINE, m.PLAYREADY, m.CLEARKEY].filter((function(t) {
							return !!e[t]
						})) : [];
					return !i[m.WIDEVINE] && r && i.push(m.WIDEVINE), i
				}! function(t) {
					t.CLEARKEY = "org.w3.clearkey", t.FAIRPLAY = "com.apple.fps", t.PLAYREADY = "com.microsoft.playready", t.WIDEVINE = "com.widevine.alpha"
				}(m || (m = {})),
				function(t) {
					t.CLEARKEY = "org.w3.clearkey", t.FAIRPLAY = "com.apple.streamingkeydelivery", t.PLAYREADY = "com.microsoft.playready", t.WIDEVINE = "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed"
				}(y || (y = {})),
				function(t) {
					t.WIDEVINE = "edef8ba979d64acea3c827dcd51d21ed"
				}(E || (E = {}));
				var k = "undefined" != typeof self && self.navigator && self.navigator.requestMediaKeySystemAccess ? self.navigator.requestMediaKeySystemAccess.bind(self.navigator) : null,
					R = r(63),
					I = {},
					w = function() {
						function t(t, e, r, i, n) {
							void 0 === i && (i = [1]), void 0 === n && (n = null), this.uri = void 0, this.method = void 0, this.keyFormat = void 0, this.keyFormatVersions = void 0, this.encrypted = void 0, this.isCommonEncryption = void 0, this.iv = null, this.key = null, this.keyId = null, this.pssh = null, this.method = t, this.uri = e, this.keyFormat = r, this.keyFormatVersions = i, this.iv = n, this.encrypted = !!t && "NONE" !== t, this.isCommonEncryption = this.encrypted && "AES-128" !== t
						}
						t.clearKeyUriToKeyIdMap = function() {
							I = {}
						};
						var e = t.prototype;
						return e.isSupported = function() {
							if(this.method) {
								if("AES-128" === this.method || "NONE" === this.method) return !0;
								switch(this.keyFormat) {
									case "identity":
										return "SAMPLE-AES" === this.method;
									case y.FAIRPLAY:
									case y.WIDEVINE:
									case y.PLAYREADY:
									case y.CLEARKEY:
										return -1 !== ["ISO-23001-7", "SAMPLE-AES", "SAMPLE-AES-CENC", "SAMPLE-AES-CTR"].indexOf(this.method)
								}
							}
							return !1
						}, e.getDecryptData = function(e) {
							if(!this.encrypted || !this.uri) return null;
							if("AES-128" === this.method && this.uri && !this.iv) {
								"number" != typeof e && ("AES-128" !== this.method || this.iv || l.logger.warn('missing IV for initialization segment with method="' + this.method + '" - compliance issue'), e = 0);
								var r = function(t) {
									for(var e = new Uint8Array(16), r = 12; r < 16; r++) e[r] = t >> 8 * (15 - r) & 255;
									return e
								}(e);
								return new t(this.method, this.uri, "identity", this.keyFormatVersions, r)
							}
							var i = function(t) {
								var e, r, i = t.split(":"),
									n = null;
								if("data" === i[0] && 2 === i.length) {
									var a = i[1].split(";"),
										s = a[a.length - 1].split(",");
									if(2 === s.length) {
										var o = "base64" === s[0],
											l = s[1];
										o ? (a.splice(-1, 1), n = S(l)) : (e = b(l).subarray(0, 16), (r = new Uint8Array(16)).set(e, 16 - e.length), n = r)
									}
								}
								return n
							}(this.uri);
							if(i) switch(this.keyFormat) {
								case y.WIDEVINE:
									this.pssh = i, i.length >= 22 && (this.keyId = i.subarray(i.length - 22, i.length - 6));
									break;
								case y.PLAYREADY:
									var n = new Uint8Array([154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95, 149]);
									this.pssh = (0, R.mp4pssh)(n, null, i);
									var a = new Uint16Array(i.buffer, i.byteOffset, i.byteLength / 2),
										s = String.fromCharCode.apply(null, Array.from(a)),
										o = s.substring(s.indexOf("<"), s.length),
										u = (new DOMParser).parseFromString(o, "text/xml").getElementsByTagName("KID")[0];
									if(u) {
										var d = u.childNodes[0] ? u.childNodes[0].nodeValue : u.getAttribute("VALUE");
										if(d) {
											var h = S(d).subarray(0, 16);
											! function(t) {
												var e = function(t, e, r) {
													var i = t[e];
													t[e] = t[r], t[r] = i
												};
												e(t, 0, 3), e(t, 1, 2), e(t, 4, 5), e(t, 6, 7)
											}(h), this.keyId = h
										}
									}
									break;
								default:
									var c = i.subarray(0, 16);
									if(16 !== c.length) {
										var f = new Uint8Array(16);
										f.set(c, 16 - c.length), c = f
									}
									this.keyId = c
							}
							if(!this.keyId || 16 !== this.keyId.byteLength) {
								var g = I[this.uri];
								if(!g) {
									var v = Object.keys(I).length % Number.MAX_SAFE_INTEGER;
									g = new Uint8Array(16), new DataView(g.buffer, 12, 4).setUint32(0, v), I[this.uri] = g
								}
								this.keyId = g
							}
							return this
						}, t
					}(),
					C = {
						audio: {
							a3ds: !0,
							"ac-3": !0,
							"ac-4": !0,
							alac: !0,
							alaw: !0,
							dra1: !0,
							"dts+": !0,
							"dts-": !0,
							dtsc: !0,
							dtse: !0,
							dtsh: !0,
							"ec-3": !0,
							enca: !0,
							g719: !0,
							g726: !0,
							m4ae: !0,
							mha1: !0,
							mha2: !0,
							mhm1: !0,
							mhm2: !0,
							mlpa: !0,
							mp4a: !0,
							"raw ": !0,
							Opus: !0,
							opus: !0,
							samr: !0,
							sawb: !0,
							sawp: !0,
							sevc: !0,
							sqcp: !0,
							ssmv: !0,
							twos: !0,
							ulaw: !0
						},
						video: {
							avc1: !0,
							avc2: !0,
							avc3: !0,
							avc4: !0,
							avcp: !0,
							av01: !0,
							drac: !0,
							dva1: !0,
							dvav: !0,
							dvh1: !0,
							dvhe: !0,
							encv: !0,
							hev1: !0,
							hvc1: !0,
							mjp2: !0,
							mp4v: !0,
							mvc1: !0,
							mvc2: !0,
							mvc3: !0,
							mvc4: !0,
							resv: !0,
							rv60: !0,
							s263: !0,
							svc1: !0,
							svc2: !0,
							"vc-1": !0,
							vp08: !0,
							vp09: !0
						},
						text: {
							stpp: !0,
							wvtt: !0
						}
					};

				function _(t, e) {
					return MediaSource.isTypeSupported((e || "video") + '/mp4;codecs="' + t + '"')
				}

				function O() {
					return O = Object.assign ? Object.assign.bind() : function(t) {
						for(var e = 1; e < arguments.length; e++) {
							var r = arguments[e];
							for(var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i])
						}
						return t
					}, O.apply(this, arguments)
				}
				var P = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-SESSION-DATA:([^\r\n]*)[\r\n]+|#EXT-X-SESSION-KEY:([^\n\r]*)[\r\n]+/g,
					x = /#EXT-X-MEDIA:(.*)/g,
					F = new RegExp([/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source, /(?!#) *(\S[\S ]*)/.source, /#EXT-X-BYTERANGE:*(.+)/.source, /#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, /#.*/.source].join("|"), "g"),
					M = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(DATERANGE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\r?\n?/.source].join("|")),
					N = function() {
						function t() {}
						return t.findGroup = function(t, e) {
							for(var r = 0; r < t.length; r++) {
								var i = t[r];
								if(i.id === e) return i
							}
						}, t.convertAVC1ToAVCOTI = function(t) {
							var e = t.split(".");
							if(e.length > 2) {
								var r = e.shift() + ".";
								return(r += parseInt(e.shift()).toString(16)) + ("000" + parseInt(e.shift()).toString(16)).slice(-4)
							}
							return t
						}, t.resolve = function(t, e) {
							return(0, n.buildAbsoluteURL)(e, t, {
								alwaysNormalize: !0
							})
						}, t.parseMasterPlaylist = function(e, r) {
							var i, n = [],
								a = [],
								s = {},
								o = [],
								u = !1;
							for(P.lastIndex = 0; null != (i = P.exec(e));)
								if(i[1]) {
									var d, c = new h(i[1]),
										f = {
											attrs: c,
											bitrate: c.decimalInteger("AVERAGE-BANDWIDTH") || c.decimalInteger("BANDWIDTH"),
											name: c.NAME,
											url: t.resolve(i[2], r)
										},
										g = c.decimalResolution("RESOLUTION");
									g && (f.width = g.width, f.height = g.height), B((c.CODECS || "").split(/[ ,]+/).filter((function(t) {
										return t
									})), f), f.videoCodec && -1 !== f.videoCodec.indexOf("avc1") && (f.videoCodec = t.convertAVC1ToAVCOTI(f.videoCodec)), null !== (d = f.unknownCodecs) && void 0 !== d && d.length || a.push(f), n.push(f)
								} else if(i[3]) {
								var v = new h(i[3]);
								v["DATA-ID"] && (u = !0, s[v["DATA-ID"]] = v)
							} else if(i[4]) {
								var p = i[4],
									m = U(p, r);
								m.encrypted && m.isSupported() ? o.push(m) : l.logger.warn('[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: "' + p + '"')
							}
							return {
								levels: a.length > 0 && a.length < n.length ? a : n,
								sessionData: u ? s : null,
								sessionKeys: o.length ? o : null
							}
						}, t.parseMasterPlaylistMedia = function(e, r, i, n) {
							var a;
							void 0 === n && (n = []);
							var s = [],
								o = 0;
							for(x.lastIndex = 0; null !== (a = x.exec(e));) {
								var l = new h(a[1]);
								if(l.TYPE === i) {
									var u = {
										attrs: l,
										bitrate: 0,
										id: o++,
										groupId: l["GROUP-ID"],
										instreamId: l["INSTREAM-ID"],
										name: l.NAME || l.LANGUAGE || "",
										type: i,
										default: l.bool("DEFAULT"),
										autoselect: l.bool("AUTOSELECT"),
										forced: l.bool("FORCED"),
										lang: l.LANGUAGE,
										url: l.URI ? t.resolve(l.URI, r) : ""
									};
									if(n.length) {
										var d = t.findGroup(n, u.groupId) || n[0];
										G(u, d, "audioCodec"), G(u, d, "textCodec")
									}
									s.push(u)
								}
							}
							return s
						}, t.parseLevelPlaylist = function(t, e, r, i, n) {
							var s, o, u, d = new T(e),
								c = d.fragments,
								f = null,
								p = 0,
								m = 0,
								y = 0,
								E = 0,
								S = null,
								b = new v.Fragment(i, e),
								L = -1,
								A = !1;
							for(F.lastIndex = 0, d.m3u8 = t; null !== (s = F.exec(t));) {
								A && (A = !1, (b = new v.Fragment(i, e)).start = y, b.sn = p, b.cc = E, b.level = r, f && (b.initSegment = f, b.rawProgramDateTime = f.rawProgramDateTime, f.rawProgramDateTime = null));
								var D = s[1];
								if(D) {
									b.duration = parseFloat(D);
									var k = (" " + s[2]).slice(1);
									b.title = k || null, b.tagList.push(k ? ["INF", D, k] : ["INF", D])
								} else if(s[3])(0, a.isFiniteNumber)(b.duration) && (b.start = y, u && j(b, u, d), b.sn = p, b.level = r, b.cc = E, b.urlId = n, c.push(b), b.relurl = (" " + s[3]).slice(1), K(b, S), S = b, y += b.duration, p++, m = 0, A = !0);
								else if(s[4]) {
									var R = (" " + s[4]).slice(1);
									S ? b.setByteRange(R, S) : b.setByteRange(R)
								} else if(s[5]) b.rawProgramDateTime = (" " + s[5]).slice(1), b.tagList.push(["PROGRAM-DATE-TIME", b.rawProgramDateTime]), -1 === L && (L = c.length);
								else {
									if(!(s = s[0].match(M))) {
										l.logger.warn("No matches on slow regex match for level playlist!");
										continue
									}
									for(o = 1; o < s.length && void 0 === s[o]; o++);
									var I = (" " + s[o]).slice(1),
										w = (" " + s[o + 1]).slice(1),
										C = s[o + 2] ? (" " + s[o + 2]).slice(1) : "";
									switch(I) {
										case "PLAYLIST-TYPE":
											d.type = w.toUpperCase();
											break;
										case "MEDIA-SEQUENCE":
											p = d.startSN = parseInt(w);
											break;
										case "SKIP":
											var _ = new h(w),
												P = _.decimalInteger("SKIPPED-SEGMENTS");
											if((0, a.isFiniteNumber)(P)) {
												d.skippedSegments = P;
												for(var x = P; x--;) c.unshift(null);
												p += P
											}
											var N = _.enumeratedString("RECENTLY-REMOVED-DATERANGES");
											N && (d.recentlyRemovedDateranges = N.split("\t"));
											break;
										case "TARGETDURATION":
											d.targetduration = parseFloat(w);
											break;
										case "VERSION":
											d.version = parseInt(w);
											break;
										case "EXTM3U":
											break;
										case "ENDLIST":
											d.live = !1;
											break;
										case "#":
											(w || C) && b.tagList.push(C ? [w, C] : [w]);
											break;
										case "DISCONTINUITY":
											E++, b.tagList.push(["DIS"]);
											break;
										case "GAP":
											b.tagList.push([I]);
											break;
										case "BITRATE":
											b.tagList.push([I, w]);
											break;
										case "DATERANGE":
											var B = new h(w),
												G = new g(B, d.dateRanges[B.ID]);
											G.isValid || d.skippedSegments ? d.dateRanges[G.id] = G : l.logger.warn('Ignoring invalid DATERANGE tag: "' + w + '"'), b.tagList.push(["EXT-X-DATERANGE", w]);
											break;
										case "DISCONTINUITY-SEQUENCE":
											E = parseInt(w);
											break;
										case "KEY":
											var V = U(w, e);
											if(V.isSupported()) {
												if("NONE" === V.method) {
													u = void 0;
													break
												}
												u || (u = {}), u[V.keyFormat] && (u = O({}, u)), u[V.keyFormat] = V
											} else l.logger.warn('[Keys] Ignoring invalid EXT-X-KEY tag: "' + w + '"');
											break;
										case "START":
											var Y = new h(w).decimalFloatingPoint("TIME-OFFSET");
											(0, a.isFiniteNumber)(Y) && (d.startTimeOffset = Y);
											break;
										case "MAP":
											var W = new h(w);
											if(b.duration) {
												var q = new v.Fragment(i, e);
												H(q, W, r, u), f = q, b.initSegment = f, f.rawProgramDateTime && !b.rawProgramDateTime && (b.rawProgramDateTime = f.rawProgramDateTime)
											} else H(b, W, r, u), f = b, A = !0;
											break;
										case "SERVER-CONTROL":
											var X = new h(w);
											d.canBlockReload = X.bool("CAN-BLOCK-RELOAD"), d.canSkipUntil = X.optionalFloat("CAN-SKIP-UNTIL", 0), d.canSkipDateRanges = d.canSkipUntil > 0 && X.bool("CAN-SKIP-DATERANGES"), d.partHoldBack = X.optionalFloat("PART-HOLD-BACK", 0), d.holdBack = X.optionalFloat("HOLD-BACK", 0);
											break;
										case "PART-INF":
											var z = new h(w);
											d.partTarget = z.decimalFloatingPoint("PART-TARGET");
											break;
										case "PART":
											var Q = d.partList;
											Q || (Q = d.partList = []);
											var $ = m > 0 ? Q[Q.length - 1] : void 0,
												J = m++,
												Z = new v.Part(new h(w), b, e, J, $);
											Q.push(Z), b.duration += Z.duration;
											break;
										case "PRELOAD-HINT":
											var tt = new h(w);
											d.preloadHint = tt;
											break;
										case "RENDITION-REPORT":
											var et = new h(w);
											d.renditionReports = d.renditionReports || [], d.renditionReports.push(et);
											break;
										default:
											l.logger.warn("line parsed but not handled: " + s)
									}
								}
							}
							S && !S.relurl ? (c.pop(), y -= S.duration, d.partList && (d.fragmentHint = S)) : d.partList && (K(b, S), b.cc = E, d.fragmentHint = b, u && j(b, u, d));
							var rt = c.length,
								it = c[0],
								nt = c[rt - 1];
							if((y += d.skippedSegments * d.targetduration) > 0 && rt && nt) {
								d.averagetargetduration = y / rt;
								var at = nt.sn;
								d.endSN = "initSegment" !== at ? at : 0, d.live || (nt.endList = !0), it && (d.startCC = it.cc)
							} else d.endSN = 0, d.startCC = 0;
							return d.fragmentHint && (y += d.fragmentHint.duration), d.totalduration = y, d.endCC = E, L > 0 && function(t, e) {
								for(var r = t[e], i = e; i--;) {
									var n = t[i];
									if(!n) return;
									n.programDateTime = r.programDateTime - 1e3 * n.duration, r = n
								}
							}(c, L), d
						}, t
					}();

				function U(t, e) {
					var r, i, n = new h(t),
						a = null != (r = n.enumeratedString("METHOD")) ? r : "",
						s = n.URI,
						o = n.hexadecimalInteger("IV"),
						u = n.enumeratedString("KEYFORMATVERSIONS"),
						d = null != (i = n.enumeratedString("KEYFORMAT")) ? i : "identity";
					s && n.IV && !o && l.logger.error("Invalid IV: " + n.IV);
					var c = s ? N.resolve(s, e) : "",
						f = (u || "1").split("/").map(Number).filter(Number.isFinite);
					return new w(a, c, d, f, o)
				}

				function B(t, e) {
					["video", "audio", "text"].forEach((function(r) {
						var i = t.filter((function(t) {
							return function(t, e) {
								var r = C[e];
								return !!r && !0 === r[t.slice(0, 4)]
							}(t, r)
						}));
						if(i.length) {
							var n = i.filter((function(t) {
								return 0 === t.lastIndexOf("avc1", 0) || 0 === t.lastIndexOf("mp4a", 0)
							}));
							e[r + "Codec"] = n.length > 0 ? n[0] : i[0], t = t.filter((function(t) {
								return -1 === i.indexOf(t)
							}))
						}
					})), e.unknownCodecs = t
				}

				function G(t, e, r) {
					var i = e[r];
					i && (t[r] = i)
				}

				function K(t, e) {
					t.rawProgramDateTime ? t.programDateTime = Date.parse(t.rawProgramDateTime) : null != e && e.programDateTime && (t.programDateTime = e.endProgramDateTime), (0, a.isFiniteNumber)(t.programDateTime) || (t.programDateTime = null, t.rawProgramDateTime = null)
				}

				function H(t, e, r, i) {
					t.relurl = e.URI, e.BYTERANGE && t.setByteRange(e.BYTERANGE), t.level = r, t.sn = "initSegment", i && (t.levelkeys = i), t.initSegment = null
				}

				function j(t, e, r) {
					t.levelkeys = e;
					var i = r.encryptedFragments;
					i.length && i[i.length - 1].levelkeys === e || !Object.keys(e).some((function(t) {
						return e[t].isCommonEncryption
					})) || i.push(t)
				}
				var V = r(308);

				function Y(t, e) {
					var r = t.url;
					return void 0 !== r && 0 !== r.indexOf("data:") || (r = e.url), r
				}
				const W = function() {
					function t(t) {
						this.hls = void 0, this.loaders = Object.create(null), this.hls = t, this.registerListeners()
					}
					var e = t.prototype;
					return e.startLoad = function(t) {}, e.stopLoad = function() {
						this.destroyInternalLoaders()
					}, e.registerListeners = function() {
						var t = this.hls;
						t.on(s.Events.MANIFEST_LOADING, this.onManifestLoading, this), t.on(s.Events.LEVEL_LOADING, this.onLevelLoading, this), t.on(s.Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), t.on(s.Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this)
					}, e.unregisterListeners = function() {
						var t = this.hls;
						t.off(s.Events.MANIFEST_LOADING, this.onManifestLoading, this), t.off(s.Events.LEVEL_LOADING, this.onLevelLoading, this), t.off(s.Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), t.off(s.Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this)
					}, e.createInternalLoader = function(t) {
						var e = this.hls.config,
							r = e.pLoader,
							i = e.loader,
							n = new(r || i)(e);
						return t.loader = n, this.loaders[t.type] = n, n
					}, e.getInternalLoader = function(t) {
						return this.loaders[t.type]
					}, e.resetInternalLoader = function(t) {
						this.loaders[t] && delete this.loaders[t]
					}, e.destroyInternalLoaders = function() {
						for(var t in this.loaders) {
							var e = this.loaders[t];
							e && e.destroy(), this.resetInternalLoader(t)
						}
					}, e.destroy = function() {
						this.unregisterListeners(), this.destroyInternalLoaders()
					}, e.onManifestLoading = function(t, e) {
						var r = e.url;
						this.load({
							id: null,
							groupId: null,
							level: 0,
							responseType: "text",
							type: V.PlaylistContextType.MANIFEST,
							url: r,
							deliveryDirectives: null
						})
					}, e.onLevelLoading = function(t, e) {
						var r = e.id,
							i = e.level,
							n = e.url,
							a = e.deliveryDirectives;
						this.load({
							id: r,
							groupId: null,
							level: i,
							responseType: "text",
							type: V.PlaylistContextType.LEVEL,
							url: n,
							deliveryDirectives: a
						})
					}, e.onAudioTrackLoading = function(t, e) {
						var r = e.id,
							i = e.groupId,
							n = e.url,
							a = e.deliveryDirectives;
						this.load({
							id: r,
							groupId: i,
							level: null,
							responseType: "text",
							type: V.PlaylistContextType.AUDIO_TRACK,
							url: n,
							deliveryDirectives: a
						})
					}, e.onSubtitleTrackLoading = function(t, e) {
						var r = e.id,
							i = e.groupId,
							n = e.url,
							a = e.deliveryDirectives;
						this.load({
							id: r,
							groupId: i,
							level: null,
							responseType: "text",
							type: V.PlaylistContextType.SUBTITLE_TRACK,
							url: n,
							deliveryDirectives: a
						})
					}, e.load = function(t) {
						var e, r, i, n, a, s, o = this.hls.config,
							u = this.getInternalLoader(t);
						if(u) {
							var d = u.context;
							if(d && d.url === t.url) return void l.logger.trace("[playlist-loader]: playlist request ongoing");
							l.logger.log("[playlist-loader]: aborting previous loader for type: " + t.type), u.abort()
						}
						switch(t.type) {
							case V.PlaylistContextType.MANIFEST:
								r = o.manifestLoadingMaxRetry, i = o.manifestLoadingTimeOut, n = o.manifestLoadingRetryDelay, a = o.manifestLoadingMaxRetryTimeout;
								break;
							case V.PlaylistContextType.LEVEL:
							case V.PlaylistContextType.AUDIO_TRACK:
							case V.PlaylistContextType.SUBTITLE_TRACK:
								r = 0, i = o.levelLoadingTimeOut;
								break;
							default:
								r = o.levelLoadingMaxRetry, i = o.levelLoadingTimeOut, n = o.levelLoadingRetryDelay, a = o.levelLoadingMaxRetryTimeout
						}
						if(u = this.createInternalLoader(t), null !== (e = t.deliveryDirectives) && void 0 !== e && e.part && (t.type === V.PlaylistContextType.LEVEL && null !== t.level ? s = this.hls.levels[t.level].details : t.type === V.PlaylistContextType.AUDIO_TRACK && null !== t.id ? s = this.hls.audioTracks[t.id].details : t.type === V.PlaylistContextType.SUBTITLE_TRACK && null !== t.id && (s = this.hls.subtitleTracks[t.id].details), s)) {
							var h = s.partTarget,
								c = s.targetduration;
							h && c && (i = Math.min(1e3 * Math.max(3 * h, .8 * c), i))
						}
						var f = {
								timeout: i,
								maxRetry: r,
								retryDelay: n,
								maxRetryDelay: a,
								highWaterMark: 0
							},
							g = {
								onSuccess: this.loadsuccess.bind(this),
								onError: this.loaderror.bind(this),
								onTimeout: this.loadtimeout.bind(this)
							};
						u.load(t, f, g)
					}, e.loadsuccess = function(t, e, r, i) {
						void 0 === i && (i = null), this.resetInternalLoader(r.type);
						var n = t.data;
						0 === n.indexOf("#EXTM3U") ? (e.parsing.start = performance.now(), n.indexOf("#EXTINF:") > 0 || n.indexOf("#EXT-X-TARGETDURATION:") > 0 ? this.handleTrackOrLevelPlaylist(t, e, r, i) : this.handleMasterPlaylist(t, e, r, i)) : this.handleManifestParsingError(t, r, "no EXTM3U delimiter", i)
					}, e.loaderror = function(t, e, r) {
						void 0 === r && (r = null), this.handleNetworkError(e, r, !1, t)
					}, e.loadtimeout = function(t, e, r) {
						void 0 === r && (r = null), this.handleNetworkError(e, r, !0)
					}, e.handleMasterPlaylist = function(t, e, r, i) {
						var n = this.hls,
							a = t.data,
							o = Y(t, r),
							u = N.parseMasterPlaylist(a, o),
							d = u.levels,
							c = u.sessionData,
							f = u.sessionKeys;
						if(d.length) {
							var g = d.map((function(t) {
									return {
										id: t.attrs.AUDIO,
										audioCodec: t.audioCodec
									}
								})),
								v = d.map((function(t) {
									return {
										id: t.attrs.SUBTITLES,
										textCodec: t.textCodec
									}
								})),
								p = N.parseMasterPlaylistMedia(a, o, "AUDIO", g),
								m = N.parseMasterPlaylistMedia(a, o, "SUBTITLES", v),
								y = N.parseMasterPlaylistMedia(a, o, "CLOSED-CAPTIONS");
							p.length && (p.some((function(t) {
								return !t.url
							})) || !d[0].audioCodec || d[0].attrs.AUDIO || (l.logger.log("[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one"), p.unshift({
								type: "main",
								name: "main",
								default: !1,
								autoselect: !1,
								forced: !1,
								id: -1,
								attrs: new h({}),
								bitrate: 0,
								url: ""
							}))), n.trigger(s.Events.MANIFEST_LOADED, {
								levels: d,
								audioTracks: p,
								subtitles: m,
								captions: y,
								url: o,
								stats: e,
								networkDetails: i,
								sessionData: c,
								sessionKeys: f
							})
						} else this.handleManifestParsingError(t, r, "no level found in manifest", i)
					}, e.handleTrackOrLevelPlaylist = function(t, e, r, i) {
						var n = this.hls,
							l = r.id,
							u = r.level,
							d = r.type,
							c = Y(t, r),
							f = (0, a.isFiniteNumber)(l) ? l : 0,
							g = (0, a.isFiniteNumber)(u) ? u : f,
							v = function(t) {
								switch(t.type) {
									case V.PlaylistContextType.AUDIO_TRACK:
										return V.PlaylistLevelType.AUDIO;
									case V.PlaylistContextType.SUBTITLE_TRACK:
										return V.PlaylistLevelType.SUBTITLE;
									default:
										return V.PlaylistLevelType.MAIN
								}
							}(r),
							p = N.parseLevelPlaylist(t.data, c, g, v, f);
						if(p.fragments.length) {
							if(d === V.PlaylistContextType.MANIFEST) {
								var m = {
									attrs: new h({}),
									bitrate: 0,
									details: p,
									name: "",
									url: c
								};
								n.trigger(s.Events.MANIFEST_LOADED, {
									levels: [m],
									audioTracks: [],
									url: c,
									stats: e,
									networkDetails: i,
									sessionData: null,
									sessionKeys: null
								})
							}
							e.parsing.end = performance.now(), r.levelDetails = p, this.handlePlaylistLoaded(t, e, r, i)
						} else n.trigger(s.Events.ERROR, {
							type: o.ErrorTypes.NETWORK_ERROR,
							details: o.ErrorDetails.LEVEL_EMPTY_ERROR,
							fatal: !1,
							url: c,
							reason: "no fragments found in level",
							level: "number" == typeof r.level ? r.level : void 0
						})
					}, e.handleManifestParsingError = function(t, e, r, i) {
						this.hls.trigger(s.Events.ERROR, {
							type: o.ErrorTypes.NETWORK_ERROR,
							details: o.ErrorDetails.MANIFEST_PARSING_ERROR,
							fatal: e.type === V.PlaylistContextType.MANIFEST,
							url: t.url,
							reason: r,
							response: t,
							context: e,
							networkDetails: i
						})
					}, e.handleNetworkError = function(t, e, r, i) {
						void 0 === r && (r = !1), l.logger.warn("[playlist-loader]: A network " + (r ? "timeout" : "error") + " occurred while loading " + t.type + " level: " + t.level + " id: " + t.id + ' group-id: "' + t.groupId + '"');
						var n = o.ErrorDetails.UNKNOWN,
							a = !1,
							u = this.getInternalLoader(t);
						switch(t.type) {
							case V.PlaylistContextType.MANIFEST:
								n = r ? o.ErrorDetails.MANIFEST_LOAD_TIMEOUT : o.ErrorDetails.MANIFEST_LOAD_ERROR, a = !0;
								break;
							case V.PlaylistContextType.LEVEL:
								n = r ? o.ErrorDetails.LEVEL_LOAD_TIMEOUT : o.ErrorDetails.LEVEL_LOAD_ERROR, a = !1;
								break;
							case V.PlaylistContextType.AUDIO_TRACK:
								n = r ? o.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT : o.ErrorDetails.AUDIO_TRACK_LOAD_ERROR, a = !1;
								break;
							case V.PlaylistContextType.SUBTITLE_TRACK:
								n = r ? o.ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT : o.ErrorDetails.SUBTITLE_LOAD_ERROR, a = !1
						}
						u && this.resetInternalLoader(t.type);
						var d = {
							type: o.ErrorTypes.NETWORK_ERROR,
							details: n,
							fatal: a,
							url: t.url,
							loader: u,
							context: t,
							networkDetails: e
						};
						i && (d.response = i), this.hls.trigger(s.Events.ERROR, d)
					}, e.handlePlaylistLoaded = function(t, e, r, i) {
						var n = r.type,
							a = r.level,
							o = r.id,
							l = r.groupId,
							u = r.loader,
							d = r.levelDetails,
							h = r.deliveryDirectives;
						if(null != d && d.targetduration) {
							if(u) switch(d.live && (u.getCacheAge && (d.ageHeader = u.getCacheAge() || 0), u.getCacheAge && !isNaN(d.ageHeader) || (d.ageHeader = 0)), n) {
								case V.PlaylistContextType.MANIFEST:
								case V.PlaylistContextType.LEVEL:
									this.hls.trigger(s.Events.LEVEL_LOADED, {
										details: d,
										level: a || 0,
										id: o || 0,
										stats: e,
										networkDetails: i,
										deliveryDirectives: h
									});
									break;
								case V.PlaylistContextType.AUDIO_TRACK:
									this.hls.trigger(s.Events.AUDIO_TRACK_LOADED, {
										details: d,
										id: o || 0,
										groupId: l || "",
										stats: e,
										networkDetails: i,
										deliveryDirectives: h
									});
									break;
								case V.PlaylistContextType.SUBTITLE_TRACK:
									this.hls.trigger(s.Events.SUBTITLE_TRACK_LOADED, {
										details: d,
										id: o || 0,
										groupId: l || "",
										stats: e,
										networkDetails: i,
										deliveryDirectives: h
									})
							}
						} else this.handleManifestParsingError(t, r, "invalid target duration", i)
					}, t
				}();

				function q(t, e) {
					var r;
					try {
						r = new Event("addtrack")
					} catch(t) {
						(r = document.createEvent("Event")).initEvent("addtrack", !1, !1)
					}
					r.track = t, e.dispatchEvent(r)
				}

				function X(t, e) {
					var r = t.mode;
					if("disabled" === r && (t.mode = "hidden"), t.cues && !t.cues.getCueById(e.id)) try {
						if(t.addCue(e), !t.cues.getCueById(e.id)) throw new Error("addCue is failed for: " + e)
					} catch(r) {
						l.logger.debug("[texttrack-utils]: " + r);
						var i = new self.TextTrackCue(e.startTime, e.endTime, e.text);
						i.id = e.id, t.addCue(i)
					}
					"disabled" === r && (t.mode = r)
				}

				function z(t) {
					var e = t.mode;
					if("disabled" === e && (t.mode = "hidden"), t.cues)
						for(var r = t.cues.length; r--;) t.removeCue(t.cues[r]);
					"disabled" === e && (t.mode = e)
				}

				function Q(t, e, r, i) {
					var n = t.mode;
					if("disabled" === n && (t.mode = "hidden"), t.cues && t.cues.length > 0)
						for(var a = function(t, e, r) {
								var i = [],
									n = function(t, e) {
										if(e < t[0].startTime) return 0;
										var r = t.length - 1;
										if(e > t[r].endTime) return -1;
										for(var i = 0, n = r; i <= n;) {
											var a = Math.floor((n + i) / 2);
											if(e < t[a].startTime) n = a - 1;
											else {
												if(!(e > t[a].startTime && i < r)) return a;
												i = a + 1
											}
										}
										return t[i].startTime - e < e - t[n].startTime ? i : n
									}(t, e);
								if(n > -1)
									for(var a = n, s = t.length; a < s; a++) {
										var o = t[a];
										if(o.startTime >= e && o.endTime <= r) i.push(o);
										else if(o.startTime > r) return i
									}
								return i
							}(t.cues, e, r), s = 0; s < a.length; s++) i && !i(a[s]) || t.removeCue(a[s]);
					"disabled" === n && (t.mode = n)
				}
				var $ = r(181),
					J = r(856);

				function Z() {
					return self.WebKitDataCue || self.VTTCue || self.TextTrackCue
				}
				var tt = function() {
					var t = Z();
					try {
						new t(0, Number.POSITIVE_INFINITY, "")
					} catch(t) {
						return Number.MAX_VALUE
					}
					return Number.POSITIVE_INFINITY
				}();

				function et(t, e) {
					return t.getTime() / 1e3 - e
				}
				const rt = function() {
					function t(t) {
						this.hls = void 0, this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = t, this._registerListeners()
					}
					var e = t.prototype;
					return e.destroy = function() {
						this._unregisterListeners(), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = null
					}, e._registerListeners = function() {
						var t = this.hls;
						t.on(s.Events.MEDIA_ATTACHED, this.onMediaAttached, this), t.on(s.Events.MEDIA_DETACHING, this.onMediaDetaching, this), t.on(s.Events.MANIFEST_LOADING, this.onManifestLoading, this), t.on(s.Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), t.on(s.Events.BUFFER_FLUSHING, this.onBufferFlushing, this), t.on(s.Events.LEVEL_UPDATED, this.onLevelUpdated, this)
					}, e._unregisterListeners = function() {
						var t = this.hls;
						t.off(s.Events.MEDIA_ATTACHED, this.onMediaAttached, this), t.off(s.Events.MEDIA_DETACHING, this.onMediaDetaching, this), t.off(s.Events.MANIFEST_LOADING, this.onManifestLoading, this), t.off(s.Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), t.off(s.Events.BUFFER_FLUSHING, this.onBufferFlushing, this), t.off(s.Events.LEVEL_UPDATED, this.onLevelUpdated, this)
					}, e.onMediaAttached = function(t, e) {
						this.media = e.media
					}, e.onMediaDetaching = function() {
						this.id3Track && (z(this.id3Track), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {})
					}, e.onManifestLoading = function() {
						this.dateRangeCuesAppended = {}
					}, e.createTrack = function(t) {
						var e = this.getID3Track(t.textTracks);
						return e.mode = "hidden", e
					}, e.getID3Track = function(t) {
						if(this.media) {
							for(var e = 0; e < t.length; e++) {
								var r = t[e];
								if("metadata" === r.kind && "id3" === r.label) return q(r, this.media), r
							}
							return this.media.addTextTrack("metadata", "id3")
						}
					}, e.onFragParsingMetadata = function(t, e) {
						if(this.media) {
							var r = this.hls.config,
								i = r.enableEmsgMetadataCues,
								n = r.enableID3MetadataCues;
							if(i || n) {
								var a = e.samples;
								this.id3Track || (this.id3Track = this.createTrack(this.media));
								for(var s = Z(), o = 0; o < a.length; o++) {
									var l = a[o].type;
									if((l !== J.MetadataSchema.emsg || i) && n) {
										var u = $.getID3Frames(a[o].data);
										if(u) {
											var d = a[o].pts,
												h = d + a[o].duration;
											h > tt && (h = tt), h - d <= 0 && (h = d + .25);
											for(var c = 0; c < u.length; c++) {
												var f = u[c];
												if(!$.isTimeStampFrame(f)) {
													this.updateId3CueEnds(d);
													var g = new s(d, h, "");
													g.value = f, l && (g.type = l), this.id3Track.addCue(g)
												}
											}
										}
									}
								}
							}
						}
					}, e.updateId3CueEnds = function(t) {
						var e, r = null === (e = this.id3Track) || void 0 === e ? void 0 : e.cues;
						if(r)
							for(var i = r.length; i--;) {
								var n = r[i];
								n.startTime < t && n.endTime === tt && (n.endTime = t)
							}
					}, e.onBufferFlushing = function(t, e) {
						var r = e.startOffset,
							i = e.endOffset,
							n = e.type,
							a = this.id3Track,
							s = this.hls;
						if(s) {
							var o = s.config,
								l = o.enableEmsgMetadataCues,
								u = o.enableID3MetadataCues;
							a && (l || u) && Q(a, r, i, "audio" === n ? function(t) {
								return t.type === J.MetadataSchema.audioId3 && u
							} : "video" === n ? function(t) {
								return t.type === J.MetadataSchema.emsg && l
							} : function(t) {
								return t.type === J.MetadataSchema.audioId3 && u || t.type === J.MetadataSchema.emsg && l
							})
						}
					}, e.onLevelUpdated = function(t, e) {
						var r = this,
							n = e.details;
						if(this.media && n.hasProgramDateTime && this.hls.config.enableDateRangeMetadataCues) {
							var s = this.dateRangeCuesAppended,
								o = this.id3Track,
								l = n.dateRanges,
								u = Object.keys(l);
							if(o)
								for(var d = Object.keys(s).filter((function(t) {
										return !u.includes(t)
									})), h = function(t) {
										var e = d[t];
										Object.keys(s[e].cues).forEach((function(t) {
											o.removeCue(s[e].cues[t])
										})), delete s[e]
									}, c = d.length; c--;) h(c);
							var f = n.fragments[n.fragments.length - 1];
							if(0 !== u.length && (0, a.isFiniteNumber)(null == f ? void 0 : f.programDateTime)) {
								this.id3Track || (this.id3Track = this.createTrack(this.media));
								for(var g = f.programDateTime / 1e3 - f.start, v = Z(), p = function(t) {
										var e = u[t],
											n = l[e],
											a = s[e],
											o = (null == a ? void 0 : a.cues) || {},
											d = (null == a ? void 0 : a.durationKnown) || !1,
											h = et(n.startDate, g),
											c = tt,
											f = n.endDate;
										if(f) c = et(f, g), d = !0;
										else if(n.endOnNext && !d) {
											var p = u.reduce((function(t, e) {
												var r = l[e];
												return r.class === n.class && r.id !== e && r.startDate > n.startDate && t.push(r), t
											}), []).sort((function(t, e) {
												return t.startDate.getTime() - e.startDate.getTime()
											}))[0];
											p && (c = et(p.startDate, g), d = !0)
										}
										for(var m, y = Object.keys(n.attr), E = 0; E < y.length; E++) {
											var T = y[E];
											if(T !== i.ID && T !== i.CLASS && T !== i.START_DATE && T !== i.DURATION && T !== i.END_DATE && T !== i.END_ON_NEXT) {
												var S = o[T];
												if(S) d && !a.durationKnown && (S.endTime = c);
												else {
													var b = n.attr[T];
													S = new v(h, c, ""), T !== i.SCTE35_OUT && T !== i.SCTE35_IN || (m = b, b = Uint8Array.from(m.replace(/^0x/, "").replace(/([\da-fA-F]{2}) ?/g, "0x$1 ").replace(/ +$/, "").split(" ")).buffer), S.value = {
														key: T,
														data: b
													}, S.type = J.MetadataSchema.dateRange, r.id3Track.addCue(S), o[T] = S
												}
											}
										}
										s[e] = {
											cues: o,
											dateRange: n,
											durationKnown: d
										}
									}, m = 0; m < u.length; m++) p(m)
							}
						}
					}, t
				}();

				function it(t, e) {
					for(var r = 0; r < e.length; r++) {
						var i = e[r];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, (void 0, "symbol" == typeof(n = function(t, e) {
							if("object" != typeof t || null === t) return t;
							var r = t[Symbol.toPrimitive];
							if(void 0 !== r) {
								var i = r.call(t, e);
								if("object" != typeof i) return i;
								throw new TypeError("@@toPrimitive must return a primitive value.")
							}
							return String(t)
						}(i.key, "string")) ? n : String(n)), i)
					}
					var n
				}
				var nt = function() {
					function t(t) {
						var e = this;
						this.hls = void 0, this.config = void 0, this.media = null, this.levelDetails = null, this.currentTime = 0, this.stallCount = 0, this._latency = null, this.timeupdateHandler = function() {
							return e.timeupdate()
						}, this.hls = t, this.config = t.config, this.registerListeners()
					}
					var e, r, i = t.prototype;
					return i.destroy = function() {
						this.unregisterListeners(), this.onMediaDetaching(), this.levelDetails = null, this.hls = this.timeupdateHandler = null
					}, i.registerListeners = function() {
						this.hls.on(s.Events.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(s.Events.MEDIA_DETACHING, this.onMediaDetaching, this), this.hls.on(s.Events.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.on(s.Events.LEVEL_UPDATED, this.onLevelUpdated, this), this.hls.on(s.Events.ERROR, this.onError, this)
					}, i.unregisterListeners = function() {
						this.hls.off(s.Events.MEDIA_ATTACHED, this.onMediaAttached), this.hls.off(s.Events.MEDIA_DETACHING, this.onMediaDetaching), this.hls.off(s.Events.MANIFEST_LOADING, this.onManifestLoading), this.hls.off(s.Events.LEVEL_UPDATED, this.onLevelUpdated), this.hls.off(s.Events.ERROR, this.onError)
					}, i.onMediaAttached = function(t, e) {
						this.media = e.media, this.media.addEventListener("timeupdate", this.timeupdateHandler)
					}, i.onMediaDetaching = function() {
						this.media && (this.media.removeEventListener("timeupdate", this.timeupdateHandler), this.media = null)
					}, i.onManifestLoading = function() {
						this.levelDetails = null, this._latency = null, this.stallCount = 0
					}, i.onLevelUpdated = function(t, e) {
						var r = e.details;
						this.levelDetails = r, r.advanced && this.timeupdate(), !r.live && this.media && this.media.removeEventListener("timeupdate", this.timeupdateHandler)
					}, i.onError = function(t, e) {
						e.details === o.ErrorDetails.BUFFER_STALLED_ERROR && (this.stallCount++, l.logger.warn("[playback-rate-controller]: Stall detected, adjusting target latency"))
					}, i.timeupdate = function() {
						var t = this.media,
							e = this.levelDetails;
						if(t && e) {
							this.currentTime = t.currentTime;
							var r = this.computeLatency();
							if(null !== r) {
								this._latency = r;
								var i = this.config,
									n = i.lowLatencyMode,
									a = i.maxLiveSyncPlaybackRate;
								if(n && 1 !== a) {
									var s = this.targetLatency;
									if(null !== s) {
										var o = r - s,
											l = o < Math.min(this.maxLatency, s + e.targetduration);
										if(e.live && l && o > .05 && this.forwardBufferLength > 1) {
											var u = Math.min(2, Math.max(1, a)),
												d = Math.round(2 / (1 + Math.exp(-.75 * o - this.edgeStalled)) * 20) / 20;
											t.playbackRate = Math.min(u, Math.max(1, d))
										} else 1 !== t.playbackRate && 0 !== t.playbackRate && (t.playbackRate = 1)
									}
								}
							}
						}
					}, i.estimateLiveEdge = function() {
						var t = this.levelDetails;
						return null === t ? null : t.edge + t.age
					}, i.computeLatency = function() {
						var t = this.estimateLiveEdge();
						return null === t ? null : t - this.currentTime
					}, e = t, (r = [{
						key: "latency",
						get: function() {
							return this._latency || 0
						}
					}, {
						key: "maxLatency",
						get: function() {
							var t = this.config,
								e = this.levelDetails;
							return void 0 !== t.liveMaxLatencyDuration ? t.liveMaxLatencyDuration : e ? t.liveMaxLatencyDurationCount * e.targetduration : 0
						}
					}, {
						key: "targetLatency",
						get: function() {
							var t = this.levelDetails;
							if(null === t) return null;
							var e = t.holdBack,
								r = t.partHoldBack,
								i = t.targetduration,
								n = this.config,
								a = n.liveSyncDuration,
								s = n.liveSyncDurationCount,
								o = n.lowLatencyMode,
								l = this.hls.userConfig,
								u = o && r || e;
							(l.liveSyncDuration || l.liveSyncDurationCount || 0 === u) && (u = void 0 !== a ? a : s * i);
							var d = i;
							return u + Math.min(1 * this.stallCount, d)
						}
					}, {
						key: "liveSyncPosition",
						get: function() {
							var t = this.estimateLiveEdge(),
								e = this.targetLatency,
								r = this.levelDetails;
							if(null === t || null === e || null === r) return null;
							var i = r.edge,
								n = t - e - this.edgeStalled,
								a = i - r.totalduration,
								s = i - (this.config.lowLatencyMode && r.partTarget || r.targetduration);
							return Math.min(Math.max(a, n), s)
						}
					}, {
						key: "drift",
						get: function() {
							var t = this.levelDetails;
							return null === t ? 1 : t.drift
						}
					}, {
						key: "edgeStalled",
						get: function() {
							var t = this.levelDetails;
							if(null === t) return 0;
							var e = 3 * (this.config.lowLatencyMode && t.partTarget || t.targetduration);
							return Math.max(t.age - e, 0)
						}
					}, {
						key: "forwardBufferLength",
						get: function() {
							var t = this.media,
								e = this.levelDetails;
							if(!t || !e) return 0;
							var r = t.buffered.length;
							return(r ? t.buffered.end(r - 1) : e.edge) - this.currentTime
						}
					}]) && it(e.prototype, r), Object.defineProperty(e, "prototype", {
						writable: !1
					}), t
				}();

				function at(t, e) {
					for(var r = 0; r < e.length; r++) {
						var i = e[r];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, (void 0, "symbol" == typeof(n = function(t, e) {
							if("object" != typeof t || null === t) return t;
							var r = t[Symbol.toPrimitive];
							if(void 0 !== r) {
								var i = r.call(t, e);
								if("object" != typeof i) return i;
								throw new TypeError("@@toPrimitive must return a primitive value.")
							}
							return String(t)
						}(i.key, "string")) ? n : String(n)), i)
					}
					var n
				}
				var st, ot = ["NONE", "TYPE-0", "TYPE-1", "TYPE-2", null];
				! function(t) {
					t.No = "", t.Yes = "YES", t.v2 = "v2"
				}(st || (st = {}));
				var lt = function() {
						function t(t, e, r) {
							this.msn = void 0, this.part = void 0, this.skip = void 0, this.msn = t, this.part = e, this.skip = r
						}
						return t.prototype.addDirectives = function(t) {
							var e = new self.URL(t);
							return void 0 !== this.msn && e.searchParams.set("_HLS_msn", this.msn.toString()), void 0 !== this.part && e.searchParams.set("_HLS_part", this.part.toString()), this.skip && e.searchParams.set("_HLS_skip", this.skip), e.href
						}, t
					}(),
					ut = function() {
						function t(t) {
							this.attrs = void 0, this.audioCodec = void 0, this.bitrate = void 0, this.codecSet = void 0, this.height = void 0, this.id = void 0, this.name = void 0, this.videoCodec = void 0, this.width = void 0, this.unknownCodecs = void 0, this.audioGroupIds = void 0, this.details = void 0, this.fragmentError = 0, this.loadError = 0, this.loaded = void 0, this.realBitrate = 0, this.textGroupIds = void 0, this.url = void 0, this._urlId = 0, this.url = [t.url], this.attrs = t.attrs, this.bitrate = t.bitrate, t.details && (this.details = t.details), this.id = t.id || 0, this.name = t.name, this.width = t.width || 0, this.height = t.height || 0, this.audioCodec = t.audioCodec, this.videoCodec = t.videoCodec, this.unknownCodecs = t.unknownCodecs, this.codecSet = [t.videoCodec, t.audioCodec].filter((function(t) {
								return t
							})).join(",").replace(/\.[^.,]+/g, "")
						}
						var e, r;
						return e = t, (r = [{
							key: "maxBitrate",
							get: function() {
								return Math.max(this.realBitrate, this.bitrate)
							}
						}, {
							key: "uri",
							get: function() {
								return this.url[this._urlId] || ""
							}
						}, {
							key: "urlId",
							get: function() {
								return this._urlId
							},
							set: function(t) {
								var e = t % this.url.length;
								this._urlId !== e && (this.details = void 0, this._urlId = e)
							}
						}]) && at(e.prototype, r), Object.defineProperty(e, "prototype", {
							writable: !1
						}), t
					}();

				function dt() {
					return dt = Object.assign ? Object.assign.bind() : function(t) {
						for(var e = 1; e < arguments.length; e++) {
							var r = arguments[e];
							for(var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i])
						}
						return t
					}, dt.apply(this, arguments)
				}

				function ht(t, e, r) {
					switch(e) {
						case "audio":
							t.audioGroupIds || (t.audioGroupIds = []), t.audioGroupIds.push(r);
							break;
						case "text":
							t.textGroupIds || (t.textGroupIds = []), t.textGroupIds.push(r)
					}
				}

				function ct(t) {
					var e = {};
					t.forEach((function(t) {
						var r = t.groupId || "";
						t.id = e[r] = e[r] || 0, e[r]++
					}))
				}

				function ft(t, e) {
					var r = e.startPTS;
					if((0, a.isFiniteNumber)(r)) {
						var i, n = 0;
						e.sn > t.sn ? (n = r - t.start, i = t) : (n = t.start - r, i = e), i.duration !== n && (i.duration = n)
					} else e.sn > t.sn ? t.cc === e.cc && t.minEndPTS ? e.start = t.start + (t.minEndPTS - t.start) : e.start = t.start + t.duration : e.start = Math.max(t.start - e.duration, 0)
				}

				function gt(t, e, r, i, n, s) {
					i - r <= 0 && (l.logger.warn("Fragment should have a positive duration", e), i = r + e.duration, s = n + e.duration);
					var o = r,
						u = i,
						d = e.startPTS,
						h = e.endPTS;
					if((0, a.isFiniteNumber)(d)) {
						var c = Math.abs(d - r);
						(0, a.isFiniteNumber)(e.deltaPTS) ? e.deltaPTS = Math.max(c, e.deltaPTS): e.deltaPTS = c, o = Math.max(r, d), r = Math.min(r, d), n = Math.min(n, e.startDTS), u = Math.min(i, h), i = Math.max(i, h), s = Math.max(s, e.endDTS)
					}
					e.duration = i - r;
					var f = r - e.start;
					e.start = e.startPTS = r, e.maxStartPTS = o, e.startDTS = n, e.endPTS = i, e.minEndPTS = u, e.endDTS = s;
					var g, v = e.sn;
					if(!t || v < t.startSN || v > t.endSN) return 0;
					var p = v - t.startSN,
						m = t.fragments;
					for(m[p] = e, g = p; g > 0; g--) ft(m[g], m[g - 1]);
					for(g = p; g < m.length - 1; g++) ft(m[g], m[g + 1]);
					return t.fragmentHint && ft(m[m.length - 1], t.fragmentHint), t.PTSKnown = t.alignedSliding = !0, f
				}

				function vt(t, e) {
					var r = e.startSN + e.skippedSegments - t.startSN,
						i = t.fragments;
					r < 0 || r >= i.length || pt(e, i[r].start)
				}

				function pt(t, e) {
					if(e) {
						for(var r = t.fragments, i = t.skippedSegments; i < r.length; i++) r[i].start += e;
						t.fragmentHint && (t.fragmentHint.start += e)
					}
				}
				var mt = function() {
					function t(t, e) {
						this.hls = void 0, this.timer = -1, this.requestScheduled = -1, this.canLoad = !1, this.retryCount = 0, this.log = void 0, this.warn = void 0, this.log = l.logger.log.bind(l.logger, e + ":"), this.warn = l.logger.warn.bind(l.logger, e + ":"), this.hls = t
					}
					var e = t.prototype;
					return e.destroy = function() {
						this.clearTimer(), this.hls = this.log = this.warn = null
					}, e.onError = function(t, e) {
						!e.fatal || e.type !== o.ErrorTypes.NETWORK_ERROR && e.type !== o.ErrorTypes.KEY_SYSTEM_ERROR || this.stopLoad()
					}, e.clearTimer = function() {
						clearTimeout(this.timer), this.timer = -1
					}, e.startLoad = function() {
						this.canLoad = !0, this.retryCount = 0, this.requestScheduled = -1, this.loadPlaylist()
					}, e.stopLoad = function() {
						this.canLoad = !1, this.clearTimer()
					}, e.switchParams = function(t, e) {
						var r = null == e ? void 0 : e.renditionReports;
						if(r)
							for(var i = 0; i < r.length; i++) {
								var n = r[i],
									a = void 0;
								try {
									a = new self.URL(n.URI, e.url).href
								} catch(t) {
									l.logger.warn("Could not construct new URL for Rendition Report: " + t), a = n.URI || ""
								}
								if(a === t.slice(-a.length)) {
									var s = parseInt(n["LAST-MSN"]) || (null == e ? void 0 : e.lastPartSn),
										o = parseInt(n["LAST-PART"]) || (null == e ? void 0 : e.lastPartIndex);
									if(this.hls.config.lowLatencyMode) {
										var u = Math.min(e.age - e.partTarget, e.targetduration);
										o >= 0 && u > e.partTarget && (o += 1)
									}
									return new lt(s, o >= 0 ? o : void 0, st.No)
								}
							}
					}, e.loadPlaylist = function(t) {
						-1 === this.requestScheduled && (this.requestScheduled = self.performance.now())
					}, e.shouldLoadTrack = function(t) {
						return this.canLoad && t && !!t.url && (!t.details || t.details.live)
					}, e.playlistLoaded = function(t, e, r) {
						var i = this,
							n = e.details,
							s = e.stats,
							o = self.performance.now(),
							u = s.loading.first ? Math.max(0, o - s.loading.first) : 0;
						if(n.advancedDateTime = Date.now() - u, n.live || null != r && r.live) {
							if(n.reloaded(r), r && this.log("live playlist " + t + " " + (n.advanced ? "REFRESHED " + n.lastPartSn + "-" + n.lastPartIndex : "MISSED")), r && n.fragments.length > 0 && function(t, e) {
									for(var r = null, i = t.fragments, n = i.length - 1; n >= 0; n--) {
										var s = i[n].initSegment;
										if(s) {
											r = s;
											break
										}
									}
									t.fragmentHint && delete t.fragmentHint.endPTS;
									var o, u, d, h, c, f = 0;
									if(function(t, e, r) {
											for(var i = e.skippedSegments, n = Math.max(t.startSN, e.startSN) - e.startSN, a = (t.fragmentHint ? 1 : 0) + (i ? e.endSN : Math.min(t.endSN, e.endSN)) - e.startSN, s = e.startSN - t.startSN, o = e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments, l = t.fragmentHint ? t.fragments.concat(t.fragmentHint) : t.fragments, u = n; u <= a; u++) {
												var d = l[s + u],
													h = o[u];
												i && !h && u < i && (h = e.fragments[u] = d), d && h && r(d, h)
											}
										}(t, e, (function(t, i) {
											t.relurl && (f = t.cc - i.cc), (0, a.isFiniteNumber)(t.startPTS) && (0, a.isFiniteNumber)(t.endPTS) && (i.start = i.startPTS = t.startPTS, i.startDTS = t.startDTS, i.appendedPTS = t.appendedPTS, i.maxStartPTS = t.maxStartPTS, i.endPTS = t.endPTS, i.endDTS = t.endDTS, i.minEndPTS = t.minEndPTS, i.duration = t.endPTS - t.startPTS, i.duration && (o = i), e.PTSKnown = e.alignedSliding = !0), i.elementaryStreams = t.elementaryStreams, i.loader = t.loader, i.stats = t.stats, i.urlId = t.urlId, t.initSegment && (i.initSegment = t.initSegment, r = t.initSegment)
										})), r && (e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments).forEach((function(t) {
											var e;
											t.initSegment && t.initSegment.relurl !== (null === (e = r) || void 0 === e ? void 0 : e.relurl) || (t.initSegment = r)
										})), e.skippedSegments)
										if(e.deltaUpdateFailed = e.fragments.some((function(t) {
												return !t
											})), e.deltaUpdateFailed) {
											l.logger.warn("[level-helper] Previous playlist missing segments skipped in delta playlist");
											for(var v = e.skippedSegments; v--;) e.fragments.shift();
											e.startSN = e.fragments[0].sn, e.startCC = e.fragments[0].cc
										} else e.canSkipDateRanges && (e.dateRanges = (u = t.dateRanges, d = e.dateRanges, h = e.recentlyRemovedDateranges, c = dt({}, u), h && h.forEach((function(t) {
											delete c[t]
										})), Object.keys(d).forEach((function(t) {
											var e = new g(d[t].attr, c[t]);
											e.isValid ? c[t] = e : l.logger.warn('Ignoring invalid Playlist Delta Update DATERANGE tag: "' + JSON.stringify(d[t].attr) + '"')
										})), c));
									var p = e.fragments;
									if(f) {
										l.logger.warn("discontinuity sliding from playlist, take drift into account");
										for(var m = 0; m < p.length; m++) p[m].cc += f
									}
									e.skippedSegments && (e.startCC = e.fragments[0].cc),
										function(t, e, r) {
											if(t && e)
												for(var i = 0, n = 0, a = t.length; n <= a; n++) {
													var s = t[n],
														o = e[n + i];
													s && o && s.index === o.index && s.fragment.sn === o.fragment.sn ? (l = s, (u = o).elementaryStreams = l.elementaryStreams, u.stats = l.stats) : i--
												}
											var l, u
										}(t.partList, e.partList), o ? gt(e, o, o.startPTS, o.endPTS, o.startDTS, o.endDTS) : vt(t, e), p.length && (e.totalduration = e.edge - p[0].start), e.driftStartTime = t.driftStartTime, e.driftStart = t.driftStart;
									var y = e.advancedDateTime;
									if(e.advanced && y) {
										var E = e.edge;
										e.driftStart || (e.driftStartTime = y, e.driftStart = E), e.driftEndTime = y, e.driftEnd = E
									} else e.driftEndTime = t.driftEndTime, e.driftEnd = t.driftEnd, e.advancedDateTime = t.advancedDateTime
								}(r, n), !this.canLoad || !n.live) return;
							var d, h = void 0,
								c = void 0;
							if(n.canBlockReload && n.endSN && n.advanced) {
								var f = this.hls.config.lowLatencyMode,
									v = n.lastPartSn,
									p = n.endSN,
									m = n.lastPartIndex,
									y = v === p; - 1 !== m ? (h = y ? p + 1 : v, c = y ? f ? 0 : m : m + 1) : h = p + 1;
								var E = n.age,
									T = E + n.ageHeader,
									S = Math.min(T - n.partTarget, 1.5 * n.targetduration);
								if(S > 0) {
									if(r && S > r.tuneInGoal) this.warn("CDN Tune-in goal increased from: " + r.tuneInGoal + " to: " + S + " with playlist age: " + n.age), S = 0;
									else {
										var b = Math.floor(S / n.targetduration);
										h += b, void 0 !== c && (c += Math.round(S % n.targetduration / n.partTarget)), this.log("CDN Tune-in age: " + n.ageHeader + "s last advanced " + E.toFixed(2) + "s goal: " + S + " skip sn " + b + " to part " + c)
									}
									n.tuneInGoal = S
								}
								if(d = this.getDeliveryDirectives(n, e.deliveryDirectives, h, c), f || !y) return void this.loadPlaylist(d)
							} else d = this.getDeliveryDirectives(n, e.deliveryDirectives, h, c);
							var L = this.hls.mainForwardBufferInfo,
								A = L ? L.end - L.len : 0,
								D = function(t, e) {
									void 0 === e && (e = 1 / 0);
									var r = 1e3 * t.targetduration;
									if(t.updated) {
										var i = t.fragments;
										if(i.length && 4 * r > e) {
											var n = 1e3 * i[i.length - 1].duration;
											n < r && (r = n)
										}
									} else r /= 2;
									return Math.round(r)
								}(n, 1e3 * (n.edge - A));
							n.updated ? o > this.requestScheduled + D && (this.requestScheduled = s.loading.start) : this.requestScheduled = -1, void 0 !== h && n.canBlockReload ? this.requestScheduled = s.loading.first + D - (1e3 * n.partTarget || 1e3) : this.requestScheduled = (-1 === this.requestScheduled ? o : this.requestScheduled) + D;
							var k = this.requestScheduled - o;
							k = Math.max(0, k), this.log("reload live playlist " + t + " in " + Math.round(k) + " ms"), this.timer = self.setTimeout((function() {
								return i.loadPlaylist(d)
							}), k)
						} else this.clearTimer()
					}, e.getDeliveryDirectives = function(t, e, r, i) {
						var n = function(t, e) {
							var r = t.canSkipUntil,
								i = t.canSkipDateRanges,
								n = t.endSN;
							return r && (void 0 !== e ? e - n : 0) < r ? i ? st.v2 : st.Yes : st.No
						}(t, r);
						return null != e && e.skip && t.deltaUpdateFailed && (r = e.msn, i = e.part, n = st.No), new lt(r, i, n)
					}, e.retryLoadingOrFail = function(t) {
						var e, r = this,
							i = this.hls.config,
							n = this.retryCount < i.levelLoadingMaxRetry;
						if(n)
							if(this.requestScheduled = -1, this.retryCount++, t.details.indexOf("LoadTimeOut") > -1 && null !== (e = t.context) && void 0 !== e && e.deliveryDirectives) this.warn("retry playlist loading #" + this.retryCount + ' after "' + t.details + '"'), this.loadPlaylist();
							else {
								var a = Math.min(Math.pow(2, this.retryCount) * i.levelLoadingRetryDelay, i.levelLoadingMaxRetryTimeout);
								this.timer = self.setTimeout((function() {
									return r.loadPlaylist()
								}), a), this.warn("retry playlist loading #" + this.retryCount + " in " + a + ' ms after "' + t.details + '"')
							} else this.warn('cannot recover from error "' + t.details + '"'), this.clearTimer(), t.fatal = !0;
						return n
					}, t
				}();

				function yt() {
					return yt = Object.assign ? Object.assign.bind() : function(t) {
						for(var e = 1; e < arguments.length; e++) {
							var r = arguments[e];
							for(var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i])
						}
						return t
					}, yt.apply(this, arguments)
				}

				function Et(t, e) {
					for(var r = 0; r < e.length; r++) {
						var i = e[r];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, (void 0, "symbol" == typeof(n = function(t, e) {
							if("object" != typeof t || null === t) return t;
							var r = t[Symbol.toPrimitive];
							if(void 0 !== r) {
								var i = r.call(t, e);
								if("object" != typeof i) return i;
								throw new TypeError("@@toPrimitive must return a primitive value.")
							}
							return String(t)
						}(i.key, "string")) ? n : String(n)), i)
					}
					var n
				}

				function Tt(t, e) {
					return Tt = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
						return t.__proto__ = e, t
					}, Tt(t, e)
				}
				var St, bt = /chrome|firefox/.test(navigator.userAgent.toLowerCase()),
					Lt = function(t) {
						var e, r;

						function i(e) {
							var r;
							return(r = t.call(this, e, "[level-controller]") || this)._levels = [], r._firstLevel = -1, r._startLevel = void 0, r.currentLevelIndex = -1, r.manualLevelIndex = -1, r.onParsedComplete = void 0, r._registerListeners(), r
						}
						r = t, (e = i).prototype = Object.create(r.prototype), e.prototype.constructor = e, Tt(e, r);
						var n, a, l = i.prototype;
						return l._registerListeners = function() {
							var t = this.hls;
							t.on(s.Events.MANIFEST_LOADED, this.onManifestLoaded, this), t.on(s.Events.LEVEL_LOADED, this.onLevelLoaded, this), t.on(s.Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), t.on(s.Events.FRAG_LOADED, this.onFragLoaded, this), t.on(s.Events.ERROR, this.onError, this)
						}, l._unregisterListeners = function() {
							var t = this.hls;
							t.off(s.Events.MANIFEST_LOADED, this.onManifestLoaded, this), t.off(s.Events.LEVEL_LOADED, this.onLevelLoaded, this), t.off(s.Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), t.off(s.Events.FRAG_LOADED, this.onFragLoaded, this), t.off(s.Events.ERROR, this.onError, this)
						}, l.destroy = function() {
							this._unregisterListeners(), this.manualLevelIndex = -1, this._levels.length = 0, t.prototype.destroy.call(this)
						}, l.startLoad = function() {
							this._levels.forEach((function(t) {
								t.loadError = 0
							})), t.prototype.startLoad.call(this)
						}, l.onManifestLoaded = function(t, e) {
							var r, i, n = [],
								a = [],
								l = [],
								u = {},
								d = !1,
								h = !1,
								c = !1;
							if(e.levels.forEach((function(t) {
									var e = t.attrs;
									d = d || !(!t.width || !t.height), h = h || !!t.videoCodec, c = c || !!t.audioCodec, bt && t.audioCodec && -1 !== t.audioCodec.indexOf("mp4a.40.34") && (t.audioCodec = void 0);
									var r = t.bitrate + "-" + t.attrs.RESOLUTION + "-" + t.attrs.CODECS;
									(i = u[r]) ? i.url.push(t.url): (i = new ut(t), u[r] = i, n.push(i)), e && (e.AUDIO && ht(i, "audio", e.AUDIO), e.SUBTITLES && ht(i, "text", e.SUBTITLES))
								})), (d || h) && c && (n = n.filter((function(t) {
									var e = t.videoCodec,
										r = t.width,
										i = t.height;
									return !!e || !(!r || !i)
								}))), n = n.filter((function(t) {
									var e = t.audioCodec,
										r = t.videoCodec;
									return(!e || _(e, "audio")) && (!r || _(r, "video"))
								})), e.audioTracks && ct(a = e.audioTracks.filter((function(t) {
									return !t.audioCodec || _(t.audioCodec, "audio")
								}))), e.subtitles && ct(l = e.subtitles), n.length > 0) {
								r = n[0].bitrate, n.sort((function(t, e) {
									return t.attrs["HDCP-LEVEL"] !== e.attrs["HDCP-LEVEL"] ? (t.attrs["HDCP-LEVEL"] || "") > (e.attrs["HDCP-LEVEL"] || "") ? 1 : -1 : t.bitrate !== e.bitrate ? t.bitrate - e.bitrate : t.attrs.SCORE !== e.attrs.SCORE ? t.attrs.decimalFloatingPoint("SCORE") - e.attrs.decimalFloatingPoint("SCORE") : d && t.height !== e.height ? t.height - e.height : 0
								})), this._levels = n;
								for(var f = 0; f < n.length; f++)
									if(n[f].bitrate === r) {
										this._firstLevel = f, this.log("manifest loaded, " + n.length + " level(s) found, first bitrate: " + r);
										break
									}
								var g = c && !h,
									v = {
										levels: n,
										audioTracks: a,
										subtitleTracks: l,
										sessionData: e.sessionData,
										sessionKeys: e.sessionKeys,
										firstLevel: this._firstLevel,
										stats: e.stats,
										audio: c,
										video: h,
										altAudio: !g && a.some((function(t) {
											return !!t.url
										}))
									};
								this.hls.trigger(s.Events.MANIFEST_PARSED, v), (this.hls.config.autoStartLoad || this.hls.forceStartLoad) && this.hls.startLoad(this.hls.config.startPosition)
							} else this.hls.trigger(s.Events.ERROR, {
								type: o.ErrorTypes.MEDIA_ERROR,
								details: o.ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
								fatal: !0,
								url: e.url,
								reason: "no level with compatible codecs found in manifest"
							})
						}, l.onError = function(e, r) {
							var i, n;
							if(t.prototype.onError.call(this, e, r), !r.fatal) {
								var a = r.context,
									s = this._levels[this.currentLevelIndex];
								if(a && (a.type === V.PlaylistContextType.AUDIO_TRACK && s.audioGroupIds && a.groupId === s.audioGroupIds[s.urlId] || a.type === V.PlaylistContextType.SUBTITLE_TRACK && s.textGroupIds && a.groupId === s.textGroupIds[s.urlId])) this.redundantFailover(this.currentLevelIndex);
								else {
									var l, u = !1,
										d = !0;
									switch(r.details) {
										case o.ErrorDetails.FRAG_LOAD_ERROR:
										case o.ErrorDetails.FRAG_LOAD_TIMEOUT:
										case o.ErrorDetails.KEY_LOAD_ERROR:
										case o.ErrorDetails.KEY_LOAD_TIMEOUT:
											if(r.frag) {
												var h = r.frag.type === V.PlaylistLevelType.MAIN ? r.frag.level : this.currentLevelIndex,
													c = this._levels[h];
												c ? (c.fragmentError++, c.fragmentError > this.hls.config.fragLoadingMaxRetry && (l = h)) : l = h
											}
											break;
										case o.ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:
											var f = s.attrs["HDCP-LEVEL"];
											f && (this.hls.maxHdcpLevel = ot[ot.indexOf(f) - 1], this.warn('Restricting playback to HDCP-LEVEL of "' + this.hls.maxHdcpLevel + '" or lower'));
										case o.ErrorDetails.FRAG_PARSING_ERROR:
										case o.ErrorDetails.KEY_SYSTEM_NO_SESSION:
											l = (null === (i = r.frag) || void 0 === i ? void 0 : i.type) === V.PlaylistLevelType.MAIN ? r.frag.level : this.currentLevelIndex, r.levelRetry = !1;
											break;
										case o.ErrorDetails.LEVEL_LOAD_ERROR:
										case o.ErrorDetails.LEVEL_LOAD_TIMEOUT:
											a && (a.deliveryDirectives && (d = !1), l = a.level), u = !0;
											break;
										case o.ErrorDetails.REMUX_ALLOC_ERROR:
											l = null != (n = r.level) ? n : this.currentLevelIndex, u = !0
									}
									void 0 !== l && this.recoverLevel(r, l, u, d)
								}
							}
						}, l.recoverLevel = function(t, e, r, i) {
							var n = t.details,
								a = this._levels[e];
							if(a.loadError++, r) {
								if(!this.retryLoadingOrFail(t)) return void(this.currentLevelIndex = -1);
								t.levelRetry = !0
							}
							if(i) {
								var s = a.url.length;
								if(s > 1 && a.loadError < s) t.levelRetry = !0, this.redundantFailover(e);
								else if(-1 === this.manualLevelIndex) {
									for(var o = -1, l = this._levels, u = l.length; u--;) {
										var d = (u + this.currentLevelIndex) % l.length;
										if(d !== this.currentLevelIndex && 0 === l[d].loadError) {
											o = d;
											break
										}
									}
									o > -1 && this.currentLevelIndex !== o ? (this.warn(n + ": switch to " + o), t.levelRetry = !0, this.hls.nextAutoLevel = o) : !1 === t.levelRetry && (t.fatal = !0)
								}
							}
						}, l.redundantFailover = function(t) {
							var e = this._levels[t],
								r = e.url.length;
							if(r > 1) {
								var i = (e.urlId + 1) % r;
								this.warn("Switching to redundant URL-id " + i), this._levels.forEach((function(t) {
									t.urlId = i
								})), this.level = t
							}
						}, l.onFragLoaded = function(t, e) {
							var r = e.frag;
							if(void 0 !== r && r.type === V.PlaylistLevelType.MAIN) {
								var i = this._levels[r.level];
								void 0 !== i && (i.fragmentError = 0, i.loadError = 0)
							}
						}, l.onLevelLoaded = function(t, e) {
							var r, i, n = e.level,
								a = e.details,
								s = this._levels[n];
							if(!s) return this.warn("Invalid level index " + n), void(null !== (i = e.deliveryDirectives) && void 0 !== i && i.skip && (a.deltaUpdateFailed = !0));
							n === this.currentLevelIndex ? (0 === s.fragmentError && (s.loadError = 0, this.retryCount = 0), this.playlistLoaded(n, e, s.details)) : null !== (r = e.deliveryDirectives) && void 0 !== r && r.skip && (a.deltaUpdateFailed = !0)
						}, l.onAudioTrackSwitched = function(t, e) {
							var r = this.hls.levels[this.currentLevelIndex];
							if(r && r.audioGroupIds) {
								for(var i = -1, n = this.hls.audioTracks[e.id].groupId, a = 0; a < r.audioGroupIds.length; a++)
									if(r.audioGroupIds[a] === n) {
										i = a;
										break
									}
								i !== r.urlId && (r.urlId = i, this.startLoad())
							}
						}, l.loadPlaylist = function(e) {
							t.prototype.loadPlaylist.call(this);
							var r = this.currentLevelIndex,
								i = this._levels[r];
							if(this.canLoad && i && i.url.length > 0) {
								var n = i.urlId,
									a = i.url[n];
								if(e) try {
									a = e.addDirectives(a)
								} catch(t) {
									this.warn("Could not construct new URL with HLS Delivery Directives: " + t)
								}
								this.log("Attempt loading level index " + r + (void 0 !== (null == e ? void 0 : e.msn) ? " at sn " + e.msn + " part " + e.part : "") + " with URL-id " + n + " " + a), this.clearTimer(), this.hls.trigger(s.Events.LEVEL_LOADING, {
									url: a,
									level: r,
									id: n,
									deliveryDirectives: e || null
								})
							}
						}, l.removeLevel = function(t, e) {
							var r = function(t, r) {
									return r !== e
								},
								i = this._levels.filter((function(i, n) {
									return n !== t || i.url.length > 1 && void 0 !== e && (i.url = i.url.filter(r), i.audioGroupIds && (i.audioGroupIds = i.audioGroupIds.filter(r)), i.textGroupIds && (i.textGroupIds = i.textGroupIds.filter(r)), i.urlId = 0, !0)
								})).map((function(t, e) {
									var r = t.details;
									return null != r && r.fragments && r.fragments.forEach((function(t) {
										t.level = e
									})), t
								}));
							this._levels = i, this.hls.trigger(s.Events.LEVELS_UPDATED, {
								levels: i
							})
						}, n = i, (a = [{
							key: "levels",
							get: function() {
								return 0 === this._levels.length ? null : this._levels
							}
						}, {
							key: "level",
							get: function() {
								return this.currentLevelIndex
							},
							set: function(t) {
								var e, r = this._levels;
								if(0 !== r.length && (this.currentLevelIndex !== t || null === (e = r[t]) || void 0 === e || !e.details)) {
									if(t < 0 || t >= r.length) {
										var i = t < 0;
										if(this.hls.trigger(s.Events.ERROR, {
												type: o.ErrorTypes.OTHER_ERROR,
												details: o.ErrorDetails.LEVEL_SWITCH_ERROR,
												level: t,
												fatal: i,
												reason: "invalid level idx"
											}), i) return;
										t = Math.min(t, r.length - 1)
									}
									this.clearTimer();
									var n = this.currentLevelIndex,
										a = r[n],
										l = r[t];
									this.log("switching to level " + t + " from " + n), this.currentLevelIndex = t;
									var u = yt({}, l, {
										level: t,
										maxBitrate: l.maxBitrate,
										uri: l.uri,
										urlId: l.urlId
									});
									delete u._urlId, this.hls.trigger(s.Events.LEVEL_SWITCHING, u);
									var d = l.details;
									if(!d || d.live) {
										var h = this.switchParams(l.uri, null == a ? void 0 : a.details);
										this.loadPlaylist(h)
									}
								}
							}
						}, {
							key: "manualLevel",
							get: function() {
								return this.manualLevelIndex
							},
							set: function(t) {
								this.manualLevelIndex = t, void 0 === this._startLevel && (this._startLevel = t), -1 !== t && (this.level = t)
							}
						}, {
							key: "firstLevel",
							get: function() {
								return this._firstLevel
							},
							set: function(t) {
								this._firstLevel = t
							}
						}, {
							key: "startLevel",
							get: function() {
								if(void 0 === this._startLevel) {
									var t = this.hls.config.startLevel;
									return void 0 !== t ? t : this._firstLevel
								}
								return this._startLevel
							},
							set: function(t) {
								this._startLevel = t
							}
						}, {
							key: "nextLoadLevel",
							get: function() {
								return -1 !== this.manualLevelIndex ? this.manualLevelIndex : this.hls.nextAutoLevel
							},
							set: function(t) {
								this.level = t, -1 === this.manualLevelIndex && (this.hls.nextAutoLevel = t)
							}
						}]) && Et(n.prototype, a), Object.defineProperty(n, "prototype", {
							writable: !1
						}), i
					}(mt);
				! function(t) {
					t.NOT_LOADED = "NOT_LOADED", t.APPENDING = "APPENDING", t.PARTIAL = "PARTIAL", t.OK = "OK"
				}(St || (St = {}));
				var At = function() {
					function t(t) {
						this.activeFragment = null, this.activeParts = null, this.endListFragments = Object.create(null), this.fragments = Object.create(null), this.timeRanges = Object.create(null), this.bufferPadding = .2, this.hls = void 0, this.hls = t, this._registerListeners()
					}
					var e = t.prototype;
					return e._registerListeners = function() {
						var t = this.hls;
						t.on(s.Events.BUFFER_APPENDED, this.onBufferAppended, this), t.on(s.Events.FRAG_BUFFERED, this.onFragBuffered, this), t.on(s.Events.FRAG_LOADED, this.onFragLoaded, this)
					}, e._unregisterListeners = function() {
						var t = this.hls;
						t.off(s.Events.BUFFER_APPENDED, this.onBufferAppended, this), t.off(s.Events.FRAG_BUFFERED, this.onFragBuffered, this), t.off(s.Events.FRAG_LOADED, this.onFragLoaded, this)
					}, e.destroy = function() {
						this._unregisterListeners(), this.fragments = this.endListFragments = this.timeRanges = this.activeFragment = this.activeParts = null
					}, e.getAppendedFrag = function(t, e) {
						if(e === V.PlaylistLevelType.MAIN) {
							var r = this.activeFragment,
								i = this.activeParts;
							if(!r) return null;
							if(i)
								for(var n = i.length; n--;) {
									var a = i[n],
										s = a ? a.end : r.appendedPTS;
									if(a.start <= t && void 0 !== s && t <= s) return n > 9 && (this.activeParts = i.slice(n - 9)), a
								} else if(r.start <= t && void 0 !== r.appendedPTS && t <= r.appendedPTS) return r
						}
						return this.getBufferedFrag(t, e)
					}, e.getBufferedFrag = function(t, e) {
						for(var r = this.fragments, i = Object.keys(r), n = i.length; n--;) {
							var a = r[i[n]];
							if((null == a ? void 0 : a.body.type) === e && a.buffered) {
								var s = a.body;
								if(s.start <= t && t <= s.end) return s
							}
						}
						return null
					}, e.detectEvictedFragments = function(t, e, r) {
						var i = this;
						this.timeRanges && (this.timeRanges[t] = e), Object.keys(this.fragments).forEach((function(n) {
							var a = i.fragments[n];
							if(a)
								if(a.buffered || a.loaded) {
									var s = a.range[t];
									s && s.time.some((function(t) {
										var r = !i.isTimeBuffered(t.startPTS, t.endPTS, e);
										return r && i.removeFragment(a.body), r
									}))
								} else a.body.type === r && i.removeFragment(a.body)
						}))
					}, e.detectPartialFragments = function(t) {
						var e = this,
							r = this.timeRanges,
							i = t.frag,
							n = t.part;
						if(r && "initSegment" !== i.sn) {
							var a = kt(i),
								s = this.fragments[a];
							s && (Object.keys(r).forEach((function(t) {
								var a = i.elementaryStreams[t];
								if(a) {
									var o = r[t],
										l = null !== n || !0 === a.partial;
									s.range[t] = e.getBufferedTimes(i, n, l, o)
								}
							})), s.loaded = null, Object.keys(s.range).length ? (s.buffered = !0, s.body.endList && (this.endListFragments[s.body.type] = s)) : this.removeFragment(s.body))
						}
					}, e.fragBuffered = function(t) {
						var e = kt(t),
							r = this.fragments[e];
						r && (r.loaded = null, r.buffered = !0)
					}, e.getBufferedTimes = function(t, e, r, i) {
						for(var n = {
								time: [],
								partial: r
							}, a = e ? e.start : t.start, s = e ? e.end : t.end, o = t.minEndPTS || s, l = t.maxStartPTS || a, u = 0; u < i.length; u++) {
							var d = i.start(u) - this.bufferPadding,
								h = i.end(u) + this.bufferPadding;
							if(l >= d && o <= h) {
								n.time.push({
									startPTS: Math.max(a, i.start(u)),
									endPTS: Math.min(s, i.end(u))
								});
								break
							}
							if(a < h && s > d) n.partial = !0, n.time.push({
								startPTS: Math.max(a, i.start(u)),
								endPTS: Math.min(s, i.end(u))
							});
							else if(s <= d) break
						}
						return n
					}, e.getPartialFragment = function(t) {
						var e, r, i, n = null,
							a = 0,
							s = this.bufferPadding,
							o = this.fragments;
						return Object.keys(o).forEach((function(l) {
							var u = o[l];
							u && Dt(u) && (r = u.body.start - s, i = u.body.end + s, t >= r && t <= i && (e = Math.min(t - r, i - t), a <= e && (n = u.body, a = e)))
						})), n
					}, e.isEndListAppended = function(t) {
						var e = this.endListFragments[t];
						return void 0 !== e && (e.buffered || Dt(e))
					}, e.getState = function(t) {
						var e = kt(t),
							r = this.fragments[e];
						return r ? r.buffered ? Dt(r) ? St.PARTIAL : St.OK : St.APPENDING : St.NOT_LOADED
					}, e.isTimeBuffered = function(t, e, r) {
						for(var i, n, a = 0; a < r.length; a++) {
							if(i = r.start(a) - this.bufferPadding, n = r.end(a) + this.bufferPadding, t >= i && e <= n) return !0;
							if(e <= i) return !1
						}
						return !1
					}, e.onFragLoaded = function(t, e) {
						var r = e.frag,
							i = e.part;
						if("initSegment" !== r.sn && !r.bitrateTest && !i) {
							var n = kt(r);
							this.fragments[n] = {
								body: r,
								loaded: e,
								buffered: !1,
								range: Object.create(null)
							}
						}
					}, e.onBufferAppended = function(t, e) {
						var r = this,
							i = e.frag,
							n = e.part,
							a = e.timeRanges;
						if(i.type === V.PlaylistLevelType.MAIN)
							if(this.activeFragment !== i && (this.activeFragment = i, i.appendedPTS = void 0), n) {
								var s = this.activeParts;
								s || (this.activeParts = s = []), s.push(n)
							} else this.activeParts = null;
						this.timeRanges = a, Object.keys(a).forEach((function(t) {
							var e = a[t];
							if(r.detectEvictedFragments(t, e), !n && i.type === V.PlaylistLevelType.MAIN) {
								var s = i.elementaryStreams[t];
								if(!s) return;
								for(var o = 0; o < e.length; o++) {
									var l = e.end(o);
									l <= s.endPTS && l > s.startPTS ? i.appendedPTS = Math.max(l, i.appendedPTS || 0) : i.appendedPTS = s.endPTS
								}
							}
						}))
					}, e.onFragBuffered = function(t, e) {
						this.detectPartialFragments(e)
					}, e.hasFragment = function(t) {
						var e = kt(t);
						return !!this.fragments[e]
					}, e.removeFragmentsInRange = function(t, e, r) {
						var i = this;
						Object.keys(this.fragments).forEach((function(n) {
							var a = i.fragments[n];
							if(a && a.buffered) {
								var s = a.body;
								s.type === r && s.start < e && s.end > t && i.removeFragment(s)
							}
						}))
					}, e.removeFragment = function(t) {
						var e = kt(t);
						t.stats.loaded = 0, t.clearElementaryStreamInfo(), t.appendedPTS = void 0, delete this.fragments[e], t.endList && delete this.endListFragments[t.type]
					}, e.removeAllFragments = function() {
						this.fragments = Object.create(null), this.endListFragments = Object.create(null), this.activeFragment = null, this.activeParts = null
					}, t
				}();

				function Dt(t) {
					var e, r;
					return t.buffered && ((null === (e = t.range.video) || void 0 === e ? void 0 : e.partial) || (null === (r = t.range.audio) || void 0 === r ? void 0 : r.partial))
				}

				function kt(t) {
					return t.type + "_" + t.level + "_" + t.urlId + "_" + t.sn
				}

				function Rt(t) {
					var e = "function" == typeof Map ? new Map : void 0;
					return Rt = function(t) {
						if(null === t || (r = t, -1 === Function.toString.call(r).indexOf("[native code]"))) return t;
						var r;
						if("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
						if(void 0 !== e) {
							if(e.has(t)) return e.get(t);
							e.set(t, i)
						}

						function i() {
							return It(t, arguments, _t(this).constructor)
						}
						return i.prototype = Object.create(t.prototype, {
							constructor: {
								value: i,
								enumerable: !1,
								writable: !0,
								configurable: !0
							}
						}), Ct(i, t)
					}, Rt(t)
				}

				function It(t, e, r) {
					return It = wt() ? Reflect.construct.bind() : function(t, e, r) {
						var i = [null];
						i.push.apply(i, e);
						var n = new(Function.bind.apply(t, i));
						return r && Ct(n, r.prototype), n
					}, It.apply(null, arguments)
				}

				function wt() {
					if("undefined" == typeof Reflect || !Reflect.construct) return !1;
					if(Reflect.construct.sham) return !1;
					if("function" == typeof Proxy) return !0;
					try {
						return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
					} catch(t) {
						return !1
					}
				}

				function Ct(t, e) {
					return Ct = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
						return t.__proto__ = e, t
					}, Ct(t, e)
				}

				function _t(t) {
					return _t = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
						return t.__proto__ || Object.getPrototypeOf(t)
					}, _t(t)
				}
				var Ot = Math.pow(2, 17),
					Pt = function() {
						function t(t) {
							this.config = void 0, this.loader = null, this.partLoadTimeout = -1, this.config = t
						}
						var e = t.prototype;
						return e.destroy = function() {
							this.loader && (this.loader.destroy(), this.loader = null)
						}, e.abort = function() {
							this.loader && this.loader.abort()
						}, e.load = function(t, e) {
							var r = this,
								i = t.url;
							if(!i) return Promise.reject(new Ft({
								type: o.ErrorTypes.NETWORK_ERROR,
								details: o.ErrorDetails.FRAG_LOAD_ERROR,
								fatal: !1,
								frag: t,
								networkDetails: null
							}, "Fragment does not have a " + (i ? "part list" : "url")));
							this.abort();
							var n = this.config,
								a = n.fLoader,
								s = n.loader;
							return new Promise((function(i, l) {
								r.loader && r.loader.destroy();
								var u = r.loader = t.loader = a ? new a(n) : new s(n),
									d = xt(t),
									h = {
										timeout: n.fragLoadingTimeOut,
										maxRetry: 0,
										retryDelay: 0,
										maxRetryDelay: n.fragLoadingMaxRetryTimeout,
										highWaterMark: "initSegment" === t.sn ? 1 / 0 : Ot
									};
								t.stats = u.stats, u.load(d, h, {
									onSuccess: function(e, n, a, s) {
										r.resetLoader(t, u);
										var o = e.data;
										a.resetIV && t.decryptdata && (t.decryptdata.iv = new Uint8Array(o.slice(0, 16)), o = o.slice(16)), i({
											frag: t,
											part: null,
											payload: o,
											networkDetails: s
										})
									},
									onError: function(e, i, n) {
										r.resetLoader(t, u), l(new Ft({
											type: o.ErrorTypes.NETWORK_ERROR,
											details: o.ErrorDetails.FRAG_LOAD_ERROR,
											fatal: !1,
											frag: t,
											response: e,
											networkDetails: n
										}))
									},
									onAbort: function(e, i, n) {
										r.resetLoader(t, u), l(new Ft({
											type: o.ErrorTypes.NETWORK_ERROR,
											details: o.ErrorDetails.INTERNAL_ABORTED,
											fatal: !1,
											frag: t,
											networkDetails: n
										}))
									},
									onTimeout: function(e, i, n) {
										r.resetLoader(t, u), l(new Ft({
											type: o.ErrorTypes.NETWORK_ERROR,
											details: o.ErrorDetails.FRAG_LOAD_TIMEOUT,
											fatal: !1,
											frag: t,
											networkDetails: n
										}))
									},
									onProgress: function(r, i, n, a) {
										e && e({
											frag: t,
											part: null,
											payload: n,
											networkDetails: a
										})
									}
								})
							}))
						}, e.loadPart = function(t, e, r) {
							var i = this;
							this.abort();
							var n = this.config,
								a = n.fLoader,
								s = n.loader;
							return new Promise((function(l, u) {
								i.loader && i.loader.destroy();
								var d = i.loader = t.loader = a ? new a(n) : new s(n),
									h = xt(t, e),
									c = {
										timeout: n.fragLoadingTimeOut,
										maxRetry: 0,
										retryDelay: 0,
										maxRetryDelay: n.fragLoadingMaxRetryTimeout,
										highWaterMark: Ot
									};
								e.stats = d.stats, d.load(h, c, {
									onSuccess: function(n, a, s, o) {
										i.resetLoader(t, d), i.updateStatsFromPart(t, e);
										var u = {
											frag: t,
											part: e,
											payload: n.data,
											networkDetails: o
										};
										r(u), l(u)
									},
									onError: function(r, n, a) {
										i.resetLoader(t, d), u(new Ft({
											type: o.ErrorTypes.NETWORK_ERROR,
											details: o.ErrorDetails.FRAG_LOAD_ERROR,
											fatal: !1,
											frag: t,
											part: e,
											response: r,
											networkDetails: a
										}))
									},
									onAbort: function(r, n, a) {
										t.stats.aborted = e.stats.aborted, i.resetLoader(t, d), u(new Ft({
											type: o.ErrorTypes.NETWORK_ERROR,
											details: o.ErrorDetails.INTERNAL_ABORTED,
											fatal: !1,
											frag: t,
											part: e,
											networkDetails: a
										}))
									},
									onTimeout: function(r, n, a) {
										i.resetLoader(t, d), u(new Ft({
											type: o.ErrorTypes.NETWORK_ERROR,
											details: o.ErrorDetails.FRAG_LOAD_TIMEOUT,
											fatal: !1,
											frag: t,
											part: e,
											networkDetails: a
										}))
									}
								})
							}))
						}, e.updateStatsFromPart = function(t, e) {
							var r = t.stats,
								i = e.stats,
								n = i.total;
							if(r.loaded += i.loaded, n) {
								var a = Math.round(t.duration / e.duration),
									s = Math.min(Math.round(r.loaded / n), a),
									o = (a - s) * Math.round(r.loaded / s);
								r.total = r.loaded + o
							} else r.total = Math.max(r.loaded, r.total);
							var l = r.loading,
								u = i.loading;
							l.start ? l.first += u.first - u.start : (l.start = u.start, l.first = u.first), l.end = u.end
						}, e.resetLoader = function(t, e) {
							t.loader = null, this.loader === e && (self.clearTimeout(this.partLoadTimeout), this.loader = null), e.destroy()
						}, t
					}();

				function xt(t, e) {
					void 0 === e && (e = null);
					var r = e || t,
						i = {
							frag: t,
							part: e,
							responseType: "arraybuffer",
							url: r.url,
							headers: {},
							rangeStart: 0,
							rangeEnd: 0
						},
						n = r.byteRangeStartOffset,
						s = r.byteRangeEndOffset;
					if((0, a.isFiniteNumber)(n) && (0, a.isFiniteNumber)(s)) {
						var o, l = n,
							u = s;
						if("initSegment" === t.sn && "AES-128" === (null === (o = t.decryptdata) || void 0 === o ? void 0 : o.method)) {
							var d = s - n;
							d % 16 && (u = s + (16 - d % 16)), 0 !== n && (i.resetIV = !0, l = n - 16)
						}
						i.rangeStart = l, i.rangeEnd = u
					}
					return i
				}
				var Ft = function(t) {
						var e, r;

						function i(e) {
							for(var r, i = arguments.length, n = new Array(i > 1 ? i - 1 : 0), a = 1; a < i; a++) n[a - 1] = arguments[a];
							return(r = t.call.apply(t, [this].concat(n)) || this).data = void 0, r.data = e, r
						}
						return r = t, (e = i).prototype = Object.create(r.prototype), e.prototype.constructor = e, Ct(e, r), i
					}(Rt(Error)),
					Mt = function() {
						function t(t) {
							this.config = void 0, this.keyUriToKeyInfo = {}, this.emeController = null, this.config = t
						}
						var e = t.prototype;
						return e.abort = function() {
							for(var t in this.keyUriToKeyInfo) {
								var e = this.keyUriToKeyInfo[t].loader;
								e && e.abort()
							}
						}, e.detach = function() {
							for(var t in this.keyUriToKeyInfo) {
								var e = this.keyUriToKeyInfo[t];
								(e.mediaKeySessionContext || e.decryptdata.isCommonEncryption) && delete this.keyUriToKeyInfo[t]
							}
						}, e.destroy = function() {
							for(var t in this.detach(), this.keyUriToKeyInfo) {
								var e = this.keyUriToKeyInfo[t].loader;
								e && e.destroy()
							}
							this.keyUriToKeyInfo = {}
						}, e.createKeyLoadError = function(t, e, r, i) {
							return void 0 === e && (e = o.ErrorDetails.KEY_LOAD_ERROR), new Ft({
								type: o.ErrorTypes.NETWORK_ERROR,
								details: e,
								fatal: !1,
								frag: t,
								networkDetails: r
							})
						}, e.loadClear = function(t, e) {
							var r = this;
							if(this.emeController && this.config.emeEnabled)
								for(var i = t.sn, n = t.cc, a = function(t) {
										var a = e[t];
										if(n <= a.cc && ("initSegment" === i || i < a.sn)) return r.emeController.selectKeySystemFormat(a).then((function(t) {
											a.setKeyFormat(t)
										})), "break"
									}, s = 0; s < e.length && "break" !== a(s); s++);
						}, e.load = function(t) {
							var e = this;
							return !t.decryptdata && t.encrypted && this.emeController ? this.emeController.selectKeySystemFormat(t).then((function(r) {
								return e.loadInternal(t, r)
							})) : this.loadInternal(t)
						}, e.loadInternal = function(t, e) {
							var r, i;
							e && t.setKeyFormat(e);
							var n = t.decryptdata;
							if(!n) {
								var a = e ? "Expected frag.decryptdata to be defined after setting format " + e : "Missing decryption data on fragment in onKeyLoading";
								return Promise.reject(this.createKeyLoadError(t, o.ErrorDetails.KEY_LOAD_ERROR, null, a))
							}
							var s = n.uri;
							if(!s) return Promise.reject(this.createKeyLoadError(t, o.ErrorDetails.KEY_LOAD_ERROR, null, 'Invalid key URI: "' + s + '"'));
							var l, u = this.keyUriToKeyInfo[s];
							if(null !== (r = u) && void 0 !== r && r.decryptdata.key) return n.key = u.decryptdata.key, Promise.resolve({
								frag: t,
								keyInfo: u
							});
							if(null !== (i = u) && void 0 !== i && i.keyLoadPromise) switch(null === (l = u.mediaKeySessionContext) || void 0 === l ? void 0 : l.keyStatus) {
								case void 0:
								case "status-pending":
								case "usable":
								case "usable-in-future":
									return u.keyLoadPromise
							}
							switch(u = this.keyUriToKeyInfo[s] = {
								decryptdata: n,
								keyLoadPromise: null,
								loader: null,
								mediaKeySessionContext: null
							}, n.method) {
								case "ISO-23001-7":
								case "SAMPLE-AES":
								case "SAMPLE-AES-CENC":
								case "SAMPLE-AES-CTR":
									return "identity" === n.keyFormat ? this.loadKeyHTTP(u, t) : this.loadKeyEME(u, t);
								case "AES-128":
									return this.loadKeyHTTP(u, t);
								default:
									return Promise.reject(this.createKeyLoadError(t, o.ErrorDetails.KEY_LOAD_ERROR, null, 'Key supplied with unsupported METHOD: "' + n.method + '"'))
							}
						}, e.loadKeyEME = function(t, e) {
							var r = {
								frag: e,
								keyInfo: t
							};
							if(this.emeController && this.config.emeEnabled) {
								var i = this.emeController.loadKey(r);
								if(i) return(t.keyLoadPromise = i.then((function(e) {
									return t.mediaKeySessionContext = e, r
								}))).catch((function(e) {
									throw t.keyLoadPromise = null, e
								}))
							}
							return Promise.resolve(r)
						}, e.loadKeyHTTP = function(t, e) {
							var r = this,
								i = this.config,
								n = new(0, i.loader)(i);
							return e.keyLoader = t.loader = n, t.keyLoadPromise = new Promise((function(a, s) {
								var l = {
										keyInfo: t,
										frag: e,
										responseType: "arraybuffer",
										url: t.decryptdata.uri
									},
									u = {
										timeout: i.fragLoadingTimeOut,
										maxRetry: 0,
										retryDelay: i.fragLoadingRetryDelay,
										maxRetryDelay: i.fragLoadingMaxRetryTimeout,
										highWaterMark: 0
									},
									d = {
										onSuccess: function(t, e, i, n) {
											var l = i.frag,
												u = i.keyInfo,
												d = i.url;
											if(!l.decryptdata || u !== r.keyUriToKeyInfo[d]) return s(r.createKeyLoadError(l, o.ErrorDetails.KEY_LOAD_ERROR, n, "after key load, decryptdata unset or changed"));
											u.decryptdata.key = l.decryptdata.key = new Uint8Array(t.data), l.keyLoader = null, u.loader = null, a({
												frag: l,
												keyInfo: u
											})
										},
										onError: function(t, i, n) {
											r.resetLoader(i), s(r.createKeyLoadError(e, o.ErrorDetails.KEY_LOAD_ERROR, n))
										},
										onTimeout: function(t, i, n) {
											r.resetLoader(i), s(r.createKeyLoadError(e, o.ErrorDetails.KEY_LOAD_TIMEOUT, n))
										},
										onAbort: function(t, i, n) {
											r.resetLoader(i), s(r.createKeyLoadError(e, o.ErrorDetails.INTERNAL_ABORTED, n))
										}
									};
								n.load(l, u, d)
							}))
						}, e.resetLoader = function(t) {
							var e = t.frag,
								r = t.keyInfo,
								i = t.url,
								n = r.loader;
							e.keyLoader === n && (e.keyLoader = null, r.loader = null), delete this.keyUriToKeyInfo[i], n && n.destroy()
						}, t
					}(),
					Nt = function() {
						function t() {
							this._boundTick = void 0, this._tickTimer = null, this._tickInterval = null, this._tickCallCount = 0, this._boundTick = this.tick.bind(this)
						}
						var e = t.prototype;
						return e.destroy = function() {
							this.onHandlerDestroying(), this.onHandlerDestroyed()
						}, e.onHandlerDestroying = function() {
							this.clearNextTick(), this.clearInterval()
						}, e.onHandlerDestroyed = function() {}, e.hasInterval = function() {
							return !!this._tickInterval
						}, e.hasNextTick = function() {
							return !!this._tickTimer
						}, e.setInterval = function(t) {
							return !this._tickInterval && (this._tickInterval = self.setInterval(this._boundTick, t), !0)
						}, e.clearInterval = function() {
							return !!this._tickInterval && (self.clearInterval(this._tickInterval), this._tickInterval = null, !0)
						}, e.clearNextTick = function() {
							return !!this._tickTimer && (self.clearTimeout(this._tickTimer), this._tickTimer = null, !0)
						}, e.tick = function() {
							this._tickCallCount++, 1 === this._tickCallCount && (this.doTick(), this._tickCallCount > 1 && this.tickImmediate(), this._tickCallCount = 0)
						}, e.tickImmediate = function() {
							this.clearNextTick(), this._tickTimer = self.setTimeout(this._boundTick, 0)
						}, e.doTick = function() {}, t
					}(),
					Ut = {
						length: 0,
						start: function() {
							return 0
						},
						end: function() {
							return 0
						}
					},
					Bt = function() {
						function t() {}
						return t.isBuffered = function(e, r) {
							try {
								if(e)
									for(var i = t.getBuffered(e), n = 0; n < i.length; n++)
										if(r >= i.start(n) && r <= i.end(n)) return !0
							} catch(t) {}
							return !1
						}, t.bufferInfo = function(e, r, i) {
							try {
								if(e) {
									var n, a = t.getBuffered(e),
										s = [];
									for(n = 0; n < a.length; n++) s.push({
										start: a.start(n),
										end: a.end(n)
									});
									return this.bufferedInfo(s, r, i)
								}
							} catch(t) {}
							return {
								len: 0,
								start: r,
								end: r,
								nextStart: void 0
							}
						}, t.bufferedInfo = function(t, e, r) {
							e = Math.max(0, e), t.sort((function(t, e) {
								return t.start - e.start || e.end - t.end
							}));
							var i = [];
							if(r)
								for(var n = 0; n < t.length; n++) {
									var a = i.length;
									if(a) {
										var s = i[a - 1].end;
										t[n].start - s < r ? t[n].end > s && (i[a - 1].end = t[n].end) : i.push(t[n])
									} else i.push(t[n])
								} else i = t;
							for(var o, l = 0, u = e, d = e, h = 0; h < i.length; h++) {
								var c = i[h].start,
									f = i[h].end;
								if(e + r >= c && e < f) u = c, l = (d = f) - e;
								else if(e + r < c) {
									o = c;
									break
								}
							}
							return {
								len: l,
								start: u || 0,
								end: d || 0,
								nextStart: o
							}
						}, t.getBuffered = function(t) {
							try {
								return t.buffered
							} catch(t) {
								return l.logger.log("failed to get media.buffered", t), Ut
							}
						}, t
					}(),
					Gt = function(t, e, r, i, n, a) {
						void 0 === i && (i = 0), void 0 === n && (n = -1), void 0 === a && (a = !1), this.level = void 0, this.sn = void 0, this.part = void 0, this.id = void 0, this.size = void 0, this.partial = void 0, this.transmuxing = {
							start: 0,
							executeStart: 0,
							executeEnd: 0,
							end: 0
						}, this.buffering = {
							audio: {
								start: 0,
								executeStart: 0,
								executeEnd: 0,
								end: 0
							},
							video: {
								start: 0,
								executeStart: 0,
								executeEnd: 0,
								end: 0
							},
							audiovideo: {
								start: 0,
								executeStart: 0,
								executeEnd: 0,
								end: 0
							}
						}, this.level = t, this.sn = e, this.id = r, this.size = i, this.part = n, this.partial = a
					};

				function Kt(t, e) {
					for(var r = null, i = 0, n = t.length; i < n; i++) {
						var a = t[i];
						if(a && a.cc === e) {
							r = a;
							break
						}
					}
					return r
				}

				function Ht(t, e) {
					if(t) {
						var r = t.start + e;
						t.start = t.startPTS = r, t.endPTS = r + t.duration
					}
				}

				function jt(t, e) {
					for(var r = e.fragments, i = 0, n = r.length; i < n; i++) Ht(r[i], t);
					e.fragmentHint && Ht(e.fragmentHint, t), e.alignedSliding = !0
				}

				function Vt(t, e) {
					if(t.hasProgramDateTime && e.hasProgramDateTime) {
						var r = t.fragments,
							i = e.fragments;
						if(r.length && i.length) {
							var n = i[Math.round(i.length / 2) - 1],
								a = Kt(r, n.cc) || r[Math.round(r.length / 2) - 1],
								s = n.programDateTime,
								o = a.programDateTime;
							null !== s && null !== o && jt((o - s) / 1e3 - (a.start - n.start), t)
						}
					}
				}
				const Yt = function(t, e) {
					for(var r = 0, i = t.length - 1, n = null, a = null; r <= i;) {
						var s = e(a = t[n = (r + i) / 2 | 0]);
						if(s > 0) r = n + 1;
						else {
							if(!(s < 0)) return a;
							i = n - 1
						}
					}
					return null
				};

				function Wt(t, e, r, i) {
					void 0 === r && (r = 0), void 0 === i && (i = 0);
					var n = null;
					if(t ? n = e[t.sn - e[0].sn + 1] || null : 0 === r && 0 === e[0].start && (n = e[0]), n && 0 === qt(r, i, n)) return n;
					var a = Yt(e, qt.bind(null, r, i));
					return !a || a === t && n ? n : a
				}

				function qt(t, e, r) {
					if(void 0 === t && (t = 0), void 0 === e && (e = 0), r.start <= t && r.start + r.duration > t) return 0;
					var i = Math.min(e, r.duration + (r.deltaPTS ? r.deltaPTS : 0));
					return r.start + r.duration - i <= t ? 1 : r.start - i > t && r.start ? -1 : 0
				}

				function Xt(t, e, r) {
					var i = 1e3 * Math.min(e, r.duration + (r.deltaPTS ? r.deltaPTS : 0));
					return(r.endProgramDateTime || 0) - i > t
				}
				var zt = r(21);
				const Qt = function(t) {
					for(var e = "", r = t.length, i = 0; i < r; i++) e += "[" + t.start(i).toFixed(3) + "-" + t.end(i).toFixed(3) + "]";
					return e
				};

				function $t(t, e) {
					for(var r = 0; r < e.length; r++) {
						var i = e[r];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, (void 0, "symbol" == typeof(n = function(t, e) {
							if("object" != typeof t || null === t) return t;
							var r = t[Symbol.toPrimitive];
							if(void 0 !== r) {
								var i = r.call(t, e);
								if("object" != typeof i) return i;
								throw new TypeError("@@toPrimitive must return a primitive value.")
							}
							return String(t)
						}(i.key, "string")) ? n : String(n)), i)
					}
					var n
				}

				function Jt(t, e) {
					return Jt = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
						return t.__proto__ = e, t
					}, Jt(t, e)
				}
				var Zt = "STOPPED",
					te = "IDLE",
					ee = "KEY_LOADING",
					re = "FRAG_LOADING",
					ie = "FRAG_LOADING_WAITING_RETRY",
					ne = "WAITING_TRACK",
					ae = "PARSING",
					se = "PARSED",
					oe = "ENDED",
					le = "ERROR",
					ue = "WAITING_INIT_PTS",
					de = "WAITING_LEVEL",
					he = function(t) {
						var e, r;

						function i(e, r, i, n) {
							var a;
							return(a = t.call(this) || this).hls = void 0, a.fragPrevious = null, a.fragCurrent = null, a.fragmentTracker = void 0, a.transmuxer = null, a._state = Zt, a.media = null, a.mediaBuffer = null, a.config = void 0, a.bitrateTest = !1, a.lastCurrentTime = 0, a.nextLoadPosition = 0, a.startPosition = 0, a.loadedmetadata = !1, a.fragLoadError = 0, a.retryDate = 0, a.levels = null, a.fragmentLoader = void 0, a.keyLoader = void 0, a.levelLastLoaded = null, a.startFragRequested = !1, a.decrypter = void 0, a.initPTS = [], a.onvseeking = null, a.onvended = null, a.logPrefix = "", a.log = void 0, a.warn = void 0, a.logPrefix = n, a.log = l.logger.log.bind(l.logger, n + ":"), a.warn = l.logger.warn.bind(l.logger, n + ":"), a.hls = e, a.fragmentLoader = new Pt(e.config), a.keyLoader = i, a.fragmentTracker = r, a.config = e.config, a.decrypter = new zt.default(e.config), e.on(s.Events.LEVEL_SWITCHING, a.onLevelSwitching, function(t) {
								if(void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
								return t
							}(a)), a
						}
						r = t, (e = i).prototype = Object.create(r.prototype), e.prototype.constructor = e, Jt(e, r);
						var n, u, d = i.prototype;
						return d.doTick = function() {
							this.onTickEnd()
						}, d.onTickEnd = function() {}, d.startLoad = function(t) {}, d.stopLoad = function() {
							this.fragmentLoader.abort(), this.keyLoader.abort();
							var t = this.fragCurrent;
							t && (t.abortRequests(), this.fragmentTracker.removeFragment(t)), this.resetTransmuxer(), this.fragCurrent = null, this.fragPrevious = null, this.clearInterval(), this.clearNextTick(), this.state = Zt
						}, d._streamEnded = function(t, e) {
							if(e.live || t.nextStart || !t.end || !this.media) return !1;
							var r = e.partList;
							if(null != r && r.length) {
								var i = r[r.length - 1];
								return Bt.isBuffered(this.media, i.start + i.duration / 2)
							}
							var n = e.fragments[e.fragments.length - 1].type;
							return this.fragmentTracker.isEndListAppended(n)
						}, d.getLevelDetails = function() {
							var t;
							if(this.levels && null !== this.levelLastLoaded) return null === (t = this.levels[this.levelLastLoaded]) || void 0 === t ? void 0 : t.details
						}, d.onMediaAttached = function(t, e) {
							var r = this.media = this.mediaBuffer = e.media;
							this.onvseeking = this.onMediaSeeking.bind(this), this.onvended = this.onMediaEnded.bind(this), r.addEventListener("seeking", this.onvseeking), r.addEventListener("ended", this.onvended);
							var i = this.config;
							this.levels && i.autoStartLoad && this.state === Zt && this.startLoad(i.startPosition)
						}, d.onMediaDetaching = function() {
							var t = this.media;
							null != t && t.ended && (this.log("MSE detaching and video ended, reset startPosition"), this.startPosition = this.lastCurrentTime = 0), t && this.onvseeking && this.onvended && (t.removeEventListener("seeking", this.onvseeking), t.removeEventListener("ended", this.onvended), this.onvseeking = this.onvended = null), this.keyLoader && this.keyLoader.detach(), this.media = this.mediaBuffer = null, this.loadedmetadata = !1, this.fragmentTracker.removeAllFragments(), this.stopLoad()
						}, d.onMediaSeeking = function() {
							var t = this.config,
								e = this.fragCurrent,
								r = this.media,
								i = this.mediaBuffer,
								n = this.state,
								s = r ? r.currentTime : 0,
								o = Bt.bufferInfo(i || r, s, t.maxBufferHole);
							if(this.log("media seeking to " + ((0, a.isFiniteNumber)(s) ? s.toFixed(3) : s) + ", state: " + n), this.state === oe) this.resetLoadingState();
							else if(e) {
								var l = t.maxFragLookUpTolerance,
									u = e.start - l,
									d = e.start + e.duration + l;
								if(!o.len || d < o.start || u > o.end) {
									var h = s > d;
									(s < u || h) && (h && e.loader && (this.log("seeking outside of buffer while fragment load in progress, cancel fragment load"), e.abortRequests()), this.resetLoadingState())
								}
							}
							r && (this.lastCurrentTime = s), this.loadedmetadata || o.len || (this.nextLoadPosition = this.startPosition = s), this.tickImmediate()
						}, d.onMediaEnded = function() {
							this.startPosition = this.lastCurrentTime = 0
						}, d.onLevelSwitching = function(t, e) {
							this.fragLoadError = 0
						}, d.onHandlerDestroying = function() {
							this.stopLoad(), t.prototype.onHandlerDestroying.call(this)
						}, d.onHandlerDestroyed = function() {
							this.state = Zt, this.hls.off(s.Events.LEVEL_SWITCHING, this.onLevelSwitching, this), this.fragmentLoader && this.fragmentLoader.destroy(), this.keyLoader && this.keyLoader.destroy(), this.decrypter && this.decrypter.destroy(), this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null, t.prototype.onHandlerDestroyed.call(this)
						}, d.loadFragment = function(t, e, r) {
							this._loadFragForPlayback(t, e, r)
						}, d._loadFragForPlayback = function(t, e, r) {
							var i = this;
							this._doFragLoad(t, e, r, (function(e) {
								if(i.fragContextChanged(t)) return i.warn("Fragment " + t.sn + (e.part ? " p: " + e.part.index : "") + " of level " + t.level + " was dropped during download."), void i.fragmentTracker.removeFragment(t);
								t.stats.chunkCount++, i._handleFragmentLoadProgress(e)
							})).then((function(e) {
								if(e) {
									i.fragLoadError = 0;
									var r = i.state;
									i.fragContextChanged(t) ? (r === re || !i.fragCurrent && r === ae) && (i.fragmentTracker.removeFragment(t), i.state = te) : ("payload" in e && (i.log("Loaded fragment " + t.sn + " of level " + t.level), i.hls.trigger(s.Events.FRAG_LOADED, e)), i._handleFragmentLoadComplete(e))
								}
							})).catch((function(e) {
								i.state !== Zt && i.state !== le && (i.warn(e), i.resetFragmentLoading(t))
							}))
						}, d.flushMainBuffer = function(t, e, r) {
							if(void 0 === r && (r = null), t - e) {
								var i = {
									startOffset: t,
									endOffset: e,
									type: r
								};
								this.fragLoadError = 0, this.hls.trigger(s.Events.BUFFER_FLUSHING, i)
							}
						}, d._loadInitSegment = function(t, e) {
							var r = this;
							this._doFragLoad(t, e).then((function(e) {
								if(!e || r.fragContextChanged(t) || !r.levels) throw new Error("init load aborted");
								return e
							})).then((function(e) {
								var i = r.hls,
									n = e.payload,
									a = t.decryptdata;
								if(n && n.byteLength > 0 && a && a.key && a.iv && "AES-128" === a.method) {
									var o = self.performance.now();
									return r.decrypter.decrypt(new Uint8Array(n), a.key.buffer, a.iv.buffer).then((function(r) {
										var n = self.performance.now();
										return i.trigger(s.Events.FRAG_DECRYPTED, {
											frag: t,
											payload: r,
											stats: {
												tstart: o,
												tdecrypt: n
											}
										}), e.payload = r, e
									}))
								}
								return e
							})).then((function(e) {
								var i = r.fragCurrent,
									n = r.hls,
									a = r.levels;
								if(!a) throw new Error("init load aborted, missing levels");
								a[t.level].details;
								var o = t.stats;
								r.state = te, r.fragLoadError = 0, t.data = new Uint8Array(e.payload), o.parsing.start = o.buffering.start = self.performance.now(), o.parsing.end = o.buffering.end = self.performance.now(), e.frag === i && n.trigger(s.Events.FRAG_BUFFERED, {
									stats: o,
									frag: i,
									part: null,
									id: t.type
								}), r.tick()
							})).catch((function(e) {
								r.state !== Zt && r.state !== le && (r.warn(e), r.resetFragmentLoading(t))
							}))
						}, d.fragContextChanged = function(t) {
							var e = this.fragCurrent;
							return !t || !e || t.level !== e.level || t.sn !== e.sn || t.urlId !== e.urlId
						}, d.fragBufferedComplete = function(t, e) {
							var r, i, n = this.mediaBuffer ? this.mediaBuffer : this.media;
							this.log("Buffered " + t.type + " sn: " + t.sn + (e ? " part: " + e.index : "") + " of " + ("[stream-controller]" === this.logPrefix ? "level" : "track") + " " + t.level + " (frag:[" + (t.startPTS || NaN).toFixed(3) + "-" + (t.endPTS || NaN).toFixed(3) + "] > buffer:" + (n ? Qt(Bt.getBuffered(n)) : "(detached)") + ")"), this.state = te, n && (!this.loadedmetadata && t.type == V.PlaylistLevelType.MAIN && n.buffered.length && (null === (r = this.fragCurrent) || void 0 === r ? void 0 : r.sn) === (null === (i = this.fragPrevious) || void 0 === i ? void 0 : i.sn) && (this.loadedmetadata = !0, this.seekToStartPos()), this.tick())
						}, d.seekToStartPos = function() {}, d._handleFragmentLoadComplete = function(t) {
							var e = this.transmuxer;
							if(e) {
								var r = t.frag,
									i = t.part,
									n = t.partsLoaded,
									a = !n || 0 === n.length || n.some((function(t) {
										return !t
									})),
									s = new Gt(r.level, r.sn, r.stats.chunkCount + 1, 0, i ? i.index : -1, !a);
								e.flush(s)
							}
						}, d._handleFragmentLoadProgress = function(t) {}, d._doFragLoad = function(t, e, r, i) {
							var n, o = this;
							if(void 0 === r && (r = null), !this.levels) throw new Error("frag load aborted, missing levels");
							var l = null;
							if(!t.encrypted || null !== (n = t.decryptdata) && void 0 !== n && n.key ? !t.encrypted && e.encryptedFragments.length && this.keyLoader.loadClear(t, e.encryptedFragments) : (this.log("Loading key for " + t.sn + " of [" + e.startSN + "-" + e.endSN + "], " + ("[stream-controller]" === this.logPrefix ? "level" : "track") + " " + t.level), this.state = ee, this.fragCurrent = t, l = this.keyLoader.load(t).then((function(t) {
									if(!o.fragContextChanged(t.frag)) return o.hls.trigger(s.Events.KEY_LOADED, t), o.state === ee && (o.state = te), t
								})), this.hls.trigger(s.Events.KEY_LOADING, {
									frag: t
								}), this.throwIfFragContextChanged("KEY_LOADING")), r = Math.max(t.start, r || 0), this.config.lowLatencyMode && e) {
								var u = e.partList;
								if(u && i) {
									r > t.end && e.fragmentHint && (t = e.fragmentHint);
									var d = this.getNextPart(u, t, r);
									if(d > -1) {
										var h = u[d];
										return this.log("Loading part sn: " + t.sn + " p: " + h.index + " cc: " + t.cc + " of playlist [" + e.startSN + "-" + e.endSN + "] parts [0-" + d + "-" + (u.length - 1) + "] " + ("[stream-controller]" === this.logPrefix ? "level" : "track") + ": " + t.level + ", target: " + parseFloat(r.toFixed(3))), this.nextLoadPosition = h.start + h.duration, this.state = re, this.hls.trigger(s.Events.FRAG_LOADING, {
											frag: t,
											part: u[d],
											targetBufferTime: r
										}), this.throwIfFragContextChanged("FRAG_LOADING parts"), l ? l.then((function(e) {
											return !e || o.fragContextChanged(e.frag) ? null : o.doFragPartsLoad(t, u, d, i)
										})).catch((function(t) {
											return o.handleFragLoadError(t)
										})) : this.doFragPartsLoad(t, u, d, i).catch((function(t) {
											return o.handleFragLoadError(t)
										}))
									}
									if(!t.url || this.loadedEndOfParts(u, r)) return Promise.resolve(null)
								}
							}
							this.log("Loading fragment " + t.sn + " cc: " + t.cc + " " + (e ? "of [" + e.startSN + "-" + e.endSN + "] " : "") + ("[stream-controller]" === this.logPrefix ? "level" : "track") + ": " + t.level + ", target: " + parseFloat(r.toFixed(3))), (0, a.isFiniteNumber)(t.sn) && !this.bitrateTest && (this.nextLoadPosition = t.start + t.duration), this.state = re, this.hls.trigger(s.Events.FRAG_LOADING, {
								frag: t,
								targetBufferTime: r
							}), this.throwIfFragContextChanged("FRAG_LOADING");
							var c = this.config.progressive;
							return c && l ? l.then((function(e) {
								return !e || o.fragContextChanged(null == e ? void 0 : e.frag) ? null : o.fragmentLoader.load(t, i)
							})).catch((function(t) {
								return o.handleFragLoadError(t)
							})) : Promise.all([this.fragmentLoader.load(t, c ? i : void 0), l]).then((function(t) {
								var e = t[0];
								return !c && e && i && i(e), e
							})).catch((function(t) {
								return o.handleFragLoadError(t)
							}))
						}, d.throwIfFragContextChanged = function(t) {
							if(null === this.fragCurrent) throw new Error("frag load aborted, context changed in " + t)
						}, d.doFragPartsLoad = function(t, e, r, i) {
							var n = this;
							return new Promise((function(a, o) {
								var l = [];
								! function r(u) {
									var d = e[u];
									n.fragmentLoader.loadPart(t, d, i).then((function(i) {
										l[d.index] = i;
										var o = i.part;
										n.hls.trigger(s.Events.FRAG_LOADED, i);
										var h = e[u + 1];
										if(!h || h.fragment !== t) return a({
											frag: t,
											part: o,
											partsLoaded: l
										});
										r(u + 1)
									})).catch(o)
								}(r)
							}))
						}, d.handleFragLoadError = function(t) {
							if("data" in t) {
								var e = t.data;
								t.data && e.details === o.ErrorDetails.INTERNAL_ABORTED ? this.handleFragLoadAborted(e.frag, e.part) : this.hls.trigger(s.Events.ERROR, e)
							} else this.hls.trigger(s.Events.ERROR, {
								type: o.ErrorTypes.OTHER_ERROR,
								details: o.ErrorDetails.INTERNAL_EXCEPTION,
								err: t,
								fatal: !0
							});
							return null
						}, d._handleTransmuxerFlush = function(t) {
							var e = this.getCurrentContext(t);
							if(e && this.state === ae) {
								var r = e.frag,
									i = e.part,
									n = e.level,
									a = self.performance.now();
								r.stats.parsing.end = a, i && (i.stats.parsing.end = a), this.updateLevelTiming(r, i, n, t.partial)
							} else this.fragCurrent || this.state === Zt || this.state === le || (this.state = te)
						}, d.getCurrentContext = function(t) {
							var e = this.levels,
								r = t.level,
								i = t.sn,
								n = t.part;
							if(!e || !e[r]) return this.warn("Levels object was unset while buffering fragment " + i + " of level " + r + ". The current chunk will not be buffered."), null;
							var a = e[r],
								s = n > -1 ? function(t, e, r) {
									if(!t || !t.details) return null;
									var i = t.details.partList;
									if(i)
										for(var n = i.length; n--;) {
											var a = i[n];
											if(a.index === r && a.fragment.sn === e) return a
										}
									return null
								}(a, i, n) : null,
								o = s ? s.fragment : function(t, e, r) {
									if(!t || !t.details) return null;
									var i = t.details,
										n = i.fragments[e - i.startSN];
									return n || ((n = i.fragmentHint) && n.sn === e ? n : e < i.startSN && r && r.sn === e ? r : null)
								}(a, i, this.fragCurrent);
							return o ? {
								frag: o,
								part: s,
								level: a
							} : null
						}, d.bufferFragmentData = function(t, e, r, i) {
							if(t && this.state === ae) {
								var n = t.data1,
									a = t.data2,
									o = n;
								if(n && a && (o = (0, R.appendUint8Array)(n, a)), o && o.length) {
									var l = {
										type: t.type,
										frag: e,
										part: r,
										chunkMeta: i,
										parent: e.type,
										data: o
									};
									this.hls.trigger(s.Events.BUFFER_APPENDING, l), t.dropped && t.independent && !r && this.flushBufferGap(e)
								}
							}
						}, d.flushBufferGap = function(t) {
							var e = this.media;
							if(e)
								if(Bt.isBuffered(e, e.currentTime)) {
									var r = e.currentTime,
										i = Bt.bufferInfo(e, r, 0),
										n = t.duration,
										a = Math.min(2 * this.config.maxFragLookUpTolerance, .25 * n),
										s = Math.max(Math.min(t.start - a, i.end - a), r + a);
									t.start - s > a && this.flushMainBuffer(s, t.start)
								} else this.flushMainBuffer(0, t.start)
						}, d.getFwdBufferInfo = function(t, e) {
							var r = this.config,
								i = this.getLoadPosition();
							if(!(0, a.isFiniteNumber)(i)) return null;
							var n = Bt.bufferInfo(t, i, r.maxBufferHole);
							if(0 === n.len && void 0 !== n.nextStart) {
								var s = this.fragmentTracker.getBufferedFrag(i, e);
								if(s && n.nextStart < s.end) return Bt.bufferInfo(t, i, Math.max(n.nextStart, r.maxBufferHole))
							}
							return n
						}, d.getMaxBufferLength = function(t) {
							var e, r = this.config;
							return e = t ? Math.max(8 * r.maxBufferSize / t, r.maxBufferLength) : r.maxBufferLength, Math.min(e, r.maxMaxBufferLength)
						}, d.reduceMaxBufferLength = function(t) {
							var e = this.config,
								r = t || e.maxBufferLength;
							return e.maxMaxBufferLength >= r && (e.maxMaxBufferLength /= 2, this.warn("Reduce max buffer length to " + e.maxMaxBufferLength + "s"), !0)
						}, d.getNextFragment = function(t, e) {
							var r = e.fragments,
								i = r.length;
							if(!i) return null;
							var n, a = this.config,
								s = r[0].start;
							if(e.live) {
								var o = a.initialLiveManifestSize;
								if(i < o) return this.warn("Not enough fragments to start playback (have: " + i + ", need: " + o + ")"), null;
								e.PTSKnown || this.startFragRequested || -1 !== this.startPosition || (n = this.getInitialLiveFragment(e, r), this.startPosition = n ? this.hls.liveSyncPosition || n.start : t)
							} else t <= s && (n = r[0]);
							if(!n) {
								var l = a.lowLatencyMode ? e.partEnd : e.fragmentEnd;
								n = this.getFragmentAtPosition(t, l, e)
							}
							return this.mapToInitFragWhenRequired(n)
						}, d.mapToInitFragWhenRequired = function(t) {
							return null == t || !t.initSegment || null != t && t.initSegment.data || this.bitrateTest ? t : t.initSegment
						}, d.getNextPart = function(t, e, r) {
							for(var i = -1, n = !1, a = !0, s = 0, o = t.length; s < o; s++) {
								var l = t[s];
								if(a = a && !l.independent, i > -1 && r < l.start) break;
								var u = l.loaded;
								u ? i = -1 : (n || l.independent || a) && l.fragment === e && (i = s), n = u
							}
							return i
						}, d.loadedEndOfParts = function(t, e) {
							var r = t[t.length - 1];
							return r && e > r.start && r.loaded
						}, d.getInitialLiveFragment = function(t, e) {
							var r = this.fragPrevious,
								i = null;
							if(r) {
								if(t.hasProgramDateTime && (this.log("Live playlist, switching playlist, load frag with same PDT: " + r.programDateTime), i = function(t, e, r) {
										if(null === e || !Array.isArray(t) || !t.length || !(0, a.isFiniteNumber)(e)) return null;
										if(e < (t[0].programDateTime || 0)) return null;
										if(e >= (t[t.length - 1].endProgramDateTime || 0)) return null;
										r = r || 0;
										for(var i = 0; i < t.length; ++i) {
											var n = t[i];
											if(Xt(e, r, n)) return n
										}
										return null
									}(e, r.endProgramDateTime, this.config.maxFragLookUpTolerance)), !i) {
									var n = r.sn + 1;
									if(n >= t.startSN && n <= t.endSN) {
										var s = e[n - t.startSN];
										r.cc === s.cc && (i = s, this.log("Live playlist, switching playlist, load frag with next SN: " + i.sn))
									}
									i || (i = function(t, e) {
										return Yt(t, (function(t) {
											return t.cc < e ? 1 : t.cc > e ? -1 : 0
										}))
									}(e, r.cc), i && this.log("Live playlist, switching playlist, load frag with same CC: " + i.sn))
								}
							} else {
								var o = this.hls.liveSyncPosition;
								null !== o && (i = this.getFragmentAtPosition(o, this.bitrateTest ? t.fragmentEnd : t.edge, t))
							}
							return i
						}, d.getFragmentAtPosition = function(t, e, r) {
							var i, n = this.config,
								a = this.fragPrevious,
								s = r.fragments,
								o = r.endSN,
								l = r.fragmentHint,
								u = n.maxFragLookUpTolerance,
								d = !!(n.lowLatencyMode && r.partList && l);
							if(d && l && !this.bitrateTest && (s = s.concat(l), o = l.sn), i = t < e ? Wt(a, s, t, t > e - u ? 0 : u) : s[s.length - 1]) {
								var h = i.sn - r.startSN;
								if(this.fragmentTracker.getState(i) === St.OK && (a = i), a && i.sn === a.sn && !d && a && i.level === a.level) {
									var c = s[h + 1];
									i.sn < o && this.fragmentTracker.getState(c) !== St.OK ? (this.log("SN " + i.sn + " just loaded, load next one: " + c.sn), i = c) : i = null
								}
							}
							return i
						}, d.synchronizeToLiveEdge = function(t) {
							var e = this.config,
								r = this.media;
							if(r) {
								var i = this.hls.liveSyncPosition,
									n = r.currentTime,
									a = t.fragments[0].start,
									s = t.edge,
									o = n >= a - e.maxFragLookUpTolerance && n <= s;
								if(null !== i && r.duration > i && (n < i || !o)) {
									var l = void 0 !== e.liveMaxLatencyDuration ? e.liveMaxLatencyDuration : e.liveMaxLatencyDurationCount * t.targetduration;
									(!o && r.readyState < 4 || n < s - l) && (this.loadedmetadata || (this.nextLoadPosition = i), r.readyState && (this.warn("Playback: " + n.toFixed(3) + " is located too far from the end of live sliding playlist: " + s + ", reset currentTime to : " + i.toFixed(3)), r.currentTime = i))
								}
							}
						}, d.alignPlaylists = function(t, e) {
							var r = this.levels,
								i = this.levelLastLoaded,
								n = this.fragPrevious,
								s = null !== i ? r[i] : null,
								o = t.fragments.length;
							if(!o) return this.warn("No fragments in live playlist"), 0;
							var u = t.fragments[0].start,
								d = !e,
								h = t.alignedSliding && (0, a.isFiniteNumber)(u);
							if(d || !h && !u) {
								! function(t, e, r) {
									e && (function(t, e, r) {
										if(function(t, e, r) {
												return !(!e.details || !(r.endCC > r.startCC || t && t.cc < r.startCC))
											}(t, r, e)) {
											var i = function(t, e, r) {
												void 0 === r && (r = 0);
												var i = t.fragments,
													n = e.fragments;
												if(n.length && i.length) {
													var a = Kt(i, n[0].cc);
													if(a && (!a || a.startPTS)) return a;
													l.logger.log("No frag in previous level to align on")
												} else l.logger.log("No fragments to align")
											}(r.details, e);
											i && (0, a.isFiniteNumber)(i.start) && (l.logger.log("Adjusting PTS using last level due to CC increase within current level " + e.url), jt(i.start, e))
										}
									}(t, r, e), !r.alignedSliding && e.details && function(t, e) {
										if(e.fragments.length && t.hasProgramDateTime && e.hasProgramDateTime) {
											var r = e.fragments[0].programDateTime,
												i = t.fragments[0].programDateTime,
												n = (i - r) / 1e3 + e.fragments[0].start;
											n && (0, a.isFiniteNumber)(n) && (l.logger.log("Adjusting PTS using programDateTime delta " + (i - r) + "ms, sliding:" + n.toFixed(3) + " " + t.url + " "), jt(n, t))
										}
									}(r, e.details), r.alignedSliding || !e.details || r.skippedSegments || vt(e.details, r))
								}(n, s, t);
								var c = t.fragments[0].start;
								return this.log("Live playlist sliding: " + c.toFixed(2) + " start-sn: " + (e ? e.startSN : "na") + "->" + t.startSN + " prev-sn: " + (n ? n.sn : "na") + " fragments: " + o), c
							}
							return u
						}, d.waitForCdnTuneIn = function(t) {
							return t.live && t.canBlockReload && t.partTarget && t.tuneInGoal > Math.max(t.partHoldBack, 3 * t.partTarget)
						}, d.setStartPosition = function(t, e) {
							var r = this.startPosition;
							if(r < e && (r = -1), -1 === r || -1 === this.lastCurrentTime) {
								var i = t.startTimeOffset;
								(0, a.isFiniteNumber)(i) ? (r = e + i, i < 0 && (r += t.totalduration), r = Math.min(Math.max(e, r), e + t.totalduration), this.log("Start time offset " + i + " found in playlist, adjust startPosition to " + r), this.startPosition = r) : t.live ? r = this.hls.liveSyncPosition || e : this.startPosition = r = 0, this.lastCurrentTime = r
							}
							this.nextLoadPosition = r
						}, d.getLoadPosition = function() {
							var t = this.media,
								e = 0;
							return this.loadedmetadata && t ? e = t.currentTime : this.nextLoadPosition && (e = this.nextLoadPosition), e
						}, d.handleFragLoadAborted = function(t, e) {
							this.transmuxer && "initSegment" !== t.sn && t.stats.aborted && (this.warn("Fragment " + t.sn + (e ? " part" + e.index : "") + " of level " + t.level + " was aborted"), this.resetFragmentLoading(t))
						}, d.resetFragmentLoading = function(t) {
							this.fragCurrent && (this.fragContextChanged(t) || this.state === ie) || (this.state = te)
						}, d.onFragmentOrKeyLoadError = function(t, e) {
							if(e.fatal) return this.stopLoad(), void(this.state = le);
							var r = this.config;
							if(e.chunkMeta) {
								var i = this.getCurrentContext(e.chunkMeta);
								i && (e.frag = i.frag, e.levelRetry = !0, this.fragLoadError = r.fragLoadingMaxRetry)
							}
							var n = e.frag;
							if(n && n.type === t)
								if(this.fragCurrent, this.fragLoadError + 1 <= r.fragLoadingMaxRetry) {
									this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition);
									var a = Math.min(Math.pow(2, this.fragLoadError) * r.fragLoadingRetryDelay, r.fragLoadingMaxRetryTimeout);
									this.warn("Fragment " + n.sn + " of " + t + " " + n.level + " failed to load, retrying in " + a + "ms"), this.retryDate = self.performance.now() + a, this.fragLoadError++, this.state = ie
								} else e.levelRetry ? (t === V.PlaylistLevelType.AUDIO && (this.fragCurrent = null), this.fragLoadError = 0, this.state = te) : (l.logger.error(e.details + " reaches max retry, redispatch as fatal ..."), e.fatal = !0, this.hls.stopLoad(), this.state = le)
						}, d.afterBufferFlushed = function(t, e, r) {
							if(t) {
								var i = Bt.getBuffered(t);
								this.fragmentTracker.detectEvictedFragments(e, i, r), this.state === oe && this.resetLoadingState()
							}
						}, d.resetLoadingState = function() {
							this.log("Reset loading state"), this.fragCurrent = null, this.fragPrevious = null, this.state = te
						}, d.resetStartWhenNotLoaded = function(t) {
							if(!this.loadedmetadata) {
								this.startFragRequested = !1;
								var e = this.levels ? this.levels[t].details : null;
								null != e && e.live ? (this.startPosition = -1, this.setStartPosition(e, 0), this.resetLoadingState()) : this.nextLoadPosition = this.startPosition
							}
						}, d.updateLevelTiming = function(t, e, r, i) {
							var n = this,
								a = r.details;
							Object.keys(t.elementaryStreams).reduce((function(e, o) {
								var l = t.elementaryStreams[o];
								if(l) {
									var u = l.endPTS - l.startPTS;
									if(u <= 0) return n.warn("Could not parse fragment " + t.sn + " " + o + " duration reliably (" + u + ")"), e || !1;
									var d = i ? 0 : gt(a, t, l.startPTS, l.endPTS, l.startDTS, l.endDTS);
									return n.hls.trigger(s.Events.LEVEL_PTS_UPDATED, {
										details: a,
										level: r,
										drift: d,
										type: o,
										frag: t,
										start: l.startPTS,
										end: l.endPTS
									}), !0
								}
								return e
							}), !1) || (this.warn("Found no media in fragment " + t.sn + " of level " + r.id + " resetting transmuxer to fallback to playlist timing"), this.resetTransmuxer()), this.state = se, this.hls.trigger(s.Events.FRAG_PARSED, {
								frag: t,
								part: e
							})
						}, d.resetTransmuxer = function() {
							this.transmuxer && (this.transmuxer.destroy(), this.transmuxer = null)
						}, n = i, (u = [{
							key: "state",
							get: function() {
								return this._state
							},
							set: function(t) {
								var e = this._state;
								e !== t && (this._state = t, this.log(e + "->" + t))
							}
						}]) && $t(n.prototype, u), Object.defineProperty(n, "prototype", {
							writable: !1
						}), i
					}(Nt);

				function ce() {
					return self.MediaSource || self.WebKitMediaSource
				}

				function fe() {
					return self.SourceBuffer || self.WebKitSourceBuffer
				}
				var ge = function() {
						var t = ENTRY_MODULE,
							e = {},
							r = function r(i) {
								var n = e[i];
								if(void 0 !== n) return n.exports;
								var a = e[i] = {
									exports: {}
								};
								return t[i].call(a.exports, a, a.exports, r), a.exports
							};
						r.m = t, r.n = function(t) {
							var e = t && t.__esModule ? function() {
								return t.default
							} : function() {
								return t
							};
							return r.d(e, {
								a: e
							}), e
						}, r.d = function(t, e) {
							for(var i in e) r.o(e, i) && !r.o(t, i) && Object.defineProperty(t, i, {
								enumerable: !0,
								get: e[i]
							})
						}, r.o = function(t, e) {
							return Object.prototype.hasOwnProperty.call(t, e)
						}, r.r = function(t) {
							"undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
								value: "Module"
							}), Object.defineProperty(t, "__esModule", {
								value: !0
							})
						};
						var i = r(ENTRY_MODULE);
						return i.default || i
					}.toString().split("ENTRY_MODULE"),
					ve = "\\(\\s*(/\\*.*?\\*/)?\\s*.*?([\\.|\\-|\\+|\\w|/|@]+).*?\\)";

				function pe(t) {
					return(t + "").replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&")
				}

				function me(t, e, i) {
					var n = {};
					n[i] = [];
					var a = e.toString().replace(/^"[^"]+"/, "function"),
						s = a.match(/^function\s?\w*\(\w+,\s*\w+,\s*(\w+)\)/) || a.match(/^\(\w+,\s*\w+,\s*(\w+)\)\s?\=\s?\>/);
					if(!s) return n;
					for(var o, l = s[1], u = new RegExp("(\\\\n|\\W)" + pe(l) + ve, "g"); o = u.exec(a);) "dll-reference" !== o[3] && n[i].push(o[3]);
					for(u = new RegExp("\\(" + pe(l) + '\\("(dll-reference\\s([\\.|\\-|\\+|\\w|/|@]+))"\\)\\)' + ve, "g"); o = u.exec(a);) t[o[2]] || (n[i].push(o[1]), t[o[2]] = r(o[1]).m), n[o[2]] = n[o[2]] || [], n[o[2]].push(o[4]);
					for(var d, h = Object.keys(n), c = 0; c < h.length; c++)
						for(var f = 0; f < n[h[c]].length; f++) d = n[h[c]][f], isNaN(1 * d) || (n[h[c]][f] = 1 * n[h[c]][f]);
					return n
				}

				function ye(t) {
					return Object.keys(t).reduce((function(e, r) {
						return e || t[r].length > 0
					}), !1)
				}

				function Ee(t, e, r, i) {
					var n = t[i].map((function(t) {
						return '"' + t + '": ' + e[i][t].toString().replace(/^"[^"]+"/, "function")
					})).join(",");
					return ge[0] + "{" + n + "}" + ge[1] + '"' + r + '"' + ge[2]
				}
				var Te = r(544),
					Se = r(729),
					be = r.n(Se),
					Le = ce() || {
						isTypeSupported: function() {
							return !1
						}
					},
					Ae = function() {
						function t(t, e, i, n) {
							var a = this;
							this.hls = void 0, this.id = void 0, this.observer = void 0, this.frag = null, this.part = null, this.useWorker = void 0, this.worker = void 0, this.onwmsg = void 0, this.transmuxer = null, this.onTransmuxComplete = void 0, this.onFlush = void 0;
							var u = t.config;
							this.hls = t, this.id = e, this.useWorker = !!u.enableWorker, this.onTransmuxComplete = i, this.onFlush = n;
							var d = function(t, e) {
								(e = e || {}).frag = a.frag, e.id = a.id, a.hls.trigger(t, e)
							};
							this.observer = new Se.EventEmitter, this.observer.on(s.Events.FRAG_DECRYPTED, d), this.observer.on(s.Events.ERROR, d);
							var h = {
									mp4: Le.isTypeSupported("video/mp4"),
									mpeg: Le.isTypeSupported("audio/mpeg"),
									mp3: Le.isTypeSupported('audio/mp4; codecs="mp3"')
								},
								c = navigator.vendor;
							if(this.useWorker && "undefined" != typeof Worker) {
								var f;
								l.logger.log("demuxing in webworker");
								try {
									f = this.worker = function(t, e) {
										e = e || {};
										var i = {
												main: r.m
											},
											n = e.all ? {
												main: Object.keys(i.main)
											} : function(t, e) {
												for(var r = {
														main: [e]
													}, i = {
														main: []
													}, n = {
														main: {}
													}; ye(r);)
													for(var a = Object.keys(r), s = 0; s < a.length; s++) {
														var o = a[s],
															l = r[o].pop();
														if(n[o] = n[o] || {}, !n[o][l] && t[o][l]) {
															n[o][l] = !0, i[o] = i[o] || [], i[o].push(l);
															for(var u = me(t, t[o][l], o), d = Object.keys(u), h = 0; h < d.length; h++) r[d[h]] = r[d[h]] || [], r[d[h]] = r[d[h]].concat(u[d[h]])
														}
													}
												return i
											}(i, t),
											a = "";
										Object.keys(n).filter((function(t) {
											return "main" !== t
										})).forEach((function(t) {
											for(var e = 0; n[t][e];) e++;
											n[t].push(e), i[t][e] = "(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })", a = a + "var " + t + " = (" + Ee(n, i, e, modules) + ")();\n"
										})), a = a + "new ((" + Ee(n, i, t, "main") + ")())(self);";
										var s = new window.Blob([a], {
												type: "text/javascript"
											}),
											o = (window.URL || window.webkitURL || window.mozURL || window.msURL).createObjectURL(s),
											l = new window.Worker(o);
										return l.objectURL = o, l
									}(182), this.onwmsg = this.onWorkerMessage.bind(this), f.addEventListener("message", this.onwmsg), f.onerror = function(t) {
										a.useWorker = !1, l.logger.warn("Exception in webworker, fallback to inline"), a.hls.trigger(s.Events.ERROR, {
											type: o.ErrorTypes.OTHER_ERROR,
											details: o.ErrorDetails.INTERNAL_EXCEPTION,
											fatal: !1,
											event: "demuxerWorker",
											error: new Error(t.message + "  (" + t.filename + ":" + t.lineno + ")")
										})
									}, f.postMessage({
										cmd: "init",
										typeSupported: h,
										vendor: c,
										id: e,
										config: JSON.stringify(u)
									})
								} catch(t) {
									l.logger.warn("Error in worker:", t), l.logger.error("Error while initializing DemuxerWorker, fallback to inline"), f && self.URL.revokeObjectURL(f.objectURL), this.transmuxer = new Te.default(this.observer, h, u, c, e), this.worker = null
								}
							} else this.transmuxer = new Te.default(this.observer, h, u, c, e)
						}
						var e = t.prototype;
						return e.destroy = function() {
							var t = this.worker;
							if(t) t.removeEventListener("message", this.onwmsg), t.terminate(), this.worker = null, this.onwmsg = void 0;
							else {
								var e = this.transmuxer;
								e && (e.destroy(), this.transmuxer = null)
							}
							var r = this.observer;
							r && r.removeAllListeners(), this.frag = null, this.observer = null, this.hls = null
						}, e.push = function(t, e, r, i, n, a, s, o, u, d) {
							var h, c, f = this;
							u.transmuxing.start = self.performance.now();
							var g = this.transmuxer,
								v = this.worker,
								p = a ? a.start : n.start,
								m = n.decryptdata,
								y = this.frag,
								E = !(y && n.cc === y.cc),
								T = !(y && u.level === y.level),
								S = y ? u.sn - y.sn : -1,
								b = this.part ? u.part - this.part.index : -1,
								L = 0 === S && u.id > 1 && u.id === (null == y ? void 0 : y.stats.chunkCount),
								A = !T && (1 === S || 0 === S && (1 === b || L && b <= 0)),
								D = self.performance.now();
							(T || S || 0 === n.stats.parsing.start) && (n.stats.parsing.start = D), !a || !b && A || (a.stats.parsing.start = D);
							var k = !(y && (null === (h = n.initSegment) || void 0 === h ? void 0 : h.url) === (null === (c = y.initSegment) || void 0 === c ? void 0 : c.url)),
								R = new Te.TransmuxState(E, A, o, T, p, k);
							if(!A || E || k) {
								l.logger.log("[transmuxer-interface, " + n.type + "]: Starting new transmux session for sn: " + u.sn + " p: " + u.part + " level: " + u.level + " id: " + u.id + "\n        discontinuity: " + E + "\n        trackSwitch: " + T + "\n        contiguous: " + A + "\n        accurateTimeOffset: " + o + "\n        timeOffset: " + p + "\n        initSegmentChange: " + k);
								var I = new Te.TransmuxConfig(r, i, e, s, d);
								this.configureTransmuxer(I)
							}
							if(this.frag = n, this.part = a, v) v.postMessage({
								cmd: "demux",
								data: t,
								decryptdata: m,
								chunkMeta: u,
								state: R
							}, t instanceof ArrayBuffer ? [t] : []);
							else if(g) {
								var w = g.push(t, m, u, R);
								(0, Te.isPromise)(w) ? (g.async = !0, w.then((function(t) {
									f.handleTransmuxComplete(t)
								})).catch((function(t) {
									f.transmuxerError(t, u, "transmuxer-interface push error")
								}))) : (g.async = !1, this.handleTransmuxComplete(w))
							}
						}, e.flush = function(t) {
							var e = this;
							t.transmuxing.start = self.performance.now();
							var r = this.transmuxer,
								i = this.worker;
							if(i) i.postMessage({
								cmd: "flush",
								chunkMeta: t
							});
							else if(r) {
								var n = r.flush(t);
								(0, Te.isPromise)(n) || r.async ? ((0, Te.isPromise)(n) || (n = Promise.resolve(n)), n.then((function(r) {
									e.handleFlushResult(r, t)
								})).catch((function(r) {
									e.transmuxerError(r, t, "transmuxer-interface flush error")
								}))) : this.handleFlushResult(n, t)
							}
						}, e.transmuxerError = function(t, e, r) {
							this.hls && this.hls.trigger(s.Events.ERROR, {
								type: o.ErrorTypes.MEDIA_ERROR,
								details: o.ErrorDetails.FRAG_PARSING_ERROR,
								chunkMeta: e,
								fatal: !1,
								error: t,
								err: t,
								reason: r
							})
						}, e.handleFlushResult = function(t, e) {
							var r = this;
							t.forEach((function(t) {
								r.handleTransmuxComplete(t)
							})), this.onFlush(e)
						}, e.onWorkerMessage = function(t) {
							var e = t.data,
								r = this.hls;
							switch(e.event) {
								case "init":
                                    console.log(this.worker.objectURL)
									self.URL.revokeObjectURL(this.worker.objectURL);
									break;
								case "transmuxComplete":
									this.handleTransmuxComplete(e.data);
									break;
								case "flush":
									this.onFlush(e.data);
									break;
								case "workerLog":
									l.logger[e.data.logType] && l.logger[e.data.logType](e.data.message);
									break;
								default:
									e.data = e.data || {}, e.data.frag = this.frag, e.data.id = this.id, r.trigger(e.event, e.data)
							}
						}, e.configureTransmuxer = function(t) {
							var e = this.worker,
								r = this.transmuxer;
							e ? e.postMessage({
								cmd: "configure",
								config: t
							}) : r && r.configure(t)
						}, e.handleTransmuxComplete = function(t) {
							t.chunkMeta.transmuxing.end = self.performance.now(), this.onTransmuxComplete(t)
						}, t
					}(),
					De = function() {
						function t(t, e, r, i) {
							this.config = void 0, this.media = null, this.fragmentTracker = void 0, this.hls = void 0, this.nudgeRetry = 0, this.stallReported = !1, this.stalled = null, this.moved = !1, this.seeking = !1, this.config = t, this.media = e, this.fragmentTracker = r, this.hls = i
						}
						var e = t.prototype;
						return e.destroy = function() {
							this.media = null, this.hls = this.fragmentTracker = null
						}, e.poll = function(t, e) {
							var r = this.config,
								i = this.media,
								n = this.stalled;
							if(null !== i) {
								var a = i.currentTime,
									s = i.seeking,
									o = this.seeking && !s,
									u = !this.seeking && s;
								if(this.seeking = s, a === t) {
									if((u || o) && (this.stalled = null), !(i.paused && !s || i.ended || 0 === i.playbackRate) && Bt.getBuffered(i).length) {
										var d = Bt.bufferInfo(i, a, 0),
											h = d.len > 0,
											c = d.nextStart || 0;
										if(h || c) {
											if(s) {
												var f = d.len > 2,
													g = !c || e && e.start <= a || c - a > 2 && !this.fragmentTracker.getPartialFragment(a);
												if(f || g) return;
												this.moved = !1
											}
											if(!this.moved && null !== this.stalled) {
												var v, p = Math.max(c, d.start || 0) - a,
													m = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null,
													y = (null == m || null === (v = m.details) || void 0 === v ? void 0 : v.live) ? 2 * m.details.targetduration : 2;
												if(p > 0 && p <= y) return void this._trySkipBufferHole(null)
											}
											var E = self.performance.now();
											if(null !== n) {
												var T = E - n;
												if(s || !(T >= 250) || (this._reportStall(d), this.media)) {
													var S = Bt.bufferInfo(i, a, r.maxBufferHole);
													this._tryFixBufferStall(S, T)
												}
											} else this.stalled = E
										}
									}
								} else if(this.moved = !0, null !== n) {
									if(this.stallReported) {
										var b = self.performance.now() - n;
										l.logger.warn("playback not stuck anymore @" + a + ", after " + Math.round(b) + "ms"), this.stallReported = !1
									}
									this.stalled = null, this.nudgeRetry = 0
								}
							}
						}, e._tryFixBufferStall = function(t, e) {
							var r = this.config,
								i = this.fragmentTracker,
								n = this.media;
							if(null !== n) {
								var a = n.currentTime,
									s = i.getPartialFragment(a);
								if(s && (this._trySkipBufferHole(s) || !this.media)) return;
								t.len > r.maxBufferHole && e > 1e3 * r.highBufferWatchdogPeriod && (l.logger.warn("Trying to nudge playhead over buffer-hole"), this.stalled = null, this._tryNudgeBuffer())
							}
						}, e._reportStall = function(t) {
							var e = this.hls,
								r = this.media;
							!this.stallReported && r && (this.stallReported = !0, l.logger.warn("Playback stalling at @" + r.currentTime + " due to low buffer (" + JSON.stringify(t) + ")"), e.trigger(s.Events.ERROR, {
								type: o.ErrorTypes.MEDIA_ERROR,
								details: o.ErrorDetails.BUFFER_STALLED_ERROR,
								fatal: !1,
								buffer: t.len
							}))
						}, e._trySkipBufferHole = function(t) {
							var e = this.config,
								r = this.hls,
								i = this.media;
							if(null === i) return 0;
							for(var n = i.currentTime, a = 0, u = Bt.getBuffered(i), d = 0; d < u.length; d++) {
								var h = u.start(d);
								if(n + e.maxBufferHole >= a && n < h) {
									var c = Math.max(h + .05, i.currentTime + .1);
									return l.logger.warn("skipping hole, adjusting currentTime from " + n + " to " + c), this.moved = !0, this.stalled = null, i.currentTime = c, t && r.trigger(s.Events.ERROR, {
										type: o.ErrorTypes.MEDIA_ERROR,
										details: o.ErrorDetails.BUFFER_SEEK_OVER_HOLE,
										fatal: !1,
										reason: "fragment loaded with buffer holes, seeking from " + n + " to " + c,
										frag: t
									}), c
								}
								a = u.end(d)
							}
							return 0
						}, e._tryNudgeBuffer = function() {
							var t = this.config,
								e = this.hls,
								r = this.media,
								i = this.nudgeRetry;
							if(null !== r) {
								var n = r.currentTime;
								if(this.nudgeRetry++, i < t.nudgeMaxRetry) {
									var a = n + (i + 1) * t.nudgeOffset;
									l.logger.warn("Nudging 'currentTime' from " + n + " to " + a), r.currentTime = a, e.trigger(s.Events.ERROR, {
										type: o.ErrorTypes.MEDIA_ERROR,
										details: o.ErrorDetails.BUFFER_NUDGE_ON_STALL,
										fatal: !1
									})
								} else l.logger.error("Playhead still not moving while enough data buffered @" + n + " after " + t.nudgeMaxRetry + " nudges"), e.trigger(s.Events.ERROR, {
									type: o.ErrorTypes.MEDIA_ERROR,
									details: o.ErrorDetails.BUFFER_STALLED_ERROR,
									fatal: !0
								})
							}
						}, t
					}();

				function ke(t, e) {
					for(var r = 0; r < e.length; r++) {
						var i = e[r];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, (void 0, "symbol" == typeof(n = function(t, e) {
							if("object" != typeof t || null === t) return t;
							var r = t[Symbol.toPrimitive];
							if(void 0 !== r) {
								var i = r.call(t, e);
								if("object" != typeof i) return i;
								throw new TypeError("@@toPrimitive must return a primitive value.")
							}
							return String(t)
						}(i.key, "string")) ? n : String(n)), i)
					}
					var n
				}

				function Re(t, e) {
					return Re = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
						return t.__proto__ = e, t
					}, Re(t, e)
				}
				var Ie = function(t) {
					var e, r;

					function i(e, r, i) {
						var n;
						return(n = t.call(this, e, r, i, "[stream-controller]") || this).audioCodecSwap = !1, n.gapController = null, n.level = -1, n._forceStartLoad = !1, n.altAudio = !1, n.audioOnly = !1, n.fragPlaying = null, n.onvplaying = null, n.onvseeked = null, n.fragLastKbps = 0, n.couldBacktrack = !1, n.backtrackFragment = null, n.audioCodecSwitch = !1, n.videoBuffer = null, n._registerListeners(), n
					}
					r = t, (e = i).prototype = Object.create(r.prototype), e.prototype.constructor = e, Re(e, r);
					var n, l, u = i.prototype;
					return u._registerListeners = function() {
						var t = this.hls;
						t.on(s.Events.MEDIA_ATTACHED, this.onMediaAttached, this), t.on(s.Events.MEDIA_DETACHING, this.onMediaDetaching, this), t.on(s.Events.MANIFEST_LOADING, this.onManifestLoading, this), t.on(s.Events.MANIFEST_PARSED, this.onManifestParsed, this), t.on(s.Events.LEVEL_LOADING, this.onLevelLoading, this), t.on(s.Events.LEVEL_LOADED, this.onLevelLoaded, this), t.on(s.Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), t.on(s.Events.ERROR, this.onError, this), t.on(s.Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), t.on(s.Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), t.on(s.Events.BUFFER_CREATED, this.onBufferCreated, this), t.on(s.Events.BUFFER_FLUSHED, this.onBufferFlushed, this), t.on(s.Events.LEVELS_UPDATED, this.onLevelsUpdated, this), t.on(s.Events.FRAG_BUFFERED, this.onFragBuffered, this)
					}, u._unregisterListeners = function() {
						var t = this.hls;
						t.off(s.Events.MEDIA_ATTACHED, this.onMediaAttached, this), t.off(s.Events.MEDIA_DETACHING, this.onMediaDetaching, this), t.off(s.Events.MANIFEST_LOADING, this.onManifestLoading, this), t.off(s.Events.MANIFEST_PARSED, this.onManifestParsed, this), t.off(s.Events.LEVEL_LOADED, this.onLevelLoaded, this), t.off(s.Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), t.off(s.Events.ERROR, this.onError, this), t.off(s.Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), t.off(s.Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), t.off(s.Events.BUFFER_CREATED, this.onBufferCreated, this), t.off(s.Events.BUFFER_FLUSHED, this.onBufferFlushed, this), t.off(s.Events.LEVELS_UPDATED, this.onLevelsUpdated, this), t.off(s.Events.FRAG_BUFFERED, this.onFragBuffered, this)
					}, u.onHandlerDestroying = function() {
						this._unregisterListeners(), this.onMediaDetaching()
					}, u.startLoad = function(t) {
						if(this.levels) {
							var e = this.lastCurrentTime,
								r = this.hls;
							if(this.stopLoad(), this.setInterval(100), this.level = -1, this.fragLoadError = 0, !this.startFragRequested) {
								var i = r.startLevel; - 1 === i && (r.config.testBandwidth && this.levels.length > 1 ? (i = 0, this.bitrateTest = !0) : i = r.nextAutoLevel), this.level = r.nextLoadLevel = i, this.loadedmetadata = !1
							}
							e > 0 && -1 === t && (this.log("Override startPosition with lastCurrentTime @" + e.toFixed(3)), t = e), this.state = te, this.nextLoadPosition = this.startPosition = this.lastCurrentTime = t, this.tick()
						} else this._forceStartLoad = !0, this.state = Zt
					}, u.stopLoad = function() {
						this._forceStartLoad = !1, t.prototype.stopLoad.call(this)
					}, u.doTick = function() {
						switch(this.state) {
							case te:
								this.doTickIdle();
								break;
							case de:
								var t, e = this.levels,
									r = this.level,
									i = null == e || null === (t = e[r]) || void 0 === t ? void 0 : t.details;
								if(i && (!i.live || this.levelLastLoaded === this.level)) {
									if(this.waitForCdnTuneIn(i)) break;
									this.state = te;
									break
								}
								break;
							case ie:
								var n, a = self.performance.now(),
									s = this.retryDate;
								(!s || a >= s || null !== (n = this.media) && void 0 !== n && n.seeking) && (this.log("retryDate reached, switch back to IDLE state"), this.resetStartWhenNotLoaded(this.level), this.state = te)
						}
						this.onTickEnd()
					}, u.onTickEnd = function() {
						t.prototype.onTickEnd.call(this), this.checkBuffer(), this.checkFragmentChanged()
					}, u.doTickIdle = function() {
						var t = this.hls,
							e = this.levelLastLoaded,
							r = this.levels,
							i = this.media,
							n = t.config,
							a = t.nextLoadLevel;
						if(null !== e && (i || !this.startFragRequested && n.startFragPrefetch) && (!this.altAudio || !this.audioOnly) && r && r[a]) {
							var o = r[a],
								l = this.getMainFwdBufferInfo();
							if(null !== l) {
								var u = this.getLevelDetails();
								if(u && this._streamEnded(l, u)) {
									var d = {};
									return this.altAudio && (d.type = "video"), this.hls.trigger(s.Events.BUFFER_EOS, d), void(this.state = oe)
								}
								this.level = t.nextLoadLevel = a;
								var h = o.details;
								if(!h || this.state === de || h.live && this.levelLastLoaded !== a) return this.level = a, void(this.state = de);
								if(!(l.len >= this.getMaxBufferLength(o.maxBitrate))) {
									this.backtrackFragment && this.backtrackFragment.start > l.end && (this.backtrackFragment = null);
									var c = this.backtrackFragment ? this.backtrackFragment.start : l.end,
										f = this.getNextFragment(c, h);
									if(this.couldBacktrack && !this.fragPrevious && f && "initSegment" !== f.sn && this.fragmentTracker.getState(f) !== St.OK) {
										var g, p = (null != (g = this.backtrackFragment) ? g : f).sn - h.startSN,
											m = h.fragments[p - 1];
										m && f.cc === m.cc && (f = m, this.fragmentTracker.removeFragment(m))
									} else this.backtrackFragment && l.len && (this.backtrackFragment = null);
									if(f && this.fragmentTracker.getState(f) === St.OK && this.nextLoadPosition > c) {
										var y = this.audioOnly && !this.altAudio ? v.ElementaryStreamTypes.AUDIO : v.ElementaryStreamTypes.VIDEO,
											E = (y === v.ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
										E && this.afterBufferFlushed(E, y, V.PlaylistLevelType.MAIN), f = this.getNextFragment(this.nextLoadPosition, h)
									}
									f && (!f.initSegment || f.initSegment.data || this.bitrateTest || (f = f.initSegment), this.loadFragment(f, h, c))
								}
							}
						}
					}, u.loadFragment = function(e, r, i) {
						var n, a = this.fragmentTracker.getState(e);
						this.fragCurrent = e, a === St.NOT_LOADED ? "initSegment" === e.sn ? this._loadInitSegment(e, r) : this.bitrateTest ? (this.log("Fragment " + e.sn + " of level " + e.level + " is being downloaded to test bitrate and will not be buffered"), this._loadBitrateTestFrag(e, r)) : (this.startFragRequested = !0, t.prototype.loadFragment.call(this, e, r, i)) : a === St.APPENDING ? this.reduceMaxBufferLength(e.duration) && this.fragmentTracker.removeFragment(e) : 0 === (null === (n = this.media) || void 0 === n ? void 0 : n.buffered.length) && this.fragmentTracker.removeAllFragments()
					}, u.getAppendedFrag = function(t) {
						var e = this.fragmentTracker.getAppendedFrag(t, V.PlaylistLevelType.MAIN);
						return e && "fragment" in e ? e.fragment : e
					}, u.getBufferedFrag = function(t) {
						return this.fragmentTracker.getBufferedFrag(t, V.PlaylistLevelType.MAIN)
					}, u.followingBufferedFrag = function(t) {
						return t ? this.getBufferedFrag(t.end + .5) : null
					}, u.immediateLevelSwitch = function() {
						this.abortCurrentFrag(), this.flushMainBuffer(0, Number.POSITIVE_INFINITY)
					}, u.nextLevelSwitch = function() {
						var t = this.levels,
							e = this.media;
						if(null != e && e.readyState) {
							var r, i = this.getAppendedFrag(e.currentTime);
							if(i && i.start > 1 && this.flushMainBuffer(0, i.start - 1), !e.paused && t) {
								var n = t[this.hls.nextLoadLevel],
									a = this.fragLastKbps;
								r = a && this.fragCurrent ? this.fragCurrent.duration * n.maxBitrate / (1e3 * a) + 1 : 0
							} else r = 0;
							var s = this.getBufferedFrag(e.currentTime + r);
							if(s) {
								var o = this.followingBufferedFrag(s);
								if(o) {
									this.abortCurrentFrag();
									var l = o.maxStartPTS ? o.maxStartPTS : o.start,
										u = o.duration,
										d = Math.max(s.end, l + Math.min(Math.max(u - this.config.maxFragLookUpTolerance, .5 * u), .75 * u));
									this.flushMainBuffer(d, Number.POSITIVE_INFINITY)
								}
							}
						}
					}, u.abortCurrentFrag = function() {
						var t = this.fragCurrent;
						switch(this.fragCurrent = null, this.backtrackFragment = null, t && t.abortRequests(), this.state) {
							case ee:
							case re:
							case ie:
							case ae:
							case se:
								this.state = te
						}
						this.nextLoadPosition = this.getLoadPosition()
					}, u.flushMainBuffer = function(e, r) {
						t.prototype.flushMainBuffer.call(this, e, r, this.altAudio ? "video" : null)
					}, u.onMediaAttached = function(e, r) {
						t.prototype.onMediaAttached.call(this, e, r);
						var i = r.media;
						this.onvplaying = this.onMediaPlaying.bind(this), this.onvseeked = this.onMediaSeeked.bind(this), i.addEventListener("playing", this.onvplaying), i.addEventListener("seeked", this.onvseeked), this.gapController = new De(this.config, i, this.fragmentTracker, this.hls)
					}, u.onMediaDetaching = function() {
						var e = this.media;
						e && this.onvplaying && this.onvseeked && (e.removeEventListener("playing", this.onvplaying), e.removeEventListener("seeked", this.onvseeked), this.onvplaying = this.onvseeked = null, this.videoBuffer = null), this.fragPlaying = null, this.gapController && (this.gapController.destroy(), this.gapController = null), t.prototype.onMediaDetaching.call(this)
					}, u.onMediaPlaying = function() {
						this.tick()
					}, u.onMediaSeeked = function() {
						var t = this.media,
							e = t ? t.currentTime : null;
						(0, a.isFiniteNumber)(e) && this.log("Media seeked to " + e.toFixed(3)), this.tick()
					}, u.onManifestLoading = function() {
						this.log("Trigger BUFFER_RESET"), this.hls.trigger(s.Events.BUFFER_RESET, void 0), this.fragmentTracker.removeAllFragments(), this.couldBacktrack = !1, this.startPosition = this.lastCurrentTime = 0, this.fragPlaying = null, this.backtrackFragment = null
					}, u.onManifestParsed = function(t, e) {
						var r, i, n, a = !1,
							s = !1;
						e.levels.forEach((function(t) {
							(r = t.audioCodec) && (-1 !== r.indexOf("mp4a.40.2") && (a = !0), -1 !== r.indexOf("mp4a.40.5") && (s = !0))
						})), this.audioCodecSwitch = a && s && !("function" == typeof(null == (n = fe()) || null === (i = n.prototype) || void 0 === i ? void 0 : i.changeType)), this.audioCodecSwitch && this.log("Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"), this.levels = e.levels, this.startFragRequested = !1
					}, u.onLevelLoading = function(t, e) {
						var r = this.levels;
						if(r && this.state === te) {
							var i = r[e.level];
							(!i.details || i.details.live && this.levelLastLoaded !== e.level || this.waitForCdnTuneIn(i.details)) && (this.state = de)
						}
					}, u.onLevelLoaded = function(t, e) {
						var r, i = this.levels,
							n = e.level,
							a = e.details,
							o = a.totalduration;
						if(i) {
							this.log("Level " + n + " loaded [" + a.startSN + "," + a.endSN + "], cc [" + a.startCC + ", " + a.endCC + "] duration:" + o);
							var l = this.fragCurrent;
							!l || this.state !== re && this.state !== ie || l.level !== e.level && l.loader && (this.state = te, this.backtrackFragment = null, l.abortRequests());
							var u = i[n],
								d = 0;
							if(a.live || null !== (r = u.details) && void 0 !== r && r.live) {
								if(a.fragments[0] || (a.deltaUpdateFailed = !0), a.deltaUpdateFailed) return;
								d = this.alignPlaylists(a, u.details)
							}
							if(u.details = a, this.levelLastLoaded = n, this.hls.trigger(s.Events.LEVEL_UPDATED, {
									details: a,
									level: n
								}), this.state === de) {
								if(this.waitForCdnTuneIn(a)) return;
								this.state = te
							}
							this.startFragRequested ? a.live && this.synchronizeToLiveEdge(a) : this.setStartPosition(a, d), this.tick()
						} else this.warn("Levels were reset while loading level " + n)
					}, u._handleFragmentLoadProgress = function(t) {
						var e, r = t.frag,
							i = t.part,
							n = t.payload,
							a = this.levels;
						if(a) {
							var s = a[r.level],
								o = s.details;
							if(o) {
								var l = s.videoCodec,
									u = o.PTSKnown || !o.live,
									d = null === (e = r.initSegment) || void 0 === e ? void 0 : e.data,
									h = this._getAudioCodec(s),
									c = this.transmuxer = this.transmuxer || new Ae(this.hls, V.PlaylistLevelType.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)),
									f = i ? i.index : -1,
									g = -1 !== f,
									v = new Gt(r.level, r.sn, r.stats.chunkCount, n.byteLength, f, g),
									p = this.initPTS[r.cc];
								c.push(n, d, h, l, r, i, o.totalduration, u, v, p)
							} else this.warn("Dropping fragment " + r.sn + " of level " + r.level + " after level details were reset")
						} else this.warn("Levels were reset while fragment load was in progress. Fragment " + r.sn + " of level " + r.level + " will not be buffered")
					}, u.onAudioTrackSwitching = function(t, e) {
						var r = this.altAudio,
							i = !!e.url,
							n = e.id;
						if(!i) {
							if(this.mediaBuffer !== this.media) {
								this.log("Switching on main audio, use media.buffered to schedule main fragment loading"), this.mediaBuffer = this.media;
								var a = this.fragCurrent;
								a && (this.log("Switching to main audio track, cancel main fragment load"), a.abortRequests()), this.resetTransmuxer(), this.resetLoadingState()
							} else this.audioOnly && this.resetTransmuxer();
							var o = this.hls;
							r && o.trigger(s.Events.BUFFER_FLUSHING, {
								startOffset: 0,
								endOffset: Number.POSITIVE_INFINITY,
								type: "audio"
							}), o.trigger(s.Events.AUDIO_TRACK_SWITCHED, {
								id: n
							})
						}
					}, u.onAudioTrackSwitched = function(t, e) {
						var r = e.id,
							i = !!this.hls.audioTracks[r].url;
						if(i) {
							var n = this.videoBuffer;
							n && this.mediaBuffer !== n && (this.log("Switching on alternate audio, use video.buffered to schedule main fragment loading"), this.mediaBuffer = n)
						}
						this.altAudio = i, this.tick()
					}, u.onBufferCreated = function(t, e) {
						var r, i, n = e.tracks,
							a = !1;
						for(var s in n) {
							var o = n[s];
							if("main" === o.id) {
								if(i = s, r = o, "video" === s) {
									var l = n[s];
									l && (this.videoBuffer = l.buffer)
								}
							} else a = !0
						}
						a && r ? (this.log("Alternate track found, use " + i + ".buffered to schedule main fragment loading"), this.mediaBuffer = r.buffer) : this.mediaBuffer = this.media
					}, u.onFragBuffered = function(t, e) {
						var r = e.frag,
							i = e.part;
						if(!r || r.type === V.PlaylistLevelType.MAIN) {
							if(this.fragContextChanged(r)) return this.warn("Fragment " + r.sn + (i ? " p: " + i.index : "") + " of level " + r.level + " finished buffering, but was aborted. state: " + this.state), void(this.state === se && (this.state = te));
							var n = i ? i.stats : r.stats;
							this.fragLastKbps = Math.round(8 * n.total / (n.buffering.end - n.loading.first)), "initSegment" !== r.sn && (this.fragPrevious = r), this.fragBufferedComplete(r, i)
						}
					}, u.onError = function(t, e) {
						if(e.type !== o.ErrorTypes.KEY_SYSTEM_ERROR) switch(e.details) {
							case o.ErrorDetails.FRAG_LOAD_ERROR:
							case o.ErrorDetails.FRAG_LOAD_TIMEOUT:
							case o.ErrorDetails.FRAG_PARSING_ERROR:
							case o.ErrorDetails.KEY_LOAD_ERROR:
							case o.ErrorDetails.KEY_LOAD_TIMEOUT:
								this.onFragmentOrKeyLoadError(V.PlaylistLevelType.MAIN, e);
								break;
							case o.ErrorDetails.LEVEL_LOAD_ERROR:
							case o.ErrorDetails.LEVEL_LOAD_TIMEOUT:
								this.state !== le && (e.fatal ? (this.warn("" + e.details), this.state = le) : e.levelRetry || this.state !== de || (this.state = te));
								break;
							case o.ErrorDetails.BUFFER_FULL_ERROR:
								if("main" === e.parent && (this.state === ae || this.state === se)) {
									var r = !0,
										i = this.getFwdBufferInfo(this.media, V.PlaylistLevelType.MAIN);
									i && i.len > .5 && (r = !this.reduceMaxBufferLength(i.len)), r && (this.warn("buffer full error also media.currentTime is not buffered, flush main"), this.immediateLevelSwitch()), this.resetLoadingState()
								}
						} else this.onFragmentOrKeyLoadError(V.PlaylistLevelType.MAIN, e)
					}, u.checkBuffer = function() {
						var t = this.media,
							e = this.gapController;
						if(t && e && t.readyState) {
							if(this.loadedmetadata || !Bt.getBuffered(t).length) {
								var r = this.state !== te ? this.fragCurrent : null;
								e.poll(this.lastCurrentTime, r)
							}
							this.lastCurrentTime = t.currentTime
						}
					}, u.onFragLoadEmergencyAborted = function() {
						this.state = te, this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition), this.tickImmediate()
					}, u.onBufferFlushed = function(t, e) {
						var r = e.type;
						if(r !== v.ElementaryStreamTypes.AUDIO || this.audioOnly && !this.altAudio) {
							var i = (r === v.ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
							this.afterBufferFlushed(i, r, V.PlaylistLevelType.MAIN)
						}
					}, u.onLevelsUpdated = function(t, e) {
						this.levels = e.levels
					}, u.swapAudioCodec = function() {
						this.audioCodecSwap = !this.audioCodecSwap
					}, u.seekToStartPos = function() {
						var t = this.media;
						if(t) {
							var e = t.currentTime,
								r = this.startPosition;
							if(r >= 0 && e < r) {
								if(t.seeking) return void this.log("could not seek to " + r + ", already seeking at " + e);
								var i = Bt.getBuffered(t),
									n = (i.length ? i.start(0) : 0) - r;
								n > 0 && (n < this.config.maxBufferHole || n < this.config.maxFragLookUpTolerance) && (this.log("adjusting start position by " + n + " to match buffer start"), r += n, this.startPosition = r), this.log("seek to target start position " + r + " from current time " + e), t.currentTime = r
							}
						}
					}, u._getAudioCodec = function(t) {
						var e = this.config.defaultAudioCodec || t.audioCodec;
						return this.audioCodecSwap && e && (this.log("Swapping audio codec"), e = -1 !== e.indexOf("mp4a.40.5") ? "mp4a.40.2" : "mp4a.40.5"), e
					}, u._loadBitrateTestFrag = function(t, e) {
						var r = this;
						t.bitrateTest = !0, this._doFragLoad(t, e).then((function(e) {
							var i = r.hls;
							if(e && !r.fragContextChanged(t)) {
								r.fragLoadError = 0, r.state = te, r.startFragRequested = !1, r.bitrateTest = !1;
								var n = t.stats;
								n.parsing.start = n.parsing.end = n.buffering.start = n.buffering.end = self.performance.now(), i.trigger(s.Events.FRAG_LOADED, e), t.bitrateTest = !1
							}
						}))
					}, u._handleTransmuxComplete = function(t) {
						var e, r = "main",
							i = this.hls,
							n = t.remuxResult,
							o = t.chunkMeta,
							l = this.getCurrentContext(o);
						if(!l) return this.warn("The loading context changed while buffering fragment " + o.sn + " of level " + o.level + ". This chunk will not be buffered."), void this.resetStartWhenNotLoaded(o.level);
						var u = l.frag,
							d = l.part,
							h = l.level,
							c = n.video,
							f = n.text,
							g = n.id3,
							p = n.initSegment,
							m = h.details,
							y = this.altAudio ? void 0 : n.audio;
						if(!this.fragContextChanged(u)) {
							if(this.state = ae, p) {
								p.tracks && (this._bufferInitSegment(h, p.tracks, u, o), i.trigger(s.Events.FRAG_PARSING_INIT_SEGMENT, {
									frag: u,
									id: r,
									tracks: p.tracks
								}));
								var E = p.initPTS,
									T = p.timescale;
								(0, a.isFiniteNumber)(E) && (this.initPTS[u.cc] = E, i.trigger(s.Events.INIT_PTS_FOUND, {
									frag: u,
									id: r,
									initPTS: E,
									timescale: T
								}))
							}
							if(c && !1 !== n.independent) {
								if(m) {
									var S = c.startPTS,
										b = c.endPTS,
										L = c.startDTS,
										A = c.endDTS;
									if(d) d.elementaryStreams[c.type] = {
										startPTS: S,
										endPTS: b,
										startDTS: L,
										endDTS: A
									};
									else if(c.firstKeyFrame && c.independent && 1 === o.id && (this.couldBacktrack = !0), c.dropped && c.independent) {
										var D = this.getMainFwdBufferInfo();
										if((D ? D.end : this.getLoadPosition()) + this.config.maxBufferHole < (c.firstKeyFramePTS ? c.firstKeyFramePTS : S) - this.config.maxBufferHole) return void this.backtrack(u);
										u.setElementaryStreamInfo(c.type, u.start, b, u.start, A, !0)
									}
									u.setElementaryStreamInfo(c.type, S, b, L, A), this.backtrackFragment && (this.backtrackFragment = u), this.bufferFragmentData(c, u, d, o)
								}
							} else if(!1 === n.independent) return void this.backtrack(u);
							if(y) {
								var k = y.startPTS,
									R = y.endPTS,
									I = y.startDTS,
									w = y.endDTS;
								d && (d.elementaryStreams[v.ElementaryStreamTypes.AUDIO] = {
									startPTS: k,
									endPTS: R,
									startDTS: I,
									endDTS: w
								}), u.setElementaryStreamInfo(v.ElementaryStreamTypes.AUDIO, k, R, I, w), this.bufferFragmentData(y, u, d, o)
							}
							if(m && null != g && null !== (e = g.samples) && void 0 !== e && e.length) {
								var C = {
									id: r,
									frag: u,
									details: m,
									samples: g.samples
								};
								i.trigger(s.Events.FRAG_PARSING_METADATA, C)
							}
							if(m && f) {
								var _ = {
									id: r,
									frag: u,
									details: m,
									samples: f.samples
								};
								i.trigger(s.Events.FRAG_PARSING_USERDATA, _)
							}
						}
					}, u._bufferInitSegment = function(t, e, r, i) {
						var n = this;
						if(this.state === ae) {
							this.audioOnly = !!e.audio && !e.video, this.altAudio && !this.audioOnly && delete e.audio;
							var a = e.audio,
								o = e.video,
								l = e.audiovideo;
							if(a) {
								var u = t.audioCodec,
									d = navigator.userAgent.toLowerCase();
								this.audioCodecSwitch && (u && (u = -1 !== u.indexOf("mp4a.40.5") ? "mp4a.40.2" : "mp4a.40.5"), 1 !== a.metadata.channelCount && -1 === d.indexOf("firefox") && (u = "mp4a.40.5")), -1 !== d.indexOf("android") && "audio/mpeg" !== a.container && (u = "mp4a.40.2", this.log("Android: force audio codec to " + u)), t.audioCodec && t.audioCodec !== u && this.log('Swapping manifest audio codec "' + t.audioCodec + '" for "' + u + '"'), a.levelCodec = u, a.id = "main", this.log("Init audio buffer, container:" + a.container + ", codecs[selected/level/parsed]=[" + (u || "") + "/" + (t.audioCodec || "") + "/" + a.codec + "]")
							}
							o && (o.levelCodec = t.videoCodec, o.id = "main", this.log("Init video buffer, container:" + o.container + ", codecs[level/parsed]=[" + (t.videoCodec || "") + "/" + o.codec + "]")), l && this.log("Init audiovideo buffer, container:" + l.container + ", codecs[level/parsed]=[" + (t.attrs.CODECS || "") + "/" + l.codec + "]"), this.hls.trigger(s.Events.BUFFER_CODECS, e), Object.keys(e).forEach((function(t) {
								var a = e[t].initSegment;
								null != a && a.byteLength && n.hls.trigger(s.Events.BUFFER_APPENDING, {
									type: t,
									data: a,
									frag: r,
									part: null,
									chunkMeta: i,
									parent: r.type
								})
							})), this.tick()
						}
					}, u.getMainFwdBufferInfo = function() {
						return this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, V.PlaylistLevelType.MAIN)
					}, u.backtrack = function(t) {
						this.couldBacktrack = !0, this.backtrackFragment = t, this.resetTransmuxer(), this.flushBufferGap(t), this.fragmentTracker.removeFragment(t), this.fragPrevious = null, this.nextLoadPosition = t.start, this.state = te
					}, u.checkFragmentChanged = function() {
						var t = this.media,
							e = null;
						if(t && t.readyState > 1 && !1 === t.seeking) {
							var r = t.currentTime;
							if(Bt.isBuffered(t, r) ? e = this.getAppendedFrag(r) : Bt.isBuffered(t, r + .1) && (e = this.getAppendedFrag(r + .1)), e) {
								this.backtrackFragment = null;
								var i = this.fragPlaying,
									n = e.level;
								i && e.sn === i.sn && i.level === n && e.urlId === i.urlId || (this.fragPlaying = e, this.hls.trigger(s.Events.FRAG_CHANGED, {
									frag: e
								}), i && i.level === n || this.hls.trigger(s.Events.LEVEL_SWITCHED, {
									level: n
								}))
							}
						}
					}, n = i, (l = [{
						key: "nextLevel",
						get: function() {
							var t = this.nextBufferedFrag;
							return t ? t.level : -1
						}
					}, {
						key: "currentFrag",
						get: function() {
							var t = this.media;
							return t ? this.fragPlaying || this.getAppendedFrag(t.currentTime) : null
						}
					}, {
						key: "currentProgramDateTime",
						get: function() {
							var t = this.media;
							if(t) {
								var e = t.currentTime,
									r = this.currentFrag;
								if(r && (0, a.isFiniteNumber)(e) && (0, a.isFiniteNumber)(r.programDateTime)) {
									var i = r.programDateTime + 1e3 * (e - r.start);
									return new Date(i)
								}
							}
							return null
						}
					}, {
						key: "currentLevel",
						get: function() {
							var t = this.currentFrag;
							return t ? t.level : -1
						}
					}, {
						key: "nextBufferedFrag",
						get: function() {
							var t = this.currentFrag;
							return t ? this.followingBufferedFrag(t) : null
						}
					}, {
						key: "forceStartLoad",
						get: function() {
							return this._forceStartLoad
						}
					}]) && ke(n.prototype, l), Object.defineProperty(n, "prototype", {
						writable: !1
					}), i
				}(he);
				const we = function() {
						function t(t, e, r) {
							void 0 === e && (e = 0), void 0 === r && (r = 0), this.halfLife = void 0, this.alpha_ = void 0, this.estimate_ = void 0, this.totalWeight_ = void 0, this.halfLife = t, this.alpha_ = t ? Math.exp(Math.log(.5) / t) : 0, this.estimate_ = e, this.totalWeight_ = r
						}
						var e = t.prototype;
						return e.sample = function(t, e) {
							var r = Math.pow(this.alpha_, t);
							this.estimate_ = e * (1 - r) + r * this.estimate_, this.totalWeight_ += t
						}, e.getTotalWeight = function() {
							return this.totalWeight_
						}, e.getEstimate = function() {
							if(this.alpha_) {
								var t = 1 - Math.pow(this.alpha_, this.totalWeight_);
								if(t) return this.estimate_ / t
							}
							return this.estimate_
						}, t
					}(),
					Ce = function() {
						function t(t, e, r) {
							this.defaultEstimate_ = void 0, this.minWeight_ = void 0, this.minDelayMs_ = void 0, this.slow_ = void 0, this.fast_ = void 0, this.defaultEstimate_ = r, this.minWeight_ = .001, this.minDelayMs_ = 50, this.slow_ = new we(t), this.fast_ = new we(e)
						}
						var e = t.prototype;
						return e.update = function(t, e) {
							var r = this.slow_,
								i = this.fast_;
							this.slow_.halfLife !== t && (this.slow_ = new we(t, r.getEstimate(), r.getTotalWeight())), this.fast_.halfLife !== e && (this.fast_ = new we(e, i.getEstimate(), i.getTotalWeight()))
						}, e.sample = function(t, e) {
							var r = (t = Math.max(t, this.minDelayMs_)) / 1e3,
								i = 8 * e / r;
							this.fast_.sample(r, i), this.slow_.sample(r, i)
						}, e.canEstimate = function() {
							var t = this.fast_;
							return t && t.getTotalWeight() >= this.minWeight_
						}, e.getEstimate = function() {
							return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_
						}, e.destroy = function() {}, t
					}();

				function _e(t, e) {
					for(var r = 0; r < e.length; r++) {
						var i = e[r];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, (void 0, "symbol" == typeof(n = function(t, e) {
							if("object" != typeof t || null === t) return t;
							var r = t[Symbol.toPrimitive];
							if(void 0 !== r) {
								var i = r.call(t, e);
								if("object" != typeof i) return i;
								throw new TypeError("@@toPrimitive must return a primitive value.")
							}
							return String(t)
						}(i.key, "string")) ? n : String(n)), i)
					}
					var n
				}
				const Oe = function() {
					function t(t) {
						this.hls = void 0, this.lastLoadedFragLevel = 0, this._nextAutoLevel = -1, this.timer = void 0, this.onCheck = this._abandonRulesCheck.bind(this), this.fragCurrent = null, this.partCurrent = null, this.bitrateTestDelay = 0, this.bwEstimator = void 0, this.hls = t;
						var e = t.config;
						this.bwEstimator = new Ce(e.abrEwmaSlowVoD, e.abrEwmaFastVoD, e.abrEwmaDefaultEstimate), this.registerListeners()
					}
					var e, r, i = t.prototype;
					return i.registerListeners = function() {
						var t = this.hls;
						t.on(s.Events.FRAG_LOADING, this.onFragLoading, this), t.on(s.Events.FRAG_LOADED, this.onFragLoaded, this), t.on(s.Events.FRAG_BUFFERED, this.onFragBuffered, this), t.on(s.Events.LEVEL_LOADED, this.onLevelLoaded, this), t.on(s.Events.ERROR, this.onError, this)
					}, i.unregisterListeners = function() {
						var t = this.hls;
						t.off(s.Events.FRAG_LOADING, this.onFragLoading, this), t.off(s.Events.FRAG_LOADED, this.onFragLoaded, this), t.off(s.Events.FRAG_BUFFERED, this.onFragBuffered, this), t.off(s.Events.LEVEL_LOADED, this.onLevelLoaded, this), t.off(s.Events.ERROR, this.onError, this)
					}, i.destroy = function() {
						this.unregisterListeners(), this.clearTimer(), this.hls = this.onCheck = null, this.fragCurrent = this.partCurrent = null
					}, i.onFragLoading = function(t, e) {
						var r, i = e.frag;
						i.type === V.PlaylistLevelType.MAIN && (this.timer || (this.fragCurrent = i, this.partCurrent = null != (r = e.part) ? r : null, this.timer = self.setInterval(this.onCheck, 100)))
					}, i.onLevelLoaded = function(t, e) {
						var r = this.hls.config;
						e.details.live ? this.bwEstimator.update(r.abrEwmaSlowLive, r.abrEwmaFastLive) : this.bwEstimator.update(r.abrEwmaSlowVoD, r.abrEwmaFastVoD)
					}, i._abandonRulesCheck = function() {
						var t = this.fragCurrent,
							e = this.partCurrent,
							r = this.hls,
							i = r.autoLevelEnabled,
							n = r.media;
						if(t && n) {
							var o = e ? e.stats : t.stats,
								u = e ? e.duration : t.duration;
							if(o.aborted || o.loaded && o.loaded === o.total || 0 === t.level) return this.clearTimer(), void(this._nextAutoLevel = -1);
							if(i && !n.paused && n.playbackRate && n.readyState) {
								var d = r.mainForwardBufferInfo;
								if(null !== d) {
									var h = performance.now() - o.loading.start,
										c = Math.abs(n.playbackRate);
									if(!(h <= 500 * u / c)) {
										var f = o.loaded && o.loading.first,
											g = this.bwEstimator.getEstimate(),
											v = r.levels,
											p = r.minAutoLevel,
											m = v[t.level],
											y = o.total || Math.max(o.loaded, Math.round(u * m.maxBitrate / 8)),
											E = f ? 1e3 * o.loaded / h : 0,
											T = E ? (y - o.loaded) / E : 8 * y / g,
											S = d.len / c;
										if(!(T <= S)) {
											var b, L = Number.POSITIVE_INFINITY;
											for(b = t.level - 1; b > p; b--) {
												var A = v[b].maxBitrate;
												if((L = E ? u * A / (6.4 * E) : u * A / g) < S) break
											}
											L >= T || (l.logger.warn("Fragment " + t.sn + (e ? " part " + e.index : "") + " of level " + t.level + " is loading too slowly and will cause an underbuffer; aborting and switching to level " + b + "\n      Current BW estimate: " + ((0, a.isFiniteNumber)(g) ? (g / 1024).toFixed(3) : "Unknown") + " Kb/s\n      Estimated load time for current fragment: " + T.toFixed(3) + " s\n      Estimated load time for the next fragment: " + L.toFixed(3) + " s\n      Time to underbuffer: " + S.toFixed(3) + " s"), r.nextLoadLevel = b, f && this.bwEstimator.sample(h, o.loaded), this.clearTimer(), (t.loader || t.keyLoader) && (this.fragCurrent = this.partCurrent = null, t.abortRequests()), r.trigger(s.Events.FRAG_LOAD_EMERGENCY_ABORTED, {
												frag: t,
												part: e,
												stats: o
											}))
										}
									}
								}
							}
						}
					}, i.onFragLoaded = function(t, e) {
						var r = e.frag,
							i = e.part;
						if(r.type === V.PlaylistLevelType.MAIN && (0, a.isFiniteNumber)(r.sn)) {
							var n = i ? i.stats : r.stats,
								o = i ? i.duration : r.duration;
							if(this.clearTimer(), this.lastLoadedFragLevel = r.level, this._nextAutoLevel = -1, this.hls.config.abrMaxWithRealBitrate) {
								var l = this.hls.levels[r.level],
									u = (l.loaded ? l.loaded.bytes : 0) + n.loaded,
									d = (l.loaded ? l.loaded.duration : 0) + o;
								l.loaded = {
									bytes: u,
									duration: d
								}, l.realBitrate = Math.round(8 * u / d)
							}
							if(r.bitrateTest) {
								var h = {
									stats: n,
									frag: r,
									part: i,
									id: r.type
								};
								this.onFragBuffered(s.Events.FRAG_BUFFERED, h)
							}
						}
					}, i.onFragBuffered = function(t, e) {
						var r = e.frag,
							i = e.part,
							n = i ? i.stats : r.stats;
						if(!n.aborted && r.type === V.PlaylistLevelType.MAIN && "initSegment" !== r.sn) {
							var a = n.parsing.end - n.loading.start;
							this.bwEstimator.sample(a, n.loaded), n.bwEstimate = this.bwEstimator.getEstimate(), r.bitrateTest ? this.bitrateTestDelay = a / 1e3 : this.bitrateTestDelay = 0
						}
					}, i.onError = function(t, e) {
						var r;
						if((null === (r = e.frag) || void 0 === r ? void 0 : r.type) === V.PlaylistLevelType.MAIN) {
							if(e.type === o.ErrorTypes.KEY_SYSTEM_ERROR) return void this.clearTimer();
							switch(e.details) {
								case o.ErrorDetails.FRAG_LOAD_ERROR:
								case o.ErrorDetails.FRAG_LOAD_TIMEOUT:
								case o.ErrorDetails.KEY_LOAD_ERROR:
								case o.ErrorDetails.KEY_LOAD_TIMEOUT:
									this.clearTimer()
							}
						}
					}, i.clearTimer = function() {
						self.clearInterval(this.timer), this.timer = void 0
					}, i.getNextABRAutoLevel = function() {
						var t = this.fragCurrent,
							e = this.partCurrent,
							r = this.hls,
							i = r.maxAutoLevel,
							n = r.config,
							a = r.minAutoLevel,
							s = r.media,
							o = e ? e.duration : t ? t.duration : 0,
							u = s && 0 !== s.playbackRate ? Math.abs(s.playbackRate) : 1,
							d = this.bwEstimator ? this.bwEstimator.getEstimate() : n.abrEwmaDefaultEstimate,
							h = r.mainForwardBufferInfo,
							c = (h ? h.len : 0) / u,
							f = this.findBestLevel(d, a, i, c, n.abrBandWidthFactor, n.abrBandWidthUpFactor);
						if(f >= 0) return f;
						l.logger.trace((c ? "rebuffering expected" : "buffer is empty") + ", finding optimal quality level");
						var g = o ? Math.min(o, n.maxStarvationDelay) : n.maxStarvationDelay,
							v = n.abrBandWidthFactor,
							p = n.abrBandWidthUpFactor;
						if(!c) {
							var m = this.bitrateTestDelay;
							m && (g = (o ? Math.min(o, n.maxLoadingDelay) : n.maxLoadingDelay) - m, l.logger.trace("bitrate test took " + Math.round(1e3 * m) + "ms, set first fragment max fetchDuration to " + Math.round(1e3 * g) + " ms"), v = p = 1)
						}
						return f = this.findBestLevel(d, a, i, c + g, v, p), Math.max(f, 0)
					}, i.findBestLevel = function(t, e, r, i, n, s) {
						for(var o, u = this.fragCurrent, d = this.partCurrent, h = this.lastLoadedFragLevel, c = this.hls.levels, f = c[h], g = !(null == f || null === (o = f.details) || void 0 === o || !o.live), v = null == f ? void 0 : f.codecSet, p = d ? d.duration : u ? u.duration : 0, m = r; m >= e; m--) {
							var y = c[m];
							if(y && (!v || y.codecSet === v)) {
								var E, T = y.details,
									S = (d ? null == T ? void 0 : T.partTarget : null == T ? void 0 : T.averagetargetduration) || p;
								E = m <= h ? n * t : s * t;
								var b = c[m].maxBitrate,
									L = b * S / E;
								if(l.logger.trace("level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: " + m + "/" + Math.round(E) + "/" + b + "/" + S + "/" + i + "/" + L), E > b && (0 === L || !(0, a.isFiniteNumber)(L) || g && !this.bitrateTestDelay || L < i)) return m
							}
						}
						return -1
					}, e = t, (r = [{
						key: "nextAutoLevel",
						get: function() {
							var t = this._nextAutoLevel,
								e = this.bwEstimator;
							if(-1 !== t && !e.canEstimate()) return t;
							var r = this.getNextABRAutoLevel();
							return -1 !== t && this.hls.levels[r].loadError ? t : (-1 !== t && (r = Math.min(t, r)), r)
						},
						set: function(t) {
							this._nextAutoLevel = t
						}
					}]) && _e(e.prototype, r), Object.defineProperty(e, "prototype", {
						writable: !1
					}), t
				}();
				var Pe = function() {
					function t() {
						this.chunks = [], this.dataLength = 0
					}
					var e = t.prototype;
					return e.push = function(t) {
						this.chunks.push(t), this.dataLength += t.length
					}, e.flush = function() {
						var t, e = this.chunks,
							r = this.dataLength;
						return e.length ? (t = 1 === e.length ? e[0] : function(t, e) {
							for(var r = new Uint8Array(e), i = 0, n = 0; n < t.length; n++) {
								var a = t[n];
								r.set(a, i), i += a.length
							}
							return r
						}(e, r), this.reset(), t) : new Uint8Array(0)
					}, e.reset = function() {
						this.chunks.length = 0, this.dataLength = 0
					}, t
				}();

				function xe() {
					return xe = Object.assign ? Object.assign.bind() : function(t) {
						for(var e = 1; e < arguments.length; e++) {
							var r = arguments[e];
							for(var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i])
						}
						return t
					}, xe.apply(this, arguments)
				}

				function Fe(t, e) {
					return Fe = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
						return t.__proto__ = e, t
					}, Fe(t, e)
				}
				var Me = function(t) {
					var e, r;

					function i(e, r, i) {
						var n;
						return(n = t.call(this, e, r, i, "[audio-stream-controller]") || this).videoBuffer = null, n.videoTrackCC = -1, n.waitingVideoCC = -1, n.audioSwitch = !1, n.trackId = -1, n.waitingData = null, n.mainDetails = null, n.bufferFlushed = !1, n.cachedTrackLoadedData = null, n._registerListeners(), n
					}
					r = t, (e = i).prototype = Object.create(r.prototype), e.prototype.constructor = e, Fe(e, r);
					var n = i.prototype;
					return n.onHandlerDestroying = function() {
						this._unregisterListeners(), this.mainDetails = null
					}, n._registerListeners = function() {
						var t = this.hls;
						t.on(s.Events.MEDIA_ATTACHED, this.onMediaAttached, this), t.on(s.Events.MEDIA_DETACHING, this.onMediaDetaching, this), t.on(s.Events.MANIFEST_LOADING, this.onManifestLoading, this), t.on(s.Events.LEVEL_LOADED, this.onLevelLoaded, this), t.on(s.Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), t.on(s.Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), t.on(s.Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), t.on(s.Events.ERROR, this.onError, this), t.on(s.Events.BUFFER_RESET, this.onBufferReset, this), t.on(s.Events.BUFFER_CREATED, this.onBufferCreated, this), t.on(s.Events.BUFFER_FLUSHED, this.onBufferFlushed, this), t.on(s.Events.INIT_PTS_FOUND, this.onInitPtsFound, this), t.on(s.Events.FRAG_BUFFERED, this.onFragBuffered, this)
					}, n._unregisterListeners = function() {
						var t = this.hls;
						t.off(s.Events.MEDIA_ATTACHED, this.onMediaAttached, this), t.off(s.Events.MEDIA_DETACHING, this.onMediaDetaching, this), t.off(s.Events.MANIFEST_LOADING, this.onManifestLoading, this), t.off(s.Events.LEVEL_LOADED, this.onLevelLoaded, this), t.off(s.Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), t.off(s.Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), t.off(s.Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), t.off(s.Events.ERROR, this.onError, this), t.off(s.Events.BUFFER_RESET, this.onBufferReset, this), t.off(s.Events.BUFFER_CREATED, this.onBufferCreated, this), t.off(s.Events.BUFFER_FLUSHED, this.onBufferFlushed, this), t.off(s.Events.INIT_PTS_FOUND, this.onInitPtsFound, this), t.off(s.Events.FRAG_BUFFERED, this.onFragBuffered, this)
					}, n.onInitPtsFound = function(t, e) {
						var r = e.frag,
							i = e.id,
							n = e.initPTS;
						if("main" === i) {
							var a = r.cc;
							this.initPTS[r.cc] = n, this.log("InitPTS for cc: " + a + " found from main: " + n), this.videoTrackCC = a, this.state === ue && this.tick()
						}
					}, n.startLoad = function(t) {
						if(!this.levels) return this.startPosition = t, void(this.state = Zt);
						var e = this.lastCurrentTime;
						this.stopLoad(), this.setInterval(100), this.fragLoadError = 0, e > 0 && -1 === t ? (this.log("Override startPosition with lastCurrentTime @" + e.toFixed(3)), t = e, this.state = te) : (this.loadedmetadata = !1, this.state = ne), this.nextLoadPosition = this.startPosition = this.lastCurrentTime = t, this.tick()
					}, n.doTick = function() {
						switch(this.state) {
							case te:
								this.doTickIdle();
								break;
							case ne:
								var e, r = this.levels,
									i = this.trackId,
									n = null == r || null === (e = r[i]) || void 0 === e ? void 0 : e.details;
								if(n) {
									if(this.waitForCdnTuneIn(n)) break;
									this.state = ue
								}
								break;
							case ie:
								var a, s = performance.now(),
									o = this.retryDate;
								(!o || s >= o || null !== (a = this.media) && void 0 !== a && a.seeking) && (this.log("RetryDate reached, switch back to IDLE state"), this.resetStartWhenNotLoaded(this.trackId), this.state = te);
								break;
							case ue:
								var l = this.waitingData;
								if(l) {
									var u = l.frag,
										d = l.part,
										h = l.cache,
										c = l.complete;
									if(void 0 !== this.initPTS[u.cc]) {
										this.waitingData = null, this.waitingVideoCC = -1, this.state = re;
										var f = {
											frag: u,
											part: d,
											payload: h.flush(),
											networkDetails: null
										};
										this._handleFragmentLoadProgress(f), c && t.prototype._handleFragmentLoadComplete.call(this, f)
									} else if(this.videoTrackCC !== this.waitingVideoCC) this.log("Waiting fragment cc (" + u.cc + ") cancelled because video is at cc " + this.videoTrackCC), this.clearWaitingFragment();
									else {
										var g = this.getLoadPosition(),
											v = Bt.bufferInfo(this.mediaBuffer, g, this.config.maxBufferHole);
										qt(v.end, this.config.maxFragLookUpTolerance, u) < 0 && (this.log("Waiting fragment cc (" + u.cc + ") @ " + u.start + " cancelled because another fragment at " + v.end + " is needed"), this.clearWaitingFragment())
									}
								} else this.state = te
						}
						this.onTickEnd()
					}, n.clearWaitingFragment = function() {
						var t = this.waitingData;
						t && (this.fragmentTracker.removeFragment(t.frag), this.waitingData = null, this.waitingVideoCC = -1, this.state = te)
					}, n.resetLoadingState = function() {
						this.clearWaitingFragment(), t.prototype.resetLoadingState.call(this)
					}, n.onTickEnd = function() {
						var t = this.media;
						t && t.readyState && (this.lastCurrentTime = t.currentTime)
					}, n.doTickIdle = function() {
						var t = this.hls,
							e = this.levels,
							r = this.media,
							i = this.trackId,
							n = t.config;
						if(e && e[i] && (r || !this.startFragRequested && n.startFragPrefetch)) {
							var a = e[i].details;
							if(!a || a.live && this.levelLastLoaded !== i || this.waitForCdnTuneIn(a)) this.state = ne;
							else {
								var o = this.mediaBuffer ? this.mediaBuffer : this.media;
								this.bufferFlushed && o && (this.bufferFlushed = !1, this.afterBufferFlushed(o, v.ElementaryStreamTypes.AUDIO, V.PlaylistLevelType.AUDIO));
								var l = this.getFwdBufferInfo(o, V.PlaylistLevelType.AUDIO);
								if(null !== l) {
									var u = this.audioSwitch;
									if(!u && this._streamEnded(l, a)) return t.trigger(s.Events.BUFFER_EOS, {
										type: "audio"
									}), void(this.state = oe);
									var d = this.getFwdBufferInfo(this.videoBuffer ? this.videoBuffer : this.media, V.PlaylistLevelType.MAIN);
									if(!(l.len >= this.getMaxBufferLength(null == d ? void 0 : d.len)) || u) {
										var h = a.fragments[0].start,
											c = l.end;
										if(u && r) {
											var f = this.getLoadPosition();
											c = f, a.PTSKnown && f < h && (l.end > h || l.nextStart) && (this.log("Alt audio track ahead of main track, seek to start of alt audio track"), r.currentTime = h + .05)
										}
										if(!(d && c > d.end + a.targetduration) && (d && d.len || !l.len)) {
											var g = this.getNextFragment(c, a);
											g ? this.loadFragment(g, a, c) : this.bufferFlushed = !0
										}
									}
								}
							}
						}
					}, n.getMaxBufferLength = function(e) {
						var r = t.prototype.getMaxBufferLength.call(this);
						return e ? Math.max(r, e) : r
					}, n.onMediaDetaching = function() {
						this.videoBuffer = null, t.prototype.onMediaDetaching.call(this)
					}, n.onAudioTracksUpdated = function(t, e) {
						var r = e.audioTracks;
						this.resetTransmuxer(), this.levels = r.map((function(t) {
							return new ut(t)
						}))
					}, n.onAudioTrackSwitching = function(t, e) {
						var r = !!e.url;
						this.trackId = e.id;
						var i = this.fragCurrent;
						i && i.abortRequests(), this.fragCurrent = null, this.clearWaitingFragment(), r ? this.setInterval(100) : this.resetTransmuxer(), r ? (this.audioSwitch = !0, this.state = te) : this.state = Zt, this.tick()
					}, n.onManifestLoading = function() {
						this.mainDetails = null, this.fragmentTracker.removeAllFragments(), this.startPosition = this.lastCurrentTime = 0, this.bufferFlushed = !1
					}, n.onLevelLoaded = function(t, e) {
						this.mainDetails = e.details, null !== this.cachedTrackLoadedData && (this.hls.trigger(s.Events.AUDIO_TRACK_LOADED, this.cachedTrackLoadedData), this.cachedTrackLoadedData = null)
					}, n.onAudioTrackLoaded = function(t, e) {
						var r;
						if(null != this.mainDetails) {
							var i = this.levels,
								n = e.details,
								a = e.id;
							if(i) {
								this.log("Track " + a + " loaded [" + n.startSN + "," + n.endSN + "],duration:" + n.totalduration);
								var s = i[a],
									o = 0;
								if(n.live || null !== (r = s.details) && void 0 !== r && r.live) {
									var l = this.mainDetails;
									if(n.fragments[0] || (n.deltaUpdateFailed = !0), n.deltaUpdateFailed || !l) return;
									!s.details && n.hasProgramDateTime && l.hasProgramDateTime ? (Vt(n, l), o = n.fragments[0].start) : o = this.alignPlaylists(n, s.details)
								}
								s.details = n, this.levelLastLoaded = a, this.startFragRequested || !this.mainDetails && n.live || this.setStartPosition(s.details, o), this.state !== ne || this.waitForCdnTuneIn(n) || (this.state = te), this.tick()
							} else this.warn("Audio tracks were reset while loading level " + a)
						} else this.cachedTrackLoadedData = e
					}, n._handleFragmentLoadProgress = function(t) {
						var e, r = t.frag,
							i = t.part,
							n = t.payload,
							a = this.config,
							s = this.trackId,
							o = this.levels;
						if(o) {
							var l = o[s],
								u = l.details,
								d = a.defaultAudioCodec || l.audioCodec || "mp4a.40.2",
								h = this.transmuxer;
							h || (h = this.transmuxer = new Ae(this.hls, V.PlaylistLevelType.AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)));
							var c = this.initPTS[r.cc],
								f = null === (e = r.initSegment) || void 0 === e ? void 0 : e.data;
							if(void 0 !== c) {
								var g = i ? i.index : -1,
									v = -1 !== g,
									p = new Gt(r.level, r.sn, r.stats.chunkCount, n.byteLength, g, v);
								h.push(n, f, d, "", r, i, u.totalduration, !1, p, c)
							} else this.log("Unknown video PTS for cc " + r.cc + ", waiting for video PTS before demuxing audio frag " + r.sn + " of [" + u.startSN + " ," + u.endSN + "],track " + s), (this.waitingData = this.waitingData || {
								frag: r,
								part: i,
								cache: new Pe,
								complete: !1
							}).cache.push(new Uint8Array(n)), this.waitingVideoCC = this.videoTrackCC, this.state = ue
						} else this.warn("Audio tracks were reset while fragment load was in progress. Fragment " + r.sn + " of level " + r.level + " will not be buffered")
					}, n._handleFragmentLoadComplete = function(e) {
						this.waitingData ? this.waitingData.complete = !0 : t.prototype._handleFragmentLoadComplete.call(this, e)
					}, n.onBufferReset = function() {
						this.mediaBuffer = this.videoBuffer = null, this.loadedmetadata = !1
					}, n.onBufferCreated = function(t, e) {
						var r = e.tracks.audio;
						r && (this.mediaBuffer = r.buffer || null), e.tracks.video && (this.videoBuffer = e.tracks.video.buffer || null)
					}, n.onFragBuffered = function(t, e) {
						var r, i = e.frag,
							n = e.part;
						i.type === V.PlaylistLevelType.AUDIO ? this.fragContextChanged(i) ? this.warn("Fragment " + i.sn + (n ? " p: " + n.index : "") + " of level " + i.level + " finished buffering, but was aborted. state: " + this.state + ", audioSwitch: " + this.audioSwitch) : ("initSegment" !== i.sn && (this.fragPrevious = i, this.audioSwitch && (this.audioSwitch = !1, this.hls.trigger(s.Events.AUDIO_TRACK_SWITCHED, {
							id: this.trackId
						}))), this.fragBufferedComplete(i, n)) : this.loadedmetadata || i.type !== V.PlaylistLevelType.MAIN || null !== (r = this.videoBuffer || this.media) && void 0 !== r && r.buffered.length && (this.loadedmetadata = !0)
					}, n.onError = function(e, r) {
						if(r.type !== o.ErrorTypes.KEY_SYSTEM_ERROR) switch(r.details) {
							case o.ErrorDetails.FRAG_LOAD_ERROR:
							case o.ErrorDetails.FRAG_LOAD_TIMEOUT:
							case o.ErrorDetails.FRAG_PARSING_ERROR:
							case o.ErrorDetails.KEY_LOAD_ERROR:
							case o.ErrorDetails.KEY_LOAD_TIMEOUT:
								this.onFragmentOrKeyLoadError(V.PlaylistLevelType.AUDIO, r);
								break;
							case o.ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
							case o.ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
								this.state !== le && this.state !== Zt && (this.state = r.fatal ? le : te, this.warn(r.details + " while loading frag, switching to " + this.state + " state"));
								break;
							case o.ErrorDetails.BUFFER_FULL_ERROR:
								if("audio" === r.parent && (this.state === ae || this.state === se)) {
									var i = !0,
										n = this.getFwdBufferInfo(this.mediaBuffer, V.PlaylistLevelType.AUDIO);
									n && n.len > .5 && (i = !this.reduceMaxBufferLength(n.len)), i && (this.warn("Buffer full error also media.currentTime is not buffered, flush audio buffer"), this.fragCurrent = null, t.prototype.flushMainBuffer.call(this, 0, Number.POSITIVE_INFINITY, "audio")), this.resetLoadingState()
								}
						} else this.onFragmentOrKeyLoadError(V.PlaylistLevelType.AUDIO, r)
					}, n.onBufferFlushed = function(t, e) {
						e.type === v.ElementaryStreamTypes.AUDIO && (this.bufferFlushed = !0, this.state === oe && (this.state = te))
					}, n._handleTransmuxComplete = function(t) {
						var e, r = "audio",
							i = this.hls,
							n = t.remuxResult,
							a = t.chunkMeta,
							o = this.getCurrentContext(a);
						if(!o) return this.warn("The loading context changed while buffering fragment " + a.sn + " of level " + a.level + ". This chunk will not be buffered."), void this.resetStartWhenNotLoaded(a.level);
						var l = o.frag,
							u = o.part,
							d = o.level.details,
							h = n.audio,
							c = n.text,
							f = n.id3,
							g = n.initSegment;
						if(!this.fragContextChanged(l) && d) {
							if(this.state = ae, this.audioSwitch && h && this.completeAudioSwitch(), null != g && g.tracks && (this._bufferInitSegment(g.tracks, l, a), i.trigger(s.Events.FRAG_PARSING_INIT_SEGMENT, {
									frag: l,
									id: r,
									tracks: g.tracks
								})), h) {
								var p = h.startPTS,
									m = h.endPTS,
									y = h.startDTS,
									E = h.endDTS;
								u && (u.elementaryStreams[v.ElementaryStreamTypes.AUDIO] = {
									startPTS: p,
									endPTS: m,
									startDTS: y,
									endDTS: E
								}), l.setElementaryStreamInfo(v.ElementaryStreamTypes.AUDIO, p, m, y, E), this.bufferFragmentData(h, l, u, a)
							}
							if(null != f && null !== (e = f.samples) && void 0 !== e && e.length) {
								var T = xe({
									id: r,
									frag: l,
									details: d
								}, f);
								i.trigger(s.Events.FRAG_PARSING_METADATA, T)
							}
							if(c) {
								var S = xe({
									id: r,
									frag: l,
									details: d
								}, c);
								i.trigger(s.Events.FRAG_PARSING_USERDATA, S)
							}
						}
					}, n._bufferInitSegment = function(t, e, r) {
						if(this.state === ae) {
							t.video && delete t.video;
							var i = t.audio;
							if(i) {
								i.levelCodec = i.codec, i.id = "audio", this.log("Init audio buffer, container:" + i.container + ", codecs[parsed]=[" + i.codec + "]"), this.hls.trigger(s.Events.BUFFER_CODECS, t);
								var n = i.initSegment;
								if(null != n && n.byteLength) {
									var a = {
										type: "audio",
										frag: e,
										part: null,
										chunkMeta: r,
										parent: e.type,
										data: n
									};
									this.hls.trigger(s.Events.BUFFER_APPENDING, a)
								}
								this.tick()
							}
						}
					}, n.loadFragment = function(e, r, i) {
						var n = this.fragmentTracker.getState(e);
						this.fragCurrent = e, (this.audioSwitch || n === St.NOT_LOADED || n === St.PARTIAL) && ("initSegment" === e.sn ? this._loadInitSegment(e, r) : r.live && !(0, a.isFiniteNumber)(this.initPTS[e.cc]) ? (this.log("Waiting for video PTS in continuity counter " + e.cc + " of live stream before loading audio fragment " + e.sn + " of level " + this.trackId), this.state = ue) : (this.startFragRequested = !0, t.prototype.loadFragment.call(this, e, r, i)))
					}, n.completeAudioSwitch = function() {
						var e = this.hls,
							r = this.media,
							i = this.trackId;
						r && (this.log("Switching audio track : flushing all audio"), t.prototype.flushMainBuffer.call(this, 0, Number.POSITIVE_INFINITY, "audio")), this.audioSwitch = !1, e.trigger(s.Events.AUDIO_TRACK_SWITCHED, {
							id: i
						})
					}, i
				}(he);
				const Ne = Me;

				function Ue(t, e) {
					for(var r = 0; r < e.length; r++) {
						var i = e[r];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, (void 0, "symbol" == typeof(n = function(t, e) {
							if("object" != typeof t || null === t) return t;
							var r = t[Symbol.toPrimitive];
							if(void 0 !== r) {
								var i = r.call(t, e);
								if("object" != typeof i) return i;
								throw new TypeError("@@toPrimitive must return a primitive value.")
							}
							return String(t)
						}(i.key, "string")) ? n : String(n)), i)
					}
					var n
				}

				function Be(t, e) {
					return Be = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
						return t.__proto__ = e, t
					}, Be(t, e)
				}
				const Ge = function(t) {
					var e, r;

					function i(e) {
						var r;
						return(r = t.call(this, e, "[audio-track-controller]") || this).tracks = [], r.groupId = null, r.tracksInGroup = [], r.trackId = -1, r.trackName = "", r.selectDefaultTrack = !0, r.registerListeners(), r
					}
					r = t, (e = i).prototype = Object.create(r.prototype), e.prototype.constructor = e, Be(e, r);
					var n, a, l = i.prototype;
					return l.registerListeners = function() {
						var t = this.hls;
						t.on(s.Events.MANIFEST_LOADING, this.onManifestLoading, this), t.on(s.Events.MANIFEST_PARSED, this.onManifestParsed, this), t.on(s.Events.LEVEL_LOADING, this.onLevelLoading, this), t.on(s.Events.LEVEL_SWITCHING, this.onLevelSwitching, this), t.on(s.Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), t.on(s.Events.ERROR, this.onError, this)
					}, l.unregisterListeners = function() {
						var t = this.hls;
						t.off(s.Events.MANIFEST_LOADING, this.onManifestLoading, this), t.off(s.Events.MANIFEST_PARSED, this.onManifestParsed, this), t.off(s.Events.LEVEL_LOADING, this.onLevelLoading, this), t.off(s.Events.LEVEL_SWITCHING, this.onLevelSwitching, this), t.off(s.Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), t.off(s.Events.ERROR, this.onError, this)
					}, l.destroy = function() {
						this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, t.prototype.destroy.call(this)
					}, l.onManifestLoading = function() {
						this.tracks = [], this.groupId = null, this.tracksInGroup = [], this.trackId = -1, this.trackName = "", this.selectDefaultTrack = !0
					}, l.onManifestParsed = function(t, e) {
						this.tracks = e.audioTracks || []
					}, l.onAudioTrackLoaded = function(t, e) {
						var r = e.id,
							i = e.details,
							n = this.tracksInGroup[r];
						if(n) {
							var a = n.details;
							n.details = e.details, this.log("audioTrack " + r + " loaded [" + i.startSN + "-" + i.endSN + "]"), r === this.trackId && (this.retryCount = 0, this.playlistLoaded(r, e, a))
						} else this.warn("Invalid audio track id " + r)
					}, l.onLevelLoading = function(t, e) {
						this.switchLevel(e.level)
					}, l.onLevelSwitching = function(t, e) {
						this.switchLevel(e.level)
					}, l.switchLevel = function(t) {
						var e = this.hls.levels[t];
						if(null != e && e.audioGroupIds) {
							var r = e.audioGroupIds[e.urlId];
							if(this.groupId !== r) {
								this.groupId = r;
								var i = this.tracks.filter((function(t) {
									return !r || t.groupId === r
								}));
								this.selectDefaultTrack && !i.some((function(t) {
									return t.default
								})) && (this.selectDefaultTrack = !1), this.tracksInGroup = i;
								var n = {
									audioTracks: i
								};
								this.log("Updating audio tracks, " + i.length + ' track(s) found in "' + r + '" group-id'), this.hls.trigger(s.Events.AUDIO_TRACKS_UPDATED, n), this.selectInitialTrack()
							}
						}
					}, l.onError = function(e, r) {
						t.prototype.onError.call(this, e, r), !r.fatal && r.context && r.context.type === V.PlaylistContextType.AUDIO_TRACK && r.context.id === this.trackId && r.context.groupId === this.groupId && this.retryLoadingOrFail(r)
					}, l.setAudioTrack = function(t) {
						var e = this.tracksInGroup;
						if(t < 0 || t >= e.length) this.warn("Invalid id passed to audio-track controller");
						else {
							this.clearTimer();
							var r = e[this.trackId];
							this.log("Now switching to audio-track index " + t);
							var i = e[t],
								n = i.id,
								a = i.groupId,
								o = void 0 === a ? "" : a,
								l = i.name,
								u = i.type,
								d = i.url;
							if(this.trackId = t, this.trackName = l, this.selectDefaultTrack = !1, this.hls.trigger(s.Events.AUDIO_TRACK_SWITCHING, {
									id: n,
									groupId: o,
									name: l,
									type: u,
									url: d
								}), !i.details || i.details.live) {
								var h = this.switchParams(i.url, null == r ? void 0 : r.details);
								this.loadPlaylist(h)
							}
						}
					}, l.selectInitialTrack = function() {
						this.tracksInGroup;
						var t = this.trackName,
							e = this.findTrackId(t) || this.findTrackId(); - 1 !== e ? this.setAudioTrack(e) : (this.warn("No track found for running audio group-ID: " + this.groupId), this.hls.trigger(s.Events.ERROR, {
							type: o.ErrorTypes.MEDIA_ERROR,
							details: o.ErrorDetails.AUDIO_TRACK_LOAD_ERROR,
							fatal: !0
						}))
					}, l.findTrackId = function(t) {
						for(var e = this.tracksInGroup, r = 0; r < e.length; r++) {
							var i = e[r];
							if((!this.selectDefaultTrack || i.default) && (!t || t === i.name)) return i.id
						}
						return -1
					}, l.loadPlaylist = function(e) {
						t.prototype.loadPlaylist.call(this);
						var r = this.tracksInGroup[this.trackId];
						if(this.shouldLoadTrack(r)) {
							var i = r.id,
								n = r.groupId,
								a = r.url;
							if(e) try {
								a = e.addDirectives(a)
							} catch(t) {
								this.warn("Could not construct new URL with HLS Delivery Directives: " + t)
							}
							this.log("loading audio-track playlist for id: " + i), this.clearTimer(), this.hls.trigger(s.Events.AUDIO_TRACK_LOADING, {
								url: a,
								id: i,
								groupId: n,
								deliveryDirectives: e || null
							})
						}
					}, n = i, (a = [{
						key: "audioTracks",
						get: function() {
							return this.tracksInGroup
						}
					}, {
						key: "audioTrack",
						get: function() {
							return this.trackId
						},
						set: function(t) {
							this.selectDefaultTrack = !1, this.setAudioTrack(t)
						}
					}]) && Ue(n.prototype, a), Object.defineProperty(n, "prototype", {
						writable: !1
					}), i
				}(mt);

				function Ke(t, e) {
					for(var r = 0; r < e.length; r++) {
						var i = e[r];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, (void 0, "symbol" == typeof(n = function(t, e) {
							if("object" != typeof t || null === t) return t;
							var r = t[Symbol.toPrimitive];
							if(void 0 !== r) {
								var i = r.call(t, e);
								if("object" != typeof i) return i;
								throw new TypeError("@@toPrimitive must return a primitive value.")
							}
							return String(t)
						}(i.key, "string")) ? n : String(n)), i)
					}
					var n
				}

				function He(t, e) {
					return He = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
						return t.__proto__ = e, t
					}, He(t, e)
				}
				var je = function(t) {
						var e, r;

						function i(e, r, i) {
							var n;
							return(n = t.call(this, e, r, i, "[subtitle-stream-controller]") || this).levels = [], n.currentTrackId = -1, n.tracksBuffered = [], n.mainDetails = null, n._registerListeners(), n
						}
						r = t, (e = i).prototype = Object.create(r.prototype), e.prototype.constructor = e, He(e, r);
						var n, a, o = i.prototype;
						return o.onHandlerDestroying = function() {
							this._unregisterListeners(), this.mainDetails = null
						}, o._registerListeners = function() {
							var t = this.hls;
							t.on(s.Events.MEDIA_ATTACHED, this.onMediaAttached, this), t.on(s.Events.MEDIA_DETACHING, this.onMediaDetaching, this), t.on(s.Events.MANIFEST_LOADING, this.onManifestLoading, this), t.on(s.Events.LEVEL_LOADED, this.onLevelLoaded, this), t.on(s.Events.ERROR, this.onError, this), t.on(s.Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), t.on(s.Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), t.on(s.Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), t.on(s.Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), t.on(s.Events.BUFFER_FLUSHING, this.onBufferFlushing, this), t.on(s.Events.FRAG_BUFFERED, this.onFragBuffered, this)
						}, o._unregisterListeners = function() {
							var t = this.hls;
							t.off(s.Events.MEDIA_ATTACHED, this.onMediaAttached, this), t.off(s.Events.MEDIA_DETACHING, this.onMediaDetaching, this), t.off(s.Events.MANIFEST_LOADING, this.onManifestLoading, this), t.off(s.Events.LEVEL_LOADED, this.onLevelLoaded, this), t.off(s.Events.ERROR, this.onError, this), t.off(s.Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), t.off(s.Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), t.off(s.Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), t.off(s.Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), t.off(s.Events.BUFFER_FLUSHING, this.onBufferFlushing, this), t.off(s.Events.FRAG_BUFFERED, this.onFragBuffered, this)
						}, o.startLoad = function(t) {
							this.stopLoad(), this.state = te, this.setInterval(500), this.nextLoadPosition = this.startPosition = this.lastCurrentTime = t, this.tick()
						}, o.onManifestLoading = function() {
							this.mainDetails = null, this.fragmentTracker.removeAllFragments()
						}, o.onLevelLoaded = function(t, e) {
							this.mainDetails = e.details
						}, o.onSubtitleFragProcessed = function(t, e) {
							var r = e.frag,
								i = e.success;
							if(this.fragPrevious = r, this.state = te, i) {
								var n = this.tracksBuffered[this.currentTrackId];
								if(n) {
									for(var a, s = r.start, o = 0; o < n.length; o++)
										if(s >= n[o].start && s <= n[o].end) {
											a = n[o];
											break
										}
									var l = r.start + r.duration;
									a ? a.end = l : (a = {
										start: s,
										end: l
									}, n.push(a)), this.fragmentTracker.fragBuffered(r)
								}
							}
						}, o.onBufferFlushing = function(t, e) {
							var r = e.startOffset,
								i = e.endOffset;
							if(0 === r && i !== Number.POSITIVE_INFINITY) {
								var n = this.currentTrackId,
									a = this.levels;
								if(!a.length || !a[n] || !a[n].details) return;
								var s = i - a[n].details.targetduration;
								if(s <= 0) return;
								e.endOffsetSubtitles = Math.max(0, s), this.tracksBuffered.forEach((function(t) {
									for(var e = 0; e < t.length;)
										if(t[e].end <= s) t.shift();
										else {
											if(!(t[e].start < s)) break;
											t[e].start = s, e++
										}
								})), this.fragmentTracker.removeFragmentsInRange(r, s, V.PlaylistLevelType.SUBTITLE)
							}
						}, o.onFragBuffered = function(t, e) {
							var r;
							this.loadedmetadata || e.frag.type !== V.PlaylistLevelType.MAIN || null !== (r = this.media) && void 0 !== r && r.buffered.length && (this.loadedmetadata = !0)
						}, o.onError = function(t, e) {
							var r = e.frag;
							r && r.type === V.PlaylistLevelType.SUBTITLE && (this.fragCurrent && this.fragCurrent.abortRequests(), this.state = te)
						}, o.onSubtitleTracksUpdated = function(t, e) {
							var r = this,
								i = e.subtitleTracks;
							this.tracksBuffered = [], this.levels = i.map((function(t) {
								return new ut(t)
							})), this.fragmentTracker.removeAllFragments(), this.fragPrevious = null, this.levels.forEach((function(t) {
								r.tracksBuffered[t.id] = []
							})), this.mediaBuffer = null
						}, o.onSubtitleTrackSwitch = function(t, e) {
							if(this.currentTrackId = e.id, this.levels.length && -1 !== this.currentTrackId) {
								var r = this.levels[this.currentTrackId];
								null != r && r.details ? this.mediaBuffer = this.mediaBufferTimeRanges : this.mediaBuffer = null, r && this.setInterval(500)
							} else this.clearInterval()
						}, o.onSubtitleTrackLoaded = function(t, e) {
							var r, i = e.details,
								n = e.id,
								a = this.currentTrackId,
								s = this.levels;
							if(s.length) {
								var o = s[a];
								if(!(n >= s.length || n !== a) && o) {
									this.mediaBuffer = this.mediaBufferTimeRanges;
									var l = 0;
									if(i.live || null !== (r = o.details) && void 0 !== r && r.live) {
										var u = this.mainDetails;
										if(i.deltaUpdateFailed || !u) return;
										var d = u.fragments[0];
										o.details ? 0 === (l = this.alignPlaylists(i, o.details)) && d && pt(i, l = d.start) : i.hasProgramDateTime && u.hasProgramDateTime ? (Vt(i, u), l = i.fragments[0].start) : d && pt(i, l = d.start)
									}
									o.details = i, this.levelLastLoaded = n, this.startFragRequested || !this.mainDetails && i.live || this.setStartPosition(o.details, l), this.tick(), i.live && !this.fragCurrent && this.media && this.state === te && (Wt(null, i.fragments, this.media.currentTime, 0) || (this.warn("Subtitle playlist not aligned with playback"), o.details = void 0))
								}
							}
						}, o._handleFragmentLoadComplete = function(t) {
							var e = this,
								r = t.frag,
								i = t.payload,
								n = r.decryptdata,
								a = this.hls;
							if(!this.fragContextChanged(r) && i && i.byteLength > 0 && n && n.key && n.iv && "AES-128" === n.method) {
								var o = performance.now();
								this.decrypter.decrypt(new Uint8Array(i), n.key.buffer, n.iv.buffer).then((function(t) {
									var e = performance.now();
									a.trigger(s.Events.FRAG_DECRYPTED, {
										frag: r,
										payload: t,
										stats: {
											tstart: o,
											tdecrypt: e
										}
									})
								})).catch((function(t) {
									e.warn(t.name + ": " + t.message), e.state = te
								}))
							}
						}, o.doTick = function() {
							if(this.media) {
								if(this.state === te) {
									var t = this.currentTrackId,
										e = this.levels;
									if(!e.length || !e[t] || !e[t].details) return;
									var r = e[t].details,
										i = r.targetduration,
										n = this.config,
										a = this.getLoadPosition(),
										s = Bt.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], a - i, n.maxBufferHole),
										o = s.end,
										l = s.len,
										u = this.getFwdBufferInfo(this.media, V.PlaylistLevelType.MAIN);
									if(l > this.getMaxBufferLength(null == u ? void 0 : u.len) + i) return;
									var d = r.fragments,
										h = d.length,
										c = r.edge,
										f = null,
										g = this.fragPrevious;
									if(o < c) {
										var v = n.maxFragLookUpTolerance;
										!(f = Wt(g, d, Math.max(d[0].start, o), v)) && g && g.start < d[0].start && (f = d[0])
									} else f = d[h - 1];
									if(!f) return;
									f = this.mapToInitFragWhenRequired(f), this.fragmentTracker.getState(f) === St.NOT_LOADED && this.loadFragment(f, r, o)
								}
							} else this.state = te
						}, o.getMaxBufferLength = function(e) {
							var r = t.prototype.getMaxBufferLength.call(this);
							return e ? Math.max(r, e) : r
						}, o.loadFragment = function(e, r, i) {
							this.fragCurrent = e, "initSegment" === e.sn ? this._loadInitSegment(e, r) : (this.startFragRequested = !0, t.prototype.loadFragment.call(this, e, r, i))
						}, n = i, (a = [{
							key: "mediaBufferTimeRanges",
							get: function() {
								return new Ve(this.tracksBuffered[this.currentTrackId] || [])
							}
						}]) && Ke(n.prototype, a), Object.defineProperty(n, "prototype", {
							writable: !1
						}), i
					}(he),
					Ve = function(t) {
						this.buffered = void 0;
						var e = function(e, r, i) {
							if((r >>>= 0) > i - 1) throw new DOMException("Failed to execute '" + e + "' on 'TimeRanges': The index provided (" + r + ") is greater than the maximum bound (" + i + ")");
							return t[r][e]
						};
						this.buffered = {get length() {
								return t.length
							},
							end: function(r) {
								return e("end", r, t.length)
							},
							start: function(r) {
								return e("start", r, t.length)
							}
						}
					};

				function Ye(t, e) {
					for(var r = 0; r < e.length; r++) {
						var i = e[r];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, (void 0, "symbol" == typeof(n = function(t, e) {
							if("object" != typeof t || null === t) return t;
							var r = t[Symbol.toPrimitive];
							if(void 0 !== r) {
								var i = r.call(t, e);
								if("object" != typeof i) return i;
								throw new TypeError("@@toPrimitive must return a primitive value.")
							}
							return String(t)
						}(i.key, "string")) ? n : String(n)), i)
					}
					var n
				}

				function We(t, e) {
					return We = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
						return t.__proto__ = e, t
					}, We(t, e)
				}

				function qe(t) {
					for(var e = [], r = 0; r < t.length; r++) {
						var i = t[r];
						"subtitles" === i.kind && i.label && e.push(t[r])
					}
					return e
				}
				const Xe = function(t) {
					var e, r;

					function i(e) {
						var r;
						return(r = t.call(this, e, "[subtitle-track-controller]") || this).media = null, r.tracks = [], r.groupId = null, r.tracksInGroup = [], r.trackId = -1, r.selectDefaultTrack = !0, r.queuedDefaultTrack = -1, r.trackChangeListener = function() {
							return r.onTextTracksChanged()
						}, r.asyncPollTrackChange = function() {
							return r.pollTrackChange(0)
						}, r.useTextTrackPolling = !1, r.subtitlePollingInterval = -1, r._subtitleDisplay = !0, r.registerListeners(), r
					}
					r = t, (e = i).prototype = Object.create(r.prototype), e.prototype.constructor = e, We(e, r);
					var n, a, o = i.prototype;
					return o.destroy = function() {
						this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.trackChangeListener = this.asyncPollTrackChange = null, t.prototype.destroy.call(this)
					}, o.registerListeners = function() {
						var t = this.hls;
						t.on(s.Events.MEDIA_ATTACHED, this.onMediaAttached, this), t.on(s.Events.MEDIA_DETACHING, this.onMediaDetaching, this), t.on(s.Events.MANIFEST_LOADING, this.onManifestLoading, this), t.on(s.Events.MANIFEST_PARSED, this.onManifestParsed, this), t.on(s.Events.LEVEL_LOADING, this.onLevelLoading, this), t.on(s.Events.LEVEL_SWITCHING, this.onLevelSwitching, this), t.on(s.Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), t.on(s.Events.ERROR, this.onError, this)
					}, o.unregisterListeners = function() {
						var t = this.hls;
						t.off(s.Events.MEDIA_ATTACHED, this.onMediaAttached, this), t.off(s.Events.MEDIA_DETACHING, this.onMediaDetaching, this), t.off(s.Events.MANIFEST_LOADING, this.onManifestLoading, this), t.off(s.Events.MANIFEST_PARSED, this.onManifestParsed, this), t.off(s.Events.LEVEL_LOADING, this.onLevelLoading, this), t.off(s.Events.LEVEL_SWITCHING, this.onLevelSwitching, this), t.off(s.Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), t.off(s.Events.ERROR, this.onError, this)
					}, o.onMediaAttached = function(t, e) {
						this.media = e.media, this.media && (this.queuedDefaultTrack > -1 && (this.subtitleTrack = this.queuedDefaultTrack, this.queuedDefaultTrack = -1), this.useTextTrackPolling = !(this.media.textTracks && "onchange" in this.media.textTracks), this.useTextTrackPolling ? this.pollTrackChange(500) : this.media.textTracks.addEventListener("change", this.asyncPollTrackChange))
					}, o.pollTrackChange = function(t) {
						self.clearInterval(this.subtitlePollingInterval), this.subtitlePollingInterval = self.setInterval(this.trackChangeListener, t)
					}, o.onMediaDetaching = function() {
						this.media && (self.clearInterval(this.subtitlePollingInterval), this.useTextTrackPolling || this.media.textTracks.removeEventListener("change", this.asyncPollTrackChange), this.trackId > -1 && (this.queuedDefaultTrack = this.trackId), qe(this.media.textTracks).forEach((function(t) {
							z(t)
						})), this.subtitleTrack = -1, this.media = null)
					}, o.onManifestLoading = function() {
						this.tracks = [], this.groupId = null, this.tracksInGroup = [], this.trackId = -1, this.selectDefaultTrack = !0
					}, o.onManifestParsed = function(t, e) {
						this.tracks = e.subtitleTracks
					}, o.onSubtitleTrackLoaded = function(t, e) {
						var r = e.id,
							i = e.details,
							n = this.trackId,
							a = this.tracksInGroup[n];
						if(a) {
							var s = a.details;
							a.details = e.details, this.log("subtitle track " + r + " loaded [" + i.startSN + "-" + i.endSN + "]"), r === this.trackId && (this.retryCount = 0, this.playlistLoaded(r, e, s))
						} else this.warn("Invalid subtitle track id " + r)
					}, o.onLevelLoading = function(t, e) {
						this.switchLevel(e.level)
					}, o.onLevelSwitching = function(t, e) {
						this.switchLevel(e.level)
					}, o.switchLevel = function(t) {
						var e = this.hls.levels[t];
						if(null != e && e.textGroupIds) {
							var r = e.textGroupIds[e.urlId];
							if(this.groupId !== r) {
								var i = this.tracksInGroup ? this.tracksInGroup[this.trackId] : void 0,
									n = this.tracks.filter((function(t) {
										return !r || t.groupId === r
									}));
								this.tracksInGroup = n;
								var a = this.findTrackId(null == i ? void 0 : i.name) || this.findTrackId();
								this.groupId = r;
								var o = {
									subtitleTracks: n
								};
								this.log("Updating subtitle tracks, " + n.length + ' track(s) found in "' + r + '" group-id'), this.hls.trigger(s.Events.SUBTITLE_TRACKS_UPDATED, o), -1 !== a && this.setSubtitleTrack(a, i)
							}
						}
					}, o.findTrackId = function(t) {
						for(var e = this.tracksInGroup, r = 0; r < e.length; r++) {
							var i = e[r];
							if((!this.selectDefaultTrack || i.default) && (!t || t === i.name)) return i.id
						}
						return -1
					}, o.onError = function(e, r) {
						t.prototype.onError.call(this, e, r), !r.fatal && r.context && r.context.type === V.PlaylistContextType.SUBTITLE_TRACK && r.context.id === this.trackId && r.context.groupId === this.groupId && this.retryLoadingOrFail(r)
					}, o.loadPlaylist = function(e) {
						t.prototype.loadPlaylist.call(this);
						var r = this.tracksInGroup[this.trackId];
						if(this.shouldLoadTrack(r)) {
							var i = r.id,
								n = r.groupId,
								a = r.url;
							if(e) try {
								a = e.addDirectives(a)
							} catch(t) {
								this.warn("Could not construct new URL with HLS Delivery Directives: " + t)
							}
							this.log("Loading subtitle playlist for id " + i), this.hls.trigger(s.Events.SUBTITLE_TRACK_LOADING, {
								url: a,
								id: i,
								groupId: n,
								deliveryDirectives: e || null
							})
						}
					}, o.toggleTrackModes = function(t) {
						var e = this,
							r = this.media,
							i = this.trackId;
						if(r) {
							var n = qe(r.textTracks),
								a = n.filter((function(t) {
									return t.groupId === e.groupId
								}));
							if(-1 === t)[].slice.call(n).forEach((function(t) {
								t.mode = "disabled"
							}));
							else {
								var s = a[i];
								s && (s.mode = "disabled")
							}
							var o = a[t];
							o && (o.mode = this.subtitleDisplay ? "showing" : "hidden")
						}
					}, o.setSubtitleTrack = function(t, e) {
						var r, i = this.tracksInGroup;
						if(this.media) {
							if(this.trackId !== t && this.toggleTrackModes(t), !(this.trackId === t && (-1 === t || null !== (r = i[t]) && void 0 !== r && r.details) || t < -1 || t >= i.length)) {
								this.clearTimer();
								var n = i[t];
								if(this.log("Switching to subtitle track " + t), this.trackId = t, n) {
									var a = n.id,
										o = n.groupId,
										l = void 0 === o ? "" : o,
										u = n.name,
										d = n.type,
										h = n.url;
									this.hls.trigger(s.Events.SUBTITLE_TRACK_SWITCH, {
										id: a,
										groupId: l,
										name: u,
										type: d,
										url: h
									});
									var c = this.switchParams(n.url, null == e ? void 0 : e.details);
									this.loadPlaylist(c)
								} else this.hls.trigger(s.Events.SUBTITLE_TRACK_SWITCH, {
									id: t
								})
							}
						} else this.queuedDefaultTrack = t
					}, o.onTextTracksChanged = function() {
						if(this.useTextTrackPolling || self.clearInterval(this.subtitlePollingInterval), this.media && this.hls.config.renderTextTracksNatively) {
							for(var t = -1, e = qe(this.media.textTracks), r = 0; r < e.length; r++)
								if("hidden" === e[r].mode) t = r;
								else if("showing" === e[r].mode) {
								t = r;
								break
							}
							this.subtitleTrack !== t && (this.subtitleTrack = t)
						}
					}, n = i, (a = [{
						key: "subtitleDisplay",
						get: function() {
							return this._subtitleDisplay
						},
						set: function(t) {
							this._subtitleDisplay = t, this.trackId > -1 && this.toggleTrackModes(this.trackId)
						}
					}, {
						key: "subtitleTracks",
						get: function() {
							return this.tracksInGroup
						}
					}, {
						key: "subtitleTrack",
						get: function() {
							return this.trackId
						},
						set: function(t) {
							this.selectDefaultTrack = !1;
							var e = this.tracksInGroup ? this.tracksInGroup[this.trackId] : void 0;
							this.setSubtitleTrack(t, e)
						}
					}]) && Ye(n.prototype, a), Object.defineProperty(n, "prototype", {
						writable: !1
					}), i
				}(mt);
				var ze, Qe = function() {
						function t(t) {
							this.buffers = void 0, this.queues = {
								video: [],
								audio: [],
								audiovideo: []
							}, this.buffers = t
						}
						var e = t.prototype;
						return e.append = function(t, e) {
							var r = this.queues[e];
							r.push(t), 1 === r.length && this.buffers[e] && this.executeNext(e)
						}, e.insertAbort = function(t, e) {
							this.queues[e].unshift(t), this.executeNext(e)
						}, e.appendBlocker = function(t) {
							var e, r = new Promise((function(t) {
									e = t
								})),
								i = {
									execute: e,
									onStart: function() {},
									onComplete: function() {},
									onError: function() {}
								};
							return this.append(i, t), r
						}, e.executeNext = function(t) {
							var e = this.buffers,
								r = this.queues,
								i = e[t],
								n = r[t];
							if(n.length) {
								var a = n[0];
								try {
									a.execute()
								} catch(e) {
									l.logger.warn("[buffer-operation-queue]: Unhandled exception executing the current operation"), a.onError(e), i && i.updating || (n.shift(), this.executeNext(t))
								}
							}
						}, e.shiftAndExecuteNext = function(t) {
							this.queues[t].shift(), this.executeNext(t)
						}, e.current = function(t) {
							return this.queues[t][0]
						}, t
					}(),
					$e = ce(),
					Je = /([ha]vc.)(?:\.[^.,]+)+/,
					Ze = function() {
						function t(t) {
							var e = this;
							this.details = null, this._objectUrl = null, this.operationQueue = void 0, this.listeners = void 0, this.hls = void 0, this.bufferCodecEventsExpected = 0, this._bufferCodecEventsTotal = 0, this.media = null, this.mediaSource = null, this.lastMpegAudioChunk = null, this.appendError = 0, this.tracks = {}, this.pendingTracks = {}, this.sourceBuffer = void 0, this._onMediaSourceOpen = function() {
								var t = e.media,
									r = e.mediaSource;
								l.logger.log("[buffer-controller]: Media source opened"), t && (t.removeEventListener("emptied", e._onMediaEmptied), e.updateMediaElementDuration(), e.hls.trigger(s.Events.MEDIA_ATTACHED, {
									media: t
								})), r && r.removeEventListener("sourceopen", e._onMediaSourceOpen), e.checkPendingTracks()
							}, this._onMediaSourceClose = function() {
								l.logger.log("[buffer-controller]: Media source closed")
							}, this._onMediaSourceEnded = function() {
								l.logger.log("[buffer-controller]: Media source ended")
							}, this._onMediaEmptied = function() {
								var t = e.media,
									r = e._objectUrl;
								t && t.src !== r && l.logger.error("Media element src was set while attaching MediaSource (" + r + " > " + t.src + ")")
							}, this.hls = t, this._initSourceBuffer(), this.registerListeners()
						}
						var e = t.prototype;
						return e.hasSourceTypes = function() {
							return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0
						}, e.destroy = function() {
							this.unregisterListeners(), this.details = null, this.lastMpegAudioChunk = null
						}, e.registerListeners = function() {
							var t = this.hls;
							t.on(s.Events.MEDIA_ATTACHING, this.onMediaAttaching, this), t.on(s.Events.MEDIA_DETACHING, this.onMediaDetaching, this), t.on(s.Events.MANIFEST_PARSED, this.onManifestParsed, this), t.on(s.Events.BUFFER_RESET, this.onBufferReset, this), t.on(s.Events.BUFFER_APPENDING, this.onBufferAppending, this), t.on(s.Events.BUFFER_CODECS, this.onBufferCodecs, this), t.on(s.Events.BUFFER_EOS, this.onBufferEos, this), t.on(s.Events.BUFFER_FLUSHING, this.onBufferFlushing, this), t.on(s.Events.LEVEL_UPDATED, this.onLevelUpdated, this), t.on(s.Events.FRAG_PARSED, this.onFragParsed, this), t.on(s.Events.FRAG_CHANGED, this.onFragChanged, this)
						}, e.unregisterListeners = function() {
							var t = this.hls;
							t.off(s.Events.MEDIA_ATTACHING, this.onMediaAttaching, this), t.off(s.Events.MEDIA_DETACHING, this.onMediaDetaching, this), t.off(s.Events.MANIFEST_PARSED, this.onManifestParsed, this), t.off(s.Events.BUFFER_RESET, this.onBufferReset, this), t.off(s.Events.BUFFER_APPENDING, this.onBufferAppending, this), t.off(s.Events.BUFFER_CODECS, this.onBufferCodecs, this), t.off(s.Events.BUFFER_EOS, this.onBufferEos, this), t.off(s.Events.BUFFER_FLUSHING, this.onBufferFlushing, this), t.off(s.Events.LEVEL_UPDATED, this.onLevelUpdated, this), t.off(s.Events.FRAG_PARSED, this.onFragParsed, this), t.off(s.Events.FRAG_CHANGED, this.onFragChanged, this)
						}, e._initSourceBuffer = function() {
							this.sourceBuffer = {}, this.operationQueue = new Qe(this.sourceBuffer), this.listeners = {
								audio: [],
								video: [],
								audiovideo: []
							}, this.lastMpegAudioChunk = null
						}, e.onManifestParsed = function(t, e) {
							var r = 2;
							(e.audio && !e.video || !e.altAudio) && (r = 1), this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = r, this.details = null, l.logger.log(this.bufferCodecEventsExpected + " bufferCodec event(s) expected")
						}, e.onMediaAttaching = function(t, e) {
							var r = this.media = e.media;
							if(r && $e) {
								var i = this.mediaSource = new $e;
								i.addEventListener("sourceopen", this._onMediaSourceOpen), i.addEventListener("sourceended", this._onMediaSourceEnded), i.addEventListener("sourceclose", this._onMediaSourceClose), r.src = self.URL.createObjectURL(i), this._objectUrl = r.src, r.addEventListener("emptied", this._onMediaEmptied)
							}
						}, e.onMediaDetaching = function() {
							var t = this.media,
								e = this.mediaSource,
								r = this._objectUrl;
							if(e) {
								if(l.logger.log("[buffer-controller]: media source detaching"), "open" === e.readyState) try {
									e.endOfStream()
								} catch(t) {
									l.logger.warn("[buffer-controller]: onMediaDetaching: " + t.message + " while calling endOfStream")
								}
								this.onBufferReset(), e.removeEventListener("sourceopen", this._onMediaSourceOpen), e.removeEventListener("sourceended", this._onMediaSourceEnded), e.removeEventListener("sourceclose", this._onMediaSourceClose), t && (t.removeEventListener("emptied", this._onMediaEmptied), r && self.URL.revokeObjectURL(r), t.src === r ? (t.removeAttribute("src"), t.load()) : l.logger.warn("[buffer-controller]: media.src was changed by a third party - skip cleanup")), this.mediaSource = null, this.media = null, this._objectUrl = null, this.bufferCodecEventsExpected = this._bufferCodecEventsTotal, this.pendingTracks = {}, this.tracks = {}
							}
							this.hls.trigger(s.Events.MEDIA_DETACHED, void 0)
						}, e.onBufferReset = function() {
							var t = this;
							this.getSourceBufferTypes().forEach((function(e) {
								var r = t.sourceBuffer[e];
								try {
									r && (t.removeBufferListeners(e), t.mediaSource && t.mediaSource.removeSourceBuffer(r), t.sourceBuffer[e] = void 0)
								} catch(t) {
									l.logger.warn("[buffer-controller]: Failed to reset the " + e + " buffer", t)
								}
							})), this._initSourceBuffer()
						}, e.onBufferCodecs = function(t, e) {
							var r = this,
								i = this.getSourceBufferTypes().length;
							Object.keys(e).forEach((function(t) {
								if(i) {
									var n = r.tracks[t];
									if(n && "function" == typeof n.buffer.changeType) {
										var a = e[t],
											s = a.id,
											o = a.codec,
											u = a.levelCodec,
											d = a.container,
											h = a.metadata,
											c = (n.levelCodec || n.codec).replace(Je, "$1"),
											f = (u || o).replace(Je, "$1");
										if(c !== f) {
											var g = d + ";codecs=" + (u || o);
											r.appendChangeType(t, g), l.logger.log("[buffer-controller]: switching codec " + c + " to " + f), r.tracks[t] = {
												buffer: n.buffer,
												codec: o,
												container: d,
												levelCodec: u,
												metadata: h,
												id: s
											}
										}
									}
								} else r.pendingTracks[t] = e[t]
							})), i || (this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0), this.mediaSource && "open" === this.mediaSource.readyState && this.checkPendingTracks())
						}, e.appendChangeType = function(t, e) {
							var r = this,
								i = this.operationQueue,
								n = {
									execute: function() {
										var n = r.sourceBuffer[t];
										n && (l.logger.log("[buffer-controller]: changing " + t + " sourceBuffer type to " + e), n.changeType(e)), i.shiftAndExecuteNext(t)
									},
									onStart: function() {},
									onComplete: function() {},
									onError: function(e) {
										l.logger.warn("[buffer-controller]: Failed to change " + t + " SourceBuffer type", e)
									}
								};
							i.append(n, t)
						}, e.onBufferAppending = function(t, e) {
							var r = this,
								i = this.hls,
								n = this.operationQueue,
								a = this.tracks,
								u = e.data,
								d = e.type,
								h = e.frag,
								c = e.part,
								f = e.chunkMeta,
								g = f.buffering[d],
								v = self.performance.now();
							g.start = v;
							var p = h.stats.buffering,
								m = c ? c.stats.buffering : null;
							0 === p.start && (p.start = v), m && 0 === m.start && (m.start = v);
							var y = a.audio,
								E = !1;
							"audio" === d && "audio/mpeg" === (null == y ? void 0 : y.container) && (E = !this.lastMpegAudioChunk || 1 === f.id || this.lastMpegAudioChunk.sn !== f.sn, this.lastMpegAudioChunk = f);
							var T = h.start,
								S = {
									execute: function() {
										if(g.executeStart = self.performance.now(), E) {
											var t = r.sourceBuffer[d];
											if(t) {
												var e = T - t.timestampOffset;
												Math.abs(e) >= .1 && (l.logger.log("[buffer-controller]: Updating audio SourceBuffer timestampOffset to " + T + " (delta: " + e + ") sn: " + h.sn + ")"), t.timestampOffset = T)
											}
										}
										r.appendExecutor(u, d)
									},
									onStart: function() {},
									onComplete: function() {
										var t = self.performance.now();
										g.executeEnd = g.end = t, 0 === p.first && (p.first = t), m && 0 === m.first && (m.first = t);
										var e = r.sourceBuffer,
											i = {};
										for(var n in e) i[n] = Bt.getBuffered(e[n]);
										r.appendError = 0, r.hls.trigger(s.Events.BUFFER_APPENDED, {
											type: d,
											frag: h,
											part: c,
											chunkMeta: f,
											parent: h.type,
											timeRanges: i
										})
									},
									onError: function(t) {
										l.logger.error("[buffer-controller]: Error encountered while trying to append to the " + d + " SourceBuffer", t);
										var e = {
											type: o.ErrorTypes.MEDIA_ERROR,
											parent: h.type,
											details: o.ErrorDetails.BUFFER_APPEND_ERROR,
											err: t,
											fatal: !1
										};
										t.code === DOMException.QUOTA_EXCEEDED_ERR ? e.details = o.ErrorDetails.BUFFER_FULL_ERROR : (r.appendError++, e.details = o.ErrorDetails.BUFFER_APPEND_ERROR, r.appendError > i.config.appendErrorMaxRetry && (l.logger.error("[buffer-controller]: Failed " + i.config.appendErrorMaxRetry + " times to append segment in sourceBuffer"), e.fatal = !0, i.stopLoad())), i.trigger(s.Events.ERROR, e)
									}
								};
							n.append(S, d)
						}, e.onBufferFlushing = function(t, e) {
							var r = this,
								i = this.operationQueue,
								n = function(t) {
									return {
										execute: r.removeExecutor.bind(r, t, e.startOffset, e.endOffset),
										onStart: function() {},
										onComplete: function() {
											r.hls.trigger(s.Events.BUFFER_FLUSHED, {
												type: t
											})
										},
										onError: function(e) {
											l.logger.warn("[buffer-controller]: Failed to remove from " + t + " SourceBuffer", e)
										}
									}
								};
							e.type ? i.append(n(e.type), e.type) : this.getSourceBufferTypes().forEach((function(t) {
								i.append(n(t), t)
							}))
						}, e.onFragParsed = function(t, e) {
							var r = this,
								i = e.frag,
								n = e.part,
								a = [],
								o = n ? n.elementaryStreams : i.elementaryStreams;
							o[v.ElementaryStreamTypes.AUDIOVIDEO] ? a.push("audiovideo") : (o[v.ElementaryStreamTypes.AUDIO] && a.push("audio"), o[v.ElementaryStreamTypes.VIDEO] && a.push("video")), 0 === a.length && l.logger.warn("Fragments must have at least one ElementaryStreamType set. type: " + i.type + " level: " + i.level + " sn: " + i.sn), this.blockBuffers((function() {
								var t = self.performance.now();
								i.stats.buffering.end = t, n && (n.stats.buffering.end = t);
								var e = n ? n.stats : i.stats;
								r.hls.trigger(s.Events.FRAG_BUFFERED, {
									frag: i,
									part: n,
									stats: e,
									id: i.type
								})
							}), a)
						}, e.onFragChanged = function(t, e) {
							this.flushBackBuffer()
						}, e.onBufferEos = function(t, e) {
							var r = this;
							this.getSourceBufferTypes().reduce((function(t, i) {
								var n = r.sourceBuffer[i];
								return !n || e.type && e.type !== i || (n.ending = !0, n.ended || (n.ended = !0, l.logger.log("[buffer-controller]: " + i + " sourceBuffer now EOS"))), t && !(n && !n.ended)
							}), !0) && (l.logger.log("[buffer-controller]: Queueing mediaSource.endOfStream()"), this.blockBuffers((function() {
								r.getSourceBufferTypes().forEach((function(t) {
									var e = r.sourceBuffer[t];
									e && (e.ending = !1)
								}));
								var t = r.mediaSource;
								t && "open" === t.readyState ? (l.logger.log("[buffer-controller]: Calling mediaSource.endOfStream()"), t.endOfStream()) : t && l.logger.info("[buffer-controller]: Could not call mediaSource.endOfStream(). mediaSource.readyState: " + t.readyState)
							})))
						}, e.onLevelUpdated = function(t, e) {
							var r = e.details;
							r.fragments.length && (this.details = r, this.getSourceBufferTypes().length ? this.blockBuffers(this.updateMediaElementDuration.bind(this)) : this.updateMediaElementDuration())
						}, e.flushBackBuffer = function() {
							var t = this.hls,
								e = this.details,
								r = this.media,
								i = this.sourceBuffer;
							if(r && null !== e) {
								var n = this.getSourceBufferTypes();
								if(n.length) {
									var o = e.live && null !== t.config.liveBackBufferLength ? t.config.liveBackBufferLength : t.config.backBufferLength;
									if((0, a.isFiniteNumber)(o) && !(o < 0)) {
										var u = r.currentTime,
											d = e.levelTargetDuration,
											h = Math.max(o, d),
											c = Math.floor(u / d) * d - h;
										n.forEach((function(r) {
											var n = i[r];
											if(n) {
												var a = Bt.getBuffered(n);
												if(a.length > 0 && c > a.start(0)) {
													if(t.trigger(s.Events.BACK_BUFFER_REACHED, {
															bufferEnd: c
														}), e.live) t.trigger(s.Events.LIVE_BACK_BUFFER_REACHED, {
														bufferEnd: c
													});
													else if(n.ended && a.end(a.length - 1) - u < 2 * d) return void l.logger.info("[buffer-controller]: Cannot flush " + r + " back buffer while SourceBuffer is in ended state");
													t.trigger(s.Events.BUFFER_FLUSHING, {
														startOffset: 0,
														endOffset: c,
														type: r
													})
												}
											}
										}))
									}
								}
							}
						}, e.updateMediaElementDuration = function() {
							if(this.details && this.media && this.mediaSource && "open" === this.mediaSource.readyState) {
								var t = this.details,
									e = this.hls,
									r = this.media,
									i = this.mediaSource,
									n = t.fragments[0].start + t.totalduration,
									s = r.duration,
									o = (0, a.isFiniteNumber)(i.duration) ? i.duration : 0;
								t.live && e.config.liveDurationInfinity ? (l.logger.log("[buffer-controller]: Media Source duration is set to Infinity"), i.duration = 1 / 0, this.updateSeekableRange(t)) : (n > o && n > s || !(0, a.isFiniteNumber)(s)) && (l.logger.log("[buffer-controller]: Updating Media Source duration to " + n.toFixed(3)), i.duration = n)
							}
						}, e.updateSeekableRange = function(t) {
							var e = this.mediaSource,
								r = t.fragments;
							if(r.length && t.live && null != e && e.setLiveSeekableRange) {
								var i = Math.max(0, r[0].start),
									n = Math.max(i, i + t.totalduration);
								e.setLiveSeekableRange(i, n)
							}
						}, e.checkPendingTracks = function() {
							var t = this.bufferCodecEventsExpected,
								e = this.operationQueue,
								r = this.pendingTracks,
								i = Object.keys(r).length;
							if(i && !t || 2 === i) {
								this.createSourceBuffers(r), this.pendingTracks = {};
								var n = this.getSourceBufferTypes();
								if(0 === n.length) return void this.hls.trigger(s.Events.ERROR, {
									type: o.ErrorTypes.MEDIA_ERROR,
									details: o.ErrorDetails.BUFFER_INCOMPATIBLE_CODECS_ERROR,
									fatal: !0,
									reason: "could not create source buffer for media codec(s)"
								});
								n.forEach((function(t) {
									e.executeNext(t)
								}))
							}
						}, e.createSourceBuffers = function(t) {
							var e = this.sourceBuffer,
								r = this.mediaSource;
							if(!r) throw Error("createSourceBuffers called when mediaSource was null");
							var i = 0;
							for(var n in t)
								if(!e[n]) {
									var a = t[n];
									if(!a) throw Error("source buffer exists for track " + n + ", however track does not");
									var u = a.levelCodec || a.codec,
										d = a.container + ";codecs=" + u;
									l.logger.log("[buffer-controller]: creating sourceBuffer(" + d + ")");
									try {
										var h = e[n] = r.addSourceBuffer(d),
											c = n;
										this.addBufferListener(c, "updatestart", this._onSBUpdateStart), this.addBufferListener(c, "updateend", this._onSBUpdateEnd), this.addBufferListener(c, "error", this._onSBUpdateError), this.tracks[n] = {
											buffer: h,
											codec: u,
											container: a.container,
											levelCodec: a.levelCodec,
											metadata: a.metadata,
											id: a.id
										}, i++
									} catch(t) {
										l.logger.error("[buffer-controller]: error while trying to add sourceBuffer: " + t.message), this.hls.trigger(s.Events.ERROR, {
											type: o.ErrorTypes.MEDIA_ERROR,
											details: o.ErrorDetails.BUFFER_ADD_CODEC_ERROR,
											fatal: !1,
											error: t,
											mimeType: d
										})
									}
								}
							i && this.hls.trigger(s.Events.BUFFER_CREATED, {
								tracks: this.tracks
							})
						}, e._onSBUpdateStart = function(t) {
							this.operationQueue.current(t).onStart()
						}, e._onSBUpdateEnd = function(t) {
							var e = this.operationQueue;
							e.current(t).onComplete(), e.shiftAndExecuteNext(t)
						}, e._onSBUpdateError = function(t, e) {
							l.logger.error("[buffer-controller]: " + t + " SourceBuffer error", e), this.hls.trigger(s.Events.ERROR, {
								type: o.ErrorTypes.MEDIA_ERROR,
								details: o.ErrorDetails.BUFFER_APPENDING_ERROR,
								fatal: !1
							});
							var r = this.operationQueue.current(t);
							r && r.onError(e)
						}, e.removeExecutor = function(t, e, r) {
							var i = this.media,
								n = this.mediaSource,
								s = this.operationQueue,
								o = this.sourceBuffer[t];
							if(!i || !n || !o) return l.logger.warn("[buffer-controller]: Attempting to remove from the " + t + " SourceBuffer, but it does not exist"), void s.shiftAndExecuteNext(t);
							var u = (0, a.isFiniteNumber)(i.duration) ? i.duration : 1 / 0,
								d = (0, a.isFiniteNumber)(n.duration) ? n.duration : 1 / 0,
								h = Math.max(0, e),
								c = Math.min(r, u, d);
							c > h && !o.ending ? (o.ended = !1, l.logger.log("[buffer-controller]: Removing [" + h + "," + c + "] from the " + t + " SourceBuffer"), o.remove(h, c)) : s.shiftAndExecuteNext(t)
						}, e.appendExecutor = function(t, e) {
							var r = this.operationQueue,
								i = this.sourceBuffer[e];
							if(!i) return l.logger.warn("[buffer-controller]: Attempting to append to the " + e + " SourceBuffer, but it does not exist"), void r.shiftAndExecuteNext(e);
							i.ended = !1, i.appendBuffer(t)
						}, e.blockBuffers = function(t, e) {
							var r = this;
							if(void 0 === e && (e = this.getSourceBufferTypes()), !e.length) return l.logger.log("[buffer-controller]: Blocking operation requested, but no SourceBuffers exist"), void Promise.resolve().then(t);
							var i = this.operationQueue,
								n = e.map((function(t) {
									return i.appendBlocker(t)
								}));
							Promise.all(n).then((function() {
								t(), e.forEach((function(t) {
									var e = r.sourceBuffer[t];
									e && e.updating || i.shiftAndExecuteNext(t)
								}))
							}))
						}, e.getSourceBufferTypes = function() {
							return Object.keys(this.sourceBuffer)
						}, e.addBufferListener = function(t, e, r) {
							var i = this.sourceBuffer[t];
							if(i) {
								var n = r.bind(this, t);
								this.listeners[t].push({
									event: e,
									listener: n
								}), i.addEventListener(e, n)
							}
						}, e.removeBufferListeners = function(t) {
							var e = this.sourceBuffer[t];
							e && this.listeners[t].forEach((function(t) {
								e.removeEventListener(t.event, t.listener)
							}))
						}, t
					}(),
					tr = {
						42: 225,
						92: 233,
						94: 237,
						95: 243,
						96: 250,
						123: 231,
						124: 247,
						125: 209,
						126: 241,
						127: 9608,
						128: 174,
						129: 176,
						130: 189,
						131: 191,
						132: 8482,
						133: 162,
						134: 163,
						135: 9834,
						136: 224,
						137: 32,
						138: 232,
						139: 226,
						140: 234,
						141: 238,
						142: 244,
						143: 251,
						144: 193,
						145: 201,
						146: 211,
						147: 218,
						148: 220,
						149: 252,
						150: 8216,
						151: 161,
						152: 42,
						153: 8217,
						154: 9473,
						155: 169,
						156: 8480,
						157: 8226,
						158: 8220,
						159: 8221,
						160: 192,
						161: 194,
						162: 199,
						163: 200,
						164: 202,
						165: 203,
						166: 235,
						167: 206,
						168: 207,
						169: 239,
						170: 212,
						171: 217,
						172: 249,
						173: 219,
						174: 171,
						175: 187,
						176: 195,
						177: 227,
						178: 205,
						179: 204,
						180: 236,
						181: 210,
						182: 242,
						183: 213,
						184: 245,
						185: 123,
						186: 125,
						187: 92,
						188: 94,
						189: 95,
						190: 124,
						191: 8764,
						192: 196,
						193: 228,
						194: 214,
						195: 246,
						196: 223,
						197: 165,
						198: 164,
						199: 9475,
						200: 197,
						201: 229,
						202: 216,
						203: 248,
						204: 9487,
						205: 9491,
						206: 9495,
						207: 9499
					},
					er = function(t) {
						var e = t;
						return tr.hasOwnProperty(t) && (e = tr[t]), String.fromCharCode(e)
					},
					rr = 15,
					ir = 100,
					nr = {
						17: 1,
						18: 3,
						21: 5,
						22: 7,
						23: 9,
						16: 11,
						19: 12,
						20: 14
					},
					ar = {
						17: 2,
						18: 4,
						21: 6,
						22: 8,
						23: 10,
						19: 13,
						20: 15
					},
					sr = {
						25: 1,
						26: 3,
						29: 5,
						30: 7,
						31: 9,
						24: 11,
						27: 12,
						28: 14
					},
					or = {
						25: 2,
						26: 4,
						29: 6,
						30: 8,
						31: 10,
						27: 13,
						28: 15
					},
					lr = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"];
				! function(t) {
					t[t.ERROR = 0] = "ERROR", t[t.TEXT = 1] = "TEXT", t[t.WARNING = 2] = "WARNING", t[t.INFO = 2] = "INFO", t[t.DEBUG = 3] = "DEBUG", t[t.DATA = 3] = "DATA"
				}(ze || (ze = {}));
				var ur = function() {
						function t() {
							this.time = null, this.verboseLevel = ze.ERROR
						}
						return t.prototype.log = function(t, e) {
							if(this.verboseLevel >= t) {
								var r = "function" == typeof e ? e() : e;
								l.logger.log(this.time + " [" + t + "] " + r)
							}
						}, t
					}(),
					dr = function(t) {
						for(var e = [], r = 0; r < t.length; r++) e.push(t[r].toString(16));
						return e
					},
					hr = function() {
						function t(t, e, r, i, n) {
							this.foreground = void 0, this.underline = void 0, this.italics = void 0, this.background = void 0, this.flash = void 0, this.foreground = t || "white", this.underline = e || !1, this.italics = r || !1, this.background = i || "black", this.flash = n || !1
						}
						var e = t.prototype;
						return e.reset = function() {
							this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1
						}, e.setStyles = function(t) {
							for(var e = ["foreground", "underline", "italics", "background", "flash"], r = 0; r < e.length; r++) {
								var i = e[r];
								t.hasOwnProperty(i) && (this[i] = t[i])
							}
						}, e.isDefault = function() {
							return "white" === this.foreground && !this.underline && !this.italics && "black" === this.background && !this.flash
						}, e.equals = function(t) {
							return this.foreground === t.foreground && this.underline === t.underline && this.italics === t.italics && this.background === t.background && this.flash === t.flash
						}, e.copy = function(t) {
							this.foreground = t.foreground, this.underline = t.underline, this.italics = t.italics, this.background = t.background, this.flash = t.flash
						}, e.toString = function() {
							return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash
						}, t
					}(),
					cr = function() {
						function t(t, e, r, i, n, a) {
							this.uchar = void 0, this.penState = void 0, this.uchar = t || " ", this.penState = new hr(e, r, i, n, a)
						}
						var e = t.prototype;
						return e.reset = function() {
							this.uchar = " ", this.penState.reset()
						}, e.setChar = function(t, e) {
							this.uchar = t, this.penState.copy(e)
						}, e.setPenState = function(t) {
							this.penState.copy(t)
						}, e.equals = function(t) {
							return this.uchar === t.uchar && this.penState.equals(t.penState)
						}, e.copy = function(t) {
							this.uchar = t.uchar, this.penState.copy(t.penState)
						}, e.isEmpty = function() {
							return " " === this.uchar && this.penState.isDefault()
						}, t
					}(),
					fr = function() {
						function t(t) {
							this.chars = void 0, this.pos = void 0, this.currPenState = void 0, this.cueStartTime = void 0, this.logger = void 0, this.chars = [];
							for(var e = 0; e < ir; e++) this.chars.push(new cr);
							this.logger = t, this.pos = 0, this.currPenState = new hr
						}
						var e = t.prototype;
						return e.equals = function(t) {
							for(var e = !0, r = 0; r < ir; r++)
								if(!this.chars[r].equals(t.chars[r])) {
									e = !1;
									break
								}
							return e
						}, e.copy = function(t) {
							for(var e = 0; e < ir; e++) this.chars[e].copy(t.chars[e])
						}, e.isEmpty = function() {
							for(var t = !0, e = 0; e < ir; e++)
								if(!this.chars[e].isEmpty()) {
									t = !1;
									break
								}
							return t
						}, e.setCursor = function(t) {
							this.pos !== t && (this.pos = t), this.pos < 0 ? (this.logger.log(ze.DEBUG, "Negative cursor position " + this.pos), this.pos = 0) : this.pos > ir && (this.logger.log(ze.DEBUG, "Too large cursor position " + this.pos), this.pos = ir)
						}, e.moveCursor = function(t) {
							var e = this.pos + t;
							if(t > 1)
								for(var r = this.pos + 1; r < e + 1; r++) this.chars[r].setPenState(this.currPenState);
							this.setCursor(e)
						}, e.backSpace = function() {
							this.moveCursor(-1), this.chars[this.pos].setChar(" ", this.currPenState)
						}, e.insertChar = function(t) {
							var e = this;
							t >= 144 && this.backSpace();
							var r = er(t);
							this.pos >= ir ? this.logger.log(ze.ERROR, (function() {
								return "Cannot insert " + t.toString(16) + " (" + r + ") at position " + e.pos + ". Skipping it!"
							})) : (this.chars[this.pos].setChar(r, this.currPenState), this.moveCursor(1))
						}, e.clearFromPos = function(t) {
							var e;
							for(e = t; e < ir; e++) this.chars[e].reset()
						}, e.clear = function() {
							this.clearFromPos(0), this.pos = 0, this.currPenState.reset()
						}, e.clearToEndOfRow = function() {
							this.clearFromPos(this.pos)
						}, e.getTextString = function() {
							for(var t = [], e = !0, r = 0; r < ir; r++) {
								var i = this.chars[r].uchar;
								" " !== i && (e = !1), t.push(i)
							}
							return e ? "" : t.join("")
						}, e.setPenStyles = function(t) {
							this.currPenState.setStyles(t), this.chars[this.pos].setPenState(this.currPenState)
						}, t
					}(),
					gr = function() {
						function t(t) {
							this.rows = void 0, this.currRow = void 0, this.nrRollUpRows = void 0, this.lastOutputScreen = void 0, this.logger = void 0, this.rows = [];
							for(var e = 0; e < rr; e++) this.rows.push(new fr(t));
							this.logger = t, this.currRow = 14, this.nrRollUpRows = null, this.lastOutputScreen = null, this.reset()
						}
						var e = t.prototype;
						return e.reset = function() {
							for(var t = 0; t < rr; t++) this.rows[t].clear();
							this.currRow = 14
						}, e.equals = function(t) {
							for(var e = !0, r = 0; r < rr; r++)
								if(!this.rows[r].equals(t.rows[r])) {
									e = !1;
									break
								}
							return e
						}, e.copy = function(t) {
							for(var e = 0; e < rr; e++) this.rows[e].copy(t.rows[e])
						}, e.isEmpty = function() {
							for(var t = !0, e = 0; e < rr; e++)
								if(!this.rows[e].isEmpty()) {
									t = !1;
									break
								}
							return t
						}, e.backSpace = function() {
							this.rows[this.currRow].backSpace()
						}, e.clearToEndOfRow = function() {
							this.rows[this.currRow].clearToEndOfRow()
						}, e.insertChar = function(t) {
							this.rows[this.currRow].insertChar(t)
						}, e.setPen = function(t) {
							this.rows[this.currRow].setPenStyles(t)
						}, e.moveCursor = function(t) {
							this.rows[this.currRow].moveCursor(t)
						}, e.setCursor = function(t) {
							this.logger.log(ze.INFO, "setCursor: " + t), this.rows[this.currRow].setCursor(t)
						}, e.setPAC = function(t) {
							this.logger.log(ze.INFO, (function() {
								return "pacData = " + JSON.stringify(t)
							}));
							var e = t.row - 1;
							if(this.nrRollUpRows && e < this.nrRollUpRows - 1 && (e = this.nrRollUpRows - 1), this.nrRollUpRows && this.currRow !== e) {
								for(var r = 0; r < rr; r++) this.rows[r].clear();
								var i = this.currRow + 1 - this.nrRollUpRows,
									n = this.lastOutputScreen;
								if(n) {
									var a = n.rows[i].cueStartTime,
										s = this.logger.time;
									if(a && null !== s && a < s)
										for(var o = 0; o < this.nrRollUpRows; o++) this.rows[e - this.nrRollUpRows + o + 1].copy(n.rows[i + o])
								}
							}
							this.currRow = e;
							var l = this.rows[this.currRow];
							if(null !== t.indent) {
								var u = t.indent,
									d = Math.max(u - 1, 0);
								l.setCursor(t.indent), t.color = l.chars[d].penState.foreground
							}
							var h = {
								foreground: t.color,
								underline: t.underline,
								italics: t.italics,
								background: "black",
								flash: !1
							};
							this.setPen(h)
						}, e.setBkgData = function(t) {
							this.logger.log(ze.INFO, (function() {
								return "bkgData = " + JSON.stringify(t)
							})), this.backSpace(), this.setPen(t), this.insertChar(32)
						}, e.setRollUpRows = function(t) {
							this.nrRollUpRows = t
						}, e.rollUp = function() {
							var t = this;
							if(null !== this.nrRollUpRows) {
								this.logger.log(ze.TEXT, (function() {
									return t.getDisplayText()
								}));
								var e = this.currRow + 1 - this.nrRollUpRows,
									r = this.rows.splice(e, 1)[0];
								r.clear(), this.rows.splice(this.currRow, 0, r), this.logger.log(ze.INFO, "Rolling up")
							} else this.logger.log(ze.DEBUG, "roll_up but nrRollUpRows not set yet")
						}, e.getDisplayText = function(t) {
							t = t || !1;
							for(var e = [], r = "", i = -1, n = 0; n < rr; n++) {
								var a = this.rows[n].getTextString();
								a && (i = n + 1, t ? e.push("Row " + i + ": '" + a + "'") : e.push(a.trim()))
							}
							return e.length > 0 && (r = t ? "[" + e.join(" | ") + "]" : e.join("\n")), r
						}, e.getTextAndFormat = function() {
							return this.rows
						}, t
					}(),
					vr = function() {
						function t(t, e, r) {
							this.chNr = void 0, this.outputFilter = void 0, this.mode = void 0, this.verbose = void 0, this.displayedMemory = void 0, this.nonDisplayedMemory = void 0, this.lastOutputScreen = void 0, this.currRollUpRow = void 0, this.writeScreen = void 0, this.cueStartTime = void 0, this.logger = void 0, this.chNr = t, this.outputFilter = e, this.mode = null, this.verbose = 0, this.displayedMemory = new gr(r), this.nonDisplayedMemory = new gr(r), this.lastOutputScreen = new gr(r), this.currRollUpRow = this.displayedMemory.rows[14], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null, this.logger = r
						}
						var e = t.prototype;
						return e.reset = function() {
							this.mode = null, this.displayedMemory.reset(), this.nonDisplayedMemory.reset(), this.lastOutputScreen.reset(), this.outputFilter.reset(), this.currRollUpRow = this.displayedMemory.rows[14], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null
						}, e.getHandler = function() {
							return this.outputFilter
						}, e.setHandler = function(t) {
							this.outputFilter = t
						}, e.setPAC = function(t) {
							this.writeScreen.setPAC(t)
						}, e.setBkgData = function(t) {
							this.writeScreen.setBkgData(t)
						}, e.setMode = function(t) {
							t !== this.mode && (this.mode = t, this.logger.log(ze.INFO, (function() {
								return "MODE=" + t
							})), "MODE_POP-ON" === this.mode ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory, this.writeScreen.reset()), "MODE_ROLL-UP" !== this.mode && (this.displayedMemory.nrRollUpRows = null, this.nonDisplayedMemory.nrRollUpRows = null), this.mode = t)
						}, e.insertChars = function(t) {
							for(var e = this, r = 0; r < t.length; r++) this.writeScreen.insertChar(t[r]);
							var i = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
							this.logger.log(ze.INFO, (function() {
								return i + ": " + e.writeScreen.getDisplayText(!0)
							})), "MODE_PAINT-ON" !== this.mode && "MODE_ROLL-UP" !== this.mode || (this.logger.log(ze.TEXT, (function() {
								return "DISPLAYED: " + e.displayedMemory.getDisplayText(!0)
							})), this.outputDataUpdate())
						}, e.ccRCL = function() {
							this.logger.log(ze.INFO, "RCL - Resume Caption Loading"), this.setMode("MODE_POP-ON")
						}, e.ccBS = function() {
							this.logger.log(ze.INFO, "BS - BackSpace"), "MODE_TEXT" !== this.mode && (this.writeScreen.backSpace(), this.writeScreen === this.displayedMemory && this.outputDataUpdate())
						}, e.ccAOF = function() {}, e.ccAON = function() {}, e.ccDER = function() {
							this.logger.log(ze.INFO, "DER- Delete to End of Row"), this.writeScreen.clearToEndOfRow(), this.outputDataUpdate()
						}, e.ccRU = function(t) {
							this.logger.log(ze.INFO, "RU(" + t + ") - Roll Up"), this.writeScreen = this.displayedMemory, this.setMode("MODE_ROLL-UP"), this.writeScreen.setRollUpRows(t)
						}, e.ccFON = function() {
							this.logger.log(ze.INFO, "FON - Flash On"), this.writeScreen.setPen({
								flash: !0
							})
						}, e.ccRDC = function() {
							this.logger.log(ze.INFO, "RDC - Resume Direct Captioning"), this.setMode("MODE_PAINT-ON")
						}, e.ccTR = function() {
							this.logger.log(ze.INFO, "TR"), this.setMode("MODE_TEXT")
						}, e.ccRTD = function() {
							this.logger.log(ze.INFO, "RTD"), this.setMode("MODE_TEXT")
						}, e.ccEDM = function() {
							this.logger.log(ze.INFO, "EDM - Erase Displayed Memory"), this.displayedMemory.reset(), this.outputDataUpdate(!0)
						}, e.ccCR = function() {
							this.logger.log(ze.INFO, "CR - Carriage Return"), this.writeScreen.rollUp(), this.outputDataUpdate(!0)
						}, e.ccENM = function() {
							this.logger.log(ze.INFO, "ENM - Erase Non-displayed Memory"), this.nonDisplayedMemory.reset()
						}, e.ccEOC = function() {
							var t = this;
							if(this.logger.log(ze.INFO, "EOC - End Of Caption"), "MODE_POP-ON" === this.mode) {
								var e = this.displayedMemory;
								this.displayedMemory = this.nonDisplayedMemory, this.nonDisplayedMemory = e, this.writeScreen = this.nonDisplayedMemory, this.logger.log(ze.TEXT, (function() {
									return "DISP: " + t.displayedMemory.getDisplayText()
								}))
							}
							this.outputDataUpdate(!0)
						}, e.ccTO = function(t) {
							this.logger.log(ze.INFO, "TO(" + t + ") - Tab Offset"), this.writeScreen.moveCursor(t)
						}, e.ccMIDROW = function(t) {
							var e = {
								flash: !1
							};
							if(e.underline = t % 2 == 1, e.italics = t >= 46, e.italics) e.foreground = "white";
							else {
								var r = Math.floor(t / 2) - 16;
								e.foreground = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"][r]
							}
							this.logger.log(ze.INFO, "MIDROW: " + JSON.stringify(e)), this.writeScreen.setPen(e)
						}, e.outputDataUpdate = function(t) {
							void 0 === t && (t = !1);
							var e = this.logger.time;
							null !== e && this.outputFilter && (null !== this.cueStartTime || this.displayedMemory.isEmpty() ? this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue(this.cueStartTime, e, this.lastOutputScreen), t && this.outputFilter.dispatchCue && this.outputFilter.dispatchCue(), this.cueStartTime = this.displayedMemory.isEmpty() ? null : e) : this.cueStartTime = e, this.lastOutputScreen.copy(this.displayedMemory))
						}, e.cueSplitAtTime = function(t) {
							this.outputFilter && (this.displayedMemory.isEmpty() || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory), this.cueStartTime = t))
						}, t
					}(),
					pr = function() {
						function t(t, e, r) {
							this.channels = void 0, this.currentChannel = 0, this.cmdHistory = void 0, this.logger = void 0;
							var i = new ur;
							this.channels = [null, new vr(t, e, i), new vr(t + 1, r, i)], this.cmdHistory = {
								a: null,
								b: null
							}, this.logger = i
						}
						var e = t.prototype;
						return e.getHandler = function(t) {
							return this.channels[t].getHandler()
						}, e.setHandler = function(t, e) {
							this.channels[t].setHandler(e)
						}, e.addData = function(t, e) {
							var r, i, n, a = !1;
							this.logger.time = t;
							for(var s = 0; s < e.length; s += 2)
								if(i = 127 & e[s], n = 127 & e[s + 1], 0 !== i || 0 !== n) {
									if(this.logger.log(ze.DATA, "[" + dr([e[s], e[s + 1]]) + "] -> (" + dr([i, n]) + ")"), (r = this.parseCmd(i, n)) || (r = this.parseMidrow(i, n)), r || (r = this.parsePAC(i, n)), r || (r = this.parseBackgroundAttributes(i, n)), !r && (a = this.parseChars(i, n))) {
										var o = this.currentChannel;
										o && o > 0 ? this.channels[o].insertChars(a) : this.logger.log(ze.WARNING, "No channel found yet. TEXT-MODE?")
									}
									r || a || this.logger.log(ze.WARNING, "Couldn't parse cleaned data " + dr([i, n]) + " orig: " + dr([e[s], e[s + 1]]))
								}
						}, e.parseCmd = function(t, e) {
							var r = this.cmdHistory;
							if(!((20 === t || 28 === t || 21 === t || 29 === t) && e >= 32 && e <= 47 || (23 === t || 31 === t) && e >= 33 && e <= 35)) return !1;
							if(yr(t, e, r)) return mr(null, null, r), this.logger.log(ze.DEBUG, "Repeated command (" + dr([t, e]) + ") is dropped"), !0;
							var i = 20 === t || 21 === t || 23 === t ? 1 : 2,
								n = this.channels[i];
							return 20 === t || 21 === t || 28 === t || 29 === t ? 32 === e ? n.ccRCL() : 33 === e ? n.ccBS() : 34 === e ? n.ccAOF() : 35 === e ? n.ccAON() : 36 === e ? n.ccDER() : 37 === e ? n.ccRU(2) : 38 === e ? n.ccRU(3) : 39 === e ? n.ccRU(4) : 40 === e ? n.ccFON() : 41 === e ? n.ccRDC() : 42 === e ? n.ccTR() : 43 === e ? n.ccRTD() : 44 === e ? n.ccEDM() : 45 === e ? n.ccCR() : 46 === e ? n.ccENM() : 47 === e && n.ccEOC() : n.ccTO(e - 32), mr(t, e, r), this.currentChannel = i, !0
						}, e.parseMidrow = function(t, e) {
							var r = 0;
							if((17 === t || 25 === t) && e >= 32 && e <= 47) {
								if((r = 17 === t ? 1 : 2) !== this.currentChannel) return this.logger.log(ze.ERROR, "Mismatch channel in midrow parsing"), !1;
								var i = this.channels[r];
								return !!i && (i.ccMIDROW(e), this.logger.log(ze.DEBUG, "MIDROW (" + dr([t, e]) + ")"), !0)
							}
							return !1
						}, e.parsePAC = function(t, e) {
							var r, i = this.cmdHistory;
							if(!((t >= 17 && t <= 23 || t >= 25 && t <= 31) && e >= 64 && e <= 127 || (16 === t || 24 === t) && e >= 64 && e <= 95)) return !1;
							if(yr(t, e, i)) return mr(null, null, i), !0;
							var n = t <= 23 ? 1 : 2;
							r = e >= 64 && e <= 95 ? 1 === n ? nr[t] : sr[t] : 1 === n ? ar[t] : or[t];
							var a = this.channels[n];
							return !!a && (a.setPAC(this.interpretPAC(r, e)), mr(t, e, i), this.currentChannel = n, !0)
						}, e.interpretPAC = function(t, e) {
							var r, i = {
								color: null,
								italics: !1,
								indent: null,
								underline: !1,
								row: t
							};
							return r = e > 95 ? e - 96 : e - 64, i.underline = 1 == (1 & r), r <= 13 ? i.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(r / 2)] : r <= 15 ? (i.italics = !0, i.color = "white") : i.indent = 4 * Math.floor((r - 16) / 2), i
						}, e.parseChars = function(t, e) {
							var r, i, n = null,
								a = null;
							if(t >= 25 ? (r = 2, a = t - 8) : (r = 1, a = t), a >= 17 && a <= 19 ? (i = 17 === a ? e + 80 : 18 === a ? e + 112 : e + 144, this.logger.log(ze.INFO, "Special char '" + er(i) + "' in channel " + r), n = [i]) : t >= 32 && t <= 127 && (n = 0 === e ? [t] : [t, e]), n) {
								var s = dr(n);
								this.logger.log(ze.DEBUG, "Char codes =  " + s.join(",")), mr(t, e, this.cmdHistory)
							}
							return n
						}, e.parseBackgroundAttributes = function(t, e) {
							var r;
							if(!((16 === t || 24 === t) && e >= 32 && e <= 47 || (23 === t || 31 === t) && e >= 45 && e <= 47)) return !1;
							var i = {};
							16 === t || 24 === t ? (r = Math.floor((e - 32) / 2), i.background = lr[r], e % 2 == 1 && (i.background = i.background + "_semi")) : 45 === e ? i.background = "transparent" : (i.foreground = "black", 47 === e && (i.underline = !0));
							var n = t <= 23 ? 1 : 2;
							return this.channels[n].setBkgData(i), mr(t, e, this.cmdHistory), !0
						}, e.reset = function() {
							for(var t = 0; t < Object.keys(this.channels).length; t++) {
								var e = this.channels[t];
								e && e.reset()
							}
							this.cmdHistory = {
								a: null,
								b: null
							}
						}, e.cueSplitAtTime = function(t) {
							for(var e = 0; e < this.channels.length; e++) {
								var r = this.channels[e];
								r && r.cueSplitAtTime(t)
							}
						}, t
					}();

				function mr(t, e, r) {
					r.a = t, r.b = e
				}

				function yr(t, e, r) {
					return r.a === t && r.b === e
				}
				const Er = pr;
				var Tr = function() {
					function t(t, e) {
						this.timelineController = void 0, this.cueRanges = [], this.trackName = void 0, this.startTime = null, this.endTime = null, this.screen = null, this.timelineController = t, this.trackName = e
					}
					var e = t.prototype;
					return e.dispatchCue = function() {
						null !== this.startTime && (this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges), this.startTime = null)
					}, e.newCue = function(t, e, r) {
						(null === this.startTime || this.startTime > t) && (this.startTime = t), this.endTime = e, this.screen = r, this.timelineController.createCaptionsTrack(this.trackName)
					}, e.reset = function() {
						this.cueRanges = [], this.startTime = null
					}, t
				}();
				const Sr = function() {
					if("undefined" != typeof self && self.VTTCue) return self.VTTCue;
					var t = ["", "lr", "rl"],
						e = ["start", "middle", "end", "left", "right"];

					function r(t, e) {
						if("string" != typeof e) return !1;
						if(!Array.isArray(t)) return !1;
						var r = e.toLowerCase();
						return !!~t.indexOf(r) && r
					}

					function i(t) {
						return r(e, t)
					}

					function n(t) {
						for(var e = arguments.length, r = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) r[i - 1] = arguments[i];
						for(var n = 1; n < arguments.length; n++) {
							var a = arguments[n];
							for(var s in a) t[s] = a[s]
						}
						return t
					}

					function a(e, a, s) {
						var o = this,
							l = {
								enumerable: !0
							};
						o.hasBeenReset = !1;
						var u = "",
							d = !1,
							h = e,
							c = a,
							f = s,
							g = null,
							v = "",
							p = !0,
							m = "auto",
							y = "start",
							E = 50,
							T = "middle",
							S = 50,
							b = "middle";
						Object.defineProperty(o, "id", n({}, l, {
							get: function() {
								return u
							},
							set: function(t) {
								u = "" + t
							}
						})), Object.defineProperty(o, "pauseOnExit", n({}, l, {
							get: function() {
								return d
							},
							set: function(t) {
								d = !!t
							}
						})), Object.defineProperty(o, "startTime", n({}, l, {
							get: function() {
								return h
							},
							set: function(t) {
								if("number" != typeof t) throw new TypeError("Start time must be set to a number.");
								h = t, this.hasBeenReset = !0
							}
						})), Object.defineProperty(o, "endTime", n({}, l, {
							get: function() {
								return c
							},
							set: function(t) {
								if("number" != typeof t) throw new TypeError("End time must be set to a number.");
								c = t, this.hasBeenReset = !0
							}
						})), Object.defineProperty(o, "text", n({}, l, {
							get: function() {
								return f
							},
							set: function(t) {
								f = "" + t, this.hasBeenReset = !0
							}
						})), Object.defineProperty(o, "region", n({}, l, {
							get: function() {
								return g
							},
							set: function(t) {
								g = t, this.hasBeenReset = !0
							}
						})), Object.defineProperty(o, "vertical", n({}, l, {
							get: function() {
								return v
							},
							set: function(e) {
								var i = function(e) {
									return r(t, e)
								}(e);
								if(!1 === i) throw new SyntaxError("An invalid or illegal string was specified.");
								v = i, this.hasBeenReset = !0
							}
						})), Object.defineProperty(o, "snapToLines", n({}, l, {
							get: function() {
								return p
							},
							set: function(t) {
								p = !!t, this.hasBeenReset = !0
							}
						})), Object.defineProperty(o, "line", n({}, l, {
							get: function() {
								return m
							},
							set: function(t) {
								if("number" != typeof t && "auto" !== t) throw new SyntaxError("An invalid number or illegal string was specified.");
								m = t, this.hasBeenReset = !0
							}
						})), Object.defineProperty(o, "lineAlign", n({}, l, {
							get: function() {
								return y
							},
							set: function(t) {
								var e = i(t);
								if(!e) throw new SyntaxError("An invalid or illegal string was specified.");
								y = e, this.hasBeenReset = !0
							}
						})), Object.defineProperty(o, "position", n({}, l, {
							get: function() {
								return E
							},
							set: function(t) {
								if(t < 0 || t > 100) throw new Error("Position must be between 0 and 100.");
								E = t, this.hasBeenReset = !0
							}
						})), Object.defineProperty(o, "positionAlign", n({}, l, {
							get: function() {
								return T
							},
							set: function(t) {
								var e = i(t);
								if(!e) throw new SyntaxError("An invalid or illegal string was specified.");
								T = e, this.hasBeenReset = !0
							}
						})), Object.defineProperty(o, "size", n({}, l, {
							get: function() {
								return S
							},
							set: function(t) {
								if(t < 0 || t > 100) throw new Error("Size must be between 0 and 100.");
								S = t, this.hasBeenReset = !0
							}
						})), Object.defineProperty(o, "align", n({}, l, {
							get: function() {
								return b
							},
							set: function(t) {
								var e = i(t);
								if(!e) throw new SyntaxError("An invalid or illegal string was specified.");
								b = e, this.hasBeenReset = !0
							}
						})), o.displayState = void 0
					}
					return a.prototype.getCueAsHTML = function() {
						return self.WebVTT.convertCueToDOMTree(self, this.text)
					}, a
				}();
				var br = function() {
					function t() {}
					return t.prototype.decode = function(t, e) {
						if(!t) return "";
						if("string" != typeof t) throw new Error("Error - expected string data.");
						return decodeURIComponent(encodeURIComponent(t))
					}, t
				}();

				function Lr(t) {
					function e(t, e, r, i) {
						return 3600 * (0 | t) + 60 * (0 | e) + (0 | r) + parseFloat(i || 0)
					}
					var r = t.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/);
					return r ? parseFloat(r[2]) > 59 ? e(r[2], r[3], 0, r[4]) : e(r[1], r[2], r[3], r[4]) : null
				}
				var Ar = function() {
					function t() {
						this.values = Object.create(null)
					}
					var e = t.prototype;
					return e.set = function(t, e) {
						this.get(t) || "" === e || (this.values[t] = e)
					}, e.get = function(t, e, r) {
						return r ? this.has(t) ? this.values[t] : e[r] : this.has(t) ? this.values[t] : e
					}, e.has = function(t) {
						return t in this.values
					}, e.alt = function(t, e, r) {
						for(var i = 0; i < r.length; ++i)
							if(e === r[i]) {
								this.set(t, e);
								break
							}
					}, e.integer = function(t, e) {
						/^-?\d+$/.test(e) && this.set(t, parseInt(e, 10))
					}, e.percent = function(t, e) {
						if(/^([\d]{1,3})(\.[\d]*)?%$/.test(e)) {
							var r = parseFloat(e);
							if(r >= 0 && r <= 100) return this.set(t, r), !0
						}
						return !1
					}, t
				}();

				function Dr(t, e, r, i) {
					var n = i ? t.split(i) : [t];
					for(var a in n)
						if("string" == typeof n[a]) {
							var s = n[a].split(r);
							2 === s.length && e(s[0], s[1])
						}
				}
				var kr = new Sr(0, 0, ""),
					Rr = "middle" === kr.align ? "middle" : "center";

				function Ir(t, e, r) {
					var i = t;

					function n() {
						var e = Lr(t);
						if(null === e) throw new Error("Malformed timestamp: " + i);
						return t = t.replace(/^[^\sa-zA-Z-]+/, ""), e
					}

					function a() {
						t = t.replace(/^\s+/, "")
					}
					if(a(), e.startTime = n(), a(), "--\x3e" !== t.slice(0, 3)) throw new Error("Malformed time stamp (time stamps must be separated by '--\x3e'): " + i);
					t = t.slice(3), a(), e.endTime = n(), a(),
						function(t, e) {
							var i = new Ar;
							Dr(t, (function(t, e) {
								var n;
								switch(t) {
									case "region":
										for(var a = r.length - 1; a >= 0; a--)
											if(r[a].id === e) {
												i.set(t, r[a].region);
												break
											}
										break;
									case "vertical":
										i.alt(t, e, ["rl", "lr"]);
										break;
									case "line":
										n = e.split(","), i.integer(t, n[0]), i.percent(t, n[0]) && i.set("snapToLines", !1), i.alt(t, n[0], ["auto"]), 2 === n.length && i.alt("lineAlign", n[1], ["start", Rr, "end"]);
										break;
									case "position":
										n = e.split(","), i.percent(t, n[0]), 2 === n.length && i.alt("positionAlign", n[1], ["start", Rr, "end", "line-left", "line-right", "auto"]);
										break;
									case "size":
										i.percent(t, e);
										break;
									case "align":
										i.alt(t, e, ["start", Rr, "end", "left", "right"])
								}
							}), /:/, /\s/), e.region = i.get("region", null), e.vertical = i.get("vertical", "");
							var n = i.get("line", "auto");
							"auto" === n && -1 === kr.line && (n = -1), e.line = n, e.lineAlign = i.get("lineAlign", "start"), e.snapToLines = i.get("snapToLines", !0), e.size = i.get("size", 100), e.align = i.get("align", Rr);
							var a = i.get("position", "auto");
							"auto" === a && 50 === kr.position && (a = "start" === e.align || "left" === e.align ? 0 : "end" === e.align || "right" === e.align ? 100 : 50), e.position = a
						}(t, e)
				}

				function wr(t) {
					return t.replace(/<br(?: \/)?>/gi, "\n")
				}
				var Cr = function() {
						function t() {
							this.state = "INITIAL", this.buffer = "", this.decoder = new br, this.regionList = [], this.cue = null, this.oncue = void 0, this.onparsingerror = void 0, this.onflush = void 0
						}
						var e = t.prototype;
						return e.parse = function(t) {
							var e = this;

							function r() {
								var t = e.buffer,
									r = 0;
								for(t = wr(t); r < t.length && "\r" !== t[r] && "\n" !== t[r];) ++r;
								var i = t.slice(0, r);
								return "\r" === t[r] && ++r, "\n" === t[r] && ++r, e.buffer = t.slice(r), i
							}
							t && (e.buffer += e.decoder.decode(t, {
								stream: !0
							}));
							try {
								var i = "";
								if("INITIAL" === e.state) {
									if(!/\r\n|\n/.test(e.buffer)) return this;
									var n = (i = r()).match(/^(ГЇВ»Вї)?WEBVTT([ \t].*)?$/);
									if(!n || !n[0]) throw new Error("Malformed WebVTT signature.");
									e.state = "HEADER"
								}
								for(var a = !1; e.buffer;) {
									if(!/\r\n|\n/.test(e.buffer)) return this;
									switch(a ? a = !1 : i = r(), e.state) {
										case "HEADER":
											/:/.test(i) ? Dr(i, (function(t, e) {}), /:/) : i || (e.state = "ID");
											continue;
										case "NOTE":
											i || (e.state = "ID");
											continue;
										case "ID":
											if(/^NOTE($|[ \t])/.test(i)) {
												e.state = "NOTE";
												break
											}
											if(!i) continue;
											if(e.cue = new Sr(0, 0, ""), e.state = "CUE", -1 === i.indexOf("--\x3e")) {
												e.cue.id = i;
												continue
											}
										case "CUE":
											if(!e.cue) {
												e.state = "BADCUE";
												continue
											}
											try {
												Ir(i, e.cue, e.regionList)
											} catch(t) {
												e.cue = null, e.state = "BADCUE";
												continue
											}
											e.state = "CUETEXT";
											continue;
										case "CUETEXT":
											var s = -1 !== i.indexOf("--\x3e");
											if(!i || s && (a = !0)) {
												e.oncue && e.cue && e.oncue(e.cue), e.cue = null, e.state = "ID";
												continue
											}
											if(null === e.cue) continue;
											e.cue.text && (e.cue.text += "\n"), e.cue.text += i;
											continue;
										case "BADCUE":
											i || (e.state = "ID")
									}
								}
							} catch(t) {
								"CUETEXT" === e.state && e.cue && e.oncue && e.oncue(e.cue), e.cue = null, e.state = "INITIAL" === e.state ? "BADWEBVTT" : "BADCUE"
							}
							return this
						}, e.flush = function() {
							var t = this;
							try {
								if((t.cue || "HEADER" === t.state) && (t.buffer += "\n\n", t.parse()), "INITIAL" === t.state || "BADWEBVTT" === t.state) throw new Error("Malformed WebVTT signature.")
							} catch(e) {
								t.onparsingerror && t.onparsingerror(e)
							}
							return t.onflush && t.onflush(), this
						}, t
					}(),
					_r = r(673),
					Or = r(524),
					Pr = /\r\n|\n\r|\n|\r/g,
					xr = function(t, e, r) {
						return void 0 === r && (r = 0), t.slice(r, r + e.length) === e
					},
					Fr = function(t) {
						for(var e = 5381, r = t.length; r;) e = 33 * e ^ t.charCodeAt(--r);
						return(e >>> 0).toString()
					};

				function Mr(t, e, r) {
					return Fr(t.toString()) + Fr(e.toString()) + Fr(r)
				}

				function Nr() {
					return Nr = Object.assign ? Object.assign.bind() : function(t) {
						for(var e = 1; e < arguments.length; e++) {
							var r = arguments[e];
							for(var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i])
						}
						return t
					}, Nr.apply(this, arguments)
				}
				var Ur = "stpp.ttml.im1t",
					Br = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/,
					Gr = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/,
					Kr = {
						left: "start",
						center: "center",
						right: "end",
						start: "start",
						end: "end"
					};

				function Hr(t, e, r, i, n) {
					var a = (0, R.findBox)(new Uint8Array(t), ["mdat"]);
					if(0 !== a.length) {
						var s = a.map((function(t) {
								return(0, $.utf8ArrayToStr)(t)
							})),
							o = (0, _r.toTimescaleFromScale)(e, 1, r);
						try {
							s.forEach((function(t) {
								return i(function(t, e) {
									var r = (new DOMParser).parseFromString(t, "text/xml").getElementsByTagName("tt")[0];
									if(!r) throw new Error("Invalid ttml");
									var i = {
											frameRate: 30,
											subFrameRate: 1,
											frameRateMultiplier: 0,
											tickRate: 0
										},
										n = Object.keys(i).reduce((function(t, e) {
											return t[e] = r.getAttribute("ttp:" + e) || i[e], t
										}), {}),
										a = "preserve" !== r.getAttribute("xml:space"),
										s = Vr(jr(r, "styling", "style")),
										o = Vr(jr(r, "layout", "region")),
										l = jr(r, "body", "[begin]");
									return [].map.call(l, (function(t) {
										var r = Yr(t, a);
										if(!r || !t.hasAttribute("begin")) return null;
										var i = Xr(t.getAttribute("begin"), n),
											l = Xr(t.getAttribute("dur"), n),
											u = Xr(t.getAttribute("end"), n);
										if(null === i) throw qr(t);
										if(null === u) {
											if(null === l) throw qr(t);
											u = i + l
										}
										var d = new Sr(i - e, u - e, r);
										d.id = Mr(d.startTime, d.endTime, d.text);
										var h = function(t, e, r) {
												var i = "http://www.w3.org/ns/ttml#styling",
													n = null,
													a = null != t && t.hasAttribute("style") ? t.getAttribute("style") : null;
												return a && r.hasOwnProperty(a) && (n = r[a]), ["displayAlign", "textAlign", "color", "backgroundColor", "fontSize", "fontFamily"].reduce((function(r, a) {
													var s = Wr(e, i, a) || Wr(t, i, a) || Wr(n, i, a);
													return s && (r[a] = s), r
												}), {})
											}(o[t.getAttribute("region")], s[t.getAttribute("style")], s),
											c = h.textAlign;
										if(c) {
											var f = Kr[c];
											f && (d.lineAlign = f), d.align = c
										}
										return Nr(d, h), d
									})).filter((function(t) {
										return null !== t
									}))
								}(t, o))
							}))
						} catch(t) {
							n(t)
						}
					} else n(new Error("Could not parse IMSC1 mdat"))
				}

				function jr(t, e, r) {
					var i = t.getElementsByTagName(e)[0];
					return i ? [].slice.call(i.querySelectorAll(r)) : []
				}

				function Vr(t) {
					return t.reduce((function(t, e) {
						var r = e.getAttribute("xml:id");
						return r && (t[r] = e), t
					}), {})
				}

				function Yr(t, e) {
					return [].slice.call(t.childNodes).reduce((function(t, r, i) {
						var n;
						return "br" === r.nodeName && i ? t + "\n" : null !== (n = r.childNodes) && void 0 !== n && n.length ? Yr(r, e) : e ? t + r.textContent.trim().replace(/\s+/g, " ") : t + r.textContent
					}), "")
				}

				function Wr(t, e, r) {
					return t && t.hasAttributeNS(e, r) ? t.getAttributeNS(e, r) : null
				}

				function qr(t) {
					return new Error("Could not parse ttml timestamp " + t)
				}

				function Xr(t, e) {
					if(!t) return null;
					var r = Lr(t);
					return null === r && (Br.test(t) ? r = function(t, e) {
						var r = Br.exec(t),
							i = (0 | r[4]) + (0 | r[5]) / e.subFrameRate;
						return 3600 * (0 | r[1]) + 60 * (0 | r[2]) + (0 | r[3]) + i / e.frameRate
					}(t, e) : Gr.test(t) && (r = function(t, e) {
						var r = Gr.exec(t),
							i = Number(r[1]);
						switch(r[2]) {
							case "h":
								return 3600 * i;
							case "m":
								return 60 * i;
							case "ms":
								return 1e3 * i;
							case "f":
								return i / e.frameRate;
							case "t":
								return i / e.tickRate
						}
						return i
					}(t, e))), r
				}
				var zr = function() {
					function t(t) {
						if(this.hls = void 0, this.media = null, this.config = void 0, this.enabled = !0, this.Cues = void 0, this.textTracks = [], this.tracks = [], this.initPTS = [], this.timescale = [], this.unparsedVttFrags = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.cea608Parser1 = void 0, this.cea608Parser2 = void 0, this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = {
								ccOffset: 0,
								presentationOffset: 0,
								0: {
									start: 0,
									prevCC: -1,
									new: !0
								}
							}, this.captionsProperties = void 0, this.hls = t, this.config = t.config, this.Cues = t.config.cueHandler, this.captionsProperties = {
								textTrack1: {
									label: this.config.captionsTextTrack1Label,
									languageCode: this.config.captionsTextTrack1LanguageCode
								},
								textTrack2: {
									label: this.config.captionsTextTrack2Label,
									languageCode: this.config.captionsTextTrack2LanguageCode
								},
								textTrack3: {
									label: this.config.captionsTextTrack3Label,
									languageCode: this.config.captionsTextTrack3LanguageCode
								},
								textTrack4: {
									label: this.config.captionsTextTrack4Label,
									languageCode: this.config.captionsTextTrack4LanguageCode
								}
							}, this.config.enableCEA708Captions) {
							var e = new Tr(this, "textTrack1"),
								r = new Tr(this, "textTrack2"),
								i = new Tr(this, "textTrack3"),
								n = new Tr(this, "textTrack4");
							this.cea608Parser1 = new Er(1, e, r), this.cea608Parser2 = new Er(3, i, n)
						}
						t.on(s.Events.MEDIA_ATTACHING, this.onMediaAttaching, this), t.on(s.Events.MEDIA_DETACHING, this.onMediaDetaching, this), t.on(s.Events.MANIFEST_LOADING, this.onManifestLoading, this), t.on(s.Events.MANIFEST_LOADED, this.onManifestLoaded, this), t.on(s.Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), t.on(s.Events.FRAG_LOADING, this.onFragLoading, this), t.on(s.Events.FRAG_LOADED, this.onFragLoaded, this), t.on(s.Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), t.on(s.Events.FRAG_DECRYPTED, this.onFragDecrypted, this), t.on(s.Events.INIT_PTS_FOUND, this.onInitPtsFound, this), t.on(s.Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), t.on(s.Events.BUFFER_FLUSHING, this.onBufferFlushing, this)
					}
					var e = t.prototype;
					return e.destroy = function() {
						var t = this.hls;
						t.off(s.Events.MEDIA_ATTACHING, this.onMediaAttaching, this), t.off(s.Events.MEDIA_DETACHING, this.onMediaDetaching, this), t.off(s.Events.MANIFEST_LOADING, this.onManifestLoading, this), t.off(s.Events.MANIFEST_LOADED, this.onManifestLoaded, this), t.off(s.Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), t.off(s.Events.FRAG_LOADING, this.onFragLoading, this), t.off(s.Events.FRAG_LOADED, this.onFragLoaded, this), t.off(s.Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), t.off(s.Events.FRAG_DECRYPTED, this.onFragDecrypted, this), t.off(s.Events.INIT_PTS_FOUND, this.onInitPtsFound, this), t.off(s.Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), t.off(s.Events.BUFFER_FLUSHING, this.onBufferFlushing, this), this.hls = this.config = this.cea608Parser1 = this.cea608Parser2 = null
					}, e.addCues = function(t, e, r, i, n) {
						for(var a, o, l, u, d = !1, h = n.length; h--;) {
							var c = n[h],
								f = (a = c[0], o = c[1], l = e, u = r, Math.min(o, u) - Math.max(a, l));
							if(f >= 0 && (c[0] = Math.min(c[0], e), c[1] = Math.max(c[1], r), d = !0, f / (r - e) > .5)) return
						}
						if(d || n.push([e, r]), this.config.renderTextTracksNatively) {
							var g = this.captionsTracks[t];
							this.Cues.newCue(g, e, r, i)
						} else {
							var v = this.Cues.newCue(null, e, r, i);
							this.hls.trigger(s.Events.CUES_PARSED, {
								type: "captions",
								cues: v,
								track: t
							})
						}
					}, e.onInitPtsFound = function(t, e) {
						var r = this,
							i = e.frag,
							n = e.id,
							a = e.initPTS,
							o = e.timescale,
							l = this.unparsedVttFrags;
						"main" === n && (this.initPTS[i.cc] = a, this.timescale[i.cc] = o), l.length && (this.unparsedVttFrags = [], l.forEach((function(t) {
							r.onFragLoaded(s.Events.FRAG_LOADED, t)
						})))
					}, e.getExistingTrack = function(t) {
						var e = this.media;
						if(e)
							for(var r = 0; r < e.textTracks.length; r++) {
								var i = e.textTracks[r];
								if(i[t]) return i
							}
						return null
					}, e.createCaptionsTrack = function(t) {
						this.config.renderTextTracksNatively ? this.createNativeTrack(t) : this.createNonNativeTrack(t)
					}, e.createNativeTrack = function(t) {
						if(!this.captionsTracks[t]) {
							var e = this.captionsProperties,
								r = this.captionsTracks,
								i = this.media,
								n = e[t],
								a = n.label,
								s = n.languageCode,
								o = this.getExistingTrack(t);
							if(o) r[t] = o, z(r[t]), q(r[t], i);
							else {
								var l = this.createTextTrack("captions", a, s);
								l && (l[t] = !0, r[t] = l)
							}
						}
					}, e.createNonNativeTrack = function(t) {
						if(!this.nonNativeCaptionsTracks[t]) {
							var e = this.captionsProperties[t];
							if(e) {
								var r = {
									_id: t,
									label: e.label,
									kind: "captions",
									default: !!e.media && !!e.media.default,
									closedCaptions: e.media
								};
								this.nonNativeCaptionsTracks[t] = r, this.hls.trigger(s.Events.NON_NATIVE_TEXT_TRACKS_FOUND, {
									tracks: [r]
								})
							}
						}
					}, e.createTextTrack = function(t, e, r) {
						var i = this.media;
						if(i) return i.addTextTrack(t, e, r)
					}, e.onMediaAttaching = function(t, e) {
						this.media = e.media, this._cleanTracks()
					}, e.onMediaDetaching = function() {
						var t = this.captionsTracks;
						Object.keys(t).forEach((function(e) {
							z(t[e]), delete t[e]
						})), this.nonNativeCaptionsTracks = {}
					}, e.onManifestLoading = function() {
						this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = {
							ccOffset: 0,
							presentationOffset: 0,
							0: {
								start: 0,
								prevCC: -1,
								new: !0
							}
						}, this._cleanTracks(), this.tracks = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.textTracks = [], this.unparsedVttFrags = this.unparsedVttFrags || [], this.initPTS = [], this.timescale = [], this.cea608Parser1 && this.cea608Parser2 && (this.cea608Parser1.reset(), this.cea608Parser2.reset())
					}, e._cleanTracks = function() {
						var t = this.media;
						if(t) {
							var e = t.textTracks;
							if(e)
								for(var r = 0; r < e.length; r++) z(e[r])
						}
					}, e.onSubtitleTracksUpdated = function(t, e) {
						var r = this;
						this.textTracks = [];
						var i = e.subtitleTracks || [],
							n = i.some((function(t) {
								return t.textCodec === Ur
							}));
						if(this.config.enableWebVTT || n && this.config.enableIMSC1) {
							var a = this.tracks && i && this.tracks.length === i.length;
							if(this.tracks = i || [], this.config.renderTextTracksNatively) {
								var o = this.media ? this.media.textTracks : [];
								this.tracks.forEach((function(t, e) {
									var i;
									if(e < o.length) {
										for(var n = null, a = 0; a < o.length; a++)
											if(Qr(o[a], t)) {
												n = o[a];
												break
											}
										n && (i = n)
									}
									if(i) z(i);
									else {
										var s = r._captionsOrSubtitlesFromCharacteristics(t);
										(i = r.createTextTrack(s, t.name, t.lang)) && (i.mode = "disabled")
									}
									i && (i.groupId = t.groupId, r.textTracks.push(i))
								}))
							} else if(!a && this.tracks && this.tracks.length) {
								var l = this.tracks.map((function(t) {
									return {
										label: t.name,
										kind: t.type.toLowerCase(),
										default: t.default,
										subtitleTrack: t
									}
								}));
								this.hls.trigger(s.Events.NON_NATIVE_TEXT_TRACKS_FOUND, {
									tracks: l
								})
							}
						}
					}, e._captionsOrSubtitlesFromCharacteristics = function(t) {
						var e;
						if(null !== (e = t.attrs) && void 0 !== e && e.CHARACTERISTICS) {
							var r = /transcribes-spoken-dialog/gi.test(t.attrs.CHARACTERISTICS),
								i = /describes-music-and-sound/gi.test(t.attrs.CHARACTERISTICS);
							if(r && i) return "captions"
						}
						return "subtitles"
					}, e.onManifestLoaded = function(t, e) {
						var r = this;
						this.config.enableCEA708Captions && e.captions && e.captions.forEach((function(t) {
							var e = /(?:CC|SERVICE)([1-4])/.exec(t.instreamId);
							if(e) {
								var i = "textTrack" + e[1],
									n = r.captionsProperties[i];
								n && (n.label = t.name, t.lang && (n.languageCode = t.lang), n.media = t)
							}
						}))
					}, e.closedCaptionsForLevel = function(t) {
						var e = this.hls.levels[t.level];
						return null == e ? void 0 : e.attrs["CLOSED-CAPTIONS"]
					}, e.onFragLoading = function(t, e) {
						var r = this.cea608Parser1,
							i = this.cea608Parser2,
							n = this.lastSn,
							a = this.lastPartIndex;
						if(this.enabled && r && i && e.frag.type === V.PlaylistLevelType.MAIN) {
							var s, o, l = e.frag.sn,
								u = null != (s = null == e || null === (o = e.part) || void 0 === o ? void 0 : o.index) ? s : -1;
							l === n + 1 || l === n && u === a + 1 || (r.reset(), i.reset()), this.lastSn = l, this.lastPartIndex = u
						}
					}, e.onFragLoaded = function(t, e) {
						var r = e.frag,
							i = e.payload,
							n = this.initPTS,
							o = this.unparsedVttFrags;
						if(r.type === V.PlaylistLevelType.SUBTITLE)
							if(i.byteLength) {
								if(!(0, a.isFiniteNumber)(n[r.cc])) return o.push(e), void(n.length && this.hls.trigger(s.Events.SUBTITLE_FRAG_PROCESSED, {
									success: !1,
									frag: r,
									error: new Error("Missing initial subtitle PTS")
								}));
								var l = r.decryptdata,
									u = "stats" in e;
								if(null == l || !l.encrypted || u) {
									var d = this.tracks[r.level],
										h = this.vttCCs;
									h[r.cc] || (h[r.cc] = {
										start: r.start,
										prevCC: this.prevCC,
										new: !0
									}, this.prevCC = r.cc), d && d.textCodec === Ur ? this._parseIMSC1(r, i) : this._parseVTTs(r, i, h)
								}
							} else this.hls.trigger(s.Events.SUBTITLE_FRAG_PROCESSED, {
								success: !1,
								frag: r,
								error: new Error("Empty subtitle payload")
							})
					}, e._parseIMSC1 = function(t, e) {
						var r = this,
							i = this.hls;
						Hr(e, this.initPTS[t.cc], this.timescale[t.cc], (function(e) {
							r._appendCues(e, t.level), i.trigger(s.Events.SUBTITLE_FRAG_PROCESSED, {
								success: !0,
								frag: t
							})
						}), (function(e) {
							l.logger.log("Failed to parse IMSC1: " + e), i.trigger(s.Events.SUBTITLE_FRAG_PROCESSED, {
								success: !1,
								frag: t,
								error: e
							})
						}))
					}, e._parseVTTs = function(t, e, r) {
						var i, n = this,
							o = this.hls;
						! function(t, e, r, i, n, s, o, l) {
							var u, d = new Cr,
								h = (0, $.utf8ArrayToStr)(new Uint8Array(t)).trim().replace(Pr, "\n").split("\n"),
								c = [],
								f = (0, _r.toMpegTsClockFromTimescale)(e, r),
								g = "00:00.000",
								v = 0,
								p = 0,
								m = !0;
							d.oncue = function(t) {
								var e = i[n],
									r = i.ccOffset,
									a = (v - f) / 9e4;
								null != e && e.new && (void 0 !== p ? r = i.ccOffset = e.start : function(t, e, r) {
									var i = t[e],
										n = t[i.prevCC];
									if(!n || !n.new && i.new) return t.ccOffset = t.presentationOffset = i.start, void(i.new = !1);
									for(; null !== (a = n) && void 0 !== a && a.new;) {
										var a;
										t.ccOffset += i.start - n.start, i.new = !1, n = t[(i = n).prevCC]
									}
									t.presentationOffset = r
								}(i, n, a)), a && (r = a - i.presentationOffset);
								var o = t.endTime - t.startTime,
									l = (0, Or.normalizePts)(9e4 * (t.startTime + r - p), 9e4 * s) / 9e4;
								t.startTime = Math.max(l, 0), t.endTime = Math.max(l + o, 0);
								var u = t.text.trim();
								t.text = decodeURIComponent(encodeURIComponent(u)), t.id || (t.id = Mr(t.startTime, t.endTime, u)), t.endTime > 0 && c.push(t)
							}, d.onparsingerror = function(t) {
								u = t
							}, d.onflush = function() {
								u ? l(u) : o(c)
							}, h.forEach((function(t) {
								if(m) {
									if(xr(t, "X-TIMESTAMP-MAP=")) {
										m = !1, t.slice(16).split(",").forEach((function(t) {
											xr(t, "LOCAL:") ? g = t.slice(6) : xr(t, "MPEGTS:") && (v = parseInt(t.slice(7)))
										}));
										try {
											p = function(t) {
												var e = parseInt(t.slice(-3)),
													r = parseInt(t.slice(-6, -4)),
													i = parseInt(t.slice(-9, -7)),
													n = t.length > 9 ? parseInt(t.substring(0, t.indexOf(":"))) : 0;
												if(!((0, a.isFiniteNumber)(e) && (0, a.isFiniteNumber)(r) && (0, a.isFiniteNumber)(i) && (0, a.isFiniteNumber)(n))) throw Error("Malformed X-TIMESTAMP-MAP: Local:" + t);
												return e += 1e3 * r, (e += 6e4 * i) + 36e5 * n
											}(g) / 1e3
										} catch(t) {
											u = t
										}
										return
									}
									"" === t && (m = !1)
								}
								d.parse(t + "\n")
							})), d.flush()
						}(null !== (i = t.initSegment) && void 0 !== i && i.data ? (0, R.appendUint8Array)(t.initSegment.data, new Uint8Array(e)) : e, this.initPTS[t.cc], this.timescale[t.cc], r, t.cc, t.start, (function(e) {
							n._appendCues(e, t.level), o.trigger(s.Events.SUBTITLE_FRAG_PROCESSED, {
								success: !0,
								frag: t
							})
						}), (function(r) {
							n._fallbackToIMSC1(t, e), l.logger.log("Failed to parse VTT cue: " + r), o.trigger(s.Events.SUBTITLE_FRAG_PROCESSED, {
								success: !1,
								frag: t,
								error: r
							})
						}))
					}, e._fallbackToIMSC1 = function(t, e) {
						var r = this,
							i = this.tracks[t.level];
						i.textCodec || Hr(e, this.initPTS[t.cc], this.timescale[t.cc], (function() {
							i.textCodec = Ur, r._parseIMSC1(t, e)
						}), (function() {
							i.textCodec = "wvtt"
						}))
					}, e._appendCues = function(t, e) {
						var r = this.hls;
						if(this.config.renderTextTracksNatively) {
							var i = this.textTracks[e];
							if(!i || "disabled" === i.mode) return;
							t.forEach((function(t) {
								return X(i, t)
							}))
						} else {
							var n = this.tracks[e];
							if(!n) return;
							var a = n.default ? "default" : "subtitles" + e;
							r.trigger(s.Events.CUES_PARSED, {
								type: "subtitles",
								cues: t,
								track: a
							})
						}
					}, e.onFragDecrypted = function(t, e) {
						var r = e.frag;
						if(r.type === V.PlaylistLevelType.SUBTITLE) {
							if(!(0, a.isFiniteNumber)(this.initPTS[r.cc])) return void this.unparsedVttFrags.push(e);
							this.onFragLoaded(s.Events.FRAG_LOADED, e)
						}
					}, e.onSubtitleTracksCleared = function() {
						this.tracks = [], this.captionsTracks = {}
					}, e.onFragParsingUserdata = function(t, e) {
						var r = this.cea608Parser1,
							i = this.cea608Parser2;
						if(this.enabled && r && i) {
							var n = e.frag,
								a = e.samples;
							if(n.type !== V.PlaylistLevelType.MAIN || "NONE" !== this.closedCaptionsForLevel(n))
								for(var s = 0; s < a.length; s++) {
									var o = a[s].bytes;
									if(o) {
										var l = this.extractCea608Data(o);
										r.addData(a[s].pts, l[0]), i.addData(a[s].pts, l[1])
									}
								}
						}
					}, e.onBufferFlushing = function(t, e) {
						var r = e.startOffset,
							i = e.endOffset,
							n = e.endOffsetSubtitles,
							a = e.type,
							s = this.media;
						if(s && !(s.currentTime < i)) {
							if(!a || "video" === a) {
								var o = this.captionsTracks;
								Object.keys(o).forEach((function(t) {
									return Q(o[t], r, i)
								}))
							}
							if(this.config.renderTextTracksNatively && 0 === r && void 0 !== n) {
								var l = this.textTracks;
								Object.keys(l).forEach((function(t) {
									return Q(l[t], r, n)
								}))
							}
						}
					}, e.extractCea608Data = function(t) {
						for(var e = [
								[],
								[]
							], r = 31 & t[0], i = 2, n = 0; n < r; n++) {
							var a = t[i++],
								s = 127 & t[i++],
								o = 127 & t[i++];
							if((0 !== s || 0 !== o) && 0 != (4 & a)) {
								var l = 3 & a;
								0 !== l && 1 !== l || (e[l].push(s), e[l].push(o))
							}
						}
						return e
					}, t
				}();

				function Qr(t, e) {
					return t && t.label === e.name && !(t.textTrack1 || t.textTrack2)
				}

				function $r(t, e) {
					for(var r = 0; r < e.length; r++) {
						var i = e[r];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, (void 0, "symbol" == typeof(n = function(t, e) {
							if("object" != typeof t || null === t) return t;
							var r = t[Symbol.toPrimitive];
							if(void 0 !== r) {
								var i = r.call(t, e);
								if("object" != typeof i) return i;
								throw new TypeError("@@toPrimitive must return a primitive value.")
							}
							return String(t)
						}(i.key, "string")) ? n : String(n)), i)
					}
					var n
				}
				const Jr = function() {
						function t(t) {
							this.autoLevelCapping = void 0, this.firstLevel = void 0, this.media = void 0, this.restrictedLevels = void 0, this.timer = void 0, this.hls = void 0, this.streamController = void 0, this.clientRect = void 0, this.hls = t, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.firstLevel = -1, this.media = null, this.restrictedLevels = [], this.timer = void 0, this.clientRect = null, this.registerListeners()
						}
						var e, r, i = t.prototype;
						return i.setStreamController = function(t) {
							this.streamController = t
						}, i.destroy = function() {
							this.unregisterListener(), this.hls.config.capLevelToPlayerSize && this.stopCapping(), this.media = null, this.clientRect = null, this.hls = this.streamController = null
						}, i.registerListeners = function() {
							var t = this.hls;
							t.on(s.Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), t.on(s.Events.MEDIA_ATTACHING, this.onMediaAttaching, this), t.on(s.Events.MANIFEST_PARSED, this.onManifestParsed, this), t.on(s.Events.BUFFER_CODECS, this.onBufferCodecs, this), t.on(s.Events.MEDIA_DETACHING, this.onMediaDetaching, this)
						}, i.unregisterListener = function() {
							var t = this.hls;
							t.off(s.Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), t.off(s.Events.MEDIA_ATTACHING, this.onMediaAttaching, this), t.off(s.Events.MANIFEST_PARSED, this.onManifestParsed, this), t.off(s.Events.BUFFER_CODECS, this.onBufferCodecs, this), t.off(s.Events.MEDIA_DETACHING, this.onMediaDetaching, this)
						}, i.onFpsDropLevelCapping = function(e, r) {
							t.isLevelAllowed(r.droppedLevel, this.restrictedLevels) && this.restrictedLevels.push(r.droppedLevel)
						}, i.onMediaAttaching = function(t, e) {
							this.media = e.media instanceof HTMLVideoElement ? e.media : null, this.clientRect = null
						}, i.onManifestParsed = function(t, e) {
							var r = this.hls;
							this.restrictedLevels = [], this.firstLevel = e.firstLevel, r.config.capLevelToPlayerSize && e.video && this.startCapping()
						}, i.onBufferCodecs = function(t, e) {
							this.hls.config.capLevelToPlayerSize && e.video && this.startCapping()
						}, i.onMediaDetaching = function() {
							this.stopCapping()
						}, i.detectPlayerSize = function() {
							if(this.media && this.mediaHeight > 0 && this.mediaWidth > 0) {
								var t = this.hls.levels;
								if(t.length) {
									var e = this.hls;
									e.autoLevelCapping = this.getMaxLevel(t.length - 1), e.autoLevelCapping > this.autoLevelCapping && this.streamController && this.streamController.nextLevelSwitch(), this.autoLevelCapping = e.autoLevelCapping
								}
							}
						}, i.getMaxLevel = function(e) {
							var r = this,
								i = this.hls.levels;
							if(!i.length) return -1;
							var n = i.filter((function(i, n) {
								return t.isLevelAllowed(n, r.restrictedLevels) && n <= e
							}));
							return this.clientRect = null, t.getMaxLevelByMediaSize(n, this.mediaWidth, this.mediaHeight)
						}, i.startCapping = function() {
							this.timer || (this.autoLevelCapping = Number.POSITIVE_INFINITY, this.hls.firstLevel = this.getMaxLevel(this.firstLevel), self.clearInterval(this.timer), this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3), this.detectPlayerSize())
						}, i.stopCapping = function() {
							this.restrictedLevels = [], this.firstLevel = -1, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.timer && (self.clearInterval(this.timer), this.timer = void 0)
						}, i.getDimensions = function() {
							if(this.clientRect) return this.clientRect;
							var t = this.media,
								e = {
									width: 0,
									height: 0
								};
							if(t) {
								var r = t.getBoundingClientRect();
								e.width = r.width, e.height = r.height, e.width || e.height || (e.width = r.right - r.left || t.width || 0, e.height = r.bottom - r.top || t.height || 0)
							}
							return this.clientRect = e, e
						}, t.isLevelAllowed = function(t, e) {
							return void 0 === e && (e = []), -1 === e.indexOf(t)
						}, t.getMaxLevelByMediaSize = function(t, e, r) {
							if(!t || !t.length) return -1;
							for(var i, n, a = t.length - 1, s = 0; s < t.length; s += 1) {
								var o = t[s];
								if((o.width >= e || o.height >= r) && (i = o, !(n = t[s + 1]) || i.width !== n.width || i.height !== n.height)) {
									a = s;
									break
								}
							}
							return a
						}, e = t, (r = [{
							key: "mediaWidth",
							get: function() {
								return this.getDimensions().width * this.contentScaleFactor
							}
						}, {
							key: "mediaHeight",
							get: function() {
								return this.getDimensions().height * this.contentScaleFactor
							}
						}, {
							key: "contentScaleFactor",
							get: function() {
								var t = 1;
								if(!this.hls.config.ignoreDevicePixelRatio) try {
									t = self.devicePixelRatio
								} catch(t) {}
								return t
							}
						}]) && $r(e.prototype, r), Object.defineProperty(e, "prototype", {
							writable: !1
						}), t
					}(),
					Zr = function() {
						function t(t) {
							this.hls = void 0, this.isVideoPlaybackQualityAvailable = !1, this.timer = void 0, this.media = null, this.lastTime = void 0, this.lastDroppedFrames = 0, this.lastDecodedFrames = 0, this.streamController = void 0, this.hls = t, this.registerListeners()
						}
						var e = t.prototype;
						return e.setStreamController = function(t) {
							this.streamController = t
						}, e.registerListeners = function() {
							this.hls.on(s.Events.MEDIA_ATTACHING, this.onMediaAttaching, this)
						}, e.unregisterListeners = function() {
							this.hls.off(s.Events.MEDIA_ATTACHING, this.onMediaAttaching)
						}, e.destroy = function() {
							this.timer && clearInterval(this.timer), this.unregisterListeners(), this.isVideoPlaybackQualityAvailable = !1, this.media = null
						}, e.onMediaAttaching = function(t, e) {
							var r = this.hls.config;
							if(r.capLevelOnFPSDrop) {
								var i = e.media instanceof self.HTMLVideoElement ? e.media : null;
								this.media = i, i && "function" == typeof i.getVideoPlaybackQuality && (this.isVideoPlaybackQualityAvailable = !0), self.clearInterval(this.timer), this.timer = self.setInterval(this.checkFPSInterval.bind(this), r.fpsDroppedMonitoringPeriod)
							}
						}, e.checkFPS = function(t, e, r) {
							var i = performance.now();
							if(e) {
								if(this.lastTime) {
									var n = i - this.lastTime,
										a = r - this.lastDroppedFrames,
										o = e - this.lastDecodedFrames,
										u = 1e3 * a / n,
										d = this.hls;
									if(d.trigger(s.Events.FPS_DROP, {
											currentDropped: a,
											currentDecoded: o,
											totalDroppedFrames: r
										}), u > 0 && a > d.config.fpsDroppedMonitoringThreshold * o) {
										var h = d.currentLevel;
										l.logger.warn("drop FPS ratio greater than max allowed value for currentLevel: " + h), h > 0 && (-1 === d.autoLevelCapping || d.autoLevelCapping >= h) && (h -= 1, d.trigger(s.Events.FPS_DROP_LEVEL_CAPPING, {
											level: h,
											droppedLevel: d.currentLevel
										}), d.autoLevelCapping = h, this.streamController.nextLevelSwitch())
									}
								}
								this.lastTime = i, this.lastDroppedFrames = r, this.lastDecodedFrames = e
							}
						}, e.checkFPSInterval = function() {
							var t = this.media;
							if(t)
								if(this.isVideoPlaybackQualityAvailable) {
									var e = t.getVideoPlaybackQuality();
									this.checkFPS(t, e.totalVideoFrames, e.droppedVideoFrames)
								} else this.checkFPS(t, t.webkitDecodedFrameCount, t.webkitDroppedFrameCount)
						}, t
					}();
				var ti = r(300);

				function ei(t) {
					var e = "function" == typeof Map ? new Map : void 0;
					return ei = function(t) {
						if(null === t || (r = t, -1 === Function.toString.call(r).indexOf("[native code]"))) return t;
						var r;
						if("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
						if(void 0 !== e) {
							if(e.has(t)) return e.get(t);
							e.set(t, i)
						}

						function i() {
							return ri(t, arguments, ai(this).constructor)
						}
						return i.prototype = Object.create(t.prototype, {
							constructor: {
								value: i,
								enumerable: !1,
								writable: !0,
								configurable: !0
							}
						}), ni(i, t)
					}, ei(t)
				}

				function ri(t, e, r) {
					return ri = ii() ? Reflect.construct.bind() : function(t, e, r) {
						var i = [null];
						i.push.apply(i, e);
						var n = new(Function.bind.apply(t, i));
						return r && ni(n, r.prototype), n
					}, ri.apply(null, arguments)
				}

				function ii() {
					if("undefined" == typeof Reflect || !Reflect.construct) return !1;
					if(Reflect.construct.sham) return !1;
					if("function" == typeof Proxy) return !0;
					try {
						return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
					} catch(t) {
						return !1
					}
				}

				function ni(t, e) {
					return ni = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
						return t.__proto__ = e, t
					}, ni(t, e)
				}

				function ai(t) {
					return ai = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
						return t.__proto__ || Object.getPrototypeOf(t)
					}, ai(t)
				}
				var si = "[eme]",
					oi = function() {
						function t(e) {
							this.hls = void 0, this.config = void 0, this.media = null, this.keyFormatPromise = null, this.keySystemAccessPromises = {}, this._requestLicenseFailureCount = 0, this.mediaKeySessions = [], this.keyIdToKeySessionPromise = {}, this.setMediaKeysQueue = t.CDMCleanupPromise ? [t.CDMCleanupPromise] : [], this.onMediaEncrypted = this._onMediaEncrypted.bind(this), this.onWaitingForKey = this._onWaitingForKey.bind(this), this.debug = l.logger.debug.bind(l.logger, si), this.log = l.logger.log.bind(l.logger, si), this.warn = l.logger.warn.bind(l.logger, si), this.error = l.logger.error.bind(l.logger, si), this.hls = e, this.config = e.config, this.registerListeners()
						}
						var e = t.prototype;
						return e.destroy = function() {
							this.unregisterListeners(), this.onMediaDetached(), this.hls = this.onMediaEncrypted = this.onWaitingForKey = this.keyIdToKeySessionPromise = null
						}, e.registerListeners = function() {
							this.hls.on(s.Events.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(s.Events.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.on(s.Events.MANIFEST_LOADED, this.onManifestLoaded, this)
						}, e.unregisterListeners = function() {
							this.hls.off(s.Events.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.off(s.Events.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.off(s.Events.MANIFEST_LOADED, this.onManifestLoaded, this)
						}, e.getLicenseServerUrl = function(t) {
							var e = this.config,
								r = e.drmSystems,
								i = e.widevineLicenseUrl,
								n = r[t];
							if(n) return n.licenseUrl;
							if(t === m.WIDEVINE && i) return i;
							throw new Error('no license server URL configured for key-system "' + t + '"')
						}, e.getServerCertificateUrl = function(t) {
							var e = this.config.drmSystems[t];
							if(e) return e.serverCertificateUrl;
							this.log('No Server Certificate in config.drmSystems["' + t + '"]')
						}, e.attemptKeySystemAccess = function(t) {
							var e = this,
								r = this.hls.levels,
								i = function(t, e, r) {
									return !!t && r.indexOf(t) === e
								},
								n = r.map((function(t) {
									return t.audioCodec
								})).filter(i),
								a = r.map((function(t) {
									return t.videoCodec
								})).filter(i);
							return n.length + a.length === 0 && a.push("avc1.42e01e"), new Promise((function(r, i) {
								! function t(s) {
									var l = s.shift();
									e.getMediaKeysPromise(l, n, a).then((function(t) {
										return r({
											keySystem: l,
											mediaKeys: t
										})
									})).catch((function(e) {
										s.length ? t(s) : i(e instanceof li ? e : new li({
											type: o.ErrorTypes.KEY_SYSTEM_ERROR,
											details: o.ErrorDetails.KEY_SYSTEM_NO_ACCESS,
											error: e,
											fatal: !0
										}, e.message))
									}))
								}(t)
							}))
						}, e.requestMediaKeySystemAccess = function(t, e) {
							var r = this.config.requestMediaKeySystemAccessFunc;
							if("function" != typeof r) {
								var i = "Configured requestMediaKeySystemAccess is not a function " + r;
								return null === k && "http:" === self.location.protocol && (i = "navigator.requestMediaKeySystemAccess is not available over insecure protocol " + location.protocol), Promise.reject(new Error(i))
							}
							return r(t, e)
						}, e.getMediaKeysPromise = function(t, e, r) {
							var i = this,
								n = function(t, e, r, i) {
									var n;
									switch(t) {
										case m.FAIRPLAY:
											n = ["cenc", "sinf"];
											break;
										case m.WIDEVINE:
										case m.PLAYREADY:
											n = ["cenc"];
											break;
										case m.CLEARKEY:
											n = ["cenc", "keyids"];
											break;
										default:
											throw new Error("Unknown key-system: " + t)
									}
									return function(t, e, r, i) {
										return [{
											initDataTypes: t,
											persistentState: i.persistentState || "not-allowed",
											distinctiveIdentifier: i.distinctiveIdentifier || "not-allowed",
											sessionTypes: i.sessionTypes || [i.sessionType || "temporary"],
											audioCapabilities: e.map((function(t) {
												return {
													contentType: 'audio/mp4; codecs="' + t + '"',
													robustness: i.audioRobustness || "",
													encryptionScheme: i.audioEncryptionScheme || null
												}
											})),
											videoCapabilities: r.map((function(t) {
												return {
													contentType: 'video/mp4; codecs="' + t + '"',
													robustness: i.videoRobustness || "",
													encryptionScheme: i.videoEncryptionScheme || null
												}
											}))
										}]
									}(n, e, r, i)
								}(t, e, r, this.config.drmSystemOptions),
								a = this.keySystemAccessPromises[t],
								s = null == a ? void 0 : a.keySystemAccess;
							if(!s) {
								this.log('Requesting encrypted media "' + t + '" key-system access with config: ' + JSON.stringify(n)), s = this.requestMediaKeySystemAccess(t, n);
								var o = this.keySystemAccessPromises[t] = {
									keySystemAccess: s
								};
								return s.catch((function(e) {
									i.log('Failed to obtain access to key-system "' + t + '": ' + e)
								})), s.then((function(e) {
									i.log('Access for key-system "' + e.keySystem + '" obtained');
									var r = i.fetchServerCertificate(t);
									return i.log('Create media-keys for "' + t + '"'), o.mediaKeys = e.createMediaKeys().then((function(e) {
										return i.log('Media-keys created for "' + t + '"'), r.then((function(r) {
											return r ? i.setMediaKeysServerCertificate(e, t, r) : e
										}))
									})), o.mediaKeys.catch((function(e) {
										i.error('Failed to create media-keys for "' + t + '"}: ' + e)
									})), o.mediaKeys
								}))
							}
							return s.then((function() {
								return a.mediaKeys
							}))
						}, e.createMediaKeySessionContext = function(t) {
							var e = t.decryptdata,
								r = t.keySystem,
								i = t.mediaKeys;
							this.log('Creating key-system session "' + r + '" keyId: ' + ti.default.hexDump(e.keyId || []));
							var n = i.createSession(),
								a = {
									decryptdata: e,
									keySystem: r,
									mediaKeys: i,
									mediaKeysSession: n,
									keyStatus: "status-pending"
								};
							return this.mediaKeySessions.push(a), a
						}, e.renewKeySession = function(t) {
							var e = t.decryptdata;
							if(e.pssh) {
								var r = this.createMediaKeySessionContext(t),
									i = this.getKeyIdString(e);
								this.keyIdToKeySessionPromise[i] = this.generateRequestWithPreferredKeySession(r, "cenc", e.pssh, "expired")
							} else this.warn("Could not renew expired session. Missing pssh initData.");
							this.removeSession(t)
						}, e.getKeyIdString = function(t) {
							if(!t) throw new Error("Could not read keyId of undefined decryptdata");
							if(null === t.keyId) throw new Error("keyId is null");
							return ti.default.hexDump(t.keyId)
						}, e.updateKeySession = function(t, e) {
							var r, i = t.mediaKeysSession;
							return this.log('Updating key-session "' + i.sessionId + '" for keyID ' + ti.default.hexDump((null === (r = t.decryptdata) || void 0 === r ? void 0 : r.keyId) || []) + "\n      } (data length: " + (e ? e.byteLength : e) + ")"), i.update(e)
						}, e.selectKeySystemFormat = function(t) {
							var e = Object.keys(t.levelkeys || {});
							return this.keyFormatPromise || (this.log("Selecting key-system from fragment (sn: " + t.sn + " " + t.type + ": " + t.level + ") key formats " + e.join(", ")), this.keyFormatPromise = this.getKeyFormatPromise(e)), this.keyFormatPromise
						}, e.getKeyFormatPromise = function(t) {
							var e = this;
							return new Promise((function(r, i) {
								var n = D(e.config),
									a = t.map(L).filter((function(t) {
										return !!t && -1 !== n.indexOf(t)
									}));
								return e.getKeySystemSelectionPromise(a).then((function(t) {
									var e = t.keySystem,
										n = A(e);
									n ? r(n) : i(new Error('Unable to find format for key-system "' + e + '"'))
								})).catch(i)
							}))
						}, e.loadKey = function(t) {
							var e = this,
								r = t.keyInfo.decryptdata,
								i = this.getKeyIdString(r),
								n = "(keyId: " + i + ' format: "' + r.keyFormat + '" method: ' + r.method + " uri: " + r.uri + ")";
							this.log("Starting session for key " + n);
							var a = this.keyIdToKeySessionPromise[i];
							return a || (a = this.keyIdToKeySessionPromise[i] = this.getKeySystemForKeyPromise(r).then((function(i) {
								var a = i.keySystem,
									s = i.mediaKeys;
								return e.throwIfDestroyed(), e.log("Handle encrypted media sn: " + t.frag.sn + " " + t.frag.type + ": " + t.frag.level + " using key " + n), e.attemptSetMediaKeys(a, s).then((function() {
									e.throwIfDestroyed();
									var t = e.createMediaKeySessionContext({
										keySystem: a,
										mediaKeys: s,
										decryptdata: r
									});
									return e.generateRequestWithPreferredKeySession(t, "cenc", r.pssh, "playlist-key")
								}))
							}))).catch((function(t) {
								return e.handleError(t)
							})), a
						}, e.throwIfDestroyed = function(t) {
							if(void 0 === t && (t = "Invalid state"), !this.hls) throw new Error("invalid state")
						}, e.handleError = function(t) {
							this.hls && (this.error(t.message), t instanceof li ? this.hls.trigger(s.Events.ERROR, t.data) : this.hls.trigger(s.Events.ERROR, {
								type: o.ErrorTypes.KEY_SYSTEM_ERROR,
								details: o.ErrorDetails.KEY_SYSTEM_NO_KEYS,
								error: t,
								fatal: !0
							}))
						}, e.getKeySystemForKeyPromise = function(t) {
							var e = this.getKeyIdString(t),
								r = this.keyIdToKeySessionPromise[e];
							if(!r) {
								var i = L(t.keyFormat),
									n = i ? [i] : D(this.config);
								return this.attemptKeySystemAccess(n)
							}
							return r
						}, e.getKeySystemSelectionPromise = function(t) {
							if(t.length || (t = D(this.config)), 0 === t.length) throw new li({
								type: o.ErrorTypes.KEY_SYSTEM_ERROR,
								details: o.ErrorDetails.KEY_SYSTEM_NO_CONFIGURED_LICENSE,
								fatal: !0
							}, "Missing key-system license configuration options " + JSON.stringify({
								drmSystems: this.config.drmSystems
							}));
							return this.attemptKeySystemAccess(t)
						}, e._onMediaEncrypted = function(t) {
							var e = this,
								r = t.initDataType,
								i = t.initData;
							if(this.debug('"' + t.type + '" event: init data type: "' + r + '"'), null !== i) {
								var n, a;
								if("sinf" === r && this.config.drmSystems[m.FAIRPLAY]) {
									var s = (0, R.bin2str)(new Uint8Array(i));
									try {
										var o = S(JSON.parse(s).sinf),
											l = (0, R.parseSinf)(new Uint8Array(o));
										if(!l) return;
										n = l.subarray(8, 24), a = m.FAIRPLAY
									} catch(t) {
										return void this.warn('Failed to parse sinf "encrypted" event message initData')
									}
								} else {
									var u = (0, R.parsePssh)(i);
									if(null === u) return;
									0 === u.version && u.systemId === E.WIDEVINE && u.data && (n = u.data.subarray(8, 24)), a = function(t) {
										if(t === E.WIDEVINE) return m.WIDEVINE
									}(u.systemId)
								}
								if(a && n) {
									for(var d = ti.default.hexDump(n), h = this.keyIdToKeySessionPromise, c = this.mediaKeySessions, f = h[d], g = function(t) {
											var a = c[t],
												s = a.decryptdata;
											if(s.pssh || !s.keyId) return "continue";
											var o = ti.default.hexDump(s.keyId);
											return d === o || -1 !== s.uri.replace(/-/g, "").indexOf(d) ? (f = h[o], delete h[o], s.pssh = new Uint8Array(i), s.keyId = n, f = h[d] = f.then((function() {
												return e.generateRequestWithPreferredKeySession(a, r, i, "encrypted-event-key-match")
											})), "break") : void 0
										}, v = 0; v < c.length; v++) {
										var p = g(v);
										if("continue" !== p && "break" === p) break
									}
									f || (f = h[d] = this.getKeySystemSelectionPromise([a]).then((function(t) {
										var a, s = t.keySystem,
											o = t.mediaKeys;
										e.throwIfDestroyed();
										var l = new w("ISO-23001-7", d, null != (a = A(s)) ? a : "");
										return l.pssh = new Uint8Array(i), l.keyId = n, e.attemptSetMediaKeys(s, o).then((function() {
											e.throwIfDestroyed();
											var t = e.createMediaKeySessionContext({
												decryptdata: l,
												keySystem: s,
												mediaKeys: o
											});
											return e.generateRequestWithPreferredKeySession(t, r, i, "encrypted-event-no-match")
										}))
									}))), f.catch((function(t) {
										return e.handleError(t)
									}))
								}
							}
						}, e._onWaitingForKey = function(t) {
							this.log('"' + t.type + '" event')
						}, e.attemptSetMediaKeys = function(t, e) {
							var r = this,
								i = this.setMediaKeysQueue.slice();
							this.log('Setting media-keys for "' + t + '"');
							var n = Promise.all(i).then((function() {
								if(!r.media) throw new Error("Attempted to set mediaKeys without media element attached");
								return r.media.setMediaKeys(e)
							}));
							return this.setMediaKeysQueue.push(n), n.then((function() {
								r.log('Media-keys set for "' + t + '"'), i.push(n), r.setMediaKeysQueue = r.setMediaKeysQueue.filter((function(t) {
									return -1 === i.indexOf(t)
								}))
							}))
						}, e.generateRequestWithPreferredKeySession = function(t, e, r, i) {
							var n, a, s = this,
								l = null === (n = this.config.drmSystems) || void 0 === n || null === (a = n[t.keySystem]) || void 0 === a ? void 0 : a.generateRequest;
							if(l) try {
								var u = l.call(this.hls, e, r, t);
								if(!u) throw new Error("Invalid response from configured generateRequest filter");
								e = u.initDataType, r = t.decryptdata.pssh = u.initData ? new Uint8Array(u.initData) : null
							} catch(t) {
								var d;
								if(this.warn(t.message), null !== (d = this.hls) && void 0 !== d && d.config.debug) throw t
							}
							if(null === r) return this.log('Skipping key-session request for "' + i + '" (no initData)'), Promise.resolve(t);
							var h = this.getKeyIdString(t.decryptdata);
							this.log('Generating key-session request for "' + i + '": ' + h + " (init data type: " + e + " length: " + (r ? r.byteLength : null) + ")");
							var c = new(be());
							t.mediaKeysSession.onmessage = function(e) {
								var r = t.mediaKeysSession;
								if(r) {
									var i = e.messageType,
										n = e.message;
									s.log('"' + i + '" message event for session "' + r.sessionId + '" message size: ' + n.byteLength), "license-request" === i || "license-renewal" === i ? s.renewLicense(t, n).catch((function(t) {
										s.handleError(t), c.emit("error", t)
									})) : "license-release" === i ? t.keySystem === m.FAIRPLAY && (s.updateKeySession(t, b("acknowledged")), s.removeSession(t)) : s.warn('unhandled media key message type "' + i + '"')
								} else c.emit("error", new Error("invalid state"))
							}, t.mediaKeysSession.onkeystatuseschange = function(e) {
								if(t.mediaKeysSession) {
									s.onKeyStatusChange(t);
									var r = t.keyStatus;
									c.emit("keyStatus", r), "expired" === r && (s.warn(t.keySystem + " expired for key " + h), s.renewKeySession(t))
								} else c.emit("error", new Error("invalid state"))
							};
							var f = new Promise((function(t, e) {
								c.on("error", e), c.on("keyStatus", (function(r) {
									r.startsWith("usable") ? t() : "output-restricted" === r ? e(new li({
										type: o.ErrorTypes.KEY_SYSTEM_ERROR,
										details: o.ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED,
										fatal: !1
									}, "HDCP level output restricted")) : "internal-error" === r ? e(new li({
										type: o.ErrorTypes.KEY_SYSTEM_ERROR,
										details: o.ErrorDetails.KEY_SYSTEM_STATUS_INTERNAL_ERROR,
										fatal: !0
									}, 'key status changed to "' + r + '"')) : "expired" === r ? e(new Error("key expired while generating request")) : s.warn('unhandled key status change "' + r + '"')
								}))
							}));
							return t.mediaKeysSession.generateRequest(e, r).then((function() {
								var e;
								s.log('Request generated for key-session "' + (null === (e = t.mediaKeysSession) || void 0 === e ? void 0 : e.sessionId) + '" keyId: ' + h)
							})).catch((function(t) {
								throw new li({
									type: o.ErrorTypes.KEY_SYSTEM_ERROR,
									details: o.ErrorDetails.KEY_SYSTEM_NO_SESSION,
									error: t,
									fatal: !1
								}, "Error generating key-session request: " + t)
							})).then((function() {
								return f
							})).catch((function(e) {
								throw c.removeAllListeners(), s.removeSession(t), e
							})).then((function() {
								return c.removeAllListeners(), t
							}))
						}, e.onKeyStatusChange = function(t) {
							var e = this;
							t.mediaKeysSession.keyStatuses.forEach((function(r, i) {
								e.log('key status change "' + r + '" for keyStatuses keyId: ' + ti.default.hexDump("buffer" in i ? new Uint8Array(i.buffer, i.byteOffset, i.byteLength) : new Uint8Array(i)) + " session keyId: " + ti.default.hexDump(new Uint8Array(t.decryptdata.keyId || [])) + " uri: " + t.decryptdata.uri), t.keyStatus = r
							}))
						}, e.fetchServerCertificate = function(t) {
							var e = this;
							return new Promise((function(r, i) {
								var n = e.getServerCertificateUrl(t);
								if(!n) return r();
								e.log('Fetching serverCertificate for "' + t + '"');
								var a = new XMLHttpRequest;
								a.open("GET", n, !0), a.responseType = "arraybuffer", a.onreadystatechange = function() {
									a.readyState === XMLHttpRequest.DONE && (200 === a.status ? r(a.response) : i(new li({
										type: o.ErrorTypes.KEY_SYSTEM_ERROR,
										details: o.ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
										fatal: !0,
										networkDetails: a
									}, '"' + t + '" certificate request XHR failed (' + n + "). Status: " + a.status + " (" + a.statusText + ")")))
								}, a.send()
							}))
						}, e.setMediaKeysServerCertificate = function(t, e, r) {
							var i = this;
							return new Promise((function(n, a) {
								t.setServerCertificate(r).then((function(a) {
									i.log("setServerCertificate " + (a ? "success" : "not supported by CDM") + " (" + (null == r ? void 0 : r.byteLength) + ') on "' + e + '"'), n(t)
								})).catch((function(t) {
									a(new li({
										type: o.ErrorTypes.KEY_SYSTEM_ERROR,
										details: o.ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,
										error: t,
										fatal: !0
									}, t.message))
								}))
							}))
						}, e.renewLicense = function(t, e) {
							var r = this;
							return this.requestLicense(t, new Uint8Array(e)).then((function(e) {
								return r.updateKeySession(t, new Uint8Array(e)).catch((function(t) {
									throw new li({
										type: o.ErrorTypes.KEY_SYSTEM_ERROR,
										details: o.ErrorDetails.KEY_SYSTEM_SESSION_UPDATE_FAILED,
										error: t,
										fatal: !0
									}, t.message)
								}))
							}))
						}, e.setupLicenseXHR = function(t, e, r, i) {
							var n = this,
								a = this.config.licenseXhrSetup;
							return a ? Promise.resolve().then((function() {
								if(!r.decryptdata) throw new Error("Key removed");
								return a.call(n.hls, t, e, r, i)
							})).catch((function(s) {
								if(!r.decryptdata) throw s;
								return t.open("POST", e, !0), a.call(n.hls, t, e, r, i)
							})).then((function(r) {
								return t.readyState || t.open("POST", e, !0), {
									xhr: t,
									licenseChallenge: r || i
								}
							})) : (t.open("POST", e, !0), Promise.resolve({
								xhr: t,
								licenseChallenge: i
							}))
						}, e.requestLicense = function(t, e) {
							var r = this;
							return new Promise((function(i, n) {
								var a = r.getLicenseServerUrl(t.keySystem);
								r.log("Sending license request to URL: " + a);
								var s = new XMLHttpRequest;
								s.responseType = "arraybuffer", s.onreadystatechange = function() {
									if(!r.hls || !t.mediaKeysSession) return n(new Error("invalid state"));
									if(4 === s.readyState)
										if(200 === s.status) {
											r._requestLicenseFailureCount = 0;
											var l = s.response;
											r.log("License received " + (l instanceof ArrayBuffer ? l.byteLength : l));
											var u = r.config.licenseResponseCallback;
											if(u) try {
												l = u.call(r.hls, s, a, t)
											} catch(t) {
												r.error(t)
											}
											i(l)
										} else if(r._requestLicenseFailureCount++, r._requestLicenseFailureCount > 3 || s.status >= 400 && s.status < 500) n(new li({
										type: o.ErrorTypes.KEY_SYSTEM_ERROR,
										details: o.ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
										fatal: !0,
										networkDetails: s
									}, "License Request XHR failed (" + a + "). Status: " + s.status + " (" + s.statusText + ")"));
									else {
										var d = 3 - r._requestLicenseFailureCount + 1;
										r.warn("Retrying license request, " + d + " attempts left"), r.requestLicense(t, e).then(i, n)
									}
								}, t.licenseXhr && t.licenseXhr.readyState !== XMLHttpRequest.DONE && t.licenseXhr.abort(), t.licenseXhr = s, r.setupLicenseXHR(s, a, t, e).then((function(t) {
									var e = t.xhr,
										r = t.licenseChallenge;
									e.send(r)
								}))
							}))
						}, e.onMediaAttached = function(t, e) {
							if(this.config.emeEnabled) {
								var r = e.media;
								this.media = r, r.addEventListener("encrypted", this.onMediaEncrypted), r.addEventListener("waitingforkey", this.onWaitingForKey)
							}
						}, e.onMediaDetached = function() {
							var e = this,
								r = this.media,
								i = this.mediaKeySessions;
							r && (r.removeEventListener("encrypted", this.onMediaEncrypted), r.removeEventListener("waitingforkey", this.onWaitingForKey), this.media = null), this._requestLicenseFailureCount = 0, this.setMediaKeysQueue = [], this.mediaKeySessions = [], this.keyIdToKeySessionPromise = {}, w.clearKeyUriToKeyIdMap();
							var n = i.length;
							t.CDMCleanupPromise = Promise.all(i.map((function(t) {
								return e.removeSession(t)
							})).concat(null == r ? void 0 : r.setMediaKeys(null).catch((function(t) {
								e.log("Could not clear media keys: " + t + ". media.src: " + (null == r ? void 0 : r.src))
							})))).then((function() {
								n && (e.log("finished closing key sessions and clearing media keys"), i.length = 0)
							})).catch((function(t) {
								e.log("Could not close sessions and clear media keys: " + t + ". media.src: " + (null == r ? void 0 : r.src))
							}))
						}, e.onManifestLoaded = function(t, e) {
							var r = e.sessionKeys;
							if(r && this.config.emeEnabled && !this.keyFormatPromise) {
								var i = r.reduce((function(t, e) {
									return -1 === t.indexOf(e.keyFormat) && t.push(e.keyFormat), t
								}), []);
								this.log("Selecting key-system from session-keys " + i.join(", ")), this.keyFormatPromise = this.getKeyFormatPromise(i)
							}
						}, e.removeSession = function(t) {
							var e = this,
								r = t.mediaKeysSession,
								i = t.licenseXhr;
							if(r) {
								this.log("Remove licenses and keys and close session " + r.sessionId), r.onmessage = null, r.onkeystatuseschange = null, i && i.readyState !== XMLHttpRequest.DONE && i.abort(), t.mediaKeysSession = t.decryptdata = t.licenseXhr = void 0;
								var n = this.mediaKeySessions.indexOf(t);
								return n > -1 && this.mediaKeySessions.splice(n, 1), r.remove().catch((function(t) {
									e.log("Could not remove session: " + t)
								})).then((function() {
									return r.close()
								})).catch((function(t) {
									e.log("Could not close session: " + t)
								}))
							}
						}, t
					}();
				oi.CDMCleanupPromise = void 0;
				var li = function(t) {
					var e, r;

					function i(e, r) {
						var i;
						return(i = t.call(this, r) || this).data = void 0, i.data = e, e.err = e.error, i
					}
					return r = t, (e = i).prototype = Object.create(r.prototype), e.prototype.constructor = e, ni(e, r), i
				}(ei(Error));
				const ui = oi;
				var di, hi, ci;

				function fi(t, e) {
					for(var r = 0; r < e.length; r++) {
						var i = e[r];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, (void 0, "symbol" == typeof(n = function(t, e) {
							if("object" != typeof t || null === t) return t;
							var r = t[Symbol.toPrimitive];
							if(void 0 !== r) {
								var i = r.call(t, e);
								if("object" != typeof i) return i;
								throw new TypeError("@@toPrimitive must return a primitive value.")
							}
							return String(t)
						}(i.key, "string")) ? n : String(n)), i)
					}
					var n
				}

				function gi(t, e, r) {
					return e && fi(t.prototype, e), r && fi(t, r), Object.defineProperty(t, "prototype", {
						writable: !1
					}), t
				}

				function vi(t, e) {
					var r = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
					if(r) return(r = r.call(t)).next.bind(r);
					if(Array.isArray(t) || (r = function(t, e) {
							if(t) {
								if("string" == typeof t) return pi(t, e);
								var r = Object.prototype.toString.call(t).slice(8, -1);
								return "Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r ? Array.from(t) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? pi(t, e) : void 0
							}
						}(t)) || e && t && "number" == typeof t.length) {
						r && (t = r);
						var i = 0;
						return function() {
							return i >= t.length ? {
								done: !0
							} : {
								done: !1,
								value: t[i++]
							}
						}
					}
					throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
				}

				function pi(t, e) {
					(null == e || e > t.length) && (e = t.length);
					for(var r = 0, i = new Array(e); r < e; r++) i[r] = t[r];
					return i
				}

				function mi() {
					return mi = Object.assign ? Object.assign.bind() : function(t) {
						for(var e = 1; e < arguments.length; e++) {
							var r = arguments[e];
							for(var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i])
						}
						return t
					}, mi.apply(this, arguments)
				}! function(t) {
					t.MANIFEST = "m", t.AUDIO = "a", t.VIDEO = "v", t.MUXED = "av", t.INIT = "i", t.CAPTION = "c", t.TIMED_TEXT = "tt", t.KEY = "k", t.OTHER = "o"
				}(di || (di = {})),
				function(t) {
					t.DASH = "d", t.HLS = "h", t.SMOOTH = "s", t.OTHER = "o"
				}(hi || (hi = {})),
				function(t) {
					t.VOD = "v", t.LIVE = "l"
				}(ci || (ci = {}));
				var yi = function() {
						function t(e) {
							var r = this;
							this.hls = void 0, this.config = void 0, this.media = void 0, this.sid = void 0, this.cid = void 0, this.useHeaders = !1, this.initialized = !1, this.starved = !1, this.buffering = !0, this.audioBuffer = void 0, this.videoBuffer = void 0, this.onWaiting = function() {
								r.initialized && (r.starved = !0), r.buffering = !0
							}, this.onPlaying = function() {
								r.initialized || (r.initialized = !0), r.buffering = !1
							}, this.applyPlaylistData = function(t) {
								try {
									r.apply(t, {
										ot: di.MANIFEST,
										su: !r.initialized
									})
								} catch(t) {
									l.logger.warn("Could not generate manifest CMCD data.", t)
								}
							}, this.applyFragmentData = function(t) {
								try {
									var e = t.frag,
										i = r.hls.levels[e.level],
										n = r.getObjectType(e),
										a = {
											d: 1e3 * e.duration,
											ot: n
										};
									n !== di.VIDEO && n !== di.AUDIO && n != di.MUXED || (a.br = i.bitrate / 1e3, a.tb = r.getTopBandwidth(n) / 1e3, a.bl = r.getBufferLength(n)), r.apply(t, a)
								} catch(t) {
									l.logger.warn("Could not generate segment CMCD data.", t)
								}
							}, this.hls = e;
							var i = this.config = e.config,
								n = i.cmcd;
							null != n && (i.pLoader = this.createPlaylistLoader(), i.fLoader = this.createFragmentLoader(), this.sid = n.sessionId || t.uuid(), this.cid = n.contentId, this.useHeaders = !0 === n.useHeaders, this.registerListeners())
						}
						var e = t.prototype;
						return e.registerListeners = function() {
							var t = this.hls;
							t.on(s.Events.MEDIA_ATTACHED, this.onMediaAttached, this), t.on(s.Events.MEDIA_DETACHED, this.onMediaDetached, this), t.on(s.Events.BUFFER_CREATED, this.onBufferCreated, this)
						}, e.unregisterListeners = function() {
							var t = this.hls;
							t.off(s.Events.MEDIA_ATTACHED, this.onMediaAttached, this), t.off(s.Events.MEDIA_DETACHED, this.onMediaDetached, this), t.off(s.Events.BUFFER_CREATED, this.onBufferCreated, this), this.onMediaDetached()
						}, e.destroy = function() {
							this.unregisterListeners(), this.hls = this.config = this.audioBuffer = this.videoBuffer = null
						}, e.onMediaAttached = function(t, e) {
							this.media = e.media, this.media.addEventListener("waiting", this.onWaiting), this.media.addEventListener("playing", this.onPlaying)
						}, e.onMediaDetached = function() {
							this.media && (this.media.removeEventListener("waiting", this.onWaiting), this.media.removeEventListener("playing", this.onPlaying), this.media = null)
						}, e.onBufferCreated = function(t, e) {
							var r, i;
							this.audioBuffer = null === (r = e.tracks.audio) || void 0 === r ? void 0 : r.buffer, this.videoBuffer = null === (i = e.tracks.video) || void 0 === i ? void 0 : i.buffer
						}, e.createData = function() {
							var t;
							return {
								v: 1,
								sf: hi.HLS,
								sid: this.sid,
								cid: this.cid,
								pr: null === (t = this.media) || void 0 === t ? void 0 : t.playbackRate,
								mtp: this.hls.bandwidthEstimate / 1e3
							}
						}, e.apply = function(e, r) {
							void 0 === r && (r = {}), mi(r, this.createData());
							var i = r.ot === di.INIT || r.ot === di.VIDEO || r.ot === di.MUXED;
							if(this.starved && i && (r.bs = !0, r.su = !0, this.starved = !1), null == r.su && (r.su = this.buffering), this.useHeaders) {
								var n = t.toHeaders(r);
								if(!Object.keys(n).length) return;
								e.headers || (e.headers = {}), mi(e.headers, n)
							} else {
								var a = t.toQuery(r);
								if(!a) return;
								e.url = t.appendQueryToUri(e.url, a)
							}
						}, e.getObjectType = function(t) {
							var e = t.type;
							return "subtitle" === e ? di.TIMED_TEXT : "initSegment" === t.sn ? di.INIT : "audio" === e ? di.AUDIO : "main" === e ? this.hls.audioTracks.length ? di.VIDEO : di.MUXED : void 0
						}, e.getTopBandwidth = function(t) {
							var e, r = 0,
								i = this.hls;
							if(t === di.AUDIO) e = i.audioTracks;
							else {
								var n = i.maxAutoLevel,
									a = n > -1 ? n + 1 : i.levels.length;
								e = i.levels.slice(0, a)
							}
							for(var s, o = vi(e); !(s = o()).done;) {
								var l = s.value;
								l.bitrate > r && (r = l.bitrate)
							}
							return r > 0 ? r : NaN
						}, e.getBufferLength = function(t) {
							var e = this.hls.media,
								r = t === di.AUDIO ? this.audioBuffer : this.videoBuffer;
							return r && e ? 1e3 * Bt.bufferInfo(r, e.currentTime, this.config.maxBufferHole).len : NaN
						}, e.createPlaylistLoader = function() {
							var t = this.config.pLoader,
								e = this.applyPlaylistData,
								r = t || this.config.loader;
							return function() {
								function t(t) {
									this.loader = void 0, this.loader = new r(t)
								}
								var i = t.prototype;
								return i.destroy = function() {
									this.loader.destroy()
								}, i.abort = function() {
									this.loader.abort()
								}, i.load = function(t, r, i) {
									e(t), this.loader.load(t, r, i)
								}, gi(t, [{
									key: "stats",
									get: function() {
										return this.loader.stats
									}
								}, {
									key: "context",
									get: function() {
										return this.loader.context
									}
								}]), t
							}()
						}, e.createFragmentLoader = function() {
							var t = this.config.fLoader,
								e = this.applyFragmentData,
								r = t || this.config.loader;
							return function() {
								function t(t) {
									this.loader = void 0, this.loader = new r(t)
								}
								var i = t.prototype;
								return i.destroy = function() {
									this.loader.destroy()
								}, i.abort = function() {
									this.loader.abort()
								}, i.load = function(t, r, i) {
									e(t), this.loader.load(t, r, i)
								}, gi(t, [{
									key: "stats",
									get: function() {
										return this.loader.stats
									}
								}, {
									key: "context",
									get: function() {
										return this.loader.context
									}
								}]), t
							}()
						}, t.uuid = function() {
							var t = URL.createObjectURL(new Blob),
								e = t.toString();
							return URL.revokeObjectURL(t), e.slice(e.lastIndexOf("/") + 1)
						}, t.serialize = function(t) {
							for(var e, r = [], i = function(t) {
									return !Number.isNaN(t) && null != t && "" !== t && !1 !== t
								}, n = function(t) {
									return Math.round(t)
								}, a = function(t) {
									return 100 * n(t / 100)
								}, s = {
									br: n,
									d: n,
									bl: a,
									dl: a,
									mtp: a,
									nor: function(t) {
										return encodeURIComponent(t)
									},
									rtp: a,
									tb: n
								}, o = vi(Object.keys(t || {}).sort()); !(e = o()).done;) {
								var l = e.value,
									u = t[l];
								if(i(u) && !("v" === l && 1 === u || "pr" == l && 1 === u)) {
									var d = s[l];
									d && (u = d(u));
									var h, c = typeof u;
									h = "ot" === l || "sf" === l || "st" === l ? l + "=" + u : "boolean" === c ? l : "number" === c ? l + "=" + u : l + "=" + JSON.stringify(u), r.push(h)
								}
							}
							return r.join(",")
						}, t.toHeaders = function(e) {
							for(var r = {}, i = ["Object", "Request", "Session", "Status"], n = [{}, {}, {}, {}], a = {
									br: 0,
									d: 0,
									ot: 0,
									tb: 0,
									bl: 1,
									dl: 1,
									mtp: 1,
									nor: 1,
									nrr: 1,
									su: 1,
									cid: 2,
									pr: 2,
									sf: 2,
									sid: 2,
									st: 2,
									v: 2,
									bs: 3,
									rtp: 3
								}, s = 0, o = Object.keys(e); s < o.length; s++) {
								var l = o[s];
								n[null != a[l] ? a[l] : 1][l] = e[l]
							}
							for(var u = 0; u < n.length; u++) {
								var d = t.serialize(n[u]);
								d && (r["CMCD-" + i[u]] = d)
							}
							return r
						}, t.toQuery = function(e) {
							return "CMCD=" + encodeURIComponent(t.serialize(e))
						}, t.appendQueryToUri = function(t, e) {
							if(!e) return t;
							var r = t.includes("?") ? "&" : "?";
							return "" + t + r + e
						}, t
					}(),
					Ei = r(408),
					Ti = /^age:\s*[\d.]+\s*$/m;
				const Si = function() {
					function t(t) {
						this.xhrSetup = void 0, this.requestTimeout = void 0, this.retryTimeout = void 0, this.retryDelay = void 0, this.config = null, this.callbacks = null, this.context = void 0, this.loader = null, this.stats = void 0, this.xhrSetup = t ? t.xhrSetup : null, this.stats = new Ei.LoadStats, this.retryDelay = 0
					}
					var e = t.prototype;
					return e.destroy = function() {
						this.callbacks = null, this.abortInternal(), this.loader = null, this.config = null
					}, e.abortInternal = function() {
						var t = this.loader;
						self.clearTimeout(this.requestTimeout), self.clearTimeout(this.retryTimeout), t && (t.onreadystatechange = null, t.onprogress = null, 4 !== t.readyState && (this.stats.aborted = !0, t.abort()))
					}, e.abort = function() {
						var t;
						this.abortInternal(), null !== (t = this.callbacks) && void 0 !== t && t.onAbort && this.callbacks.onAbort(this.stats, this.context, this.loader)
					}, e.load = function(t, e, r) {
						if(this.stats.loading.start) throw new Error("Loader can only be used once.");
						this.stats.loading.start = self.performance.now(), this.context = t, this.config = e, this.callbacks = r, this.retryDelay = e.retryDelay, this.loadInternal()
					}, e.loadInternal = function() {
						var t = this.config,
							e = this.context;
						if(t) {
							var r = this.loader = new self.XMLHttpRequest,
								i = this.stats;
							i.loading.first = 0, i.loaded = 0;
							var n = this.xhrSetup;
							try {
								if(n) try {
									n(r, e.url)
								} catch(t) {
									r.open("GET", e.url, !0), n(r, e.url)
								}
								r.readyState || r.open("GET", e.url, !0);
								var a = this.context.headers;
								if(a)
									for(var s in a) r.setRequestHeader(s, a[s])
							} catch(t) {
								return void this.callbacks.onError({
									code: r.status,
									text: t.message
								}, e, r)
							}
							e.rangeEnd && r.setRequestHeader("Range", "bytes=" + e.rangeStart + "-" + (e.rangeEnd - 1)), r.onreadystatechange = this.readystatechange.bind(this), r.onprogress = this.loadprogress.bind(this), r.responseType = e.responseType, self.clearTimeout(this.requestTimeout), this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), t.timeout), r.send()
						}
					}, e.readystatechange = function() {
						var t = this.context,
							e = this.loader,
							r = this.stats;
						if(t && e) {
							var i = e.readyState,
								n = this.config;
							if(!r.aborted && i >= 2)
								if(self.clearTimeout(this.requestTimeout), 0 === r.loading.first && (r.loading.first = Math.max(self.performance.now(), r.loading.start)), 4 === i) {
									e.onreadystatechange = null, e.onprogress = null;
									var a = e.status,
										s = "arraybuffer" === e.responseType;
									if(a >= 200 && a < 300 && (s && e.response || null !== e.responseText)) {
										var o, u;
										if(r.loading.end = Math.max(self.performance.now(), r.loading.first), u = s ? (o = e.response).byteLength : (o = e.responseText).length, r.loaded = r.total = u, !this.callbacks) return;
										var d = this.callbacks.onProgress;
										if(d && d(r, t, o, e), !this.callbacks) return;
										var h = {
											url: e.responseURL,
											data: o
										};
										this.callbacks.onSuccess(h, r, t, e)
									} else r.retry >= n.maxRetry || a >= 400 && a < 499 ? (l.logger.error(a + " while loading " + t.url), this.callbacks.onError({
										code: a,
										text: e.statusText
									}, t, e)) : (l.logger.warn(a + " while loading " + t.url + ", retrying in " + this.retryDelay + "..."), this.abortInternal(), this.loader = null, self.clearTimeout(this.retryTimeout), this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay), this.retryDelay = Math.min(2 * this.retryDelay, n.maxRetryDelay), r.retry++)
								} else self.clearTimeout(this.requestTimeout), this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), n.timeout)
						}
					}, e.loadtimeout = function() {
						l.logger.warn("timeout while loading " + this.context.url);
						var t = this.callbacks;
						t && (this.abortInternal(), t.onTimeout(this.stats, this.context, this.loader))
					}, e.loadprogress = function(t) {
						var e = this.stats;
						e.loaded = t.loaded, t.lengthComputable && (e.total = t.total)
					}, e.getCacheAge = function() {
						var t = null;
						if(this.loader && Ti.test(this.loader.getAllResponseHeaders())) {
							var e = this.loader.getResponseHeader("age");
							t = e ? parseFloat(e) : null
						}
						return t
					}, t
				}();

				function bi(t) {
					var e = "function" == typeof Map ? new Map : void 0;
					return bi = function(t) {
						if(null === t || (r = t, -1 === Function.toString.call(r).indexOf("[native code]"))) return t;
						var r;
						if("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
						if(void 0 !== e) {
							if(e.has(t)) return e.get(t);
							e.set(t, i)
						}

						function i() {
							return Li(t, arguments, ki(this).constructor)
						}
						return i.prototype = Object.create(t.prototype, {
							constructor: {
								value: i,
								enumerable: !1,
								writable: !0,
								configurable: !0
							}
						}), Di(i, t)
					}, bi(t)
				}

				function Li(t, e, r) {
					return Li = Ai() ? Reflect.construct.bind() : function(t, e, r) {
						var i = [null];
						i.push.apply(i, e);
						var n = new(Function.bind.apply(t, i));
						return r && Di(n, r.prototype), n
					}, Li.apply(null, arguments)
				}

				function Ai() {
					if("undefined" == typeof Reflect || !Reflect.construct) return !1;
					if(Reflect.construct.sham) return !1;
					if("function" == typeof Proxy) return !0;
					try {
						return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
					} catch(t) {
						return !1
					}
				}

				function Di(t, e) {
					return Di = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
						return t.__proto__ = e, t
					}, Di(t, e)
				}

				function ki(t) {
					return ki = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
						return t.__proto__ || Object.getPrototypeOf(t)
					}, ki(t)
				}

				function Ri() {
					return Ri = Object.assign ? Object.assign.bind() : function(t) {
						for(var e = 1; e < arguments.length; e++) {
							var r = arguments[e];
							for(var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i])
						}
						return t
					}, Ri.apply(this, arguments)
				}
				var Ii = function() {
					function t(t) {
						this.fetchSetup = void 0, this.requestTimeout = void 0, this.request = void 0, this.response = void 0, this.controller = void 0, this.context = void 0, this.config = null, this.callbacks = null, this.stats = void 0, this.loader = null, this.fetchSetup = t.fetchSetup || wi, this.controller = new self.AbortController, this.stats = new Ei.LoadStats
					}
					var e = t.prototype;
					return e.destroy = function() {
						this.loader = this.callbacks = null, this.abortInternal()
					}, e.abortInternal = function() {
						var t = this.response;
						t && t.ok || (this.stats.aborted = !0, this.controller.abort())
					}, e.abort = function() {
						var t;
						this.abortInternal(), null !== (t = this.callbacks) && void 0 !== t && t.onAbort && this.callbacks.onAbort(this.stats, this.context, this.response)
					}, e.load = function(t, e, r) {
						var i = this,
							n = this.stats;
						if(n.loading.start) throw new Error("Loader can only be used once.");
						n.loading.start = self.performance.now();
						var s = function(t, e) {
								var r = {
									method: "GET",
									mode: "cors",
									credentials: "same-origin",
									signal: e,
									headers: new self.Headers(Ri({}, t.headers))
								};
								return t.rangeEnd && r.headers.set("Range", "bytes=" + t.rangeStart + "-" + String(t.rangeEnd - 1)), r
							}(t, this.controller.signal),
							o = r.onProgress,
							l = "arraybuffer" === t.responseType,
							u = l ? "byteLength" : "length";
						this.context = t, this.config = e, this.callbacks = r, this.request = this.fetchSetup(t, s), self.clearTimeout(this.requestTimeout), this.requestTimeout = self.setTimeout((function() {
							i.abortInternal(), r.onTimeout(n, t, i.response)
						}), e.timeout), self.fetch(this.request).then((function(r) {
							if(i.response = i.loader = r, !r.ok) {
								var s = r.status,
									u = r.statusText;
								throw new Ci(u || "fetch, bad network response", s, r)
							}
							return n.loading.first = Math.max(self.performance.now(), n.loading.start), n.total = parseInt(r.headers.get("Content-Length") || "0"), o && (0, a.isFiniteNumber)(e.highWaterMark) ? i.loadProgressively(r, n, t, e.highWaterMark, o) : l ? r.arrayBuffer() : r.text()
						})).then((function(s) {
							var l = i.response;
							self.clearTimeout(i.requestTimeout), n.loading.end = Math.max(self.performance.now(), n.loading.first);
							var d = s[u];
							d && (n.loaded = n.total = d);
							var h = {
								url: l.url,
								data: s
							};
							o && !(0, a.isFiniteNumber)(e.highWaterMark) && o(n, t, s, l), r.onSuccess(h, n, t, l)
						})).catch((function(e) {
							if(self.clearTimeout(i.requestTimeout), !n.aborted) {
								var a = e && e.code || 0,
									s = e ? e.message : null;
								r.onError({
									code: a,
									text: s
								}, t, e ? e.details : null)
							}
						}))
					}, e.getCacheAge = function() {
						var t = null;
						if(this.response) {
							var e = this.response.headers.get("age");
							t = e ? parseFloat(e) : null
						}
						return t
					}, e.loadProgressively = function(t, e, r, i, n) {
						void 0 === i && (i = 0);
						var a = new Pe,
							s = t.body.getReader();
						return function o() {
							return s.read().then((function(s) {
								if(s.done) return a.dataLength && n(e, r, a.flush(), t), Promise.resolve(new ArrayBuffer(0));
								var l = s.value,
									u = l.length;
								return e.loaded += u, u < i || a.dataLength ? (a.push(l), a.dataLength >= i && n(e, r, a.flush(), t)) : n(e, r, l, t), o()
							})).catch((function() {
								return Promise.reject()
							}))
						}()
					}, t
				}();

				function wi(t, e) {
					return new self.Request(t.url, e)
				}
				var Ci = function(t) {
					var e, r;

					function i(e, r, i) {
						var n;
						return(n = t.call(this, e) || this).code = void 0, n.details = void 0, n.code = r, n.details = i, n
					}
					return r = t, (e = i).prototype = Object.create(r.prototype), e.prototype.constructor = e, Di(e, r), i
				}(bi(Error));
				const _i = Ii;
				var Oi = /\s/;

				function Pi() {
					return Pi = Object.assign ? Object.assign.bind() : function(t) {
						for(var e = 1; e < arguments.length; e++) {
							var r = arguments[e];
							for(var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i])
						}
						return t
					}, Pi.apply(this, arguments)
				}

				function xi(t, e) {
					var r = Object.keys(t);
					if(Object.getOwnPropertySymbols) {
						var i = Object.getOwnPropertySymbols(t);
						e && (i = i.filter((function(e) {
							return Object.getOwnPropertyDescriptor(t, e).enumerable
						}))), r.push.apply(r, i)
					}
					return r
				}

				function Fi(t) {
					for(var e = 1; e < arguments.length; e++) {
						var r = null != arguments[e] ? arguments[e] : {};
						e % 2 ? xi(Object(r), !0).forEach((function(e) {
							Mi(t, e, r[e])
						})) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : xi(Object(r)).forEach((function(e) {
							Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(r, e))
						}))
					}
					return t
				}

				function Mi(t, e, r) {
					return(e = function(t) {
						var e = function(t, e) {
							if("object" != typeof t || null === t) return t;
							var r = t[Symbol.toPrimitive];
							if(void 0 !== r) {
								var i = r.call(t, e);
								if("object" != typeof i) return i;
								throw new TypeError("@@toPrimitive must return a primitive value.")
							}
							return String(t)
						}(t, "string");
						return "symbol" == typeof e ? e : String(e)
					}(e)) in t ? Object.defineProperty(t, e, {
						value: r,
						enumerable: !0,
						configurable: !0,
						writable: !0
					}) : t[e] = r, t
				}
				var Ni = Fi(Fi({
					autoStartLoad: !0,
					startPosition: -1,
					defaultAudioCodec: void 0,
					debug: !1,
					capLevelOnFPSDrop: !1,
					capLevelToPlayerSize: !1,
					ignoreDevicePixelRatio: !1,
					initialLiveManifestSize: 1,
					maxBufferLength: 30,
					backBufferLength: 1 / 0,
					maxBufferSize: 6e7,
					maxBufferHole: .1,
					highBufferWatchdogPeriod: 2,
					nudgeOffset: .1,
					nudgeMaxRetry: 3,
					maxFragLookUpTolerance: .25,
					liveSyncDurationCount: 3,
					liveMaxLatencyDurationCount: 1 / 0,
					liveSyncDuration: void 0,
					liveMaxLatencyDuration: void 0,
					maxLiveSyncPlaybackRate: 1,
					liveDurationInfinity: !1,
					liveBackBufferLength: null,
					maxMaxBufferLength: 600,
					enableWorker: !0,
					enableSoftwareAES: !0,
					manifestLoadingTimeOut: 1e4,
					manifestLoadingMaxRetry: 1,
					manifestLoadingRetryDelay: 1e3,
					manifestLoadingMaxRetryTimeout: 64e3,
					startLevel: void 0,
					levelLoadingTimeOut: 1e4,
					levelLoadingMaxRetry: 4,
					levelLoadingRetryDelay: 1e3,
					levelLoadingMaxRetryTimeout: 64e3,
					fragLoadingTimeOut: 2e4,
					fragLoadingMaxRetry: 6,
					fragLoadingRetryDelay: 1e3,
					fragLoadingMaxRetryTimeout: 64e3,
					startFragPrefetch: !1,
					fpsDroppedMonitoringPeriod: 5e3,
					fpsDroppedMonitoringThreshold: .2,
					appendErrorMaxRetry: 3,
					loader: Si,
					fLoader: void 0,
					pLoader: void 0,
					xhrSetup: void 0,
					licenseXhrSetup: void 0,
					licenseResponseCallback: void 0,
					abrController: Oe,
					bufferController: Ze,
					capLevelController: Jr,
					fpsController: Zr,
					stretchShortVideoTrack: !1,
					maxAudioFramesDrift: 1,
					forceKeyFrameOnDiscontinuity: !0,
					abrEwmaFastLive: 3,
					abrEwmaSlowLive: 9,
					abrEwmaFastVoD: 3,
					abrEwmaSlowVoD: 9,
					abrEwmaDefaultEstimate: 5e5,
					abrBandWidthFactor: .95,
					abrBandWidthUpFactor: .7,
					abrMaxWithRealBitrate: !1,
					maxStarvationDelay: 4,
					maxLoadingDelay: 4,
					minAutoBitrate: 0,
					emeEnabled: !1,
					widevineLicenseUrl: void 0,
					drmSystems: {},
					drmSystemOptions: {},
					requestMediaKeySystemAccessFunc: k,
					testBandwidth: !0,
					progressive: !1,
					lowLatencyMode: !0,
					cmcd: void 0,
					enableDateRangeMetadataCues: !0,
					enableEmsgMetadataCues: !0,
					enableID3MetadataCues: !0
				}, {
					cueHandler: {
						newCue: function(t, e, r, i) {
							for(var n, a, s, o, l, u = [], d = self.VTTCue || self.TextTrackCue, h = 0; h < i.rows.length; h++)
								if(s = !0, o = 0, l = "", !(n = i.rows[h]).isEmpty()) {
									for(var c = 0; c < n.chars.length; c++) Oi.test(n.chars[c].uchar) && s ? o++ : (l += n.chars[c].uchar, s = !1);
									n.cueStartTime = e, e === r && (r += 1e-4), o >= 16 ? o-- : o++;
									var f = wr(l.trim()),
										g = Mr(e, r, f);
									t && t.cues && t.cues.getCueById(g) || ((a = new d(e, r, f)).id = g, a.line = h + 1, a.align = "left", a.position = 10 + Math.min(80, 10 * Math.floor(8 * o / 32)), u.push(a))
								}
							return t && u.length && (u.sort((function(t, e) {
								return "auto" === t.line || "auto" === e.line ? 0 : t.line > 8 && e.line > 8 ? e.line - t.line : t.line - e.line
							})), u.forEach((function(e) {
								return X(t, e)
							}))), u
						}
					},
					enableWebVTT: !0,
					enableIMSC1: !0,
					enableCEA708Captions: !0,
					captionsTextTrack1Label: "English",
					captionsTextTrack1LanguageCode: "en",
					captionsTextTrack2Label: "Spanish",
					captionsTextTrack2LanguageCode: "es",
					captionsTextTrack3Label: "Unknown CC",
					captionsTextTrack3LanguageCode: "",
					captionsTextTrack4Label: "Unknown CC",
					captionsTextTrack4LanguageCode: "",
					renderTextTracksNatively: !0
				}), {}, {
					subtitleStreamController: je,
					subtitleTrackController: Xe,
					timelineController: zr,
					audioStreamController: Ne,
					audioTrackController: Ge,
					emeController: ui,
					cmcdController: yi
				});

				function Ui(t, e) {
					for(var r = 0; r < e.length; r++) {
						var i = e[r];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, (void 0, "symbol" == typeof(n = function(t, e) {
							if("object" != typeof t || null === t) return t;
							var r = t[Symbol.toPrimitive];
							if(void 0 !== r) {
								var i = r.call(t, e);
								if("object" != typeof i) return i;
								throw new TypeError("@@toPrimitive must return a primitive value.")
							}
							return String(t)
						}(i.key, "string")) ? n : String(n)), i)
					}
					var n
				}
				var Bi = function() {
					function t(e) {
						void 0 === e && (e = {}), this.config = void 0, this.userConfig = void 0, this.coreComponents = void 0, this.networkControllers = void 0, this._emitter = new Se.EventEmitter, this._autoLevelCapping = void 0, this._maxHdcpLevel = null, this.abrController = void 0, this.bufferController = void 0, this.capLevelController = void 0, this.latencyController = void 0, this.levelController = void 0, this.streamController = void 0, this.audioTrackController = void 0, this.subtitleTrackController = void 0, this.emeController = void 0, this.cmcdController = void 0, this._media = null, this.url = null;
						var r = this.config = function(t, e) {
							if((e.liveSyncDurationCount || e.liveMaxLatencyDurationCount) && (e.liveSyncDuration || e.liveMaxLatencyDuration)) throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
							if(void 0 !== e.liveMaxLatencyDurationCount && (void 0 === e.liveSyncDurationCount || e.liveMaxLatencyDurationCount <= e.liveSyncDurationCount)) throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"');
							if(void 0 !== e.liveMaxLatencyDuration && (void 0 === e.liveSyncDuration || e.liveMaxLatencyDuration <= e.liveSyncDuration)) throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"');
							return Pi({}, t, e)
						}(t.DefaultConfig, e);
						this.userConfig = e, (0, l.enableLogs)(r.debug, "Hls instance"), this._autoLevelCapping = -1, r.progressive && function(t) {
							var e = t.loader;
							e !== _i && e !== Si ? (l.logger.log("[config]: Custom loader detected, cannot enable progressive streaming"), t.progressive = !1) : function() {
								if(self.fetch && self.AbortController && self.ReadableStream && self.Request) try {
									return new self.ReadableStream({}), !0
								} catch(t) {}
								return !1
							}() && (t.loader = _i, t.progressive = !0, t.enableSoftwareAES = !0, l.logger.log("[config]: Progressive streaming enabled, using FetchLoader"))
						}(r);
						var i = r.abrController,
							n = r.bufferController,
							a = r.capLevelController,
							s = r.fpsController,
							o = this.abrController = new i(this),
							u = this.bufferController = new n(this),
							d = this.capLevelController = new a(this),
							h = new s(this),
							c = new W(this),
							f = new rt(this),
							g = this.levelController = new Lt(this),
							v = new At(this),
							p = new Mt(this.config),
							m = this.streamController = new Ie(this, v, p);
						d.setStreamController(m), h.setStreamController(m);
						var y = [c, g, m];
						this.networkControllers = y;
						var E = [o, u, d, h, f, v];
						this.audioTrackController = this.createController(r.audioTrackController, y);
						var T = r.audioStreamController;
						T && y.push(new T(this, v, p)), this.subtitleTrackController = this.createController(r.subtitleTrackController, y);
						var S = r.subtitleStreamController;
						S && y.push(new S(this, v, p)), this.createController(r.timelineController, E), p.emeController = this.emeController = this.createController(r.emeController, E), this.cmcdController = this.createController(r.cmcdController, E), this.latencyController = this.createController(nt, E), this.coreComponents = E
					}
					t.isSupported = function() {
						return function() {
							var t = ce();
							if(!t) return !1;
							var e = fe(),
								r = t && "function" == typeof t.isTypeSupported && t.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"'),
								i = !e || e.prototype && "function" == typeof e.prototype.appendBuffer && "function" == typeof e.prototype.remove;
							return !!r && !!i
						}()
					};
					var e, r, i, a = t.prototype;
					return a.createController = function(t, e) {
						if(t) {
							var r = new t(this);
							return e && e.push(r), r
						}
						return null
					}, a.on = function(t, e, r) {
						void 0 === r && (r = this), this._emitter.on(t, e, r)
					}, a.once = function(t, e, r) {
						void 0 === r && (r = this), this._emitter.once(t, e, r)
					}, a.removeAllListeners = function(t) {
						this._emitter.removeAllListeners(t)
					}, a.off = function(t, e, r, i) {
						void 0 === r && (r = this), this._emitter.off(t, e, r, i)
					}, a.listeners = function(t) {
						return this._emitter.listeners(t)
					}, a.emit = function(t, e, r) {
						return this._emitter.emit(t, e, r)
					}, a.trigger = function(t, e) {
						if(this.config.debug) return this.emit(t, t, e);
						try {
							return this.emit(t, t, e)
						} catch(e) {
							l.logger.error("An internal error happened while handling event " + t + '. Error message: "' + e.message + '". Here is a stacktrace:', e), this.trigger(s.Events.ERROR, {
								type: o.ErrorTypes.OTHER_ERROR,
								details: o.ErrorDetails.INTERNAL_EXCEPTION,
								fatal: !1,
								event: t,
								error: e
							})
						}
						return !1
					}, a.listenerCount = function(t) {
						return this._emitter.listenerCount(t)
					}, a.destroy = function() {
						l.logger.log("destroy"), this.trigger(s.Events.DESTROYING, void 0), this.detachMedia(), this.removeAllListeners(), this._autoLevelCapping = -1, this.url = null, this.networkControllers.forEach((function(t) {
							return t.destroy()
						})), this.networkControllers.length = 0, this.coreComponents.forEach((function(t) {
							return t.destroy()
						})), this.coreComponents.length = 0
					}, a.attachMedia = function(t) {
						l.logger.log("attachMedia"), this._media = t, this.trigger(s.Events.MEDIA_ATTACHING, {
							media: t
						})
					}, a.detachMedia = function() {
						l.logger.log("detachMedia"), this.trigger(s.Events.MEDIA_DETACHING, void 0), this._media = null
					}, a.loadSource = function(t) {
						this.stopLoad();
						var e = this.media,
							r = this.url,
							i = this.url = n.buildAbsoluteURL(self.location.href, t, {
								alwaysNormalize: !0
							});
						l.logger.log("loadSource:" + i), e && r && r !== i && this.bufferController.hasSourceTypes() && (this.detachMedia(), this.attachMedia(e)), this.trigger(s.Events.MANIFEST_LOADING, {
							url: t
						})
					}, a.startLoad = function(t) {
						void 0 === t && (t = -1), l.logger.log("startLoad(" + t + ")"), this.networkControllers.forEach((function(e) {
							e.startLoad(t)
						}))
					}, a.stopLoad = function() {
						l.logger.log("stopLoad"), this.networkControllers.forEach((function(t) {
							t.stopLoad()
						}))
					}, a.swapAudioCodec = function() {
						l.logger.log("swapAudioCodec"), this.streamController.swapAudioCodec()
					}, a.recoverMediaError = function() {
						l.logger.log("recoverMediaError");
						var t = this._media;
						this.detachMedia(), t && this.attachMedia(t)
					}, a.removeLevel = function(t, e) {
						void 0 === e && (e = 0), this.levelController.removeLevel(t, e)
					}, e = t, i = [{
						key: "version",
						get: function() {
							return "1.3.3"
						}
					}, {
						key: "Events",
						get: function() {
							return s.Events
						}
					}, {
						key: "ErrorTypes",
						get: function() {
							return o.ErrorTypes
						}
					}, {
						key: "ErrorDetails",
						get: function() {
							return o.ErrorDetails
						}
					}, {
						key: "DefaultConfig",
						get: function() {
							return t.defaultConfig ? t.defaultConfig : Ni
						},
						set: function(e) {
							t.defaultConfig = e
						}
					}], (r = [{
						key: "levels",
						get: function() {
							return this.levelController.levels || []
						}
					}, {
						key: "currentLevel",
						get: function() {
							return this.streamController.currentLevel
						},
						set: function(t) {
							l.logger.log("set currentLevel:" + t), this.loadLevel = t, this.abrController.clearTimer(), this.streamController.immediateLevelSwitch()
						}
					}, {
						key: "nextLevel",
						get: function() {
							return this.streamController.nextLevel
						},
						set: function(t) {
							l.logger.log("set nextLevel:" + t), this.levelController.manualLevel = t, this.streamController.nextLevelSwitch()
						}
					}, {
						key: "loadLevel",
						get: function() {
							return this.levelController.level
						},
						set: function(t) {
							l.logger.log("set loadLevel:" + t), this.levelController.manualLevel = t
						}
					}, {
						key: "nextLoadLevel",
						get: function() {
							return this.levelController.nextLoadLevel
						},
						set: function(t) {
							this.levelController.nextLoadLevel = t
						}
					}, {
						key: "firstLevel",
						get: function() {
							return Math.max(this.levelController.firstLevel, this.minAutoLevel)
						},
						set: function(t) {
							l.logger.log("set firstLevel:" + t), this.levelController.firstLevel = t
						}
					}, {
						key: "startLevel",
						get: function() {
							return this.levelController.startLevel
						},
						set: function(t) {
							l.logger.log("set startLevel:" + t), -1 !== t && (t = Math.max(t, this.minAutoLevel)), this.levelController.startLevel = t
						}
					}, {
						key: "capLevelToPlayerSize",
						get: function() {
							return this.config.capLevelToPlayerSize
						},
						set: function(t) {
							var e = !!t;
							e !== this.config.capLevelToPlayerSize && (e ? this.capLevelController.startCapping() : (this.capLevelController.stopCapping(), this.autoLevelCapping = -1, this.streamController.nextLevelSwitch()), this.config.capLevelToPlayerSize = e)
						}
					}, {
						key: "autoLevelCapping",
						get: function() {
							return this._autoLevelCapping
						},
						set: function(t) {
							this._autoLevelCapping !== t && (l.logger.log("set autoLevelCapping:" + t), this._autoLevelCapping = t)
						}
					}, {
						key: "bandwidthEstimate",
						get: function() {
							var t = this.abrController.bwEstimator;
							return t ? t.getEstimate() : NaN
						}
					}, {
						key: "maxHdcpLevel",
						get: function() {
							return this._maxHdcpLevel
						},
						set: function(t) {
							ot.indexOf(t) > -1 && (this._maxHdcpLevel = t)
						}
					}, {
						key: "autoLevelEnabled",
						get: function() {
							return -1 === this.levelController.manualLevel
						}
					}, {
						key: "manualLevel",
						get: function() {
							return this.levelController.manualLevel
						}
					}, {
						key: "minAutoLevel",
						get: function() {
							var t = this.levels,
								e = this.config.minAutoBitrate;
							if(!t) return 0;
							for(var r = t.length, i = 0; i < r; i++)
								if(t[i].maxBitrate >= e) return i;
							return 0
						}
					}, {
						key: "maxAutoLevel",
						get: function() {
							var t, e = this.levels,
								r = this.autoLevelCapping,
								i = this.maxHdcpLevel;
							if(t = -1 === r && e && e.length ? e.length - 1 : r, i)
								for(var n = t; n--;) {
									var a = e[n].attrs["HDCP-LEVEL"];
									if(a && a <= i) return n
								}
							return t
						}
					}, {
						key: "nextAutoLevel",
						get: function() {
							return Math.min(Math.max(this.abrController.nextAutoLevel, this.minAutoLevel), this.maxAutoLevel)
						},
						set: function(t) {
							this.abrController.nextAutoLevel = Math.max(this.minAutoLevel, t)
						}
					}, {
						key: "playingDate",
						get: function() {
							return this.streamController.currentProgramDateTime
						}
					}, {
						key: "mainForwardBufferInfo",
						get: function() {
							return this.streamController.getMainFwdBufferInfo()
						}
					}, {
						key: "audioTracks",
						get: function() {
							var t = this.audioTrackController;
							return t ? t.audioTracks : []
						}
					}, {
						key: "audioTrack",
						get: function() {
							var t = this.audioTrackController;
							return t ? t.audioTrack : -1
						},
						set: function(t) {
							var e = this.audioTrackController;
							e && (e.audioTrack = t)
						}
					}, {
						key: "subtitleTracks",
						get: function() {
							var t = this.subtitleTrackController;
							return t ? t.subtitleTracks : []
						}
					}, {
						key: "subtitleTrack",
						get: function() {
							var t = this.subtitleTrackController;
							return t ? t.subtitleTrack : -1
						},
						set: function(t) {
							var e = this.subtitleTrackController;
							e && (e.subtitleTrack = t)
						}
					}, {
						key: "media",
						get: function() {
							return this._media
						}
					}, {
						key: "subtitleDisplay",
						get: function() {
							var t = this.subtitleTrackController;
							return !!t && t.subtitleDisplay
						},
						set: function(t) {
							var e = this.subtitleTrackController;
							e && (e.subtitleDisplay = t)
						}
					}, {
						key: "lowLatencyMode",
						get: function() {
							return this.config.lowLatencyMode
						},
						set: function(t) {
							this.config.lowLatencyMode = t
						}
					}, {
						key: "liveSyncPosition",
						get: function() {
							return this.latencyController.liveSyncPosition
						}
					}, {
						key: "latency",
						get: function() {
							return this.latencyController.latency
						}
					}, {
						key: "maxLatency",
						get: function() {
							return this.latencyController.maxLatency
						}
					}, {
						key: "targetLatency",
						get: function() {
							return this.latencyController.targetLatency
						}
					}, {
						key: "drift",
						get: function() {
							return this.latencyController.drift
						}
					}, {
						key: "forceStartLoad",
						get: function() {
							return this.streamController.forceStartLoad
						}
					}]) && Ui(e.prototype, r), i && Ui(e, i), Object.defineProperty(e, "prototype", {
						writable: !1
					}), t
				}();
				Bi.defaultConfig = void 0
			},
			923: (t, e, r) => {
				"use strict";
				r.r(e), r.d(e, {
					BaseSegment: () => h,
					ElementaryStreamTypes: () => i,
					Fragment: () => c,
					Part: () => f
				});
				var i, n = r(965),
					a = r(945),
					s = r(408);

				function o(t, e) {
					t.prototype = Object.create(e.prototype), t.prototype.constructor = t, l(t, e)
				}

				function l(t, e) {
					return l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
						return t.__proto__ = e, t
					}, l(t, e)
				}

				function u(t, e) {
					for(var r = 0; r < e.length; r++) {
						var i = e[r];
						i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, (void 0, "symbol" == typeof(n = function(t, e) {
							if("object" != typeof t || null === t) return t;
							var r = t[Symbol.toPrimitive];
							if(void 0 !== r) {
								var i = r.call(t, e);
								if("object" != typeof i) return i;
								throw new TypeError("@@toPrimitive must return a primitive value.")
							}
							return String(t)
						}(i.key, "string")) ? n : String(n)), i)
					}
					var n
				}

				function d(t, e, r) {
					return e && u(t.prototype, e), r && u(t, r), Object.defineProperty(t, "prototype", {
						writable: !1
					}), t
				}! function(t) {
					t.AUDIO = "audio", t.VIDEO = "video", t.AUDIOVIDEO = "audiovideo"
				}(i || (i = {}));
				var h = function() {
						function t(t) {
							var e;
							this._byteRange = null, this._url = null, this.baseurl = void 0, this.relurl = void 0, this.elementaryStreams = ((e = {})[i.AUDIO] = null, e[i.VIDEO] = null, e[i.AUDIOVIDEO] = null, e), this.baseurl = t
						}
						return t.prototype.setByteRange = function(t, e) {
							var r = t.split("@", 2),
								i = [];
							1 === r.length ? i[0] = e ? e.byteRangeEndOffset : 0 : i[0] = parseInt(r[1]), i[1] = parseInt(r[0]) + i[0], this._byteRange = i
						}, d(t, [{
							key: "byteRange",
							get: function() {
								return this._byteRange ? this._byteRange : []
							}
						}, {
							key: "byteRangeStartOffset",
							get: function() {
								return this.byteRange[0]
							}
						}, {
							key: "byteRangeEndOffset",
							get: function() {
								return this.byteRange[1]
							}
						}, {
							key: "url",
							get: function() {
								return !this._url && this.baseurl && this.relurl && (this._url = (0, a.buildAbsoluteURL)(this.baseurl, this.relurl, {
									alwaysNormalize: !0
								})), this._url || ""
							},
							set: function(t) {
								this._url = t
							}
						}]), t
					}(),
					c = function(t) {
						function e(e, r) {
							var i;
							return(i = t.call(this, r) || this)._decryptdata = null, i.rawProgramDateTime = null, i.programDateTime = null, i.tagList = [], i.duration = 0, i.sn = 0, i.levelkeys = void 0, i.type = void 0, i.loader = null, i.keyLoader = null, i.level = -1, i.cc = 0, i.startPTS = void 0, i.endPTS = void 0, i.appendedPTS = void 0, i.startDTS = void 0, i.endDTS = void 0, i.start = 0, i.deltaPTS = void 0, i.maxStartPTS = void 0, i.minEndPTS = void 0, i.stats = new s.LoadStats, i.urlId = 0, i.data = void 0, i.bitrateTest = !1, i.title = null, i.initSegment = null, i.endList = void 0, i.type = e, i
						}
						o(e, t);
						var r = e.prototype;
						return r.setKeyFormat = function(t) {
							if(this.levelkeys) {
								var e = this.levelkeys[t];
								e && !this._decryptdata && (this._decryptdata = e.getDecryptData(this.sn))
							}
						}, r.abortRequests = function() {
							var t, e;
							null === (t = this.loader) || void 0 === t || t.abort(), null === (e = this.keyLoader) || void 0 === e || e.abort()
						}, r.setElementaryStreamInfo = function(t, e, r, i, n, a) {
							void 0 === a && (a = !1);
							var s = this.elementaryStreams,
								o = s[t];
							o ? (o.startPTS = Math.min(o.startPTS, e), o.endPTS = Math.max(o.endPTS, r), o.startDTS = Math.min(o.startDTS, i), o.endDTS = Math.max(o.endDTS, n)) : s[t] = {
								startPTS: e,
								endPTS: r,
								startDTS: i,
								endDTS: n,
								partial: a
							}
						}, r.clearElementaryStreamInfo = function() {
							var t = this.elementaryStreams;
							t[i.AUDIO] = null, t[i.VIDEO] = null, t[i.AUDIOVIDEO] = null
						}, d(e, [{
							key: "decryptdata",
							get: function() {
								if(!this.levelkeys && !this._decryptdata) return null;
								if(!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {
									var t = this.levelkeys.identity;
									if(t) this._decryptdata = t.getDecryptData(this.sn);
									else {
										var e = Object.keys(this.levelkeys);
										if(1 === e.length) return this._decryptdata = this.levelkeys[e[0]].getDecryptData(this.sn)
									}
								}
								return this._decryptdata
							}
						}, {
							key: "end",
							get: function() {
								return this.start + this.duration
							}
						}, {
							key: "endProgramDateTime",
							get: function() {
								if(null === this.programDateTime) return null;
								if(!(0, n.isFiniteNumber)(this.programDateTime)) return null;
								var t = (0, n.isFiniteNumber)(this.duration) ? this.duration : 0;
								return this.programDateTime + 1e3 * t
							}
						}, {
							key: "encrypted",
							get: function() {
								var t;
								if(null !== (t = this._decryptdata) && void 0 !== t && t.encrypted) return !0;
								if(this.levelkeys) {
									var e = Object.keys(this.levelkeys),
										r = e.length;
									if(r > 1 || 1 === r && this.levelkeys[e[0]].encrypted) return !0
								}
								return !1
							}
						}]), e
					}(h),
					f = function(t) {
						function e(e, r, i, n, a) {
							var o;
							(o = t.call(this, i) || this).fragOffset = 0, o.duration = 0, o.gap = !1, o.independent = !1, o.relurl = void 0, o.fragment = void 0, o.index = void 0, o.stats = new s.LoadStats, o.duration = e.decimalFloatingPoint("DURATION"), o.gap = e.bool("GAP"), o.independent = e.bool("INDEPENDENT"), o.relurl = e.enumeratedString("URI"), o.fragment = r, o.index = n;
							var l = e.enumeratedString("BYTERANGE");
							return l && o.setByteRange(l, a), a && (o.fragOffset = a.fragOffset + a.duration), o
						}
						return o(e, t), d(e, [{
							key: "start",
							get: function() {
								return this.fragment.start + this.fragOffset
							}
						}, {
							key: "end",
							get: function() {
								return this.start + this.duration
							}
						}, {
							key: "loaded",
							get: function() {
								var t = this.elementaryStreams;
								return !!(t.audio || t.video || t.audiovideo)
							}
						}]), e
					}(h)
			},
			408: (t, e, r) => {
				"use strict";
				r.r(e), r.d(e, {
					LoadStats: () => i
				});
				var i = function() {
					this.aborted = !1, this.loaded = 0, this.retry = 0, this.total = 0, this.chunkCount = 0, this.bwEstimate = 0, this.loading = {
						start: 0,
						first: 0,
						end: 0
					}, this.parsing = {
						start: 0,
						end: 0
					}, this.buffering = {
						start: 0,
						first: 0,
						end: 0
					}
				}
			},
			965: (t, e, r) => {
				"use strict";
				r.r(e), r.d(e, {
					MAX_SAFE_INTEGER: () => n,
					isFiniteNumber: () => i
				});
				var i = Number.isFinite || function(t) {
						return "number" == typeof t && isFinite(t)
					},
					n = Number.MAX_SAFE_INTEGER || 9007199254740991
			},
			524: (t, e, r) => {
				"use strict";
				r.r(e), r.d(e, {
					default: () => p,
					flushTextTrackMetadataCueSamples: () => y,
					flushTextTrackUserdataCueSamples: () => E,
					normalizePts: () => m
				});
				var i = r(965);
				const n = function() {
					function t() {}
					return t.getSilentFrame = function(t, e) {
						if("mp4a.40.2" === t) {
							if(1 === e) return new Uint8Array([0, 200, 0, 128, 35, 128]);
							if(2 === e) return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
							if(3 === e) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
							if(4 === e) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
							if(5 === e) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
							if(6 === e) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224])
						} else {
							if(1 === e) return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
							if(2 === e) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
							if(3 === e) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94])
						}
					}, t
				}();
				var a = Math.pow(2, 32) - 1,
					s = function() {
						function t() {}
						return t.init = function() {
							var e;
							for(e in t.types = {
									avc1: [],
									avcC: [],
									btrt: [],
									dinf: [],
									dref: [],
									esds: [],
									ftyp: [],
									hdlr: [],
									mdat: [],
									mdhd: [],
									mdia: [],
									mfhd: [],
									minf: [],
									moof: [],
									moov: [],
									mp4a: [],
									".mp3": [],
									mvex: [],
									mvhd: [],
									pasp: [],
									sdtp: [],
									stbl: [],
									stco: [],
									stsc: [],
									stsd: [],
									stsz: [],
									stts: [],
									tfdt: [],
									tfhd: [],
									traf: [],
									trak: [],
									trun: [],
									trex: [],
									tkhd: [],
									vmhd: [],
									smhd: []
								}, t.types) t.types.hasOwnProperty(e) && (t.types[e] = [e.charCodeAt(0), e.charCodeAt(1), e.charCodeAt(2), e.charCodeAt(3)]);
							var r = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]),
								i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]);
							t.HDLR_TYPES = {
								video: r,
								audio: i
							};
							var n = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]),
								a = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]);
							t.STTS = t.STSC = t.STCO = a, t.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), t.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]), t.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), t.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]);
							var s = new Uint8Array([105, 115, 111, 109]),
								o = new Uint8Array([97, 118, 99, 49]),
								l = new Uint8Array([0, 0, 0, 1]);
							t.FTYP = t.box(t.types.ftyp, s, l, s, o), t.DINF = t.box(t.types.dinf, t.box(t.types.dref, n))
						}, t.box = function(t) {
							for(var e = 8, r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), n = 1; n < r; n++) i[n - 1] = arguments[n];
							for(var a = i.length, s = a; a--;) e += i[a].byteLength;
							var o = new Uint8Array(e);
							for(o[0] = e >> 24 & 255, o[1] = e >> 16 & 255, o[2] = e >> 8 & 255, o[3] = 255 & e, o.set(t, 4), a = 0, e = 8; a < s; a++) o.set(i[a], e), e += i[a].byteLength;
							return o
						}, t.hdlr = function(e) {
							return t.box(t.types.hdlr, t.HDLR_TYPES[e])
						}, t.mdat = function(e) {
							return t.box(t.types.mdat, e)
						}, t.mdhd = function(e, r) {
							r *= e;
							var i = Math.floor(r / (a + 1)),
								n = Math.floor(r % (a + 1));
							return t.box(t.types.mdhd, new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, n >> 24, n >> 16 & 255, n >> 8 & 255, 255 & n, 85, 196, 0, 0]))
						}, t.mdia = function(e) {
							return t.box(t.types.mdia, t.mdhd(e.timescale, e.duration), t.hdlr(e.type), t.minf(e))
						}, t.mfhd = function(e) {
							return t.box(t.types.mfhd, new Uint8Array([0, 0, 0, 0, e >> 24, e >> 16 & 255, e >> 8 & 255, 255 & e]))
						}, t.minf = function(e) {
							return "audio" === e.type ? t.box(t.types.minf, t.box(t.types.smhd, t.SMHD), t.DINF, t.stbl(e)) : t.box(t.types.minf, t.box(t.types.vmhd, t.VMHD), t.DINF, t.stbl(e))
						}, t.moof = function(e, r, i) {
							return t.box(t.types.moof, t.mfhd(e), t.traf(i, r))
						}, t.moov = function(e) {
							for(var r = e.length, i = []; r--;) i[r] = t.trak(e[r]);
							return t.box.apply(null, [t.types.moov, t.mvhd(e[0].timescale, e[0].duration)].concat(i).concat(t.mvex(e)))
						}, t.mvex = function(e) {
							for(var r = e.length, i = []; r--;) i[r] = t.trex(e[r]);
							return t.box.apply(null, [t.types.mvex].concat(i))
						}, t.mvhd = function(e, r) {
							r *= e;
							var i = Math.floor(r / (a + 1)),
								n = Math.floor(r % (a + 1)),
								s = new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, n >> 24, n >> 16 & 255, n >> 8 & 255, 255 & n, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]);
							return t.box(t.types.mvhd, s)
						}, t.sdtp = function(e) {
							var r, i, n = e.samples || [],
								a = new Uint8Array(4 + n.length);
							for(r = 0; r < n.length; r++) i = n[r].flags, a[r + 4] = i.dependsOn << 4 | i.isDependedOn << 2 | i.hasRedundancy;
							return t.box(t.types.sdtp, a)
						}, t.stbl = function(e) {
							return t.box(t.types.stbl, t.stsd(e), t.box(t.types.stts, t.STTS), t.box(t.types.stsc, t.STSC), t.box(t.types.stsz, t.STSZ), t.box(t.types.stco, t.STCO))
						}, t.avc1 = function(e) {
							var r, i, n, a = [],
								s = [];
							for(r = 0; r < e.sps.length; r++) n = (i = e.sps[r]).byteLength, a.push(n >>> 8 & 255), a.push(255 & n), a = a.concat(Array.prototype.slice.call(i));
							for(r = 0; r < e.pps.length; r++) n = (i = e.pps[r]).byteLength, s.push(n >>> 8 & 255), s.push(255 & n), s = s.concat(Array.prototype.slice.call(i));
							var o = t.box(t.types.avcC, new Uint8Array([1, a[3], a[4], a[5], 255, 224 | e.sps.length].concat(a).concat([e.pps.length]).concat(s))),
								l = e.width,
								u = e.height,
								d = e.pixelRatio[0],
								h = e.pixelRatio[1];
							return t.box(t.types.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, l >> 8 & 255, 255 & l, u >> 8 & 255, 255 & u, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 18, 100, 97, 105, 108, 121, 109, 111, 116, 105, 111, 110, 47, 104, 108, 115, 46, 106, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), o, t.box(t.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])), t.box(t.types.pasp, new Uint8Array([d >> 24, d >> 16 & 255, d >> 8 & 255, 255 & d, h >> 24, h >> 16 & 255, h >> 8 & 255, 255 & h])))
						}, t.esds = function(t) {
							var e = t.config.length;
							return new Uint8Array([0, 0, 0, 0, 3, 23 + e, 0, 1, 0, 4, 15 + e, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5].concat([e]).concat(t.config).concat([6, 1, 2]))
						}, t.mp4a = function(e) {
							var r = e.samplerate;
							return t.box(t.types.mp4a, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, e.channelCount, 0, 16, 0, 0, 0, 0, r >> 8 & 255, 255 & r, 0, 0]), t.box(t.types.esds, t.esds(e)))
						}, t.mp3 = function(e) {
							var r = e.samplerate;
							return t.box(t.types[".mp3"], new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, e.channelCount, 0, 16, 0, 0, 0, 0, r >> 8 & 255, 255 & r, 0, 0]))
						}, t.stsd = function(e) {
							return "audio" === e.type ? "mp3" === e.segmentCodec && "mp3" === e.codec ? t.box(t.types.stsd, t.STSD, t.mp3(e)) : t.box(t.types.stsd, t.STSD, t.mp4a(e)) : t.box(t.types.stsd, t.STSD, t.avc1(e))
						}, t.tkhd = function(e) {
							var r = e.id,
								i = e.duration * e.timescale,
								n = e.width,
								s = e.height,
								o = Math.floor(i / (a + 1)),
								l = Math.floor(i % (a + 1));
							return t.box(t.types.tkhd, new Uint8Array([1, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, r >> 24 & 255, r >> 16 & 255, r >> 8 & 255, 255 & r, 0, 0, 0, 0, o >> 24, o >> 16 & 255, o >> 8 & 255, 255 & o, l >> 24, l >> 16 & 255, l >> 8 & 255, 255 & l, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, n >> 8 & 255, 255 & n, 0, 0, s >> 8 & 255, 255 & s, 0, 0]))
						}, t.traf = function(e, r) {
							var i = t.sdtp(e),
								n = e.id,
								s = Math.floor(r / (a + 1)),
								o = Math.floor(r % (a + 1));
							return t.box(t.types.traf, t.box(t.types.tfhd, new Uint8Array([0, 0, 0, 0, n >> 24, n >> 16 & 255, n >> 8 & 255, 255 & n])), t.box(t.types.tfdt, new Uint8Array([1, 0, 0, 0, s >> 24, s >> 16 & 255, s >> 8 & 255, 255 & s, o >> 24, o >> 16 & 255, o >> 8 & 255, 255 & o])), t.trun(e, i.length + 16 + 20 + 8 + 16 + 8 + 8), i)
						}, t.trak = function(e) {
							return e.duration = e.duration || 4294967295, t.box(t.types.trak, t.tkhd(e), t.mdia(e))
						}, t.trex = function(e) {
							var r = e.id;
							return t.box(t.types.trex, new Uint8Array([0, 0, 0, 0, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]))
						}, t.trun = function(e, r) {
							var i, n, a, s, o, l, u = e.samples || [],
								d = u.length,
								h = 12 + 16 * d,
								c = new Uint8Array(h);
							for(r += 8 + h, c.set(["video" === e.type ? 1 : 0, 0, 15, 1, d >>> 24 & 255, d >>> 16 & 255, d >>> 8 & 255, 255 & d, r >>> 24 & 255, r >>> 16 & 255, r >>> 8 & 255, 255 & r], 0), i = 0; i < d; i++) a = (n = u[i]).duration, s = n.size, o = n.flags, l = n.cts, c.set([a >>> 24 & 255, a >>> 16 & 255, a >>> 8 & 255, 255 & a, s >>> 24 & 255, s >>> 16 & 255, s >>> 8 & 255, 255 & s, o.isLeading << 2 | o.dependsOn, o.isDependedOn << 6 | o.hasRedundancy << 4 | o.paddingValue << 1 | o.isNonSync, 61440 & o.degradPrio, 15 & o.degradPrio, l >>> 24 & 255, l >>> 16 & 255, l >>> 8 & 255, 255 & l], 12 + 16 * i);
							return t.box(t.types.trun, c)
						}, t.initSegment = function(e) {
							t.types || t.init();
							var r = t.moov(e),
								i = new Uint8Array(t.FTYP.byteLength + r.byteLength);
							return i.set(t.FTYP), i.set(r, t.FTYP.byteLength), i
						}, t
					}();
				s.types = void 0, s.HDLR_TYPES = void 0, s.STTS = void 0, s.STSC = void 0, s.STCO = void 0, s.STSZ = void 0, s.VMHD = void 0, s.SMHD = void 0, s.STSD = void 0, s.FTYP = void 0, s.DINF = void 0;
				const o = s;
				var l = r(851),
					u = r(973),
					d = r(93),
					h = r(308),
					c = r(673);

				function f() {
					return f = Object.assign ? Object.assign.bind() : function(t) {
						for(var e = 1; e < arguments.length; e++) {
							var r = arguments[e];
							for(var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i])
						}
						return t
					}, f.apply(this, arguments)
				}
				var g = null,
					v = null,
					p = function() {
						function t(t, e, r, i) {
							if(void 0 === i && (i = ""), this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.ISGenerated = !1, this._initPTS = void 0, this._initDTS = void 0, this.nextAvcDts = null, this.nextAudioPts = null, this.videoSampleDuration = null, this.isAudioContiguous = !1, this.isVideoContiguous = !1, this.observer = t, this.config = e, this.typeSupported = r, this.ISGenerated = !1, null === g) {
								var n = (navigator.userAgent || "").match(/Chrome\/(\d+)/i);
								g = n ? parseInt(n[1]) : 0
							}
							if(null === v) {
								var a = navigator.userAgent.match(/Safari\/(\d+)/i);
								v = a ? parseInt(a[1]) : 0
							}
						}
						var e = t.prototype;
						return e.destroy = function() {}, e.resetTimeStamp = function(t) {
							d.logger.log("[mp4-remuxer]: initPTS & initDTS reset"), this._initPTS = this._initDTS = t
						}, e.resetNextTimestamp = function() {
							d.logger.log("[mp4-remuxer]: reset next timestamp"), this.isVideoContiguous = !1, this.isAudioContiguous = !1
						}, e.resetInitSegment = function() {
							d.logger.log("[mp4-remuxer]: ISGenerated flag reset"), this.ISGenerated = !1
						}, e.getVideoStartPts = function(t) {
							var e = !1,
								r = t.reduce((function(t, r) {
									var i = r.pts - t;
									return i < -4294967296 ? (e = !0, m(t, r.pts)) : i > 0 ? t : r.pts
								}), t[0].pts);
							return e && d.logger.debug("PTS rollover detected"), r
						}, e.remux = function(t, e, r, i, n, a, s, o) {
							var l, u, c, f, g, v, p = n,
								T = n,
								S = t.pid > -1,
								b = e.pid > -1,
								L = e.samples.length,
								A = t.samples.length > 0,
								D = s && L > 0 || L > 1;
							if((!S || A) && (!b || D) || this.ISGenerated || s) {
								this.ISGenerated || (c = this.generateIS(t, e, n));
								var k, R = this.isVideoContiguous,
									I = -1;
								if(D && (I = function(t) {
										for(var e = 0; e < t.length; e++)
											if(t[e].key) return e;
										return -1
									}(e.samples), !R && this.config.forceKeyFrameOnDiscontinuity))
									if(v = !0, I > 0) {
										d.logger.warn("[mp4-remuxer]: Dropped " + I + " out of " + L + " video samples due to a missing keyframe");
										var w = this.getVideoStartPts(e.samples);
										e.samples = e.samples.slice(I), e.dropped += I, k = T += (e.samples[0].pts - w) / e.inputTimeScale
									} else -1 === I && (d.logger.warn("[mp4-remuxer]: No keyframe found out of " + L + " video samples"), v = !1);
								if(this.ISGenerated) {
									if(A && D) {
										var C = this.getVideoStartPts(e.samples),
											_ = (m(t.samples[0].pts, C) - C) / e.inputTimeScale;
										p += Math.max(0, _), T += Math.max(0, -_)
									}
									if(A) {
										if(t.samplerate || (d.logger.warn("[mp4-remuxer]: regenerate InitSegment as audio detected"), c = this.generateIS(t, e, n)), u = this.remuxAudio(t, p, this.isAudioContiguous, a, b || D || o === h.PlaylistLevelType.AUDIO ? T : void 0), D) {
											var O = u ? u.endPTS - u.startPTS : 0;
											e.inputTimeScale || (d.logger.warn("[mp4-remuxer]: regenerate InitSegment as video detected"), c = this.generateIS(t, e, n)), l = this.remuxVideo(e, T, R, O)
										}
									} else D && (l = this.remuxVideo(e, T, R, 0));
									l && (l.firstKeyFrame = I, l.independent = -1 !== I, l.firstKeyFramePTS = k)
								}
							}
							return this.ISGenerated && (r.samples.length && (g = y(r, n, this._initPTS, this._initDTS)), i.samples.length && (f = E(i, n, this._initPTS))), {
								audio: u,
								video: l,
								initSegment: c,
								independent: v,
								text: f,
								id3: g
							}
						}, e.generateIS = function(t, e, r) {
							var n, a, s, l = t.samples,
								u = e.samples,
								d = this.typeSupported,
								h = {},
								c = !(0, i.isFiniteNumber)(this._initPTS),
								f = "audio/mp4";
							if(c && (n = a = 1 / 0), t.config && l.length && (t.timescale = t.samplerate, "mp3" === t.segmentCodec && (d.mpeg ? (f = "audio/mpeg", t.codec = "") : d.mp3 && (t.codec = "mp3")), h.audio = {
									id: "audio",
									container: f,
									codec: t.codec,
									initSegment: "mp3" === t.segmentCodec && d.mpeg ? new Uint8Array(0) : o.initSegment([t]),
									metadata: {
										channelCount: t.channelCount
									}
								}, c && (s = t.inputTimeScale, n = a = l[0].pts - Math.round(s * r))), e.sps && e.pps && u.length && (e.timescale = e.inputTimeScale, h.video = {
									id: "main",
									container: "video/mp4",
									codec: e.codec,
									initSegment: o.initSegment([e]),
									metadata: {
										width: e.width,
										height: e.height
									}
								}, c)) {
								s = e.inputTimeScale;
								var g = this.getVideoStartPts(u),
									v = Math.round(s * r);
								a = Math.min(a, m(u[0].dts, g) - v), n = Math.min(n, g - v)
							}
							if(Object.keys(h).length) return this.ISGenerated = !0, c && (this._initPTS = n, this._initDTS = a), {
								tracks: h,
								initPTS: n,
								timescale: s
							}
						}, e.remuxVideo = function(t, e, r, i) {
							var n, a, s = t.inputTimeScale,
								h = t.samples,
								p = [],
								y = h.length,
								E = this._initPTS,
								S = this.nextAvcDts,
								b = 8,
								L = this.videoSampleDuration,
								A = Number.POSITIVE_INFINITY,
								D = Number.NEGATIVE_INFINITY,
								k = !1;
							r && null !== S || (S = e * s - (h[0].pts - m(h[0].dts, h[0].pts)));
							for(var R = 0; R < y; R++) {
								var I = h[R];
								I.pts = m(I.pts - E, S), I.dts = m(I.dts - E, S), I.dts < h[R > 0 ? R - 1 : R].dts && (k = !0)
							}
							k && h.sort((function(t, e) {
								var r = t.dts - e.dts,
									i = t.pts - e.pts;
								return r || i
							})), n = h[0].dts;
							var w = h[h.length - 1].dts - n,
								C = w ? Math.round(w / (y - 1)) : L || t.inputTimeScale / 30;
							if(r) {
								var _ = n - S,
									O = _ > C,
									P = _ < -1;
								if((O || P) && (O ? d.logger.warn("AVC: " + (0, c.toMsFromMpegTsClock)(_, !0) + " ms (" + _ + "dts) hole between fragments detected, filling it") : d.logger.warn("AVC: " + (0, c.toMsFromMpegTsClock)(-_, !0) + " ms (" + _ + "dts) overlapping between fragments detected"), !P || S > h[0].pts)) {
									n = S;
									var x = h[0].pts - _;
									h[0].dts = n, h[0].pts = x, d.logger.log("Video: First PTS/DTS adjusted: " + (0, c.toMsFromMpegTsClock)(x, !0) + "/" + (0, c.toMsFromMpegTsClock)(n, !0) + ", delta: " + (0, c.toMsFromMpegTsClock)(_, !0) + " ms")
								}
							}
							n = Math.max(0, n);
							for(var F = 0, M = 0, N = 0; N < y; N++) {
								for(var U = h[N], B = U.units, G = B.length, K = 0, H = 0; H < G; H++) K += B[H].data.length;
								M += K, F += G, U.length = K, U.dts = Math.max(U.dts, n), A = Math.min(U.pts, A), D = Math.max(U.pts, D)
							}
							a = h[y - 1].dts;
							var j, V = M + 4 * F + 8;
							try {
								j = new Uint8Array(V)
							} catch(t) {
								return void this.observer.emit(l.Events.ERROR, l.Events.ERROR, {
									type: u.ErrorTypes.MUX_ERROR,
									details: u.ErrorDetails.REMUX_ALLOC_ERROR,
									fatal: !1,
									bytes: V,
									reason: "fail allocating video mdat " + V
								})
							}
							var Y = new DataView(j.buffer);
							Y.setUint32(0, V), j.set(o.types.mdat, 4);
							for(var W = !1, q = Number.POSITIVE_INFINITY, X = Number.POSITIVE_INFINITY, z = Number.NEGATIVE_INFINITY, Q = Number.NEGATIVE_INFINITY, $ = 0; $ < y; $++) {
								for(var J = h[$], Z = J.units, tt = 0, et = 0, rt = Z.length; et < rt; et++) {
									var it = Z[et],
										nt = it.data,
										at = it.data.byteLength;
									Y.setUint32(b, at), b += 4, j.set(nt, b), b += at, tt += 4 + at
								}
								var st = void 0;
								if($ < y - 1) L = h[$ + 1].dts - J.dts, st = h[$ + 1].pts - J.pts;
								else {
									var ot = this.config,
										lt = $ > 0 ? J.dts - h[$ - 1].dts : C;
									if(st = $ > 0 ? J.pts - h[$ - 1].pts : C, ot.stretchShortVideoTrack && null !== this.nextAudioPts) {
										var ut = Math.floor(ot.maxBufferHole * s),
											dt = (i ? A + i * s : this.nextAudioPts) - J.pts;
										dt > ut ? ((L = dt - lt) < 0 ? L = lt : W = !0, d.logger.log("[mp4-remuxer]: It is approximately " + dt / 90 + " ms to the next segment; using duration " + L / 90 + " ms for the last video frame.")) : L = lt
									} else L = lt
								}
								var ht = Math.round(J.pts - J.dts);
								q = Math.min(q, L), z = Math.max(z, L), X = Math.min(X, st), Q = Math.max(Q, st), p.push(new T(J.key, L, tt, ht))
							}
							if(p.length)
								if(g) {
									if(g < 70) {
										var ct = p[0].flags;
										ct.dependsOn = 2, ct.isNonSync = 0
									}
								} else if(v && Q - X < z - q && C / z < .025 && 0 === p[0].cts) {
								d.logger.warn("Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.");
								for(var ft = n, gt = 0, vt = p.length; gt < vt; gt++) {
									var pt = ft + p[gt].duration,
										mt = ft + p[gt].cts;
									if(gt < vt - 1) {
										var yt = pt + p[gt + 1].cts;
										p[gt].duration = yt - mt
									} else p[gt].duration = gt ? p[gt - 1].duration : C;
									p[gt].cts = 0, ft = pt
								}
							}
							L = W || !L ? C : L, this.nextAvcDts = S = a + L, this.videoSampleDuration = L, this.isVideoContiguous = !0;
							var Et = {
								data1: o.moof(t.sequenceNumber++, n, f({}, t, {
									samples: p
								})),
								data2: j,
								startPTS: A / s,
								endPTS: (D + L) / s,
								startDTS: n / s,
								endDTS: S / s,
								type: "video",
								hasAudio: !1,
								hasVideo: !0,
								nb: p.length,
								dropped: t.dropped
							};
							return t.samples = [], t.dropped = 0, Et
						}, e.remuxAudio = function(t, e, r, i, a) {
							var s = t.inputTimeScale,
								h = s / (t.samplerate ? t.samplerate : s),
								c = "aac" === t.segmentCodec ? 1024 : 1152,
								g = c * h,
								v = this._initPTS,
								p = "mp3" === t.segmentCodec && this.typeSupported.mpeg,
								y = [],
								E = void 0 !== a,
								S = t.samples,
								b = p ? 0 : 8,
								L = this.nextAudioPts || -1,
								A = e * s;
							if(this.isAudioContiguous = r = r || S.length && L > 0 && (i && Math.abs(A - L) < 9e3 || Math.abs(m(S[0].pts - v, A) - L) < 20 * g), S.forEach((function(t) {
									t.pts = m(t.pts - v, A)
								})), !r || L < 0) {
								if(S = S.filter((function(t) {
										return t.pts >= 0
									})), !S.length) return;
								L = 0 === a ? 0 : i && !E ? Math.max(0, A) : S[0].pts
							}
							if("aac" === t.segmentCodec)
								for(var D = this.config.maxAudioFramesDrift, k = 0, R = L; k < S.length; k++) {
									var I = S[k],
										w = I.pts,
										C = w - R,
										_ = Math.abs(1e3 * C / s);
									if(C <= -D * g && E) 0 === k && (d.logger.warn("Audio frame @ " + (w / s).toFixed(3) + "s overlaps nextAudioPts by " + Math.round(1e3 * C / s) + " ms."), this.nextAudioPts = L = R = w);
									else if(C >= D * g && _ < 1e4 && E) {
										var O = Math.round(C / g);
										(R = w - O * g) < 0 && (O--, R += g), 0 === k && (this.nextAudioPts = L = R), d.logger.warn("[mp4-remuxer]: Injecting " + O + " audio frame @ " + (R / s).toFixed(3) + "s due to " + Math.round(1e3 * C / s) + " ms gap.");
										for(var P = 0; P < O; P++) {
											var x = Math.max(R, 0),
												F = n.getSilentFrame(t.manifestCodec || t.codec, t.channelCount);
											F || (d.logger.log("[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead."), F = I.unit.subarray()), S.splice(k, 0, {
												unit: F,
												pts: x
											}), R += g, k++
										}
									}
									I.pts = R, R += g
								}
							for(var M, N = null, U = null, B = 0, G = S.length; G--;) B += S[G].unit.byteLength;
							for(var K = 0, H = S.length; K < H; K++) {
								var j = S[K],
									V = j.unit,
									Y = j.pts;
								if(null !== U) y[K - 1].duration = Math.round((Y - U) / h);
								else {
									if(r && "aac" === t.segmentCodec && (Y = L), N = Y, !(B > 0)) return;
									B += b;
									try {
										M = new Uint8Array(B)
									} catch(t) {
										return void this.observer.emit(l.Events.ERROR, l.Events.ERROR, {
											type: u.ErrorTypes.MUX_ERROR,
											details: u.ErrorDetails.REMUX_ALLOC_ERROR,
											fatal: !1,
											bytes: B,
											reason: "fail allocating audio mdat " + B
										})
									}
									p || (new DataView(M.buffer).setUint32(0, B), M.set(o.types.mdat, 4))
								}
								M.set(V, b);
								var W = V.byteLength;
								b += W, y.push(new T(!0, c, W, 0)), U = Y
							}
							var q = y.length;
							if(q) {
								var X = y[y.length - 1];
								this.nextAudioPts = L = U + h * X.duration;
								var z = p ? new Uint8Array(0) : o.moof(t.sequenceNumber++, N / h, f({}, t, {
									samples: y
								}));
								t.samples = [];
								var Q = N / s,
									$ = L / s,
									J = {
										data1: z,
										data2: M,
										startPTS: Q,
										endPTS: $,
										startDTS: Q,
										endDTS: $,
										type: "audio",
										hasAudio: !0,
										hasVideo: !1,
										nb: q
									};
								return this.isAudioContiguous = !0, J
							}
						}, e.remuxEmptyAudio = function(t, e, r, i) {
							var a = t.inputTimeScale,
								s = a / (t.samplerate ? t.samplerate : a),
								o = this.nextAudioPts,
								l = (null !== o ? o : i.startDTS * a) + this._initDTS,
								u = i.endDTS * a + this._initDTS,
								h = 1024 * s,
								c = Math.ceil((u - l) / h),
								f = n.getSilentFrame(t.manifestCodec || t.codec, t.channelCount);
							if(d.logger.warn("[mp4-remuxer]: remux empty Audio"), f) {
								for(var g = [], v = 0; v < c; v++) {
									var p = l + v * h;
									g.push({
										unit: f,
										pts: p,
										dts: p
									})
								}
								return t.samples = g, this.remuxAudio(t, e, r, !1)
							}
							d.logger.trace("[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec")
						}, t
					}();

				function m(t, e) {
					var r;
					if(null === e) return t;
					for(r = e < t ? -8589934592 : 8589934592; Math.abs(t - e) > 4294967296;) t += r;
					return t
				}

				function y(t, e, r, i) {
					var n = t.samples.length;
					if(n) {
						for(var a = t.inputTimeScale, s = 0; s < n; s++) {
							var o = t.samples[s];
							o.pts = m(o.pts - r, e * a) / a, o.dts = m(o.dts - i, e * a) / a
						}
						var l = t.samples;
						return t.samples = [], {
							samples: l
						}
					}
				}

				function E(t, e, r) {
					var i = t.samples.length;
					if(i) {
						for(var n = t.inputTimeScale, a = 0; a < i; a++) {
							var s = t.samples[a];
							s.pts = m(s.pts - r, e * n) / n
						}
						t.samples.sort((function(t, e) {
							return t.pts - e.pts
						}));
						var o = t.samples;
						return t.samples = [], {
							samples: o
						}
					}
				}
				var T = function(t, e, r, i) {
						this.size = void 0, this.duration = void 0, this.cts = void 0, this.flags = void 0, this.duration = e, this.size = r, this.cts = i, this.flags = new S(t)
					},
					S = function(t) {
						this.isLeading = 0, this.isDependedOn = 0, this.hasRedundancy = 0, this.degradPrio = 0, this.dependsOn = 1, this.isNonSync = 1, this.dependsOn = t ? 2 : 1, this.isNonSync = t ? 0 : 1
					}
			},
			856: (t, e, r) => {
				"use strict";
				var i;
				r.r(e), r.d(e, {
						MetadataSchema: () => i
					}),
					function(t) {
						t.audioId3 = "org.id3", t.dateRange = "com.apple.quicktime.HLS", t.emsg = "https://aomedia.org/emsg/ID3"
					}(i || (i = {}))
			},
			308: (t, e, r) => {
				"use strict";
				var i, n;
				r.r(e), r.d(e, {
						PlaylistContextType: () => i,
						PlaylistLevelType: () => n
					}),
					function(t) {
						t.MANIFEST = "manifest", t.LEVEL = "level", t.AUDIO_TRACK = "audioTrack", t.SUBTITLE_TRACK = "subtitleTrack"
					}(i || (i = {})),
					function(t) {
						t.MAIN = "main", t.AUDIO = "audio", t.SUBTITLE = "subtitle"
					}(n || (n = {}))
			},
			300: (t, e, r) => {
				"use strict";
				r.r(e), r.d(e, {
					default: () => i
				});
				const i = {
					hexDump: function(t) {
						for(var e = "", r = 0; r < t.length; r++) {
							var i = t[r].toString(16);
							i.length < 2 && (i = "0" + i), e += i
						}
						return e
					}
				}
			},
			93: (t, e, r) => {
				"use strict";
				r.r(e), r.d(e, {
					enableLogs: () => o,
					logger: () => l
				});
				var i = function() {},
					n = {
						trace: i,
						debug: i,
						log: i,
						warn: i,
						info: i,
						error: i
					},
					a = n;

				function s(t) {
					var e = self.console[t];
					return e ? e.bind(self.console, "[" + t + "] >") : i
				}

				function o(t, e) {
					if(self.console && !0 === t || "object" == typeof t) {
						! function(t) {
							for(var e = arguments.length, r = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) r[i - 1] = arguments[i];
							r.forEach((function(e) {
								a[e] = t[e] ? t[e].bind(t) : s(e)
							}))
						}(t, "debug", "log", "info", "warn", "error");
						try {
							a.log('Debug logs enabled for "' + e + '"')
						} catch(t) {
							a = n
						}
					} else a = n
				}
				var l = n
			},
			63: (t, e, r) => {
				"use strict";
				r.r(e), r.d(e, {
					RemuxerTrackIdConfig: () => d,
					appendUint8Array: () => k,
					bin2str: () => h,
					computeRawDurationFromSamples: () => L,
					discardEPB: () => C,
					findBox: () => p,
					getDuration: () => b,
					getStartDTS: () => S,
					mp4Box: () => O,
					mp4pssh: () => P,
					offsetStartDTS: () => A,
					parseEmsg: () => _,
					parseInitSegment: () => y,
					parsePssh: () => x,
					parseSEIMessageFromNALu: () => w,
					parseSamples: () => R,
					parseSegmentIndex: () => m,
					parseSinf: () => T,
					patchEncyptionData: () => E,
					readSint32: () => g,
					readUint16: () => c,
					readUint32: () => f,
					segmentValidRange: () => D,
					writeUint32: () => v
				});
				var i = r(923),
					n = r(145),
					a = r(181),
					s = r(93),
					o = r(300),
					l = Math.pow(2, 32) - 1,
					u = [].push,
					d = {
						video: 1,
						audio: 2,
						id3: 3,
						text: 4
					};

				function h(t) {
					return String.fromCharCode.apply(null, t)
				}

				function c(t, e) {
					var r = t[e] << 8 | t[e + 1];
					return r < 0 ? 65536 + r : r
				}

				function f(t, e) {
					var r = g(t, e);
					return r < 0 ? 4294967296 + r : r
				}

				function g(t, e) {
					return t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3]
				}

				function v(t, e, r) {
					t[e] = r >> 24, t[e + 1] = r >> 16 & 255, t[e + 2] = r >> 8 & 255, t[e + 3] = 255 & r
				}

				function p(t, e) {
					var r = [];
					if(!e.length) return r;
					for(var i = t.byteLength, n = 0; n < i;) {
						var a = f(t, n),
							s = a > 1 ? n + a : i;
						if(h(t.subarray(n + 4, n + 8)) === e[0])
							if(1 === e.length) r.push(t.subarray(n + 8, s));
							else {
								var o = p(t.subarray(n + 8, s), e.slice(1));
								o.length && u.apply(r, o)
							}
						n = s
					}
					return r
				}

				function m(t) {
					var e = [],
						r = t[0],
						i = 8,
						n = f(t, i);
					i += 4, i += 0 === r ? 8 : 16, i += 2;
					var a = t.length + 0,
						s = c(t, i);
					i += 2;
					for(var o = 0; o < s; o++) {
						var l = i,
							u = f(t, l);
						l += 4;
						var d = 2147483647 & u;
						if(1 == (2147483648 & u) >>> 31) return console.warn("SIDX has hierarchical references (not supported)"), null;
						var h = f(t, l);
						l += 4, e.push({
							referenceSize: d,
							subsegmentDuration: h,
							info: {
								duration: h / n,
								start: a,
								end: a + d - 1
							}
						}), a += d, i = l += 4
					}
					return {
						earliestPresentationTime: 0,
						timescale: n,
						version: r,
						referencesCount: s,
						references: e
					}
				}

				function y(t) {
					for(var e = [], r = p(t, ["moov", "trak"]), n = 0; n < r.length; n++) {
						var a = r[n],
							s = p(a, ["tkhd"])[0];
						if(s) {
							var o = s[0],
								l = 0 === o ? 12 : 20,
								u = f(s, l),
								d = p(a, ["mdia", "mdhd"])[0];
							if(d) {
								var c = f(d, l = 0 === (o = d[0]) ? 12 : 20),
									g = p(a, ["mdia", "hdlr"])[0];
								if(g) {
									var v = h(g.subarray(8, 12)),
										m = {
											soun: i.ElementaryStreamTypes.AUDIO,
											vide: i.ElementaryStreamTypes.VIDEO
										}[v];
									if(m) {
										var y = p(a, ["mdia", "minf", "stbl", "stsd"])[0],
											E = void 0;
										y && (E = h(y.subarray(12, 16))), e[u] = {
											timescale: c,
											type: m
										}, e[m] = {
											timescale: c,
											id: u,
											codec: E
										}
									}
								}
							}
						}
					}
					return p(t, ["moov", "mvex", "trex"]).forEach((function(t) {
						var r = f(t, 4),
							i = e[r];
						i && (i.default = {
							duration: f(t, 12),
							flags: f(t, 20)
						})
					})), e
				}

				function E(t, e) {
					if(!t || !e) return t;
					var r = e.keyId;
					return r && e.isCommonEncryption && p(t, ["moov", "trak"]).forEach((function(t) {
						var e = p(t, ["mdia", "minf", "stbl", "stsd"])[0].subarray(8),
							i = p(e, ["enca"]),
							n = i.length > 0;
						n || (i = p(e, ["encv"])), i.forEach((function(t) {
							p(n ? t.subarray(28) : t.subarray(78), ["sinf"]).forEach((function(t) {
								var e = T(t);
								if(e) {
									var i = e.subarray(8, 24);
									i.some((function(t) {
										return 0 !== t
									})) || (s.logger.log("[eme] Patching keyId in 'enc" + (n ? "a" : "v") + ">sinf>>tenc' box: " + o.default.hexDump(i) + " -> " + o.default.hexDump(r)), e.set(r, 8))
								}
							}))
						}))
					})), t
				}

				function T(t) {
					var e = p(t, ["schm"])[0];
					if(e) {
						var r = h(e.subarray(4, 8));
						if("cbcs" === r || "cenc" === r) return p(t, ["schi", "tenc"])[0]
					}
					return s.logger.error("[eme] missing 'schm' box"), null
				}

				function S(t, e) {
					return p(e, ["moof", "traf"]).reduce((function(e, r) {
						var i = p(r, ["tfdt"])[0],
							n = i[0],
							a = p(r, ["tfhd"]).reduce((function(e, r) {
								var a = f(r, 4),
									s = t[a];
								if(s) {
									var o = f(i, 4);
									1 === n && (o *= Math.pow(2, 32), o += f(i, 8));
									var l = o / (s.timescale || 9e4);
									if(isFinite(l) && (null === e || l < e)) return l
								}
								return e
							}), null);
						return null !== a && isFinite(a) && (null === e || a < e) ? a : e
					}), null) || 0
				}

				function b(t, e) {
					for(var r = 0, n = 0, a = 0, s = p(t, ["moof", "traf"]), o = 0; o < s.length; o++) {
						var l = s[o],
							u = p(l, ["tfhd"])[0],
							d = e[f(u, 4)];
						if(d) {
							var h = d.default,
								c = f(u, 0) | (null == h ? void 0 : h.flags),
								g = null == h ? void 0 : h.duration;
							8 & c && (g = f(u, 2 & c ? 12 : 8));
							for(var v = d.timescale || 9e4, y = p(l, ["trun"]), E = 0; E < y.length; E++) !(r = L(y[E])) && g && (r = g * f(y[E], 4)), d.type === i.ElementaryStreamTypes.VIDEO ? n += r / v : d.type === i.ElementaryStreamTypes.AUDIO && (a += r / v)
						}
					}
					if(0 === n && 0 === a) {
						for(var T = 0, S = p(t, ["sidx"]), b = 0; b < S.length; b++) {
							var A = m(S[b]);
							null != A && A.references && (T += A.references.reduce((function(t, e) {
								return t + e.info.duration || 0
							}), 0))
						}
						return T
					}
					return n || a
				}

				function L(t) {
					var e = f(t, 0),
						r = 8;
					1 & e && (r += 4), 4 & e && (r += 4);
					for(var i = 0, n = f(t, 4), a = 0; a < n; a++) 256 & e && (i += f(t, r), r += 4), 512 & e && (r += 4), 1024 & e && (r += 4), 2048 & e && (r += 4);
					return i
				}

				function A(t, e, r) {
					p(e, ["moof", "traf"]).forEach((function(e) {
						p(e, ["tfhd"]).forEach((function(i) {
							var n = f(i, 4),
								a = t[n];
							if(a) {
								var s = a.timescale || 9e4;
								p(e, ["tfdt"]).forEach((function(t) {
									var e = t[0],
										i = f(t, 4);
									if(0 === e) i -= r * s, v(t, 4, i = Math.max(i, 0));
									else {
										i *= Math.pow(2, 32), i += f(t, 8), i -= r * s, i = Math.max(i, 0);
										var n = Math.floor(i / (l + 1)),
											a = Math.floor(i % (l + 1));
										v(t, 4, n), v(t, 8, a)
									}
								}))
							}
						}))
					}))
				}

				function D(t) {
					var e = {
							valid: null,
							remainder: null
						},
						r = p(t, ["moof"]);
					if(!r) return e;
					if(r.length < 2) return e.remainder = t, e;
					var i = r[r.length - 1];
					return e.valid = (0, n.sliceUint8)(t, 0, i.byteOffset - 8), e.remainder = (0, n.sliceUint8)(t, i.byteOffset - 8), e
				}

				function k(t, e) {
					var r = new Uint8Array(t.length + e.length);
					return r.set(t), r.set(e, t.length), r
				}

				function R(t, e) {
					var r = [],
						n = e.samples,
						a = e.timescale,
						s = e.id,
						o = !1;
					return p(n, ["moof"]).map((function(l) {
						var u = l.byteOffset - 8;
						p(l, ["traf"]).map((function(l) {
							var d = p(l, ["tfdt"]).map((function(t) {
								var e = t[0],
									r = f(t, 4);
								return 1 === e && (r *= Math.pow(2, 32), r += f(t, 8)), r / a
							}))[0];
							return void 0 !== d && (t = d), p(l, ["tfhd"]).map((function(d) {
								var h = f(d, 4),
									c = 16777215 & f(d, 0),
									v = 0,
									m = 0 != (16 & c),
									y = 0,
									E = 0 != (32 & c),
									T = 8;
								h === s && (0 != (1 & c) && (T += 8), 0 != (2 & c) && (T += 4), 0 != (8 & c) && (v = f(d, T), T += 4), m && (y = f(d, T), T += 4), E && (T += 4), "video" === e.type && (o = function(t) {
									if(!t) return !1;
									var e = t.indexOf("."),
										r = e < 0 ? t : t.substring(0, e);
									return "hvc1" === r || "hev1" === r || "dvh1" === r || "dvhe" === r
								}(e.codec)), p(l, ["trun"]).map((function(s) {
									var l = s[0],
										d = 16777215 & f(s, 0),
										h = 0 != (1 & d),
										c = 0,
										p = 0 != (4 & d),
										m = 0 != (256 & d),
										E = 0,
										T = 0 != (512 & d),
										S = 0,
										b = 0 != (1024 & d),
										L = 0 != (2048 & d),
										A = 0,
										D = f(s, 4),
										k = 8;
									h && (c = f(s, k), k += 4), p && (k += 4);
									for(var R = c + u, C = 0; C < D; C++) {
										if(m ? (E = f(s, k), k += 4) : E = v, T ? (S = f(s, k), k += 4) : S = y, b && (k += 4), L && (A = 0 === l ? f(s, k) : g(s, k), k += 4), e.type === i.ElementaryStreamTypes.VIDEO)
											for(var _ = 0; _ < S;) {
												var O = f(n, R);
												I(o, n[R += 4]) && w(n.subarray(R, R + O), o ? 2 : 1, t + A / a, r), R += O, _ += O + 4
											}
										t += E / a
									}
								})))
							}))
						}))
					})), r
				}

				function I(t, e) {
					if(t) {
						var r = e >> 1 & 63;
						return 39 === r || 40 === r
					}
					return 6 == (31 & e)
				}

				function w(t, e, r, i) {
					var n = C(t),
						s = 0;
					s += e;
					for(var o = 0, l = 0, u = !1, d = 0; s < n.length;) {
						o = 0;
						do {
							if(s >= n.length) break;
							o += d = n[s++]
						} while (255 === d);
						l = 0;
						do {
							if(s >= n.length) break;
							l += d = n[s++]
						} while (255 === d);
						var h = n.length - s;
						if(!u && 4 === o && s < n.length) {
							if(u = !0, 181 === n[s++]) {
								var g = c(n, s);
								if(s += 2, 49 === g) {
									var v = f(n, s);
									if(s += 4, 1195456820 === v) {
										var p = n[s++];
										if(3 === p) {
											var m = n[s++],
												y = 64 & m,
												E = y ? 2 + 3 * (31 & m) : 0,
												T = new Uint8Array(E);
											if(y) {
												T[0] = m;
												for(var S = 1; S < E; S++) T[S] = n[s++]
											}
											i.push({
												type: p,
												payloadType: o,
												pts: r,
												bytes: T
											})
										}
									}
								}
							}
						} else if(5 === o && l < h) {
							if(u = !0, l > 16) {
								for(var b = [], L = 0; L < 16; L++) {
									var A = n[s++].toString(16);
									b.push(1 == A.length ? "0" + A : A), 3 !== L && 5 !== L && 7 !== L && 9 !== L || b.push("-")
								}
								for(var D = l - 16, k = new Uint8Array(D), R = 0; R < D; R++) k[R] = n[s++];
								i.push({
									payloadType: o,
									pts: r,
									uuid: b.join(""),
									userData: (0, a.utf8ArrayToStr)(k),
									userDataBytes: k
								})
							}
						} else if(l < h) s += l;
						else if(l > h) break
					}
				}

				function C(t) {
					for(var e = t.byteLength, r = [], i = 1; i < e - 2;) 0 === t[i] && 0 === t[i + 1] && 3 === t[i + 2] ? (r.push(i + 2), i += 2) : i++;
					if(0 === r.length) return t;
					var n = e - r.length,
						a = new Uint8Array(n),
						s = 0;
					for(i = 0; i < n; s++, i++) s === r[0] && (s++, r.shift()), a[i] = t[s];
					return a
				}

				function _(t) {
					var e = t[0],
						r = "",
						i = "",
						n = 0,
						a = 0,
						s = 0,
						o = 0,
						l = 0,
						u = 0;
					if(0 === e) {
						for(;
							"\0" !== h(t.subarray(u, u + 1));) r += h(t.subarray(u, u + 1)), u += 1;
						for(r += h(t.subarray(u, u + 1)), u += 1;
							"\0" !== h(t.subarray(u, u + 1));) i += h(t.subarray(u, u + 1)), u += 1;
						i += h(t.subarray(u, u + 1)), u += 1, n = f(t, 12), a = f(t, 16), o = f(t, 20), l = f(t, 24), u = 28
					} else if(1 === e) {
						n = f(t, u += 4);
						var d = f(t, u += 4),
							c = f(t, u += 4);
						for(u += 4, s = Math.pow(2, 32) * d + c, Number.isSafeInteger(s) || (s = Number.MAX_SAFE_INTEGER, console.warn("Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box")), o = f(t, u), l = f(t, u += 4), u += 4;
							"\0" !== h(t.subarray(u, u + 1));) r += h(t.subarray(u, u + 1)), u += 1;
						for(r += h(t.subarray(u, u + 1)), u += 1;
							"\0" !== h(t.subarray(u, u + 1));) i += h(t.subarray(u, u + 1)), u += 1;
						i += h(t.subarray(u, u + 1)), u += 1
					}
					return {
						schemeIdUri: r,
						value: i,
						timeScale: n,
						presentationTime: s,
						presentationTimeDelta: a,
						eventDuration: o,
						id: l,
						payload: t.subarray(u, t.byteLength)
					}
				}

				function O(t) {
					for(var e = arguments.length, r = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) r[i - 1] = arguments[i];
					for(var n = r.length, a = 8, s = n; s--;) a += r[s].byteLength;
					var o = new Uint8Array(a);
					for(o[0] = a >> 24 & 255, o[1] = a >> 16 & 255, o[2] = a >> 8 & 255, o[3] = 255 & a, o.set(t, 4), s = 0, a = 8; s < n; s++) o.set(r[s], a), a += r[s].byteLength;
					return o
				}

				function P(t, e, r) {
					if(16 !== t.byteLength) throw new RangeError("Invalid system id");
					var i, n, a;
					if(e) {
						i = 1, n = new Uint8Array(16 * e.length);
						for(var s = 0; s < e.length; s++) {
							var o = e[s];
							if(16 !== o.byteLength) throw new RangeError("Invalid key");
							n.set(o, 16 * s)
						}
					} else i = 0, n = new Uint8Array;
					i > 0 ? (a = new Uint8Array(4), e.length > 0 && new DataView(a.buffer).setUint32(0, e.length, !1)) : a = new Uint8Array;
					var l = new Uint8Array(4);
					return r && r.byteLength > 0 && new DataView(l.buffer).setUint32(0, r.byteLength, !1), O([112, 115, 115, 104], new Uint8Array([i, 0, 0, 0]), t, a, n, l, r || new Uint8Array)
				}

				function x(t) {
					if(!(t instanceof ArrayBuffer) || t.byteLength < 32) return null;
					var e = {
							version: 0,
							systemId: "",
							kids: null,
							data: null
						},
						r = new DataView(t),
						i = r.getUint32(0);
					if(t.byteLength !== i && i > 44) return null;
					if(1886614376 !== r.getUint32(4)) return null;
					if(e.version = r.getUint32(8) >>> 24, e.version > 1) return null;
					e.systemId = o.default.hexDump(new Uint8Array(t, 12, 16));
					var n = r.getUint32(28);
					if(0 === e.version) {
						if(i - 32 < n) return null;
						e.data = new Uint8Array(t, 32, n)
					} else if(1 === e.version) {
						e.kids = [];
						for(var a = 0; a < n; a++) e.kids.push(new Uint8Array(t, 32 + 16 * a, 16))
					}
					return e
				}
			},
			673: (t, e, r) => {
				"use strict";

				function i(t, e, r, i) {
					void 0 === r && (r = 1), void 0 === i && (i = !1);
					var n = t * e * r;
					return i ? Math.round(n) : n
				}

				function n(t, e, r, n) {
					return void 0 === r && (r = 1), void 0 === n && (n = !1), i(t, e, 1 / r, n)
				}

				function a(t, e) {
					return void 0 === e && (e = !1), i(t, 1e3, 1 / 9e4, e)
				}

				function s(t, e) {
					return void 0 === e && (e = 1), i(t, 9e4, 1 / e)
				}
				r.r(e), r.d(e, {
					toMpegTsClockFromTimescale: () => s,
					toMsFromMpegTsClock: () => a,
					toTimescaleFromBase: () => i,
					toTimescaleFromScale: () => n
				})
			},
			145: (t, e, r) => {
				"use strict";

				function i(t, e, r) {
					return Uint8Array.prototype.slice ? t.slice(e, r) : new Uint8Array(Array.prototype.slice.call(t, e, r))
				}
				r.r(e), r.d(e, {
					sliceUint8: () => i
				})
			},
			729: t => {
				"use strict";
				var e = Object.prototype.hasOwnProperty,
					r = "~";

				function i() {}

				function n(t, e, r) {
					this.fn = t, this.context = e, this.once = r || !1
				}

				function a(t, e, i, a, s) {
					if("function" != typeof i) throw new TypeError("The listener must be a function");
					var o = new n(i, a || t, s),
						l = r ? r + e : e;
					return t._events[l] ? t._events[l].fn ? t._events[l] = [t._events[l], o] : t._events[l].push(o) : (t._events[l] = o, t._eventsCount++), t
				}

				function s(t, e) {
					0 == --t._eventsCount ? t._events = new i : delete t._events[e]
				}

				function o() {
					this._events = new i, this._eventsCount = 0
				}
				Object.create && (i.prototype = Object.create(null), (new i).__proto__ || (r = !1)), o.prototype.eventNames = function() {
					var t, i, n = [];
					if(0 === this._eventsCount) return n;
					for(i in t = this._events) e.call(t, i) && n.push(r ? i.slice(1) : i);
					return Object.getOwnPropertySymbols ? n.concat(Object.getOwnPropertySymbols(t)) : n
				}, o.prototype.listeners = function(t) {
					var e = r ? r + t : t,
						i = this._events[e];
					if(!i) return [];
					if(i.fn) return [i.fn];
					for(var n = 0, a = i.length, s = new Array(a); n < a; n++) s[n] = i[n].fn;
					return s
				}, o.prototype.listenerCount = function(t) {
					var e = r ? r + t : t,
						i = this._events[e];
					return i ? i.fn ? 1 : i.length : 0
				}, o.prototype.emit = function(t, e, i, n, a, s) {
					var o = r ? r + t : t;
					if(!this._events[o]) return !1;
					var l, u, d = this._events[o],
						h = arguments.length;
					if(d.fn) {
						switch(d.once && this.removeListener(t, d.fn, void 0, !0), h) {
							case 1:
								return d.fn.call(d.context), !0;
							case 2:
								return d.fn.call(d.context, e), !0;
							case 3:
								return d.fn.call(d.context, e, i), !0;
							case 4:
								return d.fn.call(d.context, e, i, n), !0;
							case 5:
								return d.fn.call(d.context, e, i, n, a), !0;
							case 6:
								return d.fn.call(d.context, e, i, n, a, s), !0
						}
						for(u = 1, l = new Array(h - 1); u < h; u++) l[u - 1] = arguments[u];
						d.fn.apply(d.context, l)
					} else {
						var c, f = d.length;
						for(u = 0; u < f; u++) switch(d[u].once && this.removeListener(t, d[u].fn, void 0, !0), h) {
							case 1:
								d[u].fn.call(d[u].context);
								break;
							case 2:
								d[u].fn.call(d[u].context, e);
								break;
							case 3:
								d[u].fn.call(d[u].context, e, i);
								break;
							case 4:
								d[u].fn.call(d[u].context, e, i, n);
								break;
							default:
								if(!l)
									for(c = 1, l = new Array(h - 1); c < h; c++) l[c - 1] = arguments[c];
								d[u].fn.apply(d[u].context, l)
						}
					}
					return !0
				}, o.prototype.on = function(t, e, r) {
					return a(this, t, e, r, !1)
				}, o.prototype.once = function(t, e, r) {
					return a(this, t, e, r, !0)
				}, o.prototype.removeListener = function(t, e, i, n) {
					var a = r ? r + t : t;
					if(!this._events[a]) return this;
					if(!e) return s(this, a), this;
					var o = this._events[a];
					if(o.fn) o.fn !== e || n && !o.once || i && o.context !== i || s(this, a);
					else {
						for(var l = 0, u = [], d = o.length; l < d; l++)(o[l].fn !== e || n && !o[l].once || i && o[l].context !== i) && u.push(o[l]);
						u.length ? this._events[a] = 1 === u.length ? u[0] : u : s(this, a)
					}
					return this
				}, o.prototype.removeAllListeners = function(t) {
					var e;
					return t ? (e = r ? r + t : t, this._events[e] && s(this, e)) : (this._events = new i, this._eventsCount = 0), this
				}, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prefixed = r, o.EventEmitter = o, t.exports = o
			},
			945: function(t) {
				var e, r, i, n, a;
				e = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/, r = /^(?=([^\/?#]*))\1([^]*)$/, i = /(?:\/|^)\.(?=\/)/g, n = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g, a = {
					buildAbsoluteURL: function(t, e, i) {
						if(i = i || {}, t = t.trim(), !(e = e.trim())) {
							if(!i.alwaysNormalize) return t;
							var n = a.parseURL(t);
							if(!n) throw new Error("Error trying to parse base URL.");
							return n.path = a.normalizePath(n.path), a.buildURLFromParts(n)
						}
						var s = a.parseURL(e);
						if(!s) throw new Error("Error trying to parse relative URL.");
						if(s.scheme) return i.alwaysNormalize ? (s.path = a.normalizePath(s.path), a.buildURLFromParts(s)) : e;
						var o = a.parseURL(t);
						if(!o) throw new Error("Error trying to parse base URL.");
						if(!o.netLoc && o.path && "/" !== o.path[0]) {
							var l = r.exec(o.path);
							o.netLoc = l[1], o.path = l[2]
						}
						o.netLoc && !o.path && (o.path = "/");
						var u = {
							scheme: o.scheme,
							netLoc: s.netLoc,
							path: null,
							params: s.params,
							query: s.query,
							fragment: s.fragment
						};
						if(!s.netLoc && (u.netLoc = o.netLoc, "/" !== s.path[0]))
							if(s.path) {
								var d = o.path,
									h = d.substring(0, d.lastIndexOf("/") + 1) + s.path;
								u.path = a.normalizePath(h)
							} else u.path = o.path, s.params || (u.params = o.params, s.query || (u.query = o.query));
						return null === u.path && (u.path = i.alwaysNormalize ? a.normalizePath(s.path) : s.path), a.buildURLFromParts(u)
					},
					parseURL: function(t) {
						var r = e.exec(t);
						return r ? {
							scheme: r[1] || "",
							netLoc: r[2] || "",
							path: r[3] || "",
							params: r[4] || "",
							query: r[5] || "",
							fragment: r[6] || ""
						} : null
					},
					normalizePath: function(t) {
						for(t = t.split("").reverse().join("").replace(i, ""); t.length !== (t = t.replace(n, "")).length;);
						return t.split("").reverse().join("")
					},
					buildURLFromParts: function(t) {
						return t.scheme + t.netLoc + t.path + t.params + t.query + t.fragment
					}
				}, t.exports = a
			}
		},
		e = {};

	function r(i) {
		var n = e[i];
		if(void 0 !== n) return n.exports;
		var a = e[i] = {
			exports: {}
		};
		return t[i].call(a.exports, a, a.exports, r), a.exports
	}
	r.m = t, r.n = t => {
		var e = t && t.__esModule ? () => t.default : () => t;
		return r.d(e, {
			a: e
		}), e
	}, r.d = (t, e) => {
		for(var i in e) r.o(e, i) && !r.o(t, i) && Object.defineProperty(t, i, {
			enumerable: !0,
			get: e[i]
		})
	}, r.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), r.r = t => {
		"undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
			value: "Module"
		}), Object.defineProperty(t, "__esModule", {
			value: !0
		})
	};
	var i = r(76);
	return i.default
})()));